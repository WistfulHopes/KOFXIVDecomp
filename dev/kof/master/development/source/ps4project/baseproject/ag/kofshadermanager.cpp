#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglshader.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/kof/master/development/source/ps4project/baseproject/ag/kofshadermanager.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/unordered_map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xhash"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/kof/master/development/source/ps4project/baseproject/pcdummy.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/main.cpp"

class std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > :
	std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,int> >,0> >
{
	class _Myt;
	class _Mytraits;
	class _Mybase;
	struct hasher;
	typedef long key_type;
	typedef long mapped_type;
	struct key_equal;
	class key_compare;
	class allocator_type;
	typedef unsigned long long size_type;
	typedef long long difference_type;
	typedef std::pair<int const ,int> pointer;
	typedef const std::pair<int const ,int> const_pointer;
	typedef std::pair<int const ,int> reference;
	typedef const std::pair<int const ,int> const_reference;
	class iterator;
	class const_iterator;
	struct value_type;
	class local_iterator;
	class const_local_iterator;
	struct _Alty;
	struct _Pairib;
public:
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::initializer_list<std::pair<int const ,int> >, unsigned long long, const std::hash<int> &, const std::equal_to<int> &, const std::allocator<std::pair<int const ,int> > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::initializer_list<std::pair<int const ,int> >, unsigned long long, const std::hash<int> &, const std::equal_to<int> &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::initializer_list<std::pair<int const ,int> >, unsigned long long, const std::hash<int> &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::initializer_list<std::pair<int const ,int> >, unsigned long long);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::initializer_list<std::pair<int const ,int> >);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &, const std::allocator<std::pair<int const ,int> > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(unsigned long long, const std::hash<int> &, const std::equal_to<int> &, const std::allocator<std::pair<int const ,int> > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(unsigned long long, const std::hash<int> &, const std::equal_to<int> &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(unsigned long long, const std::hash<int> &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(unsigned long long);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(const std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &, const std::allocator<std::pair<int const ,int> > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(const std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >(const std::allocator<std::pair<int const ,int> > &);
	unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >();
	std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > & operator=(std::initializer_list<std::pair<int const ,int> >);
	std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > & operator=(std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &);
	std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > & operator=(const std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &);
	long & operator[](const long &);
	long & operator[](long &);
	void swap(std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > &);
	std::hash<int> hash_function();
	std::equal_to<int> key_eq();
	const long & at(const long &);
	long & at(const long &);
	~unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > >();
};
std::unordered_map<int,int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,int> > > shaderLookup; // 0x140AC2050
void(*shaderLookup$initializer$)(); // 0x140740860
std::piecewise_construct_t std::piecewise_construct; // 0x1408AECC3
KOFShaderManager::Shader::Shader(); // 0x140243E20
KOFShaderManager::Shader::~Shader(); // 0x140243E40
long KOFShaderManager::onSingletonInit(); // 0x140243E80
long KOFShaderManager::onSingletonExit(); // 0x1400482A0
unsigned long KOFShaderManager::createProgram(long * outProgramSlot); // 0x140243F90
unsigned long KOFShaderManager::createShader(unsigned long type); // 0x1402440E0
void KOFShaderManager::attachShaderSlot(long programSlot, long shaderSlot); // 0x1402441A0
void KOFShaderManager::loadShader(unsigned long shaderSlot, long count, const char * * string, const long * length, const char * filename); // 0x140244200
long KOFShaderManager::findProgram(long programID); // 0x140244320
void KOFShaderManager::setProgramUniformsSlot(long programSlot, long num); // 0x1402443E0
void KOFShaderManager::link(KOFShaderManager::Program & program); // 0x140244590
void KOFShaderManager::unloadSlot(long programSlot); // 0x1402446E0
void KOFShaderManager::useProgramSlot(long programSlot); // 0x1402448B0
void KOFShaderManager::setContentBufferPtr(long no); // 0x1402449A0
void KOFShaderManager::setUniformBuffer(UniformBuffer buffer, void * uniforms, unsigned long long uniforms_size, unsigned long mask); // 0x140245450
void KOFShaderManager::setUniforms(); // 0x1402454F0
void KOFShaderManager::setUniformWriteMask(long location); // 0x140245710
unsigned long KOFShaderManager::loadVertShader(const char * _vertFile, unsigned char crypt, unsigned char * pData); // 0x140245870
void KOFShaderManager::loadFragShader(unsigned long & shader, const char * _fragFile, unsigned char crypt, unsigned char * pData); // 0x1402459A0//decompilation failure at 140AC2050!
//decompilation failure at 140740860!
//decompilation failure at 1408AECC3!
std::_List_node<std::pair<int const ,int>,void *> *__fastcall std::_List_buy<std::pair<int const,int>>::_Buynode<unsigned int &,int &>(
        std::_List_buy<std::pair<int const ,int>> *this,
        std::_List_node<std::pair<int const ,int>,void *> *_Next,
        std::_List_node<std::pair<int const ,int>,void *> *_Prev,
        unsigned int *<_Val_0>,
        int *<_Val_1>)
{
  std::_List_node<std::pair<int const ,int>,void *> *result; // rax

  result = (std::_List_node<std::pair<int const ,int>,void *> *)std::_List_alloc<std::_List_base_types<std::pair<int const,int>>>::_Buynode0(
                                                                  (std::_List_alloc<std::_List_base_types<Scaleform::Ptr<Scaleform::Render::ThreadCommand>> > *)this,
                                                                  (std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *)_Next,
                                                                  (std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *)_Prev);
  if ( result != (std::_List_node<std::pair<int const ,int>,void *> *)-16i64 )
  {
    result->_Myval.first = *<_Val_0>;
    result->_Myval.second = *<_Val_1>;
  }
  return result;
}

std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >,bool> *__fastcall std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Insert<std::pair<int const,int> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,int>>>>>(
        std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,int> >,0> > *this,
        std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >,bool> *result,
        std::pair<int const ,int> *_Val,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > _Pnode)
{
  unsigned __int64 v8; // r8
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > *Myfirst; // rbx
  std::_List_node<std::pair<int const ,int>,void *> *Ptr; // rax
  std::_List_node<std::pair<int const ,int>,void *> *Myhead; // rbx
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rax
  std::_List_node<std::pair<int const ,int>,void *> *Prev; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > *v15; // rdx
  std::_List_node<std::pair<int const ,int>,void *> **p_Next; // rax
  std::_List_node<std::pair<int const ,int>,void *> *v17; // rcx

  v8 = 2
     * ((0x100000001B3i64
       * (HIBYTE(_Val->first) ^ (0x100000001B3i64
                               * (BYTE2(_Val->first) ^ (0x100000001B3i64
                                                      * (BYTE1(_Val->first) ^ (0x100000001B3i64
                                                                             * (LOBYTE(_Val->first) ^ 0xCBF29CE484222325ui64)))))))) & this->_Mask);
  Myfirst = this->_Vec._Mypair._Myval2._Myfirst;
  Ptr = Myfirst[v8]._Ptr;
  if ( Ptr == this->_List._Mypair._Myval2._Myhead )
    Myhead = this->_List._Mypair._Myval2._Myhead;
  else
    Myhead = Myfirst[v8 + 1]._Ptr->_Next;
  if ( Myhead == Ptr )
  {
LABEL_9:
    Next = _Pnode._Ptr->_Next;
    if ( Myhead != _Pnode._Ptr->_Next )
    {
      _Pnode._Ptr->_Prev->_Next = Next;
      Next->_Prev->_Next = Myhead;
      Myhead->_Prev->_Next = _Pnode._Ptr;
      Prev = Myhead->_Prev;
      Myhead->_Prev = Next->_Prev;
      Next->_Prev = _Pnode._Ptr->_Prev;
      _Pnode._Ptr->_Prev = Prev;
    }
    v15 = &this->_Vec._Mypair._Myval2._Myfirst[v8];
    if ( v15->_Ptr == this->_List._Mypair._Myval2._Myhead )
    {
      v15->_Ptr = _Pnode._Ptr;
      this->_Vec._Mypair._Myval2._Myfirst[v8 + 1] = _Pnode;
    }
    else if ( v15->_Ptr == Myhead )
    {
      v15->_Ptr = _Pnode._Ptr;
    }
    else
    {
      p_Next = &v15[1]._Ptr->_Next;
      v17 = *p_Next;
      v15[1]._Ptr = *p_Next;
      if ( v17 != _Pnode._Ptr )
        this->_Vec._Mypair._Myval2._Myfirst[v8 + 1]._Ptr = this->_Vec._Mypair._Myval2._Myfirst[v8 + 1]._Ptr->_Prev;
    }
    std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Check_size(this);
    result->first._Ptr = _Pnode._Ptr;
    result->second = 1;
    return result;
  }
  else
  {
    while ( 1 )
    {
      Myhead = Myhead->_Prev;
      if ( _Val->first == Myhead->_Myval.first )
        break;
      if ( Myhead == Ptr )
        goto LABEL_9;
    }
    _Pnode._Ptr->_Prev->_Next = _Pnode._Ptr->_Next;
    _Pnode._Ptr->_Next->_Prev = _Pnode._Ptr->_Prev;
    --this->_List._Mypair._Myval2._Mysize;
    operator delete(_Pnode._Ptr);
    result->first._Ptr = Myhead;
    result->second = 0;
    return result;
  }
}

void __fastcall std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_First,
        unsigned __int64 _Count,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Pval,
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *_Al)
{
  for ( ; _Count; --_Count )
  {
    if ( _First )
      _First->_Ptr = _Pval->_Ptr;
    ++_First;
  }
}

std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *__fastcall std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_First,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Last,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Dest,
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *_Al)
{
  __int64 v4; // r9
  unsigned __int64 v5; // r10
  signed __int64 v6; // rcx

  v4 = 0i64;
  v5 = (unsigned __int64)((char *)_Last - (char *)_First + 7) >> 3;
  if ( _First > _Last )
    v5 = 0i64;
  if ( v5 )
  {
    v6 = (char *)_First - (char *)_Dest;
    do
    {
      if ( _Dest )
        _Dest->_Ptr = *(std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> **)((char *)_Dest + v6);
      ++_Dest;
      ++v4;
    }
    while ( v4 != v5 );
  }
  return _Dest;
}

void __fastcall std::unordered_map<int,int>::unordered_map<int,int>(std::unordered_map<int,int> *this)
{
  shaderLookup._Traitsobj._Mypair._Myval2._Myval2 = 0.0;
  shaderLookup._List._Mypair._Myval2._Myhead = 0i64;
  shaderLookup._List._Mypair._Myval2._Mysize = 0i64;
  shaderLookup._List._Mypair._Myval2._Myhead = (std::_List_node<std::pair<int const ,int>,void *> *)std::_List_alloc<std::_List_base_types<std::pair<int const,int>>>::_Buynode0((std::_List_alloc<std::_List_base_types<Scaleform::Ptr<Scaleform::Render::ThreadCommand>> > *)this, 0i64, 0i64);
  shaderLookup._Vec._Mypair._Myval2._Myfirst = 0i64;
  *(_OWORD *)&shaderLookup._Vec._Mypair._Myval2._Mylast = 0i64;
  LODWORD(shaderLookup._Traitsobj._Mypair._Myval2._Myval2) = FLOAT_1_0;
  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
    (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)&shaderLookup,
    8ui64);
}

void __fastcall KOFShaderManager::Shader::Shader(KOFShaderManager::Shader *this)
{
  AgString::AgString(&this->m_fileName);
}

void __fastcall AgSingleton<KOFShaderManager>::~AgSingleton<KOFShaderManager>(AgSingleton<KOFShaderManager> *this)
{
  this->__vftable = (AgSingleton<KOFShaderManager>_vtbl *)&AgSingleton<KOFShaderManager>::`vftable';
}

void __fastcall std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::~_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>(
        std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,int> >,0> > *this)
{
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rcx
  std::_List_node<std::pair<int const ,int>,void *> *Myhead; // rax
  std::_List_node<std::pair<int const ,int>,void *> *v3; // rbx

  if ( shaderLookup._Vec._Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      (AgLogger **)shaderLookup._Vec._Mypair._Myval2._Myfirst,
      shaderLookup._Vec._Mypair._Myval2._Myend - shaderLookup._Vec._Mypair._Myval2._Myfirst);
    shaderLookup._Vec._Mypair._Myval2._Myfirst = 0i64;
    *(_OWORD *)&shaderLookup._Vec._Mypair._Myval2._Mylast = 0i64;
  }
  Next = shaderLookup._List._Mypair._Myval2._Myhead->_Next;
  shaderLookup._List._Mypair._Myval2._Myhead->_Next = shaderLookup._List._Mypair._Myval2._Myhead;
  shaderLookup._List._Mypair._Myval2._Myhead->_Prev = shaderLookup._List._Mypair._Myval2._Myhead;
  Myhead = shaderLookup._List._Mypair._Myval2._Myhead;
  shaderLookup._List._Mypair._Myval2._Mysize = 0i64;
  if ( Next != shaderLookup._List._Mypair._Myval2._Myhead )
  {
    do
    {
      v3 = Next->_Next;
      operator delete(Next);
      Myhead = shaderLookup._List._Mypair._Myval2._Myhead;
      Next = v3;
    }
    while ( v3 != shaderLookup._List._Mypair._Myval2._Myhead );
  }
  operator delete(Myhead);
}

void __fastcall std::list<int>::~list<int>(std::list<std::pair<int const ,int>> *this)
{
  std::_List_node<std::pair<int const ,int>,void *> *Myhead; // rax
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rcx
  std::_List_node<std::pair<int const ,int>,void *> *v4; // rbx

  Myhead = this->_Mypair._Myval2._Myhead;
  Next = this->_Mypair._Myval2._Myhead->_Next;
  Myhead->_Next = Myhead;
  this->_Mypair._Myval2._Myhead->_Prev = this->_Mypair._Myval2._Myhead;
  this->_Mypair._Myval2._Mysize = 0i64;
  if ( Next != this->_Mypair._Myval2._Myhead )
  {
    do
    {
      v4 = Next->_Next;
      operator delete(Next);
      Next = v4;
    }
    while ( v4 != this->_Mypair._Myval2._Myhead );
  }
  operator delete(this->_Mypair._Myval2._Myhead);
}

void __fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>>>>(
        std::vector<unsigned char *> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall KOFShaderManager::Shader::~Shader(KOFShaderManager::Shader *this)
{
  AgString::~AgString(&this->m_fileName);
}

std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *__fastcall std::_List_alloc<std::_List_base_types<std::pair<int const,int>>>::_Buynode0(
        std::_List_alloc<std::_List_base_types<Scaleform::Ptr<Scaleform::Render::ThreadCommand>> > *this,
        std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *_Next,
        std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *_Prev)
{
  std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *result; // rax

  result = (std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *)operator new(0x18ui64);
  if ( !_Next )
  {
    _Next = result;
    _Prev = result;
  }
  if ( result )
    result->_Next = _Next;
  if ( result != (std::_List_node<Scaleform::Ptr<Scaleform::Render::ThreadCommand>,void *> *)-8i64 )
    result->_Prev = _Prev;
  return result;
}

void __fastcall std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Check_size(
        std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,int> >,0> > *this)
{
  signed __int64 Mysize; // rax
  __int64 Maxidx; // rdx
  float v4; // xmm0_4
  float v5; // xmm1_4
  std::_List_node<std::pair<int const ,int>,void *> *Myhead; // rax
  std::_List_node<std::pair<int const ,int>,void *> *Prev; // rdi
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rbx
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >,bool> result; // [rsp+20h] [rbp-18h] BYREF

  Mysize = this->_List._Mypair._Myval2._Mysize;
  Maxidx = this->_Maxidx;
  v4 = (float)(int)Mysize;
  if ( Mysize < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)Maxidx;
  if ( Maxidx < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > this->_Traitsobj._Mypair._Myval2._Myval2 )
  {
    if ( (unsigned __int64)Maxidx >= 0x200 )
    {
      if ( (unsigned __int64)Maxidx < 0xFFFFFFFFFFFFFFFi64 )
        Maxidx *= 2i64;
    }
    else
    {
      Maxidx *= 8i64;
    }
    std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
      (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
      Maxidx);
    Myhead = this->_List._Mypair._Myval2._Myhead;
    if ( Myhead->_Next != Myhead )
    {
      Prev = Myhead->_Prev;
      do
      {
        Next = this->_List._Mypair._Myval2._Myhead->_Next;
        std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Insert<std::pair<int const,int> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,int>>>>>(
          this,
          &result,
          &Next->_Myval,
          (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >)Next);
      }
      while ( Next != Prev );
    }
  }
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
        std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *this,
        unsigned __int64 _Buckets)
{
  unsigned __int64 v2; // rdi
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > _Val; // [rsp+50h] [rbp+8h] BYREF
  std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > result; // [rsp+58h] [rbp+10h] BYREF

  v2 = 2 * _Buckets;
  if ( this->_Vec._Mypair._Myval2._Myend - this->_Vec._Mypair._Myval2._Myfirst < 2 * _Buckets )
  {
    if ( v2 > 0x1FFFFFFFFFFFFFFFi64 )
      std::_Xlength_error("vector<T> too long");
    std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>::_Reallocate(
      &this->_Vec,
      v2);
  }
  _Val._Ptr = this->_List._Mypair._Myval2._Myhead;
  this->_Vec._Mypair._Myval2._Mylast = this->_Vec._Mypair._Myval2._Myfirst;
  std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>>>::_Insert_n(
    &this->_Vec,
    &result,
    (std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > >)this->_Vec._Mypair._Myval2._Myfirst,
    v2,
    &_Val);
  this->_Mask = _Buckets - 1;
  this->_Maxidx = _Buckets;
}

std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *__fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>>>::_Insert_n(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *result,
        std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > _Where,
        unsigned __int64 _Count,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Val)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *Myfirst; // r8
  signed __int64 v10; // r12
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *Mylast; // r14
  __int64 v12; // r14
  unsigned __int64 v13; // r15
  unsigned __int64 v14; // rdx
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v15; // rcx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v16; // rbx
  signed __int64 v17; // r14
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v18; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v19; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v20; // r9
  std::allocator<AgLogger *> *v21; // rcx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rbx
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v24; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v25; // rdx
  __int64 v26; // rcx
  unsigned __int64 v27; // r8
  std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *v28; // rax
  std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *Ptr; // rbx
  unsigned __int64 v30; // r15
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *i; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > _Pval; // [rsp+80h] [rbp+8h] BYREF
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Last; // [rsp+90h] [rbp+18h]
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v35; // [rsp+98h] [rbp+20h]

  _Last = _Where._Ptr;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v10 = _Where._Ptr - this->_Mypair._Myval2._Myfirst;
  if ( _Count )
  {
    Mylast = this->_Mypair._Myval2._Mylast;
    if ( this->_Mypair._Myval2._Myend - Mylast >= _Count )
    {
      if ( Mylast - _Where._Ptr >= _Count )
      {
        Ptr = _Val->_Ptr;
        v30 = _Count;
        this->_Mypair._Myval2._Mylast = std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
                                          &Mylast[-_Count],
                                          Mylast,
                                          Mylast,
                                          (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)_Count);
        memmove(&_Last[_Count], _Last, (size_t)Mylast - 8 * _Count - (_QWORD)_Last);
        for ( i = _Last; i != &_Last[v30]; ++i )
          i->_Ptr = Ptr;
      }
      else
      {
        _Pval._Ptr = _Val->_Ptr;
        v23 = 8 * _Count;
        std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
          _Where._Ptr,
          Mylast,
          &_Where._Ptr[_Count],
          (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)_Count);
        std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
          this->_Mypair._Myval2._Mylast,
          _Count - (this->_Mypair._Myval2._Mylast - _Last),
          &_Pval,
          v24);
        this->_Mypair._Myval2._Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)((char *)this->_Mypair._Myval2._Mylast + v23);
        v25 = _Last;
        v26 = 0i64;
        v27 = (unsigned __int64)((char *)&this->_Mypair._Myval2._Mylast[v23 / 0xFFFFFFFFFFFFFFF8ui64] - (char *)_Last + 7) >> 3;
        if ( _Last > &this->_Mypair._Myval2._Mylast[v23 / 0xFFFFFFFFFFFFFFF8ui64] )
          v27 = 0i64;
        if ( v27 )
        {
          v28 = _Pval._Ptr;
          do
          {
            v25->_Ptr = v28;
            ++v25;
            ++v26;
          }
          while ( v26 != v27 );
        }
      }
    }
    else
    {
      v12 = Mylast - Myfirst;
      if ( 0x1FFFFFFFFFFFFFFFi64 - v12 < _Count )
        std::_Xlength_error("vector<T> too long");
      v13 = v12 + _Count;
      v14 = this->_Mypair._Myval2._Myend - Myfirst;
      v15 = 0i64;
      if ( 0x1FFFFFFFFFFFFFFFi64 - (v14 >> 1) >= v14 )
        v15 = (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)(v14 + (v14 >> 1));
      if ( (unsigned __int64)v15 >= v13 )
        v13 = (unsigned __int64)v15;
      _Pval._Ptr = (std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *)v13;
      v16 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
              v15,
              v13);
      v35 = v16;
      v17 = _Last - this->_Mypair._Myval2._Myfirst;
      std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
        &v16[v17],
        _Count,
        _Val,
        v18);
      std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        this->_Mypair._Myval2._Myfirst,
        _Last,
        v16,
        v19);
      std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        _Last,
        this->_Mypair._Myval2._Mylast,
        &v16[v17 + _Count],
        v20);
      v22 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst + _Count;
      if ( this->_Mypair._Myval2._Myfirst )
        std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
          v21,
          (AgLogger **)this->_Mypair._Myval2._Myfirst,
          this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
      this->_Mypair._Myval2._Myend = &v16[v13];
      this->_Mypair._Myval2._Mylast = &v16[v22];
      this->_Mypair._Myval2._Myfirst = v16;
    }
  }
  result->_Ptr = &this->_Mypair._Myval2._Myfirst[v10];
  return result;
}

void __fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>::_Reallocate(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        unsigned __int64 _Count)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v4; // rdi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v5; // r9
  std::allocator<AgLogger *> *v6; // rcx
  signed __int64 v7; // rsi

  v4 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
         (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)this,
         _Count);
  std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    v5);
  v7 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      v6,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v7];
  this->_Mypair._Myval2._Myfirst = v4;
}

std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *__fastcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 v3; // rcx
  void *v4; // rax

  if ( !_Count )
    return 0i64;
  if ( _Count > 0x1FFFFFFFFFFFFFFFi64 )
    std::_Xbad_alloc();
  v3 = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
    return (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)operator new(v3);
  if ( v3 + 39 <= v3 )
    std::_Xbad_alloc();
  v4 = operator new(v3 + 39);
  *(_QWORD *)((((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64) - 8) = v4;
  return (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)(((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
}

void __fastcall KOFShaderManager::attachShaderSlot(KOFShaderManager *this, int programSlot, int shaderSlot)
{
  char *v4; // rdi
  char *v5; // rbx
  __int64 v6; // rcx
  int v7; // eax

  v4 = (char *)this + 88 * programSlot;
  v5 = (char *)this + 32 * shaderSlot;
  _glewAttachShader(*((_DWORD *)v4 + 2), *((_DWORD *)v5 + 720902));
  v6 = *((int *)v5 + 720903);
  v7 = *((_DWORD *)v5 + 720902);
  *(_DWORD *)&v4[4 * v6 + 28] = shaderSlot;
  *(_DWORD *)&v4[4 * v6 + 12] = v7;
}

__int64 __fastcall KOFShaderManager::createProgram(KOFShaderManager *this, int *outProgramSlot)
{
  int *p_m_nextProgramIDSlot; // rbx
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rsi
  std::_List_buy<std::pair<int const ,int>> *v6; // rcx
  std::_List_node<std::pair<int const ,int>,void *> *v7; // rax
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >,bool> result; // [rsp+30h] [rbp-18h] BYREF
  unsigned int Program; // [rsp+50h] [rbp+8h] BYREF

  p_m_nextProgramIDSlot = &this->m_nextProgramIDSlot;
  Program = _glewCreateProgram();
  this->m_program[this->m_nextProgramIDSlot].m_ID = Program;
  Next = shaderLookup._List._Mypair._Myval2._Myhead->_Next;
  v7 = std::_List_buy<std::pair<int const,int>>::_Buynode<unsigned int &,int &>(
         v6,
         shaderLookup._List._Mypair._Myval2._Myhead->_Next,
         shaderLookup._List._Mypair._Myval2._Myhead->_Next->_Prev,
         &Program,
         &this->m_nextProgramIDSlot);
  if ( shaderLookup._List._Mypair._Myval2._Mysize == 0xAAAAAAAAAAAAAA9i64 )
    std::_Xlength_error("list<T> too long");
  ++shaderLookup._List._Mypair._Myval2._Mysize;
  Next->_Prev = v7;
  v7->_Prev->_Next = v7;
  std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Insert<std::pair<int const,int> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,int>>>>>(
    &shaderLookup,
    &result,
    &shaderLookup._List._Mypair._Myval2._Myhead->_Next->_Myval,
    (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >)shaderLookup._List._Mypair._Myval2._Myhead->_Next);
  this->m_program[*p_m_nextProgramIDSlot].m_shader[0] = 0;
  this->m_program[*p_m_nextProgramIDSlot].m_shaderSlot[0] = -1;
  this->m_program[*p_m_nextProgramIDSlot].m_shader[1] = 0;
  this->m_program[*p_m_nextProgramIDSlot].m_shaderSlot[1] = -1;
  this->m_program[*p_m_nextProgramIDSlot].m_shader[2] = 0;
  this->m_program[*p_m_nextProgramIDSlot].m_shaderSlot[2] = -1;
  this->m_program[*p_m_nextProgramIDSlot].m_shader[3] = 0;
  this->m_program[*p_m_nextProgramIDSlot].m_shaderSlot[3] = -1;
  if ( outProgramSlot )
    *outProgramSlot = *p_m_nextProgramIDSlot;
  ++*p_m_nextProgramIDSlot;
  return Program;
}

__int64 __fastcall KOFShaderManager::createShader(KOFShaderManager *this, unsigned int type)
{
  unsigned int v4; // edi
  unsigned int v5; // edi
  unsigned int v6; // edi
  __int64 result; // rax

  this->m_shader[this->m_nextShaderSlot].m_ID = _glewCreateShader(type);
  v4 = type - 35632;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 680;
      if ( v6 )
      {
        if ( v6 == 992 )
          this->m_shader[this->m_nextShaderSlot].m_type = ShaderType_Compute;
      }
      else
      {
        this->m_shader[this->m_nextShaderSlot].m_type = ShaderType_Geometry;
      }
    }
    else
    {
      this->m_shader[this->m_nextShaderSlot].m_type = ShaderType_Vertex;
    }
  }
  else
  {
    this->m_shader[this->m_nextShaderSlot].m_type = ShaderType_Fragment;
  }
  result = (unsigned int)this->m_nextShaderSlot;
  this->m_nextShaderSlot = result + 1;
  return result;
}

void __fastcall std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
        std::allocator<AgLogger *> *this,
        AgLogger **_Ptr,
        unsigned __int64 _Count)
{
  AgLogger **v3; // rax
  char *v4; // rdx

  if ( _Count > 0x1FFFFFFFFFFFFFFFi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 8 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    v3 = (AgLogger **)*(_Ptr - 1);
    if ( v3 >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)v3);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = v3;
  }
  operator delete(_Ptr);
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > *__fastcall std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::erase(
        std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,int> >,0> > *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > *result,
        std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > _Plist)
{
  std::_List_node<std::pair<int const ,int>,void *> *Ptr; // r9
  unsigned __int64 v6; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > *v7; // rcx
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rbx

  Ptr = _Plist._Ptr;
  v6 = 2
     * ((0x100000001B3i64
       * (HIBYTE(_Plist._Ptr->_Myval.first) ^ (0x100000001B3i64
                                             * (BYTE2(_Plist._Ptr->_Myval.first) ^ (0x100000001B3i64
                                                                                  * (BYTE1(_Plist._Ptr->_Myval.first) ^ (0x100000001B3i64 * (LOBYTE(_Plist._Ptr->_Myval.first) ^ 0xCBF29CE484222325ui64)))))))) & this->_Mask);
  v7 = &this->_Vec._Mypair._Myval2._Myfirst[v6];
  if ( v7[1]._Ptr == _Plist._Ptr )
  {
    if ( v7->_Ptr == _Plist._Ptr )
    {
      v7->_Ptr = this->_List._Mypair._Myval2._Myhead;
      this->_Vec._Mypair._Myval2._Myfirst[v6 + 1]._Ptr = this->_List._Mypair._Myval2._Myhead;
    }
    else
    {
      v7[1]._Ptr = _Plist._Ptr->_Prev;
    }
    goto LABEL_7;
  }
  if ( v7->_Ptr == _Plist._Ptr )
  {
    v7->_Ptr = _Plist._Ptr->_Next;
LABEL_7:
    Ptr = _Plist._Ptr;
  }
  Next = Ptr->_Next;
  Ptr->_Prev->_Next = Ptr->_Next;
  Ptr->_Next->_Prev = Ptr->_Prev;
  --this->_List._Mypair._Myval2._Mysize;
  operator delete(Ptr);
  result->_Ptr = Next;
  return result;
}

__int64 __fastcall KOFShaderManager::findProgram(KOFShaderManager *this, int programID)
{
  std::_List_node<std::pair<int const ,int>,void *> *i; // rax
  std::_List_node<std::pair<int const ,int>,void *> *v3; // rcx

  if ( programID > 0 )
  {
    for ( i = shaderLookup._Vec._Mypair._Myval2._Myfirst[2
                                                       * ((0x100000001B3i64
                                                         * (HIBYTE(programID) ^ (0x100000001B3i64
                                                                               * (BYTE2(programID) ^ (0x100000001B3i64 * (BYTE1(programID) ^ (0x100000001B3i64 * ((unsigned __int8)programID ^ 0xCBF29CE484222325ui64)))))))) & shaderLookup._Mask)]._Ptr;
          ;
          i = i->_Next )
    {
      v3 = shaderLookup._Vec._Mypair._Myval2._Myfirst[2
                                                    * ((0x100000001B3i64
                                                      * (HIBYTE(programID) ^ (0x100000001B3i64
                                                                            * (BYTE2(programID) ^ (0x100000001B3i64
                                                                                                 * (BYTE1(programID) ^ (0x100000001B3i64 * ((unsigned __int8)programID ^ 0xCBF29CE484222325ui64)))))))) & shaderLookup._Mask)]._Ptr == shaderLookup._List._Mypair._Myval2._Myhead ? shaderLookup._List._Mypair._Myval2._Myhead : shaderLookup._Vec._Mypair._Myval2._Myfirst[2 * ((0x100000001B3i64 * (HIBYTE(programID) ^ (0x100000001B3i64 * (BYTE2(programID) ^ (0x100000001B3i64 * (BYTE1(programID) ^ (0x100000001B3i64 * ((unsigned __int8)programID ^ 0xCBF29CE484222325ui64)))))))) & shaderLookup._Mask) + 1]._Ptr->_Next;
      if ( i == v3 )
        break;
      if ( programID == i->_Myval.first )
      {
        if ( i == shaderLookup._List._Mypair._Myval2._Myhead )
          return 0xFFFFFFFFi64;
        return (unsigned int)i->_Myval.second;
      }
    }
  }
  return 0xFFFFFFFFi64;
}

void __fastcall KOFShaderManager::link(KOFShaderManager *this, KOFShaderManager::Program *program)
{
  unsigned int v3; // edi
  const char *m_fragFile; // rdx
  unsigned int v5; // eax
  OGLShader *m_pOglShader; // rdx
  unsigned __int8 *v7; // r9
  unsigned int v8; // edx
  int v9; // edi
  unsigned int shader; // [rsp+38h] [rbp+10h] BYREF

  if ( !program->m_isLinked )
  {
    v3 = program->m_shader[1];
    m_fragFile = program->m_pOglShader->m_fragFile;
    if ( m_fragFile )
    {
      AgString::operator=(&this->m_shader[program->m_shaderSlot[1]].m_fileName, m_fragFile);
      v5 = _glewCreateShader(0x8B30u);
      m_pOglShader = program->m_pOglShader;
      shader = v5;
      KOFShaderManager::loadFragShader(&shader, m_pOglShader->m_fragFile, 0, v7);
      v3 = shader;
      _glewAttachShader(program->m_ID, shader);
      _glewDeleteShader(v3);
    }
    _glewLinkProgram(program->m_ID);
    v8 = program->m_shader[2];
    if ( !v8 )
    {
      if ( !*(_BYTE *)(*(_QWORD *)&AppMain::pApp + 2197496i64)
        && ((unsigned int (__fastcall *)(AgSingleton<AgSystemManager> *))AgSingleton<AgSystemManager>::ms_instance->__vftable[3].~AgSingleton<AgSystemManager>)(AgSingleton<AgSystemManager>::ms_instance)
         - 1 > 0x7FE )
      {
        _glewDetachShader(program->m_ID, program->m_shader[0]);
      }
      v8 = v3;
    }
    _glewDetachShader(program->m_ID, v8);
    OGLShader::getAttribLocations(program->m_pOglShader, program->m_attribNum, program->m_shaderAttrib);
    OGLShader::getUniformLocations(program->m_pOglShader, program->m_uniformNum, program->m_uniformAttrib);
    if ( !program->m_shader[2] )
    {
      v9 = _glewGetFragDataLocation(program->m_ID, "xlo_fragColor0") != -1;
      if ( _glewGetFragDataLocation(program->m_ID, "xlo_fragColor1") != -1 )
        v9 |= 2u;
      if ( _glewGetFragDataLocation(program->m_ID, "xlo_fragColor2") != -1 )
        v9 |= 4u;
      program->m_pOglShader->m_outputMask = v9;
    }
    program->m_isLinked = 1;
  }
}

void __fastcall KOFShaderManager::loadFragShader(
        unsigned int *shader,
        const char *_fragFile,
        unsigned __int8 crypt,
        unsigned __int8 *pData)
{
  const char *v6; // rax
  char v7; // r9
  __int64 v8; // rdx
  char filename[256]; // [rsp+30h] [rbp-118h] BYREF

  v6 = _fragFile;
  do
  {
    v7 = *v6;
    v6[filename - _fragFile] = *v6;
    ++v6;
  }
  while ( v7 );
  v8 = -1i64;
  do
    ++v8;
  while ( _fragFile[v8] );
  filename[(int)v8 - 2] = 102;
  filename[(int)v8 - 1] = 114;
  filename[(int)v8] = 97;
  filename[(int)v8 + 1] = 103;
  if ( (unsigned __int64)((int)v8 + 2) >= 0x100 )
  {
    _report_rangecheckfailure((int)v8 + 2, v8);
    JUMPOUT(0x140245A9Bi64);
  }
  filename[(int)v8 + 2] = 0;
  if ( !OGLShader::compileShader(shader, 0x8B30u, filename, (const char *)crypt, 0i64, 0) )
  {
    if ( *shader )
    {
      _glewDeleteShader((unsigned int)AgSingleton<KOFShaderManager>::ms_instance[4 * *shader + 360451].__vftable);
      *shader = 0;
    }
  }
}

void __fastcall KOFShaderManager::loadShader(
        KOFShaderManager *this,
        unsigned int shaderSlot,
        int count,
        const char **string,
        const int *length,
        const char *filename)
{
  unsigned int v8; // er12
  const char *v9; // r14
  unsigned int v10; // ebp
  unsigned int v11; // edi
  int v12; // ebx
  const char **v13; // rsi
  const AgString *v14; // rax
  AgString v15; // [rsp+28h] [rbp-50h] BYREF
  __int64 v16; // [rsp+80h] [rbp+8h]
  char *v17; // [rsp+98h] [rbp+20h]

  v16 = shaderSlot;
  v17 = (char *)this + 32 * shaderSlot;
  v8 = *((_DWORD *)v17 + 720902);
  v9 = *string;
  v10 = 0;
  v11 = 0;
  v12 = 1;
  v13 = UniformBufferNamePlusSpace;
  do
  {
    if ( strstr(v9, *v13) )
      v10 |= v12;
    ++v11;
    v12 = __ROL4__(v12, 1);
    ++v13;
  }
  while ( v11 < 0xB );
  this->m_shader[v16].m_constantTypes = v10;
  AgString::AgString(&v15, filename, -1);
  AgString::operator=((AgString *)(v17 + 2883624), v14);
  AgString::~AgString(&v15);
  while ( Framework::GLManager::glm->m_bOpenGLBlocked )
    ;
  _glewShaderSource(v8, 1, string, length);
}

__int64 __fastcall KOFShaderManager::loadVertShader(
        const char *_vertFile,
        unsigned __int8 crypt,
        unsigned __int8 *pData)
{
  const char *v4; // rax
  char v5; // r8
  __int64 v6; // rdx
  __int64 result; // rax
  unsigned int slot[4]; // [rsp+30h] [rbp-128h] BYREF
  char filename[256]; // [rsp+40h] [rbp-118h] BYREF

  v4 = _vertFile;
  do
  {
    v5 = *v4;
    v4[filename - _vertFile] = *v4;
    ++v4;
  }
  while ( v5 );
  v6 = -1i64;
  do
    ++v6;
  while ( _vertFile[v6] );
  filename[(int)v6 - 2] = 118;
  filename[(int)v6 - 1] = 101;
  filename[(int)v6] = 114;
  filename[(int)v6 + 1] = 116;
  if ( (unsigned __int64)((int)v6 + 2) >= 0x100 )
  {
    _report_rangecheckfailure();
    JUMPOUT(0x140245991i64);
  }
  filename[(int)v6 + 2] = 0;
  slot[0] = 0;
  if ( OGLShader::compileShader(slot, 0x8B31u, filename, crypt, 0i64, 0) )
    return slot[0];
  result = slot[0];
  if ( slot[0] )
  {
    _glewDeleteShader((unsigned int)AgSingleton<KOFShaderManager>::ms_instance[4 * slot[0] + 360451].__vftable);
    return 0i64;
  }
  return result;
}

__int64 __fastcall AgUser::isSignedIn(Concurrency::details::ThreadInternalContext *this)
{
  return 1i64;
}

__int64 __fastcall KOFShaderManager::onSingletonInit(KOFShaderManager *this)
{
  KOFShaderManager::Program *m_program; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx
  KOFShaderManager::Shader *m_shader; // rax
  unsigned int *v6; // rdi
  __int64 v7; // rsi
  __int64 result; // rax

  m_program = this->m_program;
  v3 = 0x8000i64;
  v4 = 0x8000i64;
  do
  {
    m_program->m_ID = 0;
    ++m_program;
    --v4;
  }
  while ( v4 );
  *(_QWORD *)&this->m_nextProgramIDSlot = 0i64;
  m_shader = this->m_shader;
  do
  {
    m_shader->m_ID = 0;
    ++m_shader;
    --v3;
  }
  while ( v3 );
  *(_QWORD *)this->m_shaderUniformSize = 0i64;
  v6 = this->m_bufferID[0];
  *(_QWORD *)&this->m_shaderUniformSize[2] = 0i64;
  v7 = 11i64;
  *(_QWORD *)&this->m_shaderUniformSize[4] = 0i64;
  *(_QWORD *)&this->m_shaderUniformSize[6] = 0i64;
  this->m_nextShaderSlot = 0;
  do
  {
    _glewGenBuffers(3, v6);
    v6 += 3;
    --v7;
  }
  while ( v7 );
  *(_QWORD *)this->m_bufferRoundRobin = 0i64;
  *(_QWORD *)&this->m_bufferRoundRobin[2] = 0i64;
  *(_QWORD *)&this->m_bufferRoundRobin[4] = 0i64;
  *(_QWORD *)&this->m_bufferRoundRobin[6] = 0i64;
  *(_QWORD *)&this->m_bufferRoundRobin[8] = 0i64;
  this->m_bufferRoundRobin[10] = 0;
  memset(&this->m_currentConstants, 0, sizeof(this->m_currentConstants));
  memset(&this->m_currentConstants2D, 0, 0x5048ui64);
  result = 1i64;
  this->m_uniformBufferWriteMask = -1;
  return result;
}

void __fastcall KOFShaderManager::setContentBufferPtr(KOFShaderManager *this, int no)
{
  void ***v2; // r8

  v2 = &this->m_shaderUniformPtr[no];
  **v2 = &this->m_currentConstants;
  (*v2)[1] = &this->m_currentConstants.u_ModelViewProj;
  (*v2)[2] = &this->m_currentConstants.u_ModelViewOrthoProj;
  (*v2)[3] = &this->m_currentConstants.u_ModelProjPos;
  (*v2)[4] = &this->m_currentConstants.u_ModelOrthoPos;
  (*v2)[5] = &this->m_currentConstants.u_color;
  (*v2)[6] = &this->m_currentConstants.u_orthoProjRatio;
  (*v2)[7] = &this->m_currentConstants.u_zOffset;
  (*v2)[8] = &this->m_currentConstants.u_constantBaseFiller1;
  (*v2)[9] = &this->m_currentConstants.u_projNormAngCosSinRimCosRimSin;
  (*v2)[10] = &this->m_currentConstants.u_eyePosition;
  (*v2)[11] = &this->m_currentConstants.u_rimLightColour;
  (*v2)[17] = &this->m_currentConstants.u_screenSize;
  (*v2)[66] = &this->m_currentConstantOption.u_blendProjection;
  (*v2)[65] = &this->m_currentConstantOption.u_textureAddPercentage;
  (*v2)[18] = &this->m_currentConstantOption;
  (*v2)[19] = &this->m_currentConstantOption.u_materialSpecular;
  (*v2)[20] = &this->m_currentConstantOption.u_materialEmission;
  (*v2)[21] = &this->m_currentConstantOption.u_materialReflection;
  (*v2)[22] = &this->m_currentConstantOption.u_invModelView;
  (*v2)[23] = &this->m_currentConstantOption.u_texture;
  (*v2)[24] = &this->m_currentConstantOption.u_texture1;
  (*v2)[28] = &this->m_currentConstantOption.u_groundFogUpSettings;
  (*v2)[29] = &this->m_currentConstantOption.u_groundFogDownSettings;
  (*v2)[30] = &this->m_currentConstantOption.u_skyFogUpSettings;
  (*v2)[31] = &this->m_currentConstantOption.u_skyFogDownSettings;
  (*v2)[32] = &this->m_currentConstantOption.u_groundFogCalcSettings;
  (*v2)[33] = &this->m_currentConstantOption.u_skyFogCalcSettings;
  (*v2)[34] = &this->m_currentConstantOption.u_fogStrengthGroundUpDownSkyUpDown;
  (*v2)[41] = &this->m_currentConstantOption.u_fogGroundSkyOn;
  (*v2)[35] = &this->m_currentConstantOption.u_groundFogUpColour;
  (*v2)[36] = &this->m_currentConstantOption.u_groundFogDownColour;
  (*v2)[37] = &this->m_currentConstantOption.u_skyFogUpColour;
  (*v2)[38] = &this->m_currentConstantOption.u_skyFogDownColour;
  (*v2)[39] = &this->m_currentConstantOption.u_fogGroundSkyCalcType;
  (*v2)[40] = &this->m_currentConstantOption.u_fogCalcSettingsExtra;
  (*v2)[72] = &this->m_currentConstantOption.u_reflectionPinching;
  (*v2)[74] = &this->m_currentConstantOption.u_emissiveAddMul;
  (*v2)[44] = &this->m_currentConstantOption.u_hemiLightUpperColour;
  (*v2)[45] = &this->m_currentConstantOption.u_hemiLightLowerColour;
  (*v2)[46] = &this->m_currentConstantOption.u_translucencySettings;
  (*v2)[47] = &this->m_currentConstantOption.u_translucencyOuterCol;
  (*v2)[48] = &this->m_currentConstantOption.u_translucencyMiddleCol;
  (*v2)[49] = &this->m_currentConstantOption.u_translucencyInnerCol;
  (*v2)[69] = &this->m_currentConstantOption.u_specularMultiplier;
  (*v2)[64] = &this->m_currentConstantOption.u_specularPower;
  (*v2)[42] = &this->m_currentConstantOption.u_rimLightMinMax;
  (*v2)[68] = &this->m_currentConstantOption.u_normalHeight;
  (*v2)[50] = &this->m_currentConstantOption.u_anisotropicSpread;
  (*v2)[51] = &this->m_currentConstantOption.u_multiUVLerpBlend;
  (*v2)[52] = &this->m_currentConstantOption.u_reflectionMultiplier;
  (*v2)[55] = &this->m_currentConstantOption.u_nearFarPlanes;
  (*v2)[56] = &this->m_currentConstantOption.u_modelEffectNormSettings;
  (*v2)[57] = &this->m_currentConstantOption.u_modelEffectCamSettings;
  (*v2)[58] = &this->m_currentConstantOption.u_vertexColAdj;
  (*v2)[70] = &this->m_currentConstantOption.u_elapsedTime;
  (*v2)[67] = &this->m_currentConstantOption.u_fillColourType;
  (*v2)[71] = &this->m_currentConstantOption.u_causticLerp;
  (*v2)[59] = &this->m_currentConstantOption.u_fillColour;
  (*v2)[60] = &this->m_currentConstantOption.u_extraEmissionTint;
  (*v2)[63] = &this->m_currentConstantOption.u_shadowLightAreaRadius;
  (*v2)[62] = &this->m_currentConstantOption.u_shadowLightAreaType;
  (*v2)[61] = &this->m_currentConstantOption.u_shadowLightAreaPosMinMax;
  (*v2)[53] = &this->m_currentConstantOption.u_matcapVal;
  (*v2)[43] = &this->m_currentConstantOption.u_ambientLightMultiplier;
  (*v2)[75] = &this->m_currentConstantOption.u_materialOpacity;
  (*v2)[73] = &this->m_currentConstantOption.u_constOptState;
  (*v2)[77] = &this->m_currentConstantLight;
  (*v2)[78] = this->m_currentConstantLight.u_lightPosition;
  (*v2)[79] = this->m_currentConstantLight.u_lightDirection;
  (*v2)[80] = this->m_currentConstantLight.u_lightCastsShadows;
  (*v2)[81] = this->m_currentConstantLight.u_lightTypeAndSpotSettings;
  (*v2)[82] = this->m_currentConstantLight.u_lightIntensityAndDecayRate;
  (*v2)[83] = &this->m_currentConstantLight.u_lightShadowColour;
  (*v2)[84] = &this->m_currentConstantLight.u_noLighting;
  (*v2)[85] = &this->m_currentConstantLight.u_lightCount;
  (*v2)[86] = &this->m_currentConstantLight.u_lightShadowMinVisibility;
  (*v2)[87] = &this->m_currentConstantLight.u_lightHardShadowEdge;
  (*v2)[88] = &this->m_currentConstantLight.u_lightShadowBiasMaxStr;
  (*v2)[89] = &this->m_currentConstantLight.u_ShadowLightViewProj;
  (*v2)[90] = this->m_currentConstantLight.u_ShadowLightViewProjBias;
  (*v2)[91] = &this->m_currentConstantLight.u_postAddDiffuseFactor;
  (*v2)[92] = &this->m_currentConstantLight.u_postAddLightDiffuseFactor;
  (*v2)[93] = &this->m_currentConstantLight.u_lightShadowDotRangeMinMax;
  (*v2)[94] = &this->m_currentConstantPostFX;
  (*v2)[95] = &this->m_currentConstantPostFX.u_postfxBlurSize;
  (*v2)[96] = &this->m_currentConstantPostFX.u_postfxOpacity;
  (*v2)[97] = &this->m_currentConstantPostFX.u_postfxBlendFactor;
  (*v2)[98] = &this->m_currentConstantPostFX.u_postfxPixelSize;
  (*v2)[99] = &this->m_currentConstantPostFX.u_postfxNearFar;
  (*v2)[101] = &this->m_currentConstantPostFX.u_postfxDOFNearFarStr;
  (*v2)[102] = &this->m_currentConstantPostFX.u_postfxBloomSatIntBaseSatInt;
  (*v2)[100] = &this->m_currentConstantPostFX.u_postfxGodRaySettings;
  (*v2)[109] = &this->m_currentConstantPostFX.u_postfxSunPos;
  (*v2)[103] = &this->m_currentConstantPostFX.u_postfxElapsedTime;
  (*v2)[104] = &this->m_currentConstantPostFX.u_postfxWaterTranslation;
  (*v2)[105] = &this->m_currentConstantPostFX.u_postfxWaterReflectScale;
  (*v2)[107] = &this->m_currentConstantPostFX.u_postfxWaterTint;
  (*v2)[106] = &this->m_currentConstantPostFX.u_postfxWaterUseReflection;
  (*v2)[111] = &this->m_currentConstantPostFX.u_postfxWindDir;
  (*v2)[108] = &this->m_currentConstantPostFX.u_postfxFillColourType;
  (*v2)[112] = &this->m_currentConstantPostFX.u_postfxFillColour;
  (*v2)[113] = &this->m_currentConstantPostFX.u_postfxFXAA;
  (*v2)[114] = &this->m_currentConstantPostFX.u_postfxHazeFilter;
  (*v2)[110] = &this->m_currentConstantPostFX.u_postfxHighlightThresholdBrightness;
  (*v2)[115] = &this->m_currentConstantScreenFilter;
  (*v2)[116] = &this->m_currentConstantScreenFilter.u_screenFilterBriSatConOn;
  (*v2)[117] = &this->m_currentConstantScreenFilter.u_screenFilterPSLevelsOn;
  (*v2)[118] = &this->m_currentConstantScreenFilter.u_screenFilterGradientOn;
  (*v2)[120] = &this->m_currentConstantScreenFilter.u_screenFilterPSLevelsInGamma;
  (*v2)[119] = &this->m_currentConstantScreenFilter.u_screenFilterBriSatCon;
  (*v2)[121] = &this->m_currentConstantScreenFilter.u_screenFilterPSLevelsInBlackWhite;
  (*v2)[122] = &this->m_currentConstantScreenFilter.u_screenFilterPSLevelsOutBlackWhite;
  (*v2)[123] = &this->m_currentConstantScreenFilter.u_screenFilterGradientStartCol;
  (*v2)[124] = &this->m_currentConstantScreenFilter.u_screenFilterGradientEndCol;
  (*v2)[125] = &this->m_currentConstantScreenFilter.u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity;
  (*v2)[126] = &this->m_currentConstantScreenFilter.u_monitorFilterMidTonesColShift;
  (*v2)[127] = &this->m_currentConstantEffect;
  (*v2)[128] = &this->m_currentConstantEffect.u_effectColor2UvSize;
  (*v2)[129] = &this->m_currentConstantEffect.u_effectAlpha1UvSize;
  (*v2)[130] = &this->m_currentConstantEffect.u_effectAlpha2UvSize;
  (*v2)[131] = &this->m_currentConstantEffect.u_effectNormalUvSize;
  (*v2)[132] = &this->m_currentConstantEffect.u_effectUvAnimeNum;
  (*v2)[133] = &this->m_currentConstantEffect.u_effectColor1UvAnimeParam;
  (*v2)[134] = &this->m_currentConstantEffect.u_effectColor2UvAnimeParam;
  (*v2)[135] = &this->m_currentConstantEffect.u_effectAlpha1UvAnimeParam;
  (*v2)[136] = &this->m_currentConstantEffect.u_effectAlpha2UvAnimeParam;
  (*v2)[137] = &this->m_currentConstantEffect.u_effectNormalUvAnimeParam;
  (*v2)[138] = &this->m_currentConstantEffect.u_effectZOffset;
  (*v2)[139] = &this->m_currentConstantEffect.u_effectDistortionParam;
  (*v2)[140] = &this->m_currentConstantEffect.u_effectFalloffParam;
  (*v2)[141] = &this->m_currentConstantEffect.u_effectBlurUV;
  (*v2)[142] = &this->m_currentConstantEffect.u_effectFillColour;
  (*v2)[148] = &this->m_currentConstantEffect.u_effectCameraPos;
  (*v2)[143] = &this->m_currentConstantEffect.u_effectNear;
  (*v2)[144] = &this->m_currentConstantEffect.u_effectFar;
  (*v2)[145] = &this->m_currentConstantEffect.u_effectBlendProjection;
  (*v2)[146] = &this->m_currentConstantEffect.u_effectProjNormAngLightOffset;
  (*v2)[147] = &this->m_currentConstantEffect.u_effectOrthoProjRatio;
  (*v2)[149] = &this->m_currentConstantEffect.u_effectActZOffset;
  (*v2)[150] = &this->m_currentConstantEffect.u_effectPosOffset;
  (*v2)[151] = this->m_currentConstantEffect.u_effectLightDiffuse;
  (*v2)[152] = this->m_currentConstantEffect.u_effectLightPosition;
  (*v2)[153] = this->m_currentConstantEffect.u_effectLightAttenuation;
  (*v2)[154] = this->m_currentConstantEffect.u_effectLightIntensity;
  (*v2)[155] = &this->m_currentConstantEffect.u_effectBufferScale;
  (*v2)[156] = &this->m_currentConstantEffect.u_effectInfluenceOfLight;
  (*v2)[157] = &this->m_currentConstantEffect.u_effectIgnoreUvMirror;
  (*v2)[172] = &this->m_currentConstantBone;
  (*v2)[158] = &this->m_currentConstantStage;
  (*v2)[159] = &this->m_currentConstantStage.u_uvCenter;
  (*v2)[160] = &this->m_currentConstantStage.u_uvRotate;
  (*v2)[161] = &this->m_currentConstantStage.u_uvScroll1;
  (*v2)[162] = &this->m_currentConstantStage.u_uvCenter1;
  (*v2)[163] = &this->m_currentConstantStage.u_uvRotate1;
  (*v2)[164] = this->m_currentConstantStage.u_stageGroupObjectTrans;
  (*v2)[165] = &this->m_currentConstantExtra.u_opacity;
  (*v2)[167] = &this->m_currentConstantExtra;
  (*v2)[168] = &this->m_currentConstantExtra.u_textureUVPan1;
  (*v2)[169] = &this->m_currentConstantExtra.u_textureUVPan2;
  (*v2)[170] = &this->m_currentConstantExtra.u_vertexCol1Adj;
  (*v2)[171] = &this->m_currentConstantExtra.u_materialDiffuse2;
}

void __fastcall KOFShaderManager::setProgramUniformsSlot(KOFShaderManager *this, int programSlot, int num)
{
  const char **v4; // rsi
  char *v5; // rbp
  unsigned __int64 v6; // r14
  int v7; // edi
  signed int i; // ebx
  signed int UniformBlockIndex; // eax
  int *m_shaderUniformSize; // rcx
  __int64 v11; // rax
  void **v12; // rax
  __int64 v13; // r10

  if ( programSlot >= 0 )
  {
    v4 = UniformBufferName;
    v5 = (char *)this + 88 * programSlot;
    v6 = num;
    v7 = 0;
    for ( i = 0; i < 11; ++i )
    {
      UniformBlockIndex = _glewGetUniformBlockIndex(*((_DWORD *)v5 + 2), *v4);
      if ( UniformBlockIndex >= 0 )
        _glewUniformBlockBinding(*((_DWORD *)v5 + 2), UniformBlockIndex, i);
      ++v4;
    }
    m_shaderUniformSize = this->m_shaderUniformSize;
    v11 = 0i64;
    while ( *m_shaderUniformSize != (_DWORD)v6 )
    {
      if ( !*m_shaderUniformSize )
      {
        v12 = (void **)operator new[](saturated_mul(v6, 8ui64));
        v13 = v7;
        this->m_shaderUniformPtr[v7] = v12;
        switch ( (_DWORD)v6 )
        {
          case 0xAD:
            KOFShaderManager::setContentBufferPtr(this, v7);
            break;
          case 2:
            *v12 = &this->m_currentConstants2D;
            *((_QWORD *)this->m_shaderUniformPtr[v7] + 1) = &this->m_currentConstants2D.u_color;
            break;
          case 6:
            v12[2] = &this->m_currentConstants2DFog.u_ModelView;
            *this->m_shaderUniformPtr[v7] = &this->m_currentConstants2DFog;
            *((_QWORD *)this->m_shaderUniformPtr[v7] + 1) = &this->m_currentConstants2DFog.u_color;
            *((_QWORD *)this->m_shaderUniformPtr[v7] + 3) = &this->m_currentConstants2DFog.u_fogColor;
            *((_QWORD *)this->m_shaderUniformPtr[v7] + 4) = &this->m_currentConstants2DFog.u_fogParam1;
            *((_QWORD *)this->m_shaderUniformPtr[v7] + 5) = &this->m_currentConstants2DFog.u_fogParam2;
            break;
        }
        this->m_shaderUniformSize[v13] = v6;
        break;
      }
      ++v7;
      ++v11;
      ++m_shaderUniformSize;
      if ( v11 >= 8 )
        return;
    }
    *((_DWORD *)v5 + 11) = v7;
  }
}

void __fastcall KOFShaderManager::setUniformBuffer(
        KOFShaderManager *this,
        UniformBuffer buffer,
        void *uniforms,
        unsigned __int64 uniforms_size)
{
  char *v6; // r14
  __int64 v7; // rbx

  v6 = (char *)this + 4 * buffer;
  v7 = *((unsigned int *)v6 + 988364);
  _glewBindBufferBase(0x8A11u, buffer, this->m_bufferID[buffer][v7]);
  _glewBufferData(0x8A11u, uniforms_size, 0i64, 0x88E0u);
  _glewBufferSubData(0x8A11u, 0i64, uniforms_size, uniforms);
  *((_DWORD *)v6 + 988364) = ((int)v7 + 1) % 3u;
}

void __fastcall KOFShaderManager::setUniformWriteMask(KOFShaderManager *this, int location)
{
  switch ( location )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      this->m_uniformBufferWriteMask |= 7u;
      break;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 17:
      this->m_uniformBufferWriteMask |= 1u;
      break;
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 55:
    case 56:
    case 57:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
      this->m_uniformBufferWriteMask |= 8u;
      break;
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
      this->m_uniformBufferWriteMask |= 0x10u;
      break;
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
      this->m_uniformBufferWriteMask |= 0x20u;
      break;
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
      this->m_uniformBufferWriteMask |= 0x40u;
      break;
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
      this->m_uniformBufferWriteMask |= 0x100u;
      break;
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
      this->m_uniformBufferWriteMask |= 0x200u;
      break;
    case 165:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
      this->m_uniformBufferWriteMask |= 0x400u;
      break;
    case 172:
      this->m_uniformBufferWriteMask |= 0x80u;
      break;
    default:
      return;
  }
}

void __fastcall KOFShaderManager::setUniforms(KOFShaderManager *this)
{
  Framework::GLManager *v1; // rbp
  unsigned int m_uniformBufferWriteMask; // ebx
  unsigned int m_currentTypes; // esi
  __int64 commandBoneCount; // rcx

  v1 = Framework::GLManager::glm;
  Framework::GLManager::glm->m_bOpenGLBlocked = 1;
  m_uniformBufferWriteMask = this->m_uniformBufferWriteMask;
  m_currentTypes = this->m_currentTypes;
  if ( ((unsigned __int8)m_currentTypes & this->m_uniformBufferWriteMask & 1) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Base, &this->m_currentConstants, 0x138ui64);
    m_uniformBufferWriteMask &= ~1u;
  }
  if ( (m_currentTypes & 2) != 0 && (m_uniformBufferWriteMask & 8) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Option, &this->m_currentConstantOption, 0x280ui64);
    m_uniformBufferWriteMask &= ~8u;
  }
  if ( (m_currentTypes & 4) != 0 && (m_uniformBufferWriteMask & 0x10) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Light, &this->m_currentConstantLight, 0x280ui64);
    m_uniformBufferWriteMask &= ~0x10u;
  }
  if ( (m_currentTypes & 8) != 0 && (m_uniformBufferWriteMask & 0x20) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_PostFX, &this->m_currentConstantPostFX, 0xC0ui64);
    m_uniformBufferWriteMask &= ~0x20u;
  }
  if ( (m_currentTypes & 0x10) != 0 && (m_uniformBufferWriteMask & 0x40) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_ScreenFilter, &this->m_currentConstantScreenFilter, 0x70ui64);
    m_uniformBufferWriteMask &= ~0x40u;
  }
  if ( (m_currentTypes & 0x20) != 0 && (m_uniformBufferWriteMask & 0x100) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Effect, &this->m_currentConstantEffect, 0x130ui64);
    m_uniformBufferWriteMask &= ~0x100u;
  }
  if ( (m_currentTypes & 0x40) != 0 && (m_uniformBufferWriteMask & 0x80u) != 0 )
  {
    commandBoneCount = Framework::GLManager::glm->commandBoneCount;
    if ( (int)commandBoneCount > 0 )
      KOFShaderManager::setUniformBuffer(this, UniformBuffer_Bone, &this->m_currentConstantBone, commandBoneCount << 6);
    m_uniformBufferWriteMask &= ~0x80u;
  }
  if ( (m_currentTypes & 0x80u) != 0 && (m_uniformBufferWriteMask & 0x200) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Stage, &this->m_currentConstantStage, 0xA30ui64);
    m_uniformBufferWriteMask &= ~0x200u;
  }
  if ( (m_currentTypes & 0x100) != 0 && (m_uniformBufferWriteMask & 0x400) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Extra, &this->m_currentConstantExtra, 0x40ui64);
    m_uniformBufferWriteMask &= ~0x400u;
  }
  if ( (m_currentTypes & 0x200) != 0 && (m_uniformBufferWriteMask & 2) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Base2D, &this->m_currentConstants2D, 0x50ui64);
    m_uniformBufferWriteMask &= ~2u;
  }
  if ( (m_currentTypes & 0x400) != 0 && (m_uniformBufferWriteMask & 4) != 0 )
  {
    KOFShaderManager::setUniformBuffer(this, UniformBuffer_Fog, &this->m_currentConstants2DFog, 0xA8ui64);
    m_uniformBufferWriteMask &= ~4u;
  }
  this->m_uniformBufferWriteMask = m_uniformBufferWriteMask;
  v1->m_bOpenGLBlocked = 0;
}

void __fastcall KOFShaderManager::unloadSlot(KOFShaderManager *this, int programSlot)
{
  Framework::GLManager *v2; // r14
  char *v3; // rsi
  unsigned int v4; // ebp
  unsigned int Program; // eax
  std::_List_node<std::pair<int const ,int>,void *> *Next; // rbx
  std::_List_buy<std::pair<int const ,int>> *v7; // rcx
  std::_List_node<std::pair<int const ,int>,void *> *v8; // rax
  unsigned __int64 v9; // rdx
  int v10; // edi
  void *v11; // rcx
  void *v12; // rcx
  unsigned int *v13; // rbx
  unsigned int v14; // [rsp+30h] [rbp-48h] BYREF
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > > v15; // [rsp+38h] [rbp-40h]
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,int> > > >,bool> result; // [rsp+40h] [rbp-38h] BYREF
  int v17; // [rsp+88h] [rbp+10h] BYREF
  int v18; // [rsp+90h] [rbp+18h] BYREF
  int v19; // [rsp+98h] [rbp+20h] BYREF

  if ( programSlot >= 0 )
  {
    v17 = programSlot;
    v2 = Framework::GLManager::glm;
    v3 = (char *)this + 88 * programSlot;
    Framework::GLManager::glm->m_bOpenGLBlocked = 1;
    v4 = *((_DWORD *)v3 + 2);
    Program = _glewCreateProgram();
    v3[48] = 0;
    *((_DWORD *)v3 + 2) = Program;
    Next = shaderLookup._List._Mypair._Myval2._Myhead->_Next;
    v8 = std::_List_buy<std::pair<int const,int>>::_Buynode<unsigned int &,int &>(
           v7,
           shaderLookup._List._Mypair._Myval2._Myhead->_Next,
           shaderLookup._List._Mypair._Myval2._Myhead->_Next->_Prev,
           (unsigned int *)v3 + 2,
           &v17);
    if ( shaderLookup._List._Mypair._Myval2._Mysize == 0xAAAAAAAAAAAAAA9i64 )
      std::_Xlength_error("list<T> too long");
    ++shaderLookup._List._Mypair._Myval2._Mysize;
    Next->_Prev = v8;
    v8->_Prev->_Next = v8;
    v15._Ptr = shaderLookup._List._Mypair._Myval2._Myhead->_Next;
    std::_Hash<std::_Umap_traits<int,int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,int>>,0>>::_Insert<std::pair<int const,int> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,int>>>>>(
      &shaderLookup,
      &result,
      &v15._Ptr->_Myval,
      v15);
    v10 = 0;
    **((_DWORD **)v3 + 7) = *((_DWORD *)v3 + 2);
    v11 = *(void **)(*((_QWORD *)v3 + 7) + 8i64);
    if ( v11 )
    {
      operator delete(v11, v9);
      *(_QWORD *)(*((_QWORD *)v3 + 7) + 8i64) = 0i64;
    }
    v12 = *(void **)(*((_QWORD *)v3 + 7) + 40i64);
    if ( v12 )
    {
      operator delete(v12, v9);
      *(_QWORD *)(*((_QWORD *)v3 + 7) + 40i64) = 0i64;
    }
    v18 = 0;
    _glewGetAttachedShaders(v4, 2, &v18, &v14);
    if ( v18 > 0 )
    {
      v13 = &v14;
      do
      {
        _glewGetShaderiv(*v13, 0x8B4Fu, &v19);
        if ( v19 == 35633 )
        {
          _glewAttachShader(*((_DWORD *)v3 + 2), *v13);
          _glewDetachShader(v4, *v13);
        }
        ++v10;
        ++v13;
      }
      while ( v10 < v18 );
    }
    _glewDeleteProgram(v4);
    v2->m_bOpenGLBlocked = 0;
  }
}

void __fastcall KOFShaderManager::useProgramSlot(KOFShaderManager *this, int programSlot)
{
  char *v4; // rsi
  int v5; // ebx
  int v6; // er14
  unsigned int v7; // eax
  Framework::GLManager *v8; // rbp
  unsigned int m_constantTypes; // eax

  if ( programSlot >= 0 )
  {
    v4 = (char *)this + 88 * programSlot;
    v5 = *((_DWORD *)v4 + 3);
    v6 = *((_DWORD *)v4 + 5);
    KOFShaderManager::link(this, (KOFShaderManager::Program *)(v4 + 8));
    v7 = *((_DWORD *)v4 + 2);
    this->m_currentProgramSlot = programSlot;
    v8 = Framework::GLManager::glm;
    this->m_currentProgramID = v7;
    if ( v5 <= 0 )
    {
      if ( v6 <= 0 )
        return;
      v8->m_bOpenGLBlocked = 1;
      _glewUseProgram(*((_DWORD *)v4 + 2));
      v8->m_bOpenGLBlocked = 0;
      m_constantTypes = this->m_shader[*((int *)v4 + 9)].m_constantTypes;
    }
    else
    {
      v8->m_bOpenGLBlocked = 1;
      _glewUseProgram(*((_DWORD *)v4 + 2));
      v8->m_bOpenGLBlocked = 0;
      m_constantTypes = this->m_shader[*((int *)v4 + 7)].m_constantTypes | this->m_shader[*((int *)v4 + 8)].m_constantTypes;
    }
    this->m_currentTypes = m_constantTypes;
  }
}

