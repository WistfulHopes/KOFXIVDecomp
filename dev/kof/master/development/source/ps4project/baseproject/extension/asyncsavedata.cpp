#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/pc_savedata.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exwaitcondition.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xhash"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/asyncjob.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/refcountable.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exthread.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xxatomic"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/bilinkable.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/asyncsavedata.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exlockable.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/atomic_int.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/atomic"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/asyncjob.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exthread.cpp"

unsigned long long extension::savedata_detail::DataConverter::CalcHash(const std::string & data); // 0x140247120
bool extension::savedata_detail::DataConverter::CheckHashedData(std::string & data); // 0x140247190
std::string extension::savedata_detail::DataConverter::MakeSavedFileImage(const std::string & data); // 0x140247290
std::string extension::savedata_detail::AsyncSaveDataState::getData(); // 0x1402473B0
extension::savedata_detail::AsyncSaveDataJob::~AsyncSaveDataJob(); // 0x140247450
class extension::savedata_detail::AsyncSaveDataJobFactory
{
private:
	static const extension::AsyncSaveDataStorage::DataOption s_defaultOption; // 0xFFFFFFFFFFFFFFFF
public:
	static std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob,std::default_delete<extension::savedata_detail::AsyncSaveDataJob> > CreateLoadJob(const std::string &, const extension::AsyncSaveDataStorage::DataOption *);
	static std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob,std::default_delete<extension::savedata_detail::AsyncSaveDataJob> > CreateSaveJob(const std::string &, const std::string &, const extension::AsyncSaveDataStorage::DataOption *);
};
void(*??s_defaultOption$initializer$@AsyncSaveDataJobFactory@savedata_detail@extension@@0P6AXXZEA@@3P6AXXZEA)(); // 0x140740888
std::piecewise_construct_t std::piecewise_construct; // 0x1408AECE7
std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob,std::default_delete<extension::savedata_detail::AsyncSaveDataJob> > extension::savedata_detail::AsyncSaveDataJobFactory::CreateLoadJob(const std::string & fileName, const extension::AsyncSaveDataStorage::DataOption * opt); // 0x1402474F0
std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob,std::default_delete<extension::savedata_detail::AsyncSaveDataJob> > extension::savedata_detail::AsyncSaveDataJobFactory::CreateSaveJob(const std::string & fileName, const std::string & data, const extension::AsyncSaveDataStorage::DataOption * opt); // 0x140247610
extension::AsyncSaveDataStorage::AsyncSaveDataStorage(); // 0x1402477C0
extension::AsyncSaveDataStorage & extension::AsyncSaveDataStorage::Instance(); // 0x1402478D0
extension::FutureSaveData extension::AsyncSaveDataStorage::load(const std::string & fileName, const extension::AsyncSaveDataStorage::DataOption * opt); // 0x140247940
extension::FutureSaveData extension::AsyncSaveDataStorage::save(const std::string & filename, const std::string & data, const extension::AsyncSaveDataStorage::DataOption * opt); // 0x140247AA0
extension::FutureSaveData::~FutureSaveData(); // 0x140247C00
void extension::FutureSaveData::reset(); // 0x140247C50//decompilation failure at 140740888!
//decompilation failure at 1408AECE7!
void __fastcall extension::AsyncSaveDataStorage::AsyncSaveDataStorage(extension::AsyncSaveDataStorage *this)
{
  extension::ExThread::StartParam param; // [rsp+28h] [rbp-20h] BYREF

  the_instance_2.m_jobConsumer.m_abort = 0;
  the_instance_2.m_jobConsumer.m_running = 1;
  the_instance_2.m_jobConsumer.__vftable = (extension::AsyncJobConsumer_vtbl *)&extension::AsyncJobConsumer::`vftable';
  extension::ExSimpleThreadPool<extension::ExThread>::ExSimpleThreadPool<extension::ExThread>(
    &the_instance_2.m_jobConsumer.m_threads,
    1);
  extension::SynchronizedQueue<extension::ExThread::Runnable>::SynchronizedQueue<extension::ExThread::Runnable>(&the_instance_2.m_jobConsumer.m_jobQueue);
  the_instance_2.m_defaultOption.userIndex = 1;
  the_instance_2.m_defaultOption.fsName._Mypair._Myval2._Myres = 15i64;
  the_instance_2.m_defaultOption.fsName._Mypair._Myval2._Mysize = 0i64;
  the_instance_2.m_defaultOption.fsName._Mypair._Myval2._Bx._Buf[0] = 0;
  the_instance_2.m_defaultOption.fsSizeLimit = 0i64;
  the_instance_2.m_defaultOption.titleText._Mypair._Myval2._Myres = 15i64;
  the_instance_2.m_defaultOption.titleText._Mypair._Myval2._Mysize = 0i64;
  the_instance_2.m_defaultOption.titleText._Mypair._Myval2._Bx._Buf[0] = 0;
  the_instance_2.m_defaultOption.subTitleText._Mypair._Myval2._Myres = 15i64;
  the_instance_2.m_defaultOption.subTitleText._Mypair._Myval2._Mysize = 0i64;
  the_instance_2.m_defaultOption.subTitleText._Mypair._Myval2._Bx._Buf[0] = 0;
  the_instance_2.m_defaultOption.progressOption = 0;
  param.stackSize = 0x10000i64;
  *(_QWORD *)&param.priority = 0i64;
  param.name = "Async Save Data";
  extension::AsyncJobConsumer::start(&the_instance_2.m_jobConsumer, &param);
}

void __fastcall std::unique_ptr<OGLModel>::~unique_ptr<OGLModel>(
        std::unique_ptr<extension::SoundList::LazyMediaSetBuildJob> *this)
{
  extension::SoundList::LazyMediaSetBuildJob *Myval2; // rcx

  Myval2 = this->_Mypair._Myval2;
  if ( Myval2 )
    ((void (__fastcall *)(extension::SoundList::LazyMediaSetBuildJob *, __int64))Myval2->~AgIThreadHost)(Myval2, 1i64);
}

void __fastcall extension::savedata_detail::AsyncSaveDataJob::~AsyncSaveDataJob(
        extension::savedata_detail::AsyncSaveDataJob *this)
{
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rcx
  extension::savedata_detail::AsyncSaveDataState *v3; // rdi

  this->__vftable = (extension::savedata_detail::AsyncSaveDataJob_vtbl *)&extension::savedata_detail::AsyncSaveDataJob::`vftable';
  m_ptr = this->m_state.m_ptr;
  if ( (m_ptr->m_result.m_value._My_val & 0x8000000000000000ui64) != 0i64 )
    m_ptr->m_result.m_value._My_val = 1i64;
  std::string::~string(&this->m_fileImageSaveTo);
  v3 = this->m_state.m_ptr;
  if ( v3 && _InterlockedExchangeAdd64((volatile signed __int64 *)v3, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    std::string::~string(&v3->m_data);
    std::string::~string(&v3->m_fileName);
    operator delete(v3, 0x50ui64);
  }
  this->__vftable = (extension::savedata_detail::AsyncSaveDataJob_vtbl *)&AgIThreadHost::`vftable';
}

void __fastcall extension::FutureSaveData::~FutureSaveData(extension::FutureSaveData *this)
{
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rbx

  m_ptr = this->m_state.m_ptr;
  if ( this->m_state.m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    if ( m_ptr )
    {
      std::string::~string(&m_ptr->m_data);
      std::string::~string(&m_ptr->m_fileName);
      operator delete(m_ptr, 0x50ui64);
    }
  }
}

unsigned __int64 __fastcall extension::savedata_detail::DataConverter::CalcHash(const std::string *data)
{
  unsigned __int64 Mysize; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v3; // r10
  unsigned __int64 Myres; // r11
  const std::string *Ptr; // rcx
  unsigned __int64 v7; // r8

  Mysize = data->_Mypair._Myval2._Mysize;
  result = 0x49AC1E26B7E2495Ci64 - Mysize;
  v3 = 0i64;
  if ( Mysize )
  {
    Myres = data->_Mypair._Myval2._Myres;
    do
    {
      if ( Myres < 0x10 )
        Ptr = data;
      else
        Ptr = (const std::string *)data->_Mypair._Myval2._Bx._Ptr;
      v7 = (unsigned __int8)Ptr->_Mypair._Myval2._Bx._Buf[v3++];
      result = (result << 8) | (unsigned __int8)(result >> 11) ^ (unsigned __int8)(result >> 50) ^ v7;
    }
    while ( v3 < Mysize );
  }
  return result;
}

char __fastcall extension::savedata_detail::DataConverter::CheckHashedData(std::string *data)
{
  char *v2; // rax
  __int64 v3; // r8
  __int64 v4; // r9
  unsigned __int64 v5; // r9
  unsigned __int64 Mysize; // rax
  unsigned __int64 v7; // rdx
  std::string *Ptr; // rax
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // r11
  unsigned __int64 i; // r10
  std::string *v12; // rax
  unsigned __int64 v13; // r8

  if ( data->_Mypair._Myval2._Mysize >= 8 )
  {
    do
    {
      v2 = std::string::back(data);
      v5 = (unsigned __int8)*v2 | (unsigned __int64)(v4 << 8);
      Mysize = data->_Mypair._Myval2._Mysize;
      v7 = Mysize - 1;
      if ( Mysize < Mysize - 1 )
        std::_Xout_of_range("invalid string position");
      data->_Mypair._Myval2._Mysize = v7;
      if ( data->_Mypair._Myval2._Myres < 0x10 )
        Ptr = data;
      else
        Ptr = (std::string *)data->_Mypair._Myval2._Bx._Ptr;
      Ptr->_Mypair._Myval2._Bx._Buf[v7] = 0;
    }
    while ( (unsigned __int64)(v3 + 1) < 8 );
    v9 = data->_Mypair._Myval2._Mysize;
    v10 = 0i64;
    for ( i = 0x49AC1E26B7E2495Ci64 - v9;
          v10 < v9;
          i = (i << 8) | (unsigned __int8)(i >> 11) ^ (unsigned __int8)(i >> 50) ^ v13 )
    {
      if ( data->_Mypair._Myval2._Myres < 0x10 )
        v12 = data;
      else
        v12 = (std::string *)data->_Mypair._Myval2._Bx._Ptr;
      v13 = (unsigned __int8)v12->_Mypair._Myval2._Bx._Buf[v10++];
    }
    if ( i == v5 )
      return 1;
  }
  data->_Mypair._Myval2._Mysize = 0i64;
  if ( data->_Mypair._Myval2._Myres >= 0x10 )
    data = (std::string *)data->_Mypair._Myval2._Bx._Ptr;
  data->_Mypair._Myval2._Bx._Buf[0] = 0;
  return 0;
}

std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *__fastcall extension::savedata_detail::AsyncSaveDataJobFactory::CreateLoadJob(
        std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *result,
        const std::string *fileName,
        const extension::AsyncSaveDataStorage::DataOption *opt)
{
  extension::savedata_detail::AsyncSaveDataState *v6; // rax
  extension::savedata_detail::AsyncSaveDataState *v7; // rsi
  std::string *p_m_fileName; // rcx
  char *Buf; // rax
  char **p_m_data; // rax
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rbx
  extension::AsyncSaveDataStorage::DataOption *v12; // rdx

  extension::savedata_detail::PCSaveDataJob::CreateLoadJob(result);
  v6 = (extension::savedata_detail::AsyncSaveDataState *)operator new(0x50ui64);
  v7 = v6;
  v6->m_refCount.m_value._My_val = 1i64;
  p_m_fileName = &v6->m_fileName;
  v6->m_fileName._Mypair._Myval2._Myres = 15i64;
  v6->m_fileName._Mypair._Myval2._Mysize = 0i64;
  if ( v6->m_fileName._Mypair._Myval2._Myres < 0x10 )
    Buf = v6->m_fileName._Mypair._Myval2._Bx._Buf;
  else
    Buf = p_m_fileName->_Mypair._Myval2._Bx._Ptr;
  *Buf = 0;
  std::string::assign(p_m_fileName, fileName, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  p_m_data = (char **)&v7->m_data;
  v7->m_data._Mypair._Myval2._Myres = 15i64;
  v7->m_data._Mypair._Myval2._Mysize = 0i64;
  if ( v7->m_data._Mypair._Myval2._Myres >= 0x10 )
    p_m_data = (char **)*p_m_data;
  *(_BYTE *)p_m_data = 0;
  v7->m_result.m_value._My_val = -1i64;
  m_ptr = result->_Mypair._Myval2->m_state.m_ptr;
  result->_Mypair._Myval2->m_state.m_ptr = v7;
  if ( m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    std::string::~string(&m_ptr->m_data);
    std::string::~string(&m_ptr->m_fileName);
    operator delete(m_ptr, 0x50ui64);
  }
  v12 = &extension::savedata_detail::AsyncSaveDataJobFactory::s_defaultOption;
  if ( opt )
    v12 = (extension::AsyncSaveDataStorage::DataOption *)opt;
  result->_Mypair._Myval2->setDataOption(result->_Mypair._Myval2, v12);
  return result;
}

std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *__fastcall extension::savedata_detail::AsyncSaveDataJobFactory::CreateSaveJob(
        std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *result,
        const std::string *fileName,
        const std::string *data,
        const extension::AsyncSaveDataStorage::DataOption *opt)
{
  extension::savedata_detail::AsyncSaveDataState *v8; // rax
  extension::savedata_detail::AsyncSaveDataState *v9; // r14
  std::string *p_m_fileName; // rcx
  char *Buf; // rax
  char **p_m_data; // rax
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rbx
  std::string *SavedFileImage; // rax
  char *Ptr; // rcx
  char *v16; // rax
  extension::AsyncSaveDataStorage::DataOption *v17; // rdx
  std::string resulta; // [rsp+40h] [rbp-68h] BYREF

  extension::savedata_detail::PCSaveDataJob::CreateSaveJob(result);
  v8 = (extension::savedata_detail::AsyncSaveDataState *)operator new(0x50ui64);
  v9 = v8;
  v8->m_refCount.m_value._My_val = 1i64;
  p_m_fileName = &v8->m_fileName;
  v8->m_fileName._Mypair._Myval2._Myres = 15i64;
  v8->m_fileName._Mypair._Myval2._Mysize = 0i64;
  if ( v8->m_fileName._Mypair._Myval2._Myres < 0x10 )
    Buf = v8->m_fileName._Mypair._Myval2._Bx._Buf;
  else
    Buf = p_m_fileName->_Mypair._Myval2._Bx._Ptr;
  *Buf = 0;
  std::string::assign(p_m_fileName, fileName, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  p_m_data = (char **)&v9->m_data;
  v9->m_data._Mypair._Myval2._Myres = 15i64;
  v9->m_data._Mypair._Myval2._Mysize = 0i64;
  if ( v9->m_data._Mypair._Myval2._Myres >= 0x10 )
    p_m_data = (char **)*p_m_data;
  *(_BYTE *)p_m_data = 0;
  v9->m_result.m_value._My_val = -1i64;
  m_ptr = result->_Mypair._Myval2->m_state.m_ptr;
  result->_Mypair._Myval2->m_state.m_ptr = v9;
  if ( m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    std::string::~string(&m_ptr->m_data);
    std::string::~string(&m_ptr->m_fileName);
    operator delete(m_ptr, 0x50ui64);
  }
  SavedFileImage = extension::savedata_detail::DataConverter::MakeSavedFileImage(&resulta, data);
  std::string::assign(&result->_Mypair._Myval2->m_fileImageSaveTo, SavedFileImage);
  if ( resulta._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = resulta._Mypair._Myval2._Bx._Ptr;
    if ( resulta._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (resulta._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v16 = (char *)*((_QWORD *)resulta._Mypair._Myval2._Bx._Ptr - 1);
      if ( v16 >= resulta._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(resulta._Mypair._Myval2._Bx._Ptr - v16) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(resulta._Mypair._Myval2._Bx._Ptr - v16) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)resulta._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  v17 = &extension::savedata_detail::AsyncSaveDataJobFactory::s_defaultOption;
  if ( opt )
    v17 = (extension::AsyncSaveDataStorage::DataOption *)opt;
  result->_Mypair._Myval2->setDataOption(result->_Mypair._Myval2, v17);
  return result;
}

extension::AsyncSaveDataStorage *__fastcall extension::AsyncSaveDataStorage::Instance()
{
  extension::AsyncSaveDataStorage *v0; // rcx

  if ( dword_140ACDB54 > *(_DWORD *)(*(_QWORD *)NtCurrentTeb()->Reserved1[11] + 40i64) )
  {
    Init_thread_header(&dword_140ACDB54);
    if ( dword_140ACDB54 == -1 )
    {
      extension::AsyncSaveDataStorage::AsyncSaveDataStorage(v0);
      atexit(extension::AsyncSaveDataStorage::Instance_::_2_::_dynamic_atexit_destructor_for__the_instance__);
      Init_thread_footer(&dword_140ACDB54);
    }
  }
  return &the_instance_2;
}

std::string *__fastcall extension::savedata_detail::DataConverter::MakeSavedFileImage(
        std::string *result,
        const std::string *data)
{
  unsigned __int64 v3; // rbp
  std::string *Ptr; // rax
  unsigned __int64 v5; // rdi
  __int64 v6; // rsi
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r9
  unsigned __int64 Mysize; // r10
  unsigned __int8 v10; // al
  std::string *v11; // rcx

  v3 = 0i64;
  result->_Mypair._Myval2._Myres = 15i64;
  result->_Mypair._Myval2._Mysize = 0i64;
  if ( result->_Mypair._Myval2._Myres < 0x10 )
    Ptr = result;
  else
    Ptr = (std::string *)result->_Mypair._Myval2._Bx._Ptr;
  Ptr->_Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(result, data, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = extension::savedata_detail::DataConverter::CalcHash(result);
  std::string::reserve(result, result->_Mypair._Myval2._Mysize + 8);
  v6 = 8i64;
  do
  {
    std::string::push_back(result, v5);
    v5 >>= 8;
    --v6;
  }
  while ( v6 );
  v7 = 0x791FE442F2325BE7i64;
  v8 = 0x6E7EC7A948D56232i64;
  Mysize = result->_Mypair._Myval2._Mysize;
  if ( Mysize )
  {
    do
    {
      v10 = v7 ^ (v8 >> 47);
      if ( result->_Mypair._Myval2._Myres < 0x10 )
        v11 = result;
      else
        v11 = (std::string *)result->_Mypair._Myval2._Bx._Ptr;
      v11->_Mypair._Myval2._Bx._Buf[v3] ^= v10;
      v8 = (v8 << 8) | HIBYTE(v7);
      v7 = v10 | (v7 << 8);
      ++v3;
    }
    while ( v3 < Mysize );
  }
  return result;
}

char *__fastcall std::string::back(std::string *this)
{
  if ( this->_Mypair._Myval2._Myres < 0x10 )
    return (char *)this + this->_Mypair._Myval2._Mysize - 1;
  else
    return &this->_Mypair._Myval2._Bx._Ptr[this->_Mypair._Myval2._Mysize - 1];
}

std::string *__fastcall extension::savedata_detail::AsyncSaveDataState::getData(
        extension::savedata_detail::AsyncSaveDataState *this,
        std::string *result)
{
  std::string *v3; // rax

  if ( (this->m_result.m_value._My_val & 0x8000000000000000ui64) == 0i64 )
  {
    result->_Mypair._Myval2._Myres = 15i64;
    result->_Mypair._Myval2._Mysize = 0i64;
    result->_Mypair._Myval2._Bx._Buf[0] = 0;
    std::string::assign(result, &this->m_data, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    return result;
  }
  else
  {
    result->_Mypair._Myval2._Myres = 15i64;
    v3 = result;
    result->_Mypair._Myval2._Mysize = 0i64;
    result->_Mypair._Myval2._Bx._Buf[0] = 0;
  }
  return v3;
}

extension::RefCountablePtr<extension::savedata_detail::AsyncSaveDataState> *__fastcall extension::savedata_detail::AsyncSaveDataJob::getSharedState(
        extension::savedata_detail::AsyncSaveDataJob *this,
        extension::RefCountablePtr<extension::savedata_detail::AsyncSaveDataState> *result)
{
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // r8

  m_ptr = this->m_state.m_ptr;
  result->m_ptr = m_ptr;
  if ( m_ptr )
    _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 1ui64);
  return result;
}

extension::FutureSaveData *__fastcall extension::AsyncSaveDataStorage::load(
        extension::AsyncSaveDataStorage *this,
        extension::FutureSaveData *result,
        const std::string *fileName,
        const extension::AsyncSaveDataStorage::DataOption *opt)
{
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rcx
  extension::savedata_detail::AsyncSaveDataState *v7; // rbx
  extension::savedata_detail::AsyncSaveDataState *v8; // rbx
  extension::savedata_detail::AsyncSaveDataJob *v9; // rax
  void (__fastcall ***v11)(_QWORD, __int64); // [rsp+28h] [rbp-40h] BYREF
  std::unique_ptr<extension::ExThread::Runnable> obj; // [rsp+30h] [rbp-38h] BYREF
  extension::RefCountablePtr<extension::savedata_detail::AsyncSaveDataState> resulta; // [rsp+38h] [rbp-30h] BYREF
  __int64 v14; // [rsp+40h] [rbp-28h]
  extension::savedata_detail::AsyncSaveDataJob *v15; // [rsp+70h] [rbp+8h] BYREF
  extension::FutureSaveData *v16; // [rsp+78h] [rbp+10h]

  v16 = result;
  v14 = -2i64;
  result->m_state.m_ptr = 0i64;
  result->m_lastError = ErrorCode_None;
  extension::savedata_detail::AsyncSaveDataJobFactory::CreateLoadJob(
    (std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *)&v15,
    fileName,
    opt);
  m_ptr = extension::savedata_detail::AsyncSaveDataJob::getSharedState(v15, &resulta)->m_ptr;
  if ( m_ptr )
    _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 1ui64);
  v7 = result->m_state.m_ptr;
  result->m_state.m_ptr = m_ptr;
  if ( v7 && _InterlockedExchangeAdd64((volatile signed __int64 *)v7, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    std::string::~string(&v7->m_data);
    std::string::~string(&v7->m_fileName);
    operator delete(v7, 0x50ui64);
  }
  v8 = resulta.m_ptr;
  if ( resulta.m_ptr
    && _InterlockedExchangeAdd64((volatile signed __int64 *)resulta.m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1
    && v8 )
  {
    std::string::~string(&v8->m_data);
    std::string::~string(&v8->m_fileName);
    operator delete(v8, 0x50ui64);
  }
  v9 = v15;
  v15 = 0i64;
  resulta.m_ptr = (extension::savedata_detail::AsyncSaveDataState *)&v11;
  v11 = 0i64;
  obj._Mypair._Myval2 = v9;
  extension::SynchronizedQueue<extension::ExThread::Runnable>::enqueue(
    &this->m_jobConsumer.m_jobQueue,
    (std::unique_ptr<extension::ExThread::Runnable>)&obj);
  if ( v11 )
    (**v11)(v11, 1i64);
  if ( v15 )
    ((void (__fastcall *)(extension::savedata_detail::AsyncSaveDataJob *, __int64))v15->~AgIThreadHost)(v15, 1i64);
  return result;
}

void __fastcall std::string::push_back(std::string *this, char _Ch)
{
  unsigned __int64 Mysize; // rax
  unsigned __int64 *p_Mysize; // rdi
  std::string *v4; // rbx
  unsigned __int64 Myres; // rcx
  unsigned __int64 v7; // rax
  bool v8; // cf
  std::string *Ptr; // rax

  Mysize = this->_Mypair._Myval2._Mysize;
  p_Mysize = &this->_Mypair._Myval2._Mysize;
  v4 = this;
  Myres = this->_Mypair._Myval2._Myres;
  if ( Mysize == Myres )
  {
    v7 = Mysize + 1;
    if ( v7 == -1i64 )
      std::_Xlength_error("string too long");
    if ( Myres >= v7 )
    {
      if ( !v7 )
      {
        v8 = v4->_Mypair._Myval2._Myres < 0x10;
        *p_Mysize = 0i64;
        if ( v8 )
          Ptr = v4;
        else
          Ptr = (std::string *)v4->_Mypair._Myval2._Bx._Ptr;
        Ptr->_Mypair._Myval2._Bx._Buf[0] = 0;
      }
    }
    else
    {
      std::string::_Copy(v4, v7, *p_Mysize);
    }
  }
  if ( v4->_Mypair._Myval2._Myres >= 0x10 )
    v4 = (std::string *)v4->_Mypair._Myval2._Bx._Ptr;
  v4->_Mypair._Myval2._Bx._Buf[(*p_Mysize)++] = _Ch;
  v4->_Mypair._Myval2._Bx._Buf[*p_Mysize] = 0;
}

void __fastcall extension::FutureSaveData::reset(extension::FutureSaveData *this)
{
  unsigned __int64 My_val; // rax
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rbx

  if ( this->m_state.m_ptr )
  {
    My_val = this->m_state.m_ptr->m_result.m_value._My_val;
    if ( (My_val & 0x80000000) != 0i64 )
      LODWORD(My_val) = 0;
    this->m_lastError = My_val;
    m_ptr = this->m_state.m_ptr;
    this->m_state.m_ptr = 0i64;
    if ( m_ptr )
    {
      if ( _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
      {
        std::string::~string(&m_ptr->m_data);
        std::string::~string(&m_ptr->m_fileName);
        operator delete(m_ptr, 0x50ui64);
      }
    }
  }
}

extension::FutureSaveData *__fastcall extension::AsyncSaveDataStorage::save(
        extension::AsyncSaveDataStorage *this,
        extension::FutureSaveData *result,
        const std::string *filename,
        const std::string *data,
        const extension::AsyncSaveDataStorage::DataOption *opt)
{
  extension::savedata_detail::AsyncSaveDataState *m_ptr; // rcx
  extension::savedata_detail::AsyncSaveDataState *v8; // rbx
  extension::savedata_detail::AsyncSaveDataState *v9; // rbx
  extension::savedata_detail::AsyncSaveDataJob *v10; // rax
  void (__fastcall ***v12)(_QWORD, __int64); // [rsp+28h] [rbp-40h] BYREF
  std::unique_ptr<extension::ExThread::Runnable> obj; // [rsp+30h] [rbp-38h] BYREF
  extension::RefCountablePtr<extension::savedata_detail::AsyncSaveDataState> resulta; // [rsp+38h] [rbp-30h] BYREF
  __int64 v15; // [rsp+40h] [rbp-28h]
  extension::savedata_detail::AsyncSaveDataJob *v16; // [rsp+70h] [rbp+8h] BYREF
  extension::FutureSaveData *v17; // [rsp+78h] [rbp+10h]

  v17 = result;
  v15 = -2i64;
  result->m_state.m_ptr = 0i64;
  result->m_lastError = ErrorCode_None;
  extension::savedata_detail::AsyncSaveDataJobFactory::CreateSaveJob(
    (std::unique_ptr<extension::savedata_detail::AsyncSaveDataJob> *)&v16,
    filename,
    data,
    opt);
  m_ptr = extension::savedata_detail::AsyncSaveDataJob::getSharedState(v16, &resulta)->m_ptr;
  if ( m_ptr )
    _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 1ui64);
  v8 = result->m_state.m_ptr;
  result->m_state.m_ptr = m_ptr;
  if ( v8 && _InterlockedExchangeAdd64((volatile signed __int64 *)v8, 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    std::string::~string(&v8->m_data);
    std::string::~string(&v8->m_fileName);
    operator delete(v8, 0x50ui64);
  }
  v9 = resulta.m_ptr;
  if ( resulta.m_ptr
    && _InterlockedExchangeAdd64((volatile signed __int64 *)resulta.m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1
    && v9 )
  {
    std::string::~string(&v9->m_data);
    std::string::~string(&v9->m_fileName);
    operator delete(v9, 0x50ui64);
  }
  v10 = v16;
  v16 = 0i64;
  resulta.m_ptr = (extension::savedata_detail::AsyncSaveDataState *)&v12;
  v12 = 0i64;
  obj._Mypair._Myval2 = v10;
  extension::SynchronizedQueue<extension::ExThread::Runnable>::enqueue(
    &this->m_jobConsumer.m_jobQueue,
    (std::unique_ptr<extension::ExThread::Runnable>)&obj);
  if ( v12 )
    (**v12)(v12, 1i64);
  if ( v16 )
    ((void (__fastcall *)(extension::savedata_detail::AsyncSaveDataJob *, __int64))v16->~AgIThreadHost)(v16, 1i64);
  return result;
}

