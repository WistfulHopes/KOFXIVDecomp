#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmodel.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/atomic"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/streambuf"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglbone.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmirror.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfunctional"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xxatomic"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogleffect.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglcurve.h"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogllight.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglsprite.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglrender.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/silverware/git/sdk/aghash.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "dev/silverware/git/sdk/agstringutils.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglfog.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglshader.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/shaderfxhelper.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/istream"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ostream"
#include "dev/silverware/git/sdk/agstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogllight.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmateriallight.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmodel.cpp"

class ShaderFxHelper::`anonymous-namespace'::ShaderFxCSVRecordReader
{
public:
	ShaderFxCSVRecordReader(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &, long);
private:
	ShaderFxCSVRecordReader(const ShaderFxHelper::`anonymous-namespace'::ShaderFxCSVRecordReader &);
	ShaderFxHelper::`anonymous-namespace'::ShaderFxCSVRecordReader & operator=(const ShaderFxHelper::`anonymous-namespace'::ShaderFxCSVRecordReader &);
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & m_record; // 0x0
	long m_currentPosition; // 0x8
public:
	bool isEnd();
	void getNext(float &);
	void getNext(long &);
	void getNext(unsigned char &);
	void getNext(bool &);
	const char * getNext();
	bool getNextAsBool();
	unsigned char getNextAsBoolean();
	long getNextAsInt();
	float getNextAsFloat();
};
const SHADER_TYPE_TBL ShaderTypeLookUpTbl[236]; // 0x1408A1600
std::piecewise_construct_t std::piecewise_construct; // 0x1408A137E
long ShaderFxHelper::ShaderFxApplyMaterialSetting(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & line, OGLModel & model); // 0x14023BE20
void ShaderFxHelper::ShaderFxApplyLightSetting(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & line, ShaderFxHelper::ShaderFxLightSetting & lightSetting); // 0x14023BF10
void ShaderFxHelper::ShaderFxApplyLightSetting(const ShaderFxHelper::ShaderFxLightSetting & src, OGLLight & dst); // 0x14023CC80
void ShaderFxHelper::ShaderFxExtractLightSetting(const OGLLight & src, ShaderFxHelper::ShaderFxLightSetting & dst); // 0x14023CDA0
void ShaderFxHelper::ShaderFxParseCSV(const char * csvBuffer, long bufferSize, const std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,OGLModel *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,OGLModel *> > > & targets, ShaderFxHelper::ShaderFxParseOption * opt); // 0x14023CE80//decompilation failure at 1408A1600!
//decompilation failure at 1408A137E!
std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *__fastcall std::_Tree<std::_Tmap_traits<std::string,unsigned int,std::less<std::string>,std::allocator<std::pair<std::string const,unsigned int>>,0>>::_Lbound<std::string>(
        std::_Tree<std::_Tmap_traits<std::string,extension::GFXIFontManager::LanguageConfig,std::less<std::string >,std::allocator<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig> >,0> > *this,
        const std::string *_Keyval)
{
  std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *Myhead; // r14
  std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *Parent; // rbx
  unsigned __int64 Mysize; // rbp
  unsigned __int64 Myres; // r15
  char **p_Myval; // rcx
  const std::string *Ptr; // rdx
  unsigned __int64 v9; // rdi
  size_t v10; // r8
  int v11; // eax

  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  Parent = this->_Mypair._Myval2._Myval2._Myhead->_Parent;
  if ( !Parent->_Isnil )
  {
    Mysize = _Keyval->_Mypair._Myval2._Mysize;
    Myres = _Keyval->_Mypair._Myval2._Myres;
    do
    {
      p_Myval = (char **)&Parent->_Myval;
      if ( Myres < 0x10 )
        Ptr = _Keyval;
      else
        Ptr = (const std::string *)_Keyval->_Mypair._Myval2._Bx._Ptr;
      if ( Parent->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
        p_Myval = (char **)*p_Myval;
      v9 = Parent->_Myval.first._Mypair._Myval2._Mysize;
      v10 = Mysize;
      if ( v9 < Mysize )
        v10 = Parent->_Myval.first._Mypair._Myval2._Mysize;
      if ( v10 && (v11 = memcmp(p_Myval, Ptr, v10)) != 0 )
      {
        if ( v11 >= 0 )
          goto LABEL_17;
      }
      else if ( v9 >= Mysize )
      {
LABEL_17:
        Myhead = Parent;
        Parent = Parent->_Left;
        continue;
      }
      Parent = Parent->_Right;
    }
    while ( !Parent->_Isnil );
  }
  return Myhead;
}

std::istream *__fastcall std::ws<char,std::char_traits<char>>(std::istream *_Istr)
{
  __int64 v2; // rcx
  int v3; // edi
  __int64 v4; // rcx
  const std::locale *v5; // rax
  std::locale::facet *v6; // r14
  std::_Facet_base *v7; // rax
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  int v10; // eax
  std::ios_base *v11; // rcx
  int v12; // edx
  __int64 v13; // rcx
  std::locale result; // [rsp+48h] [rbp-20h] BYREF

  v2 = *(int *)(*(_QWORD *)_Istr->gap0 + 4i64);
  if ( (_Istr->gap10[v2] & 1) == 0 )
  {
    v3 = 0;
    v4 = *(_QWORD *)&_Istr->gap10[v2 + 56];
    if ( v4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8i64))(v4);
    if ( std::istream::_Ipfx(_Istr, 1) )
    {
      v5 = std::ios_base::getloc((std::ios_base *)&_Istr->gap0[*(int *)(*(_QWORD *)_Istr->gap0 + 4i64)], &result);
      v6 = std::use_facet<std::ctype<char>>(v5);
      if ( result._Ptr )
      {
        v7 = result._Ptr->_Decref(result._Ptr);
        if ( v7 )
          ((void (__fastcall *)(std::_Facet_base *, __int64))v7->~_Facet_base)(v7, 1i64);
      }
      v8 = *(_QWORD *)&_Istr->gap10[*(int *)(*(_QWORD *)_Istr->gap0 + 4i64) + 56];
      v9 = **(unsigned __int8 ***)(v8 + 56);
      if ( v9 && **(int **)(v8 + 80) > 0 )
        v10 = *v9;
      else
        v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 48i64))(v8);
      while ( v10 != -1 )
      {
        if ( (*(_BYTE *)(*(_QWORD *)&v6[1]._Myrefs + 2i64 * (unsigned __int8)v10) & 0x48) == 0 )
          goto LABEL_16;
        v10 = std::streambuf::snextc(*(std::streambuf **)&_Istr->gap10[*(int *)(*(_QWORD *)_Istr->gap0 + 4i64) + 56]);
      }
      v3 = 1;
    }
LABEL_16:
    v11 = (std::ios_base *)&_Istr->gap0[*(int *)(*(_QWORD *)_Istr->gap0 + 4i64)];
    if ( v3 )
    {
      v12 = v3 | v11->_Mystate | 4;
      if ( v11[1].__vftable )
        v12 = v3 | v11->_Mystate;
      std::ios_base::clear(v11, v12, 0);
    }
    v13 = *(_QWORD *)&_Istr->gap10[*(int *)(*(_QWORD *)_Istr->gap0 + 4i64) + 56];
    if ( v13 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
  }
  return _Istr;
}

void __fastcall ShaderFxHelper::ShaderFxApplyLightSetting(
        const ShaderFxHelper::ShaderFxLightSetting *src,
        OGLLight *dst)
{
  float v2; // xmm1_4
  float v3; // xmm0_4
  float v4; // xmm1_4
  float v5; // xmm0_4
  float v6; // xmm2_4
  float v7; // xmm0_4
  float v8; // xmm1_4
  float v9; // xmm0_4
  float v10; // xmm0_4
  float v11; // xmm1_4
  float v12; // xmm2_4
  float v13; // xmm0_4

  if ( src->type < 4 )
    dst->m_LightType = src->type;
  v2 = src->position[2];
  v3 = src->position[1];
  dst->m_fPosition[0] = src->position[0];
  dst->m_fPosition[1] = v3;
  dst->m_fPosition[2] = v2;
  dst->m_fPosition[3] = 1.0;
  v4 = src->position[2];
  v5 = src->position[1];
  dst->m_fLocalOffset[0] = src->position[0];
  dst->m_fLocalOffset[1] = v5;
  dst->m_fLocalOffset[2] = v4;
  v6 = src->direction[2];
  v7 = src->direction[1];
  dst->m_fDirection[0] = src->direction[0];
  dst->m_fDirection[1] = v7;
  dst->m_fDirection[2] = v6;
  v8 = src->colour[2];
  v9 = src->colour[1];
  dst->m_fAmbient[0] = src->colour[0];
  dst->m_fAmbient[1] = v9;
  dst->m_fAmbient[2] = v8;
  dst->m_fAmbient[3] = 1.0;
  v10 = src->colour[1];
  v11 = src->colour[2];
  dst->m_fDiffuse[0] = src->colour[0];
  dst->m_fDiffuse[1] = v10;
  dst->m_fDiffuse[2] = v11;
  dst->m_fDiffuse[3] = 1.0;
  v12 = src->colour[2];
  v13 = src->colour[1];
  dst->m_fSpecular[0] = src->colour[0];
  dst->m_fSpecular[1] = v13;
  dst->m_fSpecular[2] = v12;
  dst->m_fSpecular[3] = 1.0;
  dst->m_fIntensity = src->intensity;
  dst->m_fConeAngleRad = src->coneAngleRad;
  dst->m_fPenumbraRad = src->penumbraRad;
  dst->m_bEmitSpecular = src->emitSpecular;
  dst->m_bEmitDiffuse = src->emitDiffuse;
  dst->m_DecayRate = src->decayRate;
  dst->m_fQuadraticAttenuation = 0.0;
  dst->m_bCastsShadows = 0;
  *(_QWORD *)&dst->m_fConstantAttenuation = 1036831949i64;
  dst->m_fExponent = 1.0;
  dst->m_fShininess = 10.0;
}

void __fastcall ShaderFxHelper::ShaderFxApplyLightSetting(
        const std::vector<std::string> *line,
        ShaderFxHelper::ShaderFxLightSetting *lightSetting)
{
  std::string **p_Mylast; // r15
  int v4; // er14
  __int64 v5; // rbx
  __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  const char *v8; // rbx
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  __int64 v15; // rcx
  const char *v16; // rcx
  long double v17; // xmm0_8
  __int64 *v18; // rax
  float v19; // xmm1_4
  __int64 v20; // rcx
  const char *v21; // rcx
  long double v22; // xmm0_8
  __int64 *v23; // rax
  float v24; // xmm1_4
  __int64 v25; // rcx
  const char *v26; // rcx
  float v27; // xmm1_4
  __int64 v28; // rcx
  const char *v29; // rcx
  long double v30; // xmm0_8
  __int64 *v31; // rax
  float v32; // xmm1_4
  __int64 v33; // rcx
  const char *v34; // rcx
  long double v35; // xmm0_8
  __int64 *v36; // rax
  float v37; // xmm1_4
  __int64 v38; // rcx
  const char *v39; // rcx
  float v40; // xmm1_4
  __int64 v41; // rcx
  char v42; // al
  __int64 v43; // rcx
  char v44; // al
  __int64 v45; // rcx
  const char *v46; // rcx
  long double v47; // xmm0_8
  __int64 *v48; // rax
  float v49; // xmm1_4
  __int64 v50; // rcx
  const char *v51; // rcx
  long double v52; // xmm0_8
  __int64 *v53; // rax
  float v54; // xmm1_4
  __int64 v55; // rcx
  const char *v56; // rcx
  float v57; // xmm1_4
  __int64 v58; // rcx
  const char *v59; // rcx
  float v60; // xmm1_4
  __int64 v61; // rcx
  const char *v62; // rcx
  float v63; // xmm1_4
  __int64 v64; // rcx
  const char *v65; // rcx
  float v66; // xmm1_4
  __int64 v67; // rcx
  char v68; // al
  __int64 v69; // rcx
  const char *v70; // rcx
  __int64 v71; // rcx
  const char *v72; // rcx
  __int64 v73; // rcx
  const char *v74; // rcx
  float v75; // xmm1_4
  float NextAsFloat; // xmm0_4
  float v77; // xmm0_4
  float v78; // xmm0_4
  float v79; // xmm0_4
  float v80; // xmm0_4
  float v81; // xmm0_4
  float v82; // xmm0_4
  float v83; // xmm0_4
  float v84; // xmm0_4
  float v85; // xmm0_4
  float v86; // xmm0_4
  float v87; // xmm0_4
  float v88; // xmm0_4
  __int64 v89; // rcx
  const char *v90; // rcx
  float v91; // xmm1_4
  __int64 v92; // rcx
  const char *v93; // rcx
  float v94; // xmm1_4
  __int64 v95; // rcx
  const char *v96; // rcx
  long double v97; // xmm0_8
  __int64 *v98; // rax
  float v99; // xmm1_4
  __int64 v100; // rcx
  const char *v101; // rcx
  long double v102; // xmm0_8
  __int64 *v103; // rax
  float v104; // xmm1_4
  __int64 v105; // rcx
  const char *v106; // rcx
  float v107; // xmm1_4
  __int64 v108; // rcx
  const char *v109; // rcx
  __int64 v110; // rcx
  const char *v111; // rcx
  bool dst[8]; // [rsp+20h] [rbp-10h] BYREF
  int v113; // [rsp+28h] [rbp-8h]

  *(_QWORD *)dst = line;
  p_Mylast = &line->_Mypair._Myval2._Mylast;
  v4 = 0;
  v113 = 0;
  *(_QWORD *)&lightSetting->type = 0i64;
  lightSetting->direction[1] = 0.0;
  *(_QWORD *)&lightSetting->direction[2] = 1065353216i64;
  *(_QWORD *)&lightSetting->position[1] = 0i64;
  lightSetting->colour[0] = 0.5;
  lightSetting->colour[1] = 0.5;
  lightSetting->colour[2] = 0.5;
  *(_QWORD *)&lightSetting->coneAngleRad = 1061752792i64;
  *(_WORD *)&lightSetting->emitSpecular = 257;
  lightSetting->decayRate = 0;
  lightSetting->castShadow = 0;
  lightSetting->groundShadowColour[0] = 0.0;
  lightSetting->groundShadowColour[1] = 0.029999999;
  lightSetting->groundShadowColour[2] = 0.059999999;
  lightSetting->groundShadowIntensity = 0.44;
  lightSetting->groundShadowMaxStrength = 0.80000001;
  lightSetting->bodySelfShadowBias = 0.012;
  lightSetting->bodySelfShadowMaxStrength = 0.94;
  if ( line->_Mypair._Myval2._Mylast - line->_Mypair._Myval2._Myfirst )
  {
    do
    {
      v5 = v4;
      v6 = **(_QWORD **)dst;
      v7 = ((__int64)*p_Mylast - **(_QWORD **)dst) >> 5;
      if ( v7 <= v4 )
      {
        v8 = &pnewText;
      }
      else
      {
        ++v4;
        v8 = (const char *)(v6 + 32 * v5);
        v113 = v4;
        if ( *((_QWORD *)v8 + 3) >= 0x10ui64 )
          v8 = *(const char **)v8;
      }
      if ( !strcmp(v8, "DIRECTIONAL") )
      {
        lightSetting->type = 1;
        goto LABEL_185;
      }
      v9 = 0i64;
      while ( 1 )
      {
        v10 = v8[v9++];
        if ( v10 != aSpot[v9 - 1] )
          break;
        if ( v9 == 5 )
        {
          lightSetting->type = 2;
          goto LABEL_185;
        }
      }
      v11 = 0i64;
      while ( 1 )
      {
        v12 = v8[v11++];
        if ( v12 != aPoint[v11 - 1] )
          break;
        if ( v11 == 6 )
        {
          lightSetting->type = 0;
          goto LABEL_185;
        }
      }
      v13 = 0i64;
      while ( 1 )
      {
        v14 = v8[v13++];
        if ( v14 != aAmbient[v13 - 1] )
          break;
        if ( v13 == 8 )
        {
          lightSetting->type = 3;
          goto LABEL_185;
        }
      }
      if ( !strcmp(v8, "DIRECTION") )
      {
        v15 = v4;
        if ( v7 <= v4 )
        {
          v16 = &pnewText;
        }
        else
        {
          ++v4;
          v16 = (const char *)(v6 + 32 * v15);
          v113 = v4;
          if ( *((_QWORD *)v16 + 3) >= 0x10ui64 )
            v16 = *(const char **)v16;
        }
        v17 = strtod(v16, 0i64);
        v18 = *(__int64 **)dst;
        v19 = v17;
        v20 = v4;
        lightSetting->direction[0] = v19;
        if ( ((__int64)*p_Mylast - *v18) >> 5 <= (unsigned __int64)v4 )
        {
          v21 = &pnewText;
        }
        else
        {
          ++v4;
          v21 = (const char *)(*v18 + 32 * v20);
          v113 = v4;
          if ( *((_QWORD *)v21 + 3) >= 0x10ui64 )
            v21 = *(const char **)v21;
        }
        v22 = strtod(v21, 0i64);
        v23 = *(__int64 **)dst;
        v24 = v22;
        v25 = v4;
        lightSetting->direction[1] = v24;
        if ( ((__int64)*p_Mylast - *v23) >> 5 <= (unsigned __int64)v4 )
        {
          v26 = &pnewText;
        }
        else
        {
          ++v4;
          v26 = (const char *)(*v23 + 32 * v25);
          v113 = v4;
          if ( *((_QWORD *)v26 + 3) >= 0x10ui64 )
            v26 = *(const char **)v26;
        }
        v27 = strtod(v26, 0i64);
        lightSetting->direction[2] = v27;
        goto LABEL_185;
      }
      if ( !strcmp(v8, "POSITION") )
      {
        v28 = v4;
        if ( v7 <= v4 )
        {
          v29 = &pnewText;
        }
        else
        {
          ++v4;
          v29 = (const char *)(v6 + 32 * v28);
          v113 = v4;
          if ( *((_QWORD *)v29 + 3) >= 0x10ui64 )
            v29 = *(const char **)v29;
        }
        v30 = strtod(v29, 0i64);
        v31 = *(__int64 **)dst;
        v32 = v30;
        v33 = v4;
        lightSetting->position[0] = v32;
        if ( ((__int64)*p_Mylast - *v31) >> 5 <= (unsigned __int64)v4 )
        {
          v34 = &pnewText;
        }
        else
        {
          ++v4;
          v34 = (const char *)(*v31 + 32 * v33);
          v113 = v4;
          if ( *((_QWORD *)v34 + 3) >= 0x10ui64 )
            v34 = *(const char **)v34;
        }
        v35 = strtod(v34, 0i64);
        v36 = *(__int64 **)dst;
        v37 = v35;
        v38 = v4;
        lightSetting->position[1] = v37;
        if ( ((__int64)*p_Mylast - *v36) >> 5 <= (unsigned __int64)v4 )
        {
          v39 = &pnewText;
        }
        else
        {
          ++v4;
          v39 = (const char *)(*v36 + 32 * v38);
          v113 = v4;
          if ( *((_QWORD *)v39 + 3) >= 0x10ui64 )
            v39 = *(const char **)v39;
        }
        v40 = strtod(v39, 0i64);
        lightSetting->position[2] = v40;
        goto LABEL_185;
      }
      v41 = 0i64;
      while ( 1 )
      {
        v42 = v8[v41++];
        if ( v42 != aColour[v41 - 1] )
          break;
        if ( v41 == 7 )
        {
LABEL_55:
          v45 = v4;
          if ( v7 <= v4 )
          {
            v46 = &pnewText;
          }
          else
          {
            ++v4;
            v46 = (const char *)(v6 + 32 * v45);
            v113 = v4;
            if ( *((_QWORD *)v46 + 3) >= 0x10ui64 )
              v46 = *(const char **)v46;
          }
          v47 = strtod(v46, 0i64);
          v48 = *(__int64 **)dst;
          v49 = v47;
          v50 = v4;
          lightSetting->colour[0] = v49;
          if ( ((__int64)*p_Mylast - *v48) >> 5 <= (unsigned __int64)v4 )
          {
            v51 = &pnewText;
          }
          else
          {
            ++v4;
            v51 = (const char *)(*v48 + 32 * v50);
            v113 = v4;
            if ( *((_QWORD *)v51 + 3) >= 0x10ui64 )
              v51 = *(const char **)v51;
          }
          v52 = strtod(v51, 0i64);
          v53 = *(__int64 **)dst;
          v54 = v52;
          v55 = v4;
          lightSetting->colour[1] = v54;
          if ( ((__int64)*p_Mylast - *v53) >> 5 <= (unsigned __int64)v4 )
          {
            v56 = &pnewText;
          }
          else
          {
            ++v4;
            v56 = (const char *)(*v53 + 32 * v55);
            v113 = v4;
            if ( *((_QWORD *)v56 + 3) >= 0x10ui64 )
              v56 = *(const char **)v56;
          }
          v57 = strtod(v56, 0i64);
          lightSetting->colour[2] = v57;
          goto LABEL_185;
        }
      }
      v43 = 0i64;
      while ( 1 )
      {
        v44 = v8[v43++];
        if ( v44 != aColor_0[v43 - 1] )
          break;
        if ( v43 == 6 )
          goto LABEL_55;
      }
      if ( !strcmp(v8, "INTENSITY") )
      {
        v58 = v4;
        if ( v7 <= v4 )
        {
          v59 = &pnewText;
        }
        else
        {
          ++v4;
          v59 = (const char *)(v6 + 32 * v58);
          v113 = v4;
          if ( *((_QWORD *)v59 + 3) >= 0x10ui64 )
            v59 = *(const char **)v59;
        }
        v60 = strtod(v59, 0i64);
        lightSetting->intensity = v60;
        goto LABEL_185;
      }
      if ( !strcmp(v8, "CONEANGLE") )
      {
        v61 = v4;
        if ( v7 <= v4 )
        {
          v62 = &pnewText;
        }
        else
        {
          ++v4;
          v62 = (const char *)(v6 + 32 * v61);
          v113 = v4;
          if ( *((_QWORD *)v62 + 3) >= 0x10ui64 )
            v62 = *(const char **)v62;
        }
        v63 = strtod(v62, 0i64);
        lightSetting->coneAngleRad = v63;
        goto LABEL_185;
      }
      if ( !strcmp(v8, "PENUMBRA") )
      {
        v64 = v4;
        if ( v7 <= v4 )
        {
          v65 = &pnewText;
        }
        else
        {
          ++v4;
          v65 = (const char *)(v6 + 32 * v64);
          v113 = v4;
          if ( *((_QWORD *)v65 + 3) >= 0x10ui64 )
            v65 = *(const char **)v65;
        }
        v66 = strtod(v65, 0i64);
        lightSetting->penumbraRad = v66;
        goto LABEL_185;
      }
      v67 = 0i64;
      while ( 1 )
      {
        v68 = v8[v67++];
        if ( v68 != aDropoff[v67 - 1] )
          break;
        if ( v67 == 8 )
        {
          v69 = v4;
          if ( v7 <= v4 )
          {
            v70 = &pnewText;
          }
          else
          {
            ++v4;
            v70 = (const char *)(v6 + 32 * v69);
            v113 = v4;
            if ( *((_QWORD *)v70 + 3) >= 0x10ui64 )
            {
              strtod(*(const char **)v70, 0i64);
              goto LABEL_185;
            }
          }
          strtod(v70, 0i64);
          goto LABEL_185;
        }
      }
      if ( !strcmp(v8, "EMIT_SPECULAR") || !strcmp(v8, "EMITSPECULAR") )
      {
        v110 = v4;
        if ( v7 <= v4 )
        {
          v111 = &pnewText;
        }
        else
        {
          ++v4;
          v111 = (const char *)(v6 + 32 * v110);
          v113 = v4;
          if ( *((_QWORD *)v111 + 3) >= 0x10ui64 )
            v111 = *(const char **)v111;
        }
        lightSetting->emitSpecular = strtol(v111, 0i64, 10) != 0;
      }
      else
      {
        if ( strcmp(v8, "EMIT_DIFFUSE") && strcmp(v8, "EMITDIFFUSE") )
        {
          if ( !strcmp(v8, "DECAYRATE") )
          {
            v71 = v4;
            if ( v7 <= v4 )
            {
              v72 = &pnewText;
            }
            else
            {
              ++v4;
              v72 = (const char *)(v6 + 32 * v71);
              v113 = v4;
              if ( *((_QWORD *)v72 + 3) >= 0x10ui64 )
                v72 = *(const char **)v72;
            }
            lightSetting->decayRate = strtol(v72, 0i64, 10);
            goto LABEL_185;
          }
          if ( strcmp(v8, "CASTSHADOWS") )
          {
            if ( !strcmp(v8, "GROUNDSHADOWCOLOR") || !strcmp(v8, "SHADOWCOLOR") )
            {
              v95 = v4;
              if ( v7 <= v4 )
              {
                v96 = &pnewText;
              }
              else
              {
                ++v4;
                v96 = (const char *)(v6 + 32 * v95);
                v113 = v4;
                if ( *((_QWORD *)v96 + 3) >= 0x10ui64 )
                  v96 = *(const char **)v96;
              }
              v97 = strtod(v96, 0i64);
              v98 = *(__int64 **)dst;
              v99 = v97;
              v100 = v4;
              lightSetting->groundShadowColour[0] = v99;
              if ( ((__int64)*p_Mylast - *v98) >> 5 <= (unsigned __int64)v4 )
              {
                v101 = &pnewText;
              }
              else
              {
                ++v4;
                v101 = (const char *)(*v98 + 32 * v100);
                v113 = v4;
                if ( *((_QWORD *)v101 + 3) >= 0x10ui64 )
                  v101 = *(const char **)v101;
              }
              v102 = strtod(v101, 0i64);
              v103 = *(__int64 **)dst;
              v104 = v102;
              v105 = v4;
              lightSetting->groundShadowColour[1] = v104;
              if ( ((__int64)*p_Mylast - *v103) >> 5 <= (unsigned __int64)v4 )
              {
                v106 = &pnewText;
              }
              else
              {
                ++v4;
                v106 = (const char *)(*v103 + 32 * v105);
                v113 = v4;
                if ( *((_QWORD *)v106 + 3) >= 0x10ui64 )
                  v106 = *(const char **)v106;
              }
              v107 = strtod(v106, 0i64);
              lightSetting->groundShadowColour[2] = v107;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "GROUNDSHADOWCOLINTENSITY") || !strcmp(v8, "SHADOWINTENSITY") )
            {
              v92 = v4;
              if ( v7 <= v4 )
              {
                v93 = &pnewText;
              }
              else
              {
                ++v4;
                v93 = (const char *)(v6 + 32 * v92);
                v113 = v4;
                if ( *((_QWORD *)v93 + 3) >= 0x10ui64 )
                  v93 = *(const char **)v93;
              }
              v94 = strtod(v93, 0i64);
              lightSetting->groundShadowIntensity = v94;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "GROUNDSHADOWBIAS") )
            {
              v73 = v4;
              if ( v7 <= v4 )
              {
                v74 = &pnewText;
              }
              else
              {
                ++v4;
                v74 = (const char *)(v6 + 32 * v73);
                v113 = v4;
                if ( *((_QWORD *)v74 + 3) >= 0x10ui64 )
                  v74 = *(const char **)v74;
              }
              v75 = strtod(v74, 0i64);
              lightSetting->groundShadowBias = v75;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "GROUNDSHADOWMAXSTR") || !strcmp(v8, "SHADOWMAXSTR") )
            {
              v89 = v4;
              if ( v7 <= v4 )
              {
                v90 = &pnewText;
              }
              else
              {
                ++v4;
                v90 = (const char *)(v6 + 32 * v89);
                v113 = v4;
                if ( *((_QWORD *)v90 + 3) >= 0x10ui64 )
                  v90 = *(const char **)v90;
              }
              v91 = strtod(v90, 0i64);
              lightSetting->groundShadowMaxStrength = v91;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "GROUNDSHADOWMAX") )
            {
              NextAsFloat = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->groundShadowVisibility = NextAsFloat;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWCOLOR") )
            {
              lightSetting->bodySelfShadowColour[0] = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              lightSetting->bodySelfShadowColour[1] = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v77 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowColour[2] = v77;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWCOLINTENSITY") )
            {
              v78 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowIntensity = v78;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWBIAS") || !strcmp(v8, "SELFSHADOWBIAS") )
            {
              v88 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowBias = v88;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWMAXSTR") || !strcmp(v8, "SELFSHADOWMAXSTR") )
            {
              v87 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowMaxStrength = v87;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWMAX") )
            {
              v79 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowVisibility = v79;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "BODYSELFSHADOWHARDEDGE") )
            {
              v80 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->bodySelfShadowHardEdge = v80;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWCOLOR") )
            {
              lightSetting->skinSelfShadowColour[0] = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              lightSetting->skinSelfShadowColour[1] = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v81 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowColour[2] = v81;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWCOLINTENSITY") )
            {
              v82 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowIntensity = v82;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWBIAS") )
            {
              v83 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowBias = v83;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWMAXSTR") )
            {
              v84 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowMaxStrength = v84;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWMAX") )
            {
              v85 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowVisibility = v85;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SKINSELFSHADOWHARDEDGE") )
            {
              v86 = ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNextAsFloat();
              v4 = v113;
              lightSetting->skinSelfShadowHardEdge = v86;
              goto LABEL_185;
            }
            if ( !strcmp(v8, "SHADOWBLURSTR") )
            {
              ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNext_2((int *)dst);
              v4 = v113;
              goto LABEL_185;
            }
            if ( strcmp(v8, "SHADOWUSEFXAA") && strcmp(v8, "SHADOWUSESLOPE") )
            {
              _DummyLogging("ShaderFxApplyLightSetting:  detect unknown parameter name[%s]");
              goto LABEL_185;
            }
          }
          ShaderFxHelper::_anonymous_namespace_::ShaderFxCSVRecordReader::getNext_0(dst);
          v4 = v113;
          goto LABEL_185;
        }
        v108 = v4;
        if ( v7 <= v4 )
        {
          v109 = &pnewText;
        }
        else
        {
          ++v4;
          v109 = (const char *)(v6 + 32 * v108);
          v113 = v4;
          if ( *((_QWORD *)v109 + 3) >= 0x10ui64 )
            v109 = *(const char **)v109;
        }
        lightSetting->emitDiffuse = strtol(v109, 0i64, 10) != 0;
      }
LABEL_185:
      p_Mylast = (std::string **)(*(_QWORD *)dst + 8i64);
    }
    while ( (__int64)(*(_QWORD *)(*(_QWORD *)dst + 8i64) - **(_QWORD **)dst) >> 5 > (unsigned __int64)v4 );
  }
}

__int64 __fastcall ShaderFxHelper::ShaderFxApplyMaterialSetting(const std::vector<std::string> *line, OGLModel *model)
{
  std::string *Myfirst; // r11
  OGLMaterial *m_pMaterial; // r14
  int v6; // edi
  __int64 m_ucMaterialCount; // rbx
  const char **p_m_cName; // r9
  __int64 v9; // r10
  __int64 result; // rax
  __int64 v11; // rbx

  Myfirst = line->_Mypair._Myval2._Myfirst;
  if ( line->_Mypair._Myval2._Myfirst == line->_Mypair._Myval2._Mylast )
    return 0xFFFFFFFFi64;
  m_pMaterial = model->m_pMaterial;
  if ( !m_pMaterial )
    return 0xFFFFFFFFi64;
  if ( Myfirst->_Mypair._Myval2._Myres >= 0x10 )
    Myfirst = (std::string *)Myfirst->_Mypair._Myval2._Bx._Ptr;
  v6 = 0;
  if ( !model->m_ucMaterialCount )
  {
LABEL_10:
    _DummyLogging("ShaderFxApplyMaterialSetting: material name[%s] not found.");
    return 0xFFFFFFFFi64;
  }
  m_ucMaterialCount = model->m_ucMaterialCount;
  p_m_cName = (const char **)&m_pMaterial->m_cName;
  v9 = 0i64;
  while ( !*p_m_cName || strcmp(Myfirst->_Mypair._Myval2._Bx._Buf, *p_m_cName) )
  {
    ++v6;
    ++v9;
    p_m_cName += 141;
    if ( v9 >= m_ucMaterialCount )
      goto LABEL_10;
  }
  v11 = v6;
  ShaderFxHelper::_anonymous_namespace_::ApplyMaterialSettingImpl(line, &m_pMaterial[v11]);
  result = (unsigned int)v6;
  model->m_pMaterial[v11].m_cTextureIndex = v6;
  return result;
}

void __fastcall ShaderFxHelper::ShaderFxExtractLightSetting(
        const OGLLight *src,
        ShaderFxHelper::ShaderFxLightSetting *dst)
{
  *(_QWORD *)&dst->type = 0i64;
  *(_QWORD *)&dst->position[1] = 0i64;
  dst->direction[1] = 0.0;
  *(_QWORD *)&dst->direction[2] = 1065353216i64;
  dst->colour[0] = 0.5;
  dst->colour[1] = 0.5;
  dst->colour[2] = 0.5;
  *(_QWORD *)&dst->coneAngleRad = 1061752792i64;
  *(_WORD *)&dst->emitSpecular = 257;
  dst->decayRate = 0;
  dst->castShadow = 0;
  dst->groundShadowColour[0] = 0.0;
  dst->groundShadowColour[1] = 0.029999999;
  dst->groundShadowColour[2] = 0.059999999;
  dst->groundShadowIntensity = 0.44;
  dst->groundShadowMaxStrength = 0.80000001;
  dst->bodySelfShadowBias = 0.012;
  dst->bodySelfShadowMaxStrength = 0.94;
  dst->type = src->m_LightType;
  dst->position[0] = src->m_fPosition[0];
  dst->position[1] = src->m_fPosition[1];
  dst->position[2] = src->m_fPosition[2];
  dst->direction[0] = src->m_fDirection[0];
  dst->direction[1] = src->m_fDirection[1];
  dst->direction[2] = src->m_fDirection[2];
  dst->colour[0] = src->m_fDiffuse[0];
  dst->colour[1] = src->m_fDiffuse[1];
  dst->colour[2] = src->m_fDiffuse[2];
  dst->intensity = src->m_fIntensity;
  dst->coneAngleRad = src->m_fConeAngleRad;
  dst->penumbraRad = src->m_fPenumbraRad;
  dst->emitSpecular = src->m_bEmitSpecular != 0;
  dst->emitDiffuse = src->m_bEmitDiffuse != 0;
}

void __fastcall ShaderFxHelper::ShaderFxParseCSV(
        const char *csvBuffer,
        int bufferSize,
        const std::map<std::string,OGLModel *> *targets,
        ShaderFxHelper::ShaderFxParseOption *opt)
{
  ShaderFxHelper::ShaderFxParseOption *v4; // r14
  const char *v5; // rsi
  __int64 v6; // rbx
  OGLModel *m_ptr; // r15
  int v8; // er13
  int v9; // er12
  std::istream *v10; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v11; // r8
  std::integral_constant<bool,0> v12; // r9
  std::istream *v13; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v14; // r8
  std::integral_constant<bool,0> v15; // r9
  __int64 Myoff; // r9
  __int64 Fpos; // r10
  const char *v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // r11
  __int64 v21; // rbx
  const char *i; // r8
  __int64 v23; // rax
  unsigned __int64 v24; // rdx
  std::istream *v25; // rax
  std::istream *v26; // rax
  std::string *p_Str; // r14
  char *Ptr; // rcx
  unsigned __int64 Myres; // rdx
  unsigned __int64 Mysize; // rdi
  char *v31; // r14
  std::string *v32; // rsi
  std::string *v33; // rbx
  std::string *v34; // rbx
  std::string *v35; // rdi
  std::string *v36; // rax
  signed __int64 v37; // r8
  unsigned __int64 v38; // r14
  std::string *v39; // rax
  std::string *v40; // r9
  char *v41; // r9
  unsigned __int64 v42; // rdi
  std::string *v43; // rax
  std::string *Myfirst; // r8
  std::string *Mylast; // rcx
  signed __int64 v46; // rbx
  signed __int64 v47; // rcx
  unsigned __int64 v48; // rdx
  unsigned __int64 v49; // r9
  unsigned __int64 v50; // r8
  const std::string *v51; // rbx
  std::string *v52; // rax
  signed __int64 v53; // rcx
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // r9
  unsigned __int64 v56; // r8
  std::string *v57; // rax
  std::istream *v58; // rax
  std::istream *v59; // rax
  std::string *v60; // rdi
  std::string *v61; // rbx
  unsigned __int64 v62; // rsi
  std::string *v63; // rcx
  const char *Buf; // rcx
  std::string *v65; // rdx
  __int64 v66; // rcx
  char v67; // al
  std::string *v68; // rsi
  const std::string *v69; // rdx
  std::_Tree<std::_Tmap_traits<std::string,extension::GFXIFontManager::LanguageConfig,std::less<std::string >,std::allocator<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig> >,0> > *v70; // rdi
  std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *v71; // rax
  std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *v72; // rbx
  std::_Tree_node<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig>,void *> *Myhead; // rdi
  int v74; // er8
  int v75; // er8
  const char *v76; // rcx
  const char *v77; // rcx
  const char *v78; // rcx
  int v79; // eax
  const char *v80; // rcx
  int v81; // eax
  OGLLightManager *m_pLightManager; // rbx
  __int64 v83; // rbx
  int v84; // eax
  OGLLightNode *LightById; // rax
  std::istream *v86; // rax
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v87; // rcx
  std::vector<std::string> _First; // [rsp+20h] [rbp-E0h] BYREF
  std::fpos<_Mbstatet> v89; // [rsp+38h] [rbp-C8h] BYREF
  ShaderFxHelper::ShaderFxParseOption *v90; // [rsp+50h] [rbp-B0h]
  std::_Tree<std::_Tmap_traits<std::string,extension::GFXIFontManager::LanguageConfig,std::less<std::string >,std::allocator<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig> >,0> > *v91; // [rsp+58h] [rbp-A8h]
  const char *v92; // [rsp+60h] [rbp-A0h]
  __int64 v93; // [rsp+68h] [rbp-98h]
  std::string *v94; // [rsp+70h] [rbp-90h]
  std::fpos<_Mbstatet> result; // [rsp+78h] [rbp-88h] BYREF
  OGLMaterialLight pLightMaterial; // [rsp+90h] [rbp-70h] BYREF
  __int64 v97; // [rsp+140h] [rbp+40h]
  std::string *v98; // [rsp+148h] [rbp+48h]
  std::string *v99; // [rsp+150h] [rbp+50h]
  char v100[24]; // [rsp+158h] [rbp+58h]
  StdCompatMemoryIStream v101; // [rsp+170h] [rbp+70h] BYREF
  StdCompatMemoryIStream v102; // [rsp+250h] [rbp+150h] BYREF
  ShaderFxHelper::ShaderFxLightSetting lightSetting; // [rsp+330h] [rbp+230h] BYREF
  std::string _Str; // [rsp+3E0h] [rbp+2E0h] BYREF
  std::string v105; // [rsp+400h] [rbp+300h] BYREF

  v97 = -2i64;
  v4 = opt;
  v90 = opt;
  v91 = (std::_Tree<std::_Tmap_traits<std::string,extension::GFXIFontManager::LanguageConfig,std::less<std::string >,std::allocator<std::pair<std::string const ,extension::GFXIFontManager::LanguageConfig> >,0> > *)targets;
  v5 = csvBuffer;
  v92 = csvBuffer;
  v6 = bufferSize;
  v93 = bufferSize;
  StdCompatMemoryIStream::StdCompatMemoryIStream(&v101, csvBuffer, &csvBuffer[bufferSize]);
  if ( (v101.gap10[*(int *)(*(_QWORD *)v101.gap0 + 4i64)] & 6) == 0 )
  {
    *(_QWORD *)pLightMaterial.m_fSpecular = 0i64;
    pLightMaterial.m_fSpecular[2] = 0.0;
    *(_QWORD *)&pLightMaterial.m_fSpecular[3] = 1065353216i64;
    *(_OWORD *)pLightMaterial.m_fEmission = _xmm;
    *(_QWORD *)&pLightMaterial.m_fTransparentFactor = 0i64;
    *(_OWORD *)pLightMaterial.m_fReflection = _xmm;
    *(_QWORD *)pLightMaterial.m_fNormal = 0i64;
    pLightMaterial.m_fNormal[2] = 0.0;
    *(_OWORD *)&pLightMaterial.m_fNormal[3] = _xmm;
    *(_QWORD *)&pLightMaterial.m_fBump[3] = 1065353216i64;
    *(_QWORD *)pLightMaterial.m_fTransparent = 0i64;
    pLightMaterial.m_fTransparent[2] = 0.0;
    pLightMaterial.m_fTransparent[3] = 1.0;
    *(_QWORD *)&pLightMaterial.m_fAmbient[3] = 1065353216i64;
    *(_QWORD *)&pLightMaterial.m_fDiffuse[3] = 1065353216i64;
    pLightMaterial.m_fEmissionFactor = 0.0;
    pLightMaterial.m_fReflectionFactor = 0.0;
    *(_QWORD *)pLightMaterial.m_fAmbient = 0i64;
    pLightMaterial.m_fAmbient[2] = 0.0;
    pLightMaterial.m_uiAttrFlg = 5;
    *(_QWORD *)pLightMaterial.m_fDiffuse = 0i64;
    pLightMaterial.m_fDiffuse[2] = 0.0;
    m_ptr = 0i64;
    v105._Mypair._Myval2._Myres = 15i64;
    v105._Mypair._Myval2._Mysize = 0i64;
    v105._Mypair._Myval2._Bx._Buf[0] = 0;
    v8 = -1;
    v9 = 0;
    memset(&_First, 0, sizeof(_First));
    v10 = std::ws<char,std::char_traits<char>>(&v101);
    if ( (v10->gap10[*(int *)(*(_QWORD *)v10->gap0 + 4i64)] & 6) == 0 )
    {
      while ( 1 )
      {
        std::istream::tellg(&v101, &result);
        if ( (v101.gap10[*(int *)(*(_QWORD *)v101.gap0 + 4i64)] & 6) != 0 )
          break;
        v13 = std::istream::ignore(&v101, v6, 10);
        std::istream::tellg(v13, &v89);
        if ( v89._Myoff + v89._Fpos < 0 )
        {
          *(_QWORD *)v100 = v6;
          *(_OWORD *)&v100[8] = 0i64;
          *(_OWORD *)&v89._Myoff = *(_OWORD *)v100;
          v89._Mystate = (_Mbstatet)*(_OWORD *)&_mm_unpackhi_pd(*(__m128d *)&v100[8], *(__m128d *)&v100[8]);
        }
        std::_Destroy_range1<std::allocator<std::string>,std::string *>(
          _First._Mypair._Myval2._Myfirst,
          _First._Mypair._Myval2._Mylast,
          v14,
          v15);
        _First._Mypair._Myval2._Mylast = _First._Mypair._Myval2._Myfirst;
        Myoff = result._Myoff;
        Fpos = result._Fpos;
        v18 = &v5[result._Myoff + result._Fpos];
        v19 = 0i64;
        v20 = v89._Myoff;
        v21 = v89._Fpos;
        for ( i = &v5[v89._Myoff + v89._Fpos]; v18 != i; ++v18 )
        {
          v23 = v19 + 1;
          if ( *v18 != 44 )
            v23 = v19;
          v19 = v23;
        }
        v24 = v19 + 1;
        if ( _First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Myfirst < v24 )
        {
          if ( v24 > 0x7FFFFFFFFFFFFFFi64 )
            std::_Xlength_error("vector<T> too long");
          std::vector<std::string>::_Reallocate(&_First, v24);
          Fpos = result._Fpos;
          Myoff = result._Myoff;
          v21 = v89._Fpos;
          v20 = v89._Myoff;
        }
        StdCompatMemoryIStream::StdCompatMemoryIStream(&v102, &v5[Myoff + Fpos], &v5[v20 + v21]);
        _Str._Mypair._Myval2._Myres = 15i64;
        _Str._Mypair._Myval2._Mysize = 0i64;
        _Str._Mypair._Myval2._Bx._Buf[0] = 0;
        v25 = std::ws<char,std::char_traits<char>>(&v102);
        v26 = std::getline<char,std::char_traits<char>,std::allocator<char>>(v25, &_Str, 44);
        if ( (v26->gap10[*(int *)(*(_QWORD *)v26->gap0 + 4i64)] & 6) == 0 )
        {
          while ( 1 )
          {
            p_Str = &_Str;
            Ptr = _Str._Mypair._Myval2._Bx._Ptr;
            Myres = _Str._Mypair._Myval2._Myres;
            if ( _Str._Mypair._Myval2._Myres >= 0x10 )
              p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
            Mysize = _Str._Mypair._Myval2._Mysize;
            v31 = &p_Str->_Mypair._Myval2._Bx._Buf[_Str._Mypair._Myval2._Mysize];
            v32 = &_Str;
            if ( _Str._Mypair._Myval2._Myres >= 0x10 )
              v32 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
            v33 = &_Str;
            if ( _Str._Mypair._Myval2._Myres >= 0x10 )
              v33 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
            v34 = (std::string *)((char *)v33 + _Str._Mypair._Myval2._Mysize);
            if ( v34 != v32 )
            {
              do
              {
                v35 = (std::string *)((char *)v34 - 1);
                if ( !isspace(SHIBYTE(v34[-1]._Mypair._Myval2._Myres)) )
                  break;
                v34 = (std::string *)((char *)v34 - 1);
              }
              while ( v35 != v32 );
              Myres = _Str._Mypair._Myval2._Myres;
              Mysize = _Str._Mypair._Myval2._Mysize;
              Ptr = _Str._Mypair._Myval2._Bx._Ptr;
            }
            v36 = &_Str;
            if ( Myres >= 0x10 )
              v36 = (std::string *)Ptr;
            v37 = (char *)v34 - (char *)v36;
            v38 = v31 - (char *)v34;
            if ( Mysize < (char *)v34 - (char *)v36 )
              std::_Xout_of_range("invalid string position");
            if ( Mysize - v37 <= v38 )
              break;
            if ( v38 )
            {
              v40 = &_Str;
              if ( Myres >= 0x10 )
                v40 = (std::string *)Ptr;
              v41 = &v40->_Mypair._Myval2._Bx._Buf[v37];
              v42 = Mysize - v38;
              if ( v42 != v37 )
              {
                memmove(v41, &v41[v38], v42 - v37);
                Myres = _Str._Mypair._Myval2._Myres;
                Ptr = _Str._Mypair._Myval2._Bx._Ptr;
              }
              _Str._Mypair._Myval2._Mysize = v42;
              v43 = &_Str;
              if ( Myres >= 0x10 )
                v43 = (std::string *)Ptr;
              v43->_Mypair._Myval2._Bx._Buf[v42] = 0;
              goto LABEL_39;
            }
LABEL_40:
            if ( Mysize )
            {
              Myfirst = _First._Mypair._Myval2._Myfirst;
              Mylast = _First._Mypair._Myval2._Mylast;
              if ( &_Str >= _First._Mypair._Myval2._Mylast || _First._Mypair._Myval2._Myfirst > &_Str )
              {
                if ( _First._Mypair._Myval2._Mylast == _First._Mypair._Myval2._Myend
                  && !(_First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Mylast) )
                {
                  v53 = _First._Mypair._Myval2._Mylast - _First._Mypair._Myval2._Myfirst;
                  if ( v53 == 0x7FFFFFFFFFFFFFFi64 )
                    std::_Xlength_error("vector<T> too long");
                  v54 = v53 + 1;
                  v55 = _First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Myfirst;
                  v56 = 0i64;
                  if ( 0x7FFFFFFFFFFFFFFi64 - (v55 >> 1) >= v55 )
                    v56 = v55 + (v55 >> 1);
                  if ( v56 >= v54 )
                    v54 = v56;
                  std::vector<std::string>::_Reallocate(&_First, v54);
                  Mylast = _First._Mypair._Myval2._Mylast;
                }
                v94 = Mylast;
                v99 = Mylast;
                if ( Mylast )
                {
                  Mylast->_Mypair._Myval2._Mysize = 0i64;
                  Mylast->_Mypair._Myval2._Myres = 0i64;
                  Mylast->_Mypair._Myval2._Myres = 15i64;
                  Mylast->_Mypair._Myval2._Mysize = 0i64;
                  if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
                    v57 = Mylast;
                  else
                    v57 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
                  v57->_Mypair._Myval2._Bx._Buf[0] = 0;
                  std::string::assign(Mylast, &_Str, 0i64, 0xFFFFFFFFFFFFFFFFui64);
                  Mylast = _First._Mypair._Myval2._Mylast;
                }
              }
              else
              {
                v46 = (char *)&_Str - (char *)_First._Mypair._Myval2._Myfirst;
                if ( _First._Mypair._Myval2._Mylast == _First._Mypair._Myval2._Myend
                  && !(_First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Mylast) )
                {
                  v47 = _First._Mypair._Myval2._Mylast - _First._Mypair._Myval2._Myfirst;
                  if ( v47 == 0x7FFFFFFFFFFFFFFi64 )
                    std::_Xlength_error("vector<T> too long");
                  v48 = v47 + 1;
                  v49 = _First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Myfirst;
                  v50 = 0i64;
                  if ( 0x7FFFFFFFFFFFFFFi64 - (v49 >> 1) >= v49 )
                    v50 = v49 + (v49 >> 1);
                  if ( v50 >= v48 )
                    v48 = v50;
                  std::vector<std::string>::_Reallocate(&_First, v48);
                  Mylast = _First._Mypair._Myval2._Mylast;
                  Myfirst = _First._Mypair._Myval2._Myfirst;
                }
                v94 = Mylast;
                v51 = (std::string *)((char *)Myfirst + (v46 & 0xFFFFFFFFFFFFFFE0ui64));
                v98 = Mylast;
                if ( Mylast )
                {
                  Mylast->_Mypair._Myval2._Mysize = 0i64;
                  Mylast->_Mypair._Myval2._Myres = 0i64;
                  Mylast->_Mypair._Myval2._Myres = 15i64;
                  Mylast->_Mypair._Myval2._Mysize = 0i64;
                  if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
                    v52 = Mylast;
                  else
                    v52 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
                  v52->_Mypair._Myval2._Bx._Buf[0] = 0;
                  std::string::assign(Mylast, v51, 0i64, 0xFFFFFFFFFFFFFFFFui64);
                  Mylast = _First._Mypair._Myval2._Mylast;
                }
              }
              _First._Mypair._Myval2._Mylast = Mylast + 1;
            }
            v58 = std::ws<char,std::char_traits<char>>(&v102);
            v59 = std::getline<char,std::char_traits<char>,std::allocator<char>>(v58, &_Str, 44);
            if ( (v59->gap10[*(int *)(*(_QWORD *)v59->gap0 + 4i64)] & 6) != 0 )
            {
              v4 = v90;
              goto LABEL_73;
            }
          }
          _Str._Mypair._Myval2._Mysize = (char *)v34 - (char *)v36;
          v39 = &_Str;
          if ( Myres >= 0x10 )
            v39 = (std::string *)Ptr;
          v39->_Mypair._Myval2._Bx._Buf[v37] = 0;
LABEL_39:
          Mysize = _Str._Mypair._Myval2._Mysize;
          goto LABEL_40;
        }
LABEL_73:
        v60 = _First._Mypair._Myval2._Myfirst;
        v61 = _First._Mypair._Myval2._Mylast;
        if ( _First._Mypair._Myval2._Myfirst != _First._Mypair._Myval2._Mylast )
        {
          v62 = _First._Mypair._Myval2._Myfirst->_Mypair._Myval2._Myres;
          if ( v62 < 0x10 )
            v63 = _First._Mypair._Myval2._Myfirst;
          else
            v63 = (std::string *)_First._Mypair._Myval2._Myfirst->_Mypair._Myval2._Bx._Ptr;
          if ( !strcmp(v63->_Mypair._Myval2._Bx._Buf, "NUMMODELS") )
          {
            if ( v61 - v60 )
            {
              Buf = v60[1]._Mypair._Myval2._Bx._Buf;
              if ( v60[1]._Mypair._Myval2._Myres >= 0x10 )
                Buf = *(const char **)Buf;
              strtol(Buf, 0i64, 10);
            }
          }
          else
          {
            if ( v62 < 0x10 )
              v65 = v60;
            else
              v65 = (std::string *)v60->_Mypair._Myval2._Bx._Ptr;
            v66 = 0i64;
            while ( 1 )
            {
              v67 = v65->_Mypair._Myval2._Bx._Buf[v66++];
              if ( v67 != aModel[v66 - 1] )
                break;
              if ( v66 == 6 )
              {
                m_ptr = 0i64;
                if ( v61 - v60 )
                {
                  v68 = v60 + 1;
                  v69 = v60 + 1;
                  v70 = v91;
                  v71 = std::_Tree<std::_Tmap_traits<std::string,unsigned int,std::less<std::string>,std::allocator<std::pair<std::string const,unsigned int>>,0>>::_Lbound<std::string>(
                          v91,
                          v69);
                  v72 = v71;
                  Myhead = v70->_Mypair._Myval2._Myval2._Myhead;
                  if ( v71 == Myhead || std::string::compare(v68, &v71->_Myval.first) < 0 )
                    v72 = Myhead;
                  if ( v72 == Myhead )
                  {
                    _DummyLogging("ShaderFx csv target model[%s] not found.");
                  }
                  else
                  {
                    m_ptr = (OGLModel *)v72->_Myval.second.m_impl.m_ptr;
                    if ( &v105 != v68 )
                      std::string::assign(&v105, v68, 0i64, 0xFFFFFFFFFFFFFFFFui64);
                    if ( m_ptr )
                    {
                      v74 = 0;
                      if ( m_ptr->m_ucMaterialCount )
                      {
                        do
                        {
                          OGLMaterialLight::set(&m_ptr->m_pMaterial[v74].m_MaterialLight, &pLightMaterial);
                          v74 = v75 + 1;
                        }
                        while ( v74 < m_ptr->m_ucMaterialCount );
                      }
                      m_ptr->m_useShaderFX = 1;
                    }
                  }
                }
                v9 = 0;
                v8 = -1;
                goto LABEL_130;
              }
            }
            if ( m_ptr )
            {
              if ( v62 < 0x10 )
                v76 = (const char *)v60;
              else
                v76 = v60->_Mypair._Myval2._Bx._Ptr;
              if ( !strcmp(v76, "NUMMATERIALS") )
              {
                if ( v61 - v60 )
                {
                  v77 = v60[1]._Mypair._Myval2._Bx._Buf;
                  if ( v60[1]._Mypair._Myval2._Myres >= 0x10 )
                    v77 = *(const char **)v77;
                  if ( strtol(v77, 0i64, 10) != m_ptr->m_ucMaterialCount )
                    _DummyLogging("ShaderFx csv material count mismatch. model[%s].matCount=%d, described=%d ");
                }
              }
              else
              {
                if ( v62 < 0x10 )
                  v78 = (const char *)v60;
                else
                  v78 = v60->_Mypair._Myval2._Bx._Ptr;
                v79 = strcmp(v78, "NUMLIGHTS");
                if ( v79 )
                {
                  if ( v9 )
                  {
                    if ( v8 >= 0 )
                    {
                      ShaderFxHelper::ShaderFxApplyLightSetting(&_First, &lightSetting);
                      if ( !v4 || !v4->disableMaterialLight )
                      {
                        v83 = v8;
                        v84 = OGLLightManager::addLight(m_ptr->m_pMaterial[v83].m_pLightManager);
                        LightById = OGLLightManager::getLightById(m_ptr->m_pMaterial[v83].m_pLightManager, v84);
                        if ( LightById )
                          ShaderFxHelper::ShaderFxApplyLightSetting(&lightSetting, &LightById->m_light);
                      }
                    }
                    --v9;
                  }
                  else
                  {
                    v81 = ShaderFxHelper::ShaderFxApplyMaterialSetting(&_First, m_ptr);
                    v8 = v81;
                    if ( v81 >= 0 )
                    {
                      m_pLightManager = m_ptr->m_pMaterial[v81].m_pLightManager;
                      OGLLightManager::deleteAllLights(m_pLightManager);
                      OGLLightManager::clear(m_pLightManager);
                    }
                    else
                    {
                      _DummyLogging("ShaderFx csv model[%s].material[%s] is not found.");
                    }
                  }
                }
                else
                {
                  if ( v61 - v60 )
                  {
                    v80 = v60[1]._Mypair._Myval2._Bx._Buf;
                    if ( v60[1]._Mypair._Myval2._Myres >= 0x10 )
                      v80 = *(const char **)v80;
                    v79 = strtol(v80, 0i64, 10);
                  }
                  v9 += v79;
                }
              }
            }
          }
        }
LABEL_130:
        std::string::~string(&_Str);
        StdCompatMemoryIStream::~StdCompatMemoryIStream((StdCompatMemoryIStream *)&v102.gap78[8]);
        *(_QWORD *)&v102.gap78[8] = &std::ios_base::`vftable';
        std::ios_base::_Ios_base_dtor((std::ios_base *)&v102.gap78[8]);
        v86 = std::ws<char,std::char_traits<char>>(&v101);
        if ( (v86->gap10[*(int *)(*(_QWORD *)v86->gap0 + 4i64)] & 6) != 0 )
          break;
        v5 = v92;
        v6 = v93;
      }
    }
    if ( _First._Mypair._Myval2._Myfirst )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        _First._Mypair._Myval2._Myfirst,
        _First._Mypair._Myval2._Mylast,
        v11,
        v12);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v87,
        (AgDirectory::DirectoryEntry *)_First._Mypair._Myval2._Myfirst,
        _First._Mypair._Myval2._Myend - _First._Mypair._Myval2._Myfirst);
      memset(&_First, 0, sizeof(_First));
    }
    std::string::~string(&v105);
  }
  StdCompatMemoryIStream::~StdCompatMemoryIStream((StdCompatMemoryIStream *)&v101.gap78[8]);
  *(_QWORD *)&v101.gap78[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v101.gap78[8]);
}

std::istream *__fastcall std::istream::ignore(std::istream *this, __int64 _Count, int _Metadelim)
{
  int v6; // edi
  __int64 v8; // rcx
  _QWORD *v9; // rcx
  int *v10; // rdx
  _QWORD *v11; // rcx
  unsigned __int8 *v12; // rdx
  int v13; // eax
  std::ios_base *v14; // rcx
  int v15; // edx
  __int64 v16; // rcx

  v6 = 0;
  this->_Chcount = 0i64;
  v8 = *(_QWORD *)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
  if ( v8 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 8i64))(v8);
  if ( std::istream::_Ipfx(this, 1) && _Count > 0 )
  {
    do
    {
      if ( _Count != 0x7FFFFFFFFFFFFFFFi64 && --_Count < 0 )
        break;
      v9 = *(_QWORD **)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
      if ( *(_QWORD *)v9[7] && (v10 = (int *)v9[10], *v10 > 0) )
      {
        --*v10;
        v11 = (_QWORD *)v9[7];
        v12 = (unsigned __int8 *)(*v11)++;
        v13 = *v12;
      }
      else
      {
        v13 = (*(__int64 (__fastcall **)(_QWORD *))(*v9 + 56i64))(v9);
      }
      if ( v13 == -1 )
      {
        v6 = 1;
        break;
      }
      ++this->_Chcount;
    }
    while ( v13 != _Metadelim );
  }
  v14 = (std::ios_base *)&this->gap0[*(int *)(*(_QWORD *)this->gap0 + 4i64)];
  if ( v6 )
  {
    v15 = v6 | v14->_Mystate | 4;
    if ( v14[1].__vftable )
      v15 = v6 | v14->_Mystate;
    std::ios_base::clear(v14, v15, 0);
  }
  v16 = *(_QWORD *)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
  if ( v16 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
  return this;
}

std::fpos<_Mbstatet> *__fastcall std::istream::tellg(std::istream *this, std::fpos<_Mbstatet> *result)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx

  v4 = *(_QWORD *)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8i64))(v4);
  std::istream::_Ipfx(this, 1);
  v5 = *(int *)(*(_QWORD *)this->gap0 + 4i64);
  if ( (this->gap10[v5] & 6) != 0 )
  {
    result->_Myoff = std::_BADOFF;
    result->_Fpos = 0i64;
    result->_Mystate = 0i64;
    v7 = *(_QWORD *)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
    if ( v7 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, std::fpos<_Mbstatet> *, _QWORD, __int64, int))(**(_QWORD **)&this->gap10[v5 + 56]
                                                                                 + 80i64))(
      *(_QWORD *)&this->gap10[v5 + 56],
      result,
      0i64,
      1i64,
      1);
    v6 = *(_QWORD *)&this->gap10[*(int *)(*(_QWORD *)this->gap0 + 4i64) + 56];
    if ( v6 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16i64))(v6);
  }
  return result;
}

