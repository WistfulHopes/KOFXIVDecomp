#include "dev/kof/master/development/source/baseproject/jni/game/player/chara/actoroption.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/cameracheck.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_list.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/freecameracheck.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threadcheck.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_battleonline.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_textlayout.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_image.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effectdata/effectdata.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_sync.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_threadcommandqueue.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_log.h"
#include "dev/kof/master/development/source/baseproject/jni/game/data/savedatadefine.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/chartdata.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_uncopyable.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogleffect.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/texstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/game/cpuseq/battlecpu.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effectdata/effectappdata.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/gfx-integrate/gfxi_movie.h"
#include "dev/kof/master/development/source/baseproject/jni/game/cpuseq/sequencecontroller.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/gfx-integrate/gfxi_operation.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogllight.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/bitset"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_prefightfaceoff.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/translate_table.h"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/shared_lua_context.h"
#include "dev/kof/master/development/source/baseproject/jni/game/system/battlesysteminfo.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_screentoworld.h"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_strokeraa.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_scale9grid.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exwaitcondition.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_arraystaticbuff.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_string.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/hidpad/hidpadsystem.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/combomissionjudge.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_cxform.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_utf8util.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/soundutil.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/kof/master/development/source/baseproject/jni/game/network/chkdiscononlinesv.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/network/matchingsystem.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charaprojectdataformat.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charabasestatusformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_event.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/inputkeyrecord.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/png_imagefile.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_keycodes.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_glyphcacheconfig.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_memorymanager.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/sound/ex_sound_hashkey.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_meshkey.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_matrixstate.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_gradients.h"
#include "dev/silverware/git/sdk/agmovieplayer.h"
#include "dev/kof/master/development/source/baseproject/jni/game/battlehud/battlecall/battlecall.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_rasterizer.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_viewport.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_debug.h"
#include "dev/kof/master/development/source/baseproject/jni/game/collision/bodypush.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_drawableimage.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/game/network/netmanager.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_hal.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_buffer.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/game/network/leaderboard.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_characterdef.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/sound/ex_sound_manager.h"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "dev/kof/master/development/source/baseproject/jni/game/check/operationmapper.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/particledata.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_filters.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/weapon/actorweapon.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_filterparams.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/sstream"
#include "dev/kof/master/development/source/baseproject/jni/game/system/battlecontroller.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_glyphcache.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_glyphqueue.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_font.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/kof/master/development/source/baseproject/jni/game/player/actionsystem.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charaactiondataformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_tessdefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/battlestage.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charafilebase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shapedatapacked.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/fileformat/tkndata.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_pathdatapacker.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_linebuffer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_highlight.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shapedatafloat.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/cameramotionpreviewsettings.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/fileformat/stageprojectdata.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/commanddataformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_profiler.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exthread.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/bilinkable.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_states.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/tga_imagefile.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_statebag.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/network/titlestoragesystem.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "dev/silverware/git/sdk/agrectangle.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/battlestagedatas.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/fileformat/tkndatas.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_simplemeshcache.h"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/tween.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/fontprovider/render_fontproviderwinapi.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/asynccharafileload.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/future_asset.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/asyncjob.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_bundle.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/atomic_int.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shapedatafloatmp.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/atomic"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/kof/master/development/source/baseproject/jni/game/collision/hitrectcollection.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shapemeshprovider.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/jpeg_imagefile.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_treetext.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/render_imagefileutil.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_missiondataloading.h"
#include "dev/kof/master/development/source/baseproject/jni/game/data/trainingsetting.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/combomissionattackeventlistener.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charamaterialsettingformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_docview.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/rapper/graphicsopt.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/fix32.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_range.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/kof/master/development/source/baseproject/jni/game/player/chara/actorcharabase.h"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/game/battlehud/battlehud.h"
#include "dev/kof/master/development/source/baseproject/jni/game/define/charabonedefine.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_asstring.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_std.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_hash.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/battleeventhandler.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/colorholder.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/kof/master/development/source/baseproject/jni/game/collision/damagesetting.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_math2d.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_matrix4x4.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/battleplayerinfo.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_toleranceparams.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_matrixpool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shader.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/kof/master/development/source/baseproject/jni/game/battlehud/easingnumber.h"
#include "dev/kof/master/development/source/baseproject/jni/game/battlehud/errorchecker.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_sgmlparser.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/actionblackout.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_context.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/streambuf"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_constants.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_battleonlinewatching.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_tessgen.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_treeshape.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_tessellator.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_texturecache.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmodel.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/cpusequencedataformat.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglcurve.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/refcountable.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_battleloading.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/shot/actorshot.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/chara/actorchara.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_shapedatadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/commandcheck.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/restrictringbuffer.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_primitivebundle.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_treecachenode.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/materialshowcontrol.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_treenode.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_loader.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_cacheeffect.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_system.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_glyphfitter.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglsprite.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "dev/kof/master/development/source/baseproject/jni/game/util/syncmenuimage.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/render_imagefile.h"
#include "dev/kof/master/development/source/baseproject/jni/game/scene/st_ps4modelroom.h"
#include "dev/kof/master/development/source/baseproject/jni/game/data/moviedatadefine.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_player.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charahitrectformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglrender.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_types2d.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/gfx/gfx_resource.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_alg.h"
#include "dev/silverware/git/sdk/aghash.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/audio/mediamanager.h"
#include "dev/silverware/git/sdk/agdisplay.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/agstringutils.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglfog.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglbone.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_stroker.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_simd_sse.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/imagefiles/dds_imagefile.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/audio/audiopresenter.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/agvector2.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/battlestageresourcecontainer.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_textmeshprovider.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_color.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/input/imesystem.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/battlestageshader.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/actor.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_glyphparam.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xxatomic"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charadataunify.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_meshcache.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/unordered_map"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charaattackdataformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_meshcacheconfig.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charadamagesettingformat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_hairliner.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xhash"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/silverware/git/sdk/agvector4.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_filterdesc.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_styledtext.h"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/silverware/git/sdk/agvector3.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_matrix2x4.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_matrix3x4.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_core.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_queue.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_ampinterface.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_fontmanager.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_primitive.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocaddr.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmirror.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_radixtree.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effectdatalistmanager.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_twips.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effectcommon.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_containers.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/text/text_wwhelper.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/audio/mediasound.h"
#include "dev/kof/master/development/source/baseproject/jni/game/appmain.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exlockable.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/combomissiondataformat.h"
#include "dev/kof/master/development/source/baseproject/jni/game/data/sounddata.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/soundgroupdataformat.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effect/effect.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "dev/kof/master/development/source/baseproject/jni/game/network/playtogether.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/sound/ex_sound_bank.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_vertex.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/istream"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/fontprovider/render_fontproviderhud.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglshader.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ostream"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/shaderfxhelper.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/randommt.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "dev/kof/master/development/source/baseproject/jni/game/player/effect/actoreffect.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/actorobject.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_file.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/render/render_resizeimage.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_arrayunsafe.h"
#include "dev/kof/master/development/source/baseproject/jni/game/data/savedata.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcdummy.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/core/glstate.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/ag/kofshadermanager.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/threading/exlockable.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglvec3.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmodel.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmatrix.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogllight.cpp"
#include "dev/kof/master/development/source/baseproject/jni/game/appmain.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglvec4.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/future_asset.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglrender.cpp"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/asyncjob.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmirror.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglshader.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/rapper/graphicsopt.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogltexture.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/image/graphics.cpp"
#include "dev/kof/master/development/source/baseproject/jni/game/player/actionsystem.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/cfile.cpp"

void AppMain::loadShaderFXDataToAsyncAsset(extension::AsyncAsset * asset, AppMain::_MODEL_LIGHT_DATA * modelLightAssetData); // 0x1401D23E0
void AppMain::ModelRoomLoadStage(STAGE_ID stageID); // 0x1401D2630
void AppMain::SetUpTPose(); // 0x1401D28F0
void AppMain::SetUpModelRoomCamera(); // 0x1401D3530
bool AppMain::SwitchToCameraLights(long charId, long settingId, bool bMirror); // 0x1401D3690
bool AppMain::SwitchBackToGameLights(long charId); // 0x1401D3D30
void AppMain::SetUpGodRayData(); // 0x1401D4680
void AppMain::SetUpStageLights(); // 0x1401D4810
void AppMain::SetUpPlayerLights(); // 0x1401D50B0
void AppMain::SetupWorldLights(); // 0x1401D90C0
void AppMain::SetUpModelRoomLights(); // 0x1401D9A20
void AppMain::updateGameLights(float * camPos, float * camUp, bool bShadow); // 0x1401D9A50
void AppMain::setEffectLightOn(long charId, bool val); // 0x1401DA610
void AppMain::setupLightUniforms(long playerId); // 0x1401DA6F0
void AppMain::setupShadowMatrices(); // 0x1401DABA0
void AppMain::setupShadowMatrices(long charStack); // 0x1401DADA0
void AppMain::setupModelRoomSettings(); // 0x1401DB170
void AppMain::releasePS4ModelRoom(bool bDeleteBufferOnly); // 0x1401DB4D0
class extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> :
	extension::ExThread::Runnable,
	extension::AsyncContentConstants,
	extension::FutureObjectSpec
{
public:
	UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>(extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> &);
	UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>(const extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> &);
	UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *);
	virtual long run();
protected:
	extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> m_asset[6]; // 0x18
public:
	virtual ~UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>();
	extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> & operator=(extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> &);
	extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> & operator=(const extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> &);
};
void AppMain::ModelRoomDrawTPose(float scale); // 0x1401DCE70
void AppMain::ModelRoomReleaseBufferTPose(); // 0x1401DD410
void AppMain::_MODELROOM_SETTINGS::CalcBlendProjParam(); // 0x1401DD4B0
void AppMain::_MODELROOM_SETTINGS::SetBlendProjection(OGLModel * pModel); // 0x1401DD5B0
float AppMain::_MODELROOM_SETTINGS::CalcCamDotFromFront(); // 0x1401DD8A0
void AppMain::ModelRoomRenderToTexturePass(long frame, long stackId); // 0x1401DD960
void AppMain::RenderToTexturePass(long textureIndex, long stack, long frame); // 0x1401DDBF0
void AppMain::ModelDepthPass(long textureIndex, long stack); // 0x1401DE270
void AppMain::ModelRoomShadowPass(long charStack, unsigned char bSync); // 0x1401DE540
void AppMain::RenderReflectionToTexturePass(long textureIndex, long stack); // 0x1401DEB00
void AppMain::RenderFullScreenToTexture(long shader, OGLTexture * pSrcTexture, OGLTexture * pDestTexture, long frameBufferIndex); // 0x1401DED80
void AppMain::BlendTwoTextures(long shader, OGLTexture * pDestTexture, OGLTexture * pBlend1Texture, OGLTexture * pBlend2Texture); // 0x1401DF6D0
void AppMain::BlendThreeTexturesInOrder(long shader, OGLTexture * pDestTexture, OGLTexture * pBlend1Texture, OGLTexture * pBlend2Texture, OGLTexture * pBlend3Texture); // 0x1401DFEF0
void AppMain::BlendThreeTexturesUsingDepth(long shader, OGLTexture * pDestTexture, OGLTexture * pBlend1Texture, OGLTexture * pBlend2Texture, OGLTexture * pBlend3Texture, long blendBuffer1, long blendBuffer2, long blendBuffer3); // 0x1401E06F0
void AppMain::BlendTwoTexturesUsingDepth(long shader, OGLTexture * pDestTexture, OGLTexture * pBlend1Texture, OGLTexture * pBlend2Texture, long blendBuffer1, long blendBuffer2); // 0x1401E1010
void AppMain::CharHighlightExtractionWithoutDepth(OGLTexture * pSrcTexture, OGLTexture * pDestTexture, long width, long height, long frameBufferIndex); // 0x1401E19F0
void AppMain::CharHighlightExtractionWithoutDepthWithMask(OGLTexture * pSrcTexture, OGLTexture * pDestTexture, OGLTexture * pMaskTexture, long width, long height, long frameBufferIndex); // 0x1401E2210
void AppMain::CharHighlightExtractionTwoBuffers(OGLTexture * pSrcTexture1, OGLTexture * pSrcTexture2, OGLTexture * pDestTexture, long width, long height, long frameBufferIndex1, long frameBufferIndex2); // 0x1401E2900
void AppMain::DownsampleTexture(long shader, OGLTexture * pSrcTexture, OGLTexture * pDestTexture, long width, long height); // 0x1401E3360
void AppMain::SetPostFXUniforms(OGLShader * pShader, const ConstantPostFX & postFXUniforms, const ConstantScreenFilter & filterUniforms); // 0x1401E3D40
void AppMain::DepthFilterBloom(); // 0x1401E4530
void AppMain::PreFightSceneDepthFilterBloom(); // 0x1401E4600
void AppMain::PreBloomEffectPass(long frameBufferIndex); // 0x1401E46D0
void AppMain::BloomEffectPass(long frameBufferIndex); // 0x1401E47D0
void AppMain::NewBloomEffectPass(long frameBufferIndex); // 0x1401E4920
void AppMain::PreFightSceneBloomEffectPass(long frameBufferIndex, long stackId); // 0x1401E4D10
void AppMain::PreFightSceneNewBloomEffectPass(long frameBufferIndex, long stackId); // 0x1401E4ED0
void AppMain::ResultsSceneBloomEffectPass(long frameBufferIndex); // 0x1401E52B0
void AppMain::ResultsSceneNewBloomEffectPass(long frameBufferIndex); // 0x1401E5450
void AppMain::PreFightSceneHighlightExtractionPass(long frameBufferIndex); // 0x1401E5800
void AppMain::ResultsSceneHighlightExtractionPass(long frameBufferIndex, bool bFront); // 0x1401E58E0
void AppMain::HighlightExtractionTwoBuffersPass(); // 0x1401E5A30
void AppMain::BloomEffectBlend(long frameBufferIndex); // 0x1401E5B20
void AppMain::TextureCopyCS(OGLTexture * pSrcTexture, OGLTexture * pDestTexture); // 0x1401E5C20
void AppMain::CopyDepthTextureCS(OGLTexture * pOGLDepthTexture1, OGLTexture * pOGLDestTexture); // 0x1401E5CE0
void AppMain::CombineTwoDepthTexturesCS(OGLTexture * pOGLDepthTexture1, OGLTexture * pOGLDepthTexture2, OGLTexture * pOGLDestTexture); // 0x1401E5F00
void AppMain::BlendThreeTexturesCS(long computeShaderID, OGLTexture * pDest1, OGLTexture * pDest2, OGLTexture * pSrcBlend1, OGLTexture * pSrcBlend2, OGLTexture * pSrcBlend3); // 0x1401E6220
void AppMain::BlendTwoTexturesCS(long computeShaderID, OGLTexture * pDest1, OGLTexture * pDest2, OGLTexture * pSrcBlend1, OGLTexture * pSrcBlend2); // 0x1401E6620
void AppMain::ApplyShaderToTexture(long shader, OGLTexture * pSrcTexture, OGLTexture * pDestTexture, long width, long height, long srcFrameBufferIndex, long dstFrameBufferIndex); // 0x1401E6970
void AppMain::FadeFrameBuffers(long curFrame, long numFrames, long charId, OGLTexture * pDestTexture, long numVisibleFrames); // 0x1401E8110
void AppMain::FadeFrameDepthBuffers(long curFrame, long numFrames, long charId, OGLTexture * pDestTexture, long numVisibleFrames); // 0x1401E8DD0
void AppMain::BlendTwoTexturesExt(long shader, OGLTexture * pDestTexture, OGLTexture * pSrcBlend1, OGLTexture * pSrcBlend2, long width, long height); // 0x1401E9A00
void AppMain::MaskTwoTexturesExt(long shader, OGLTexture * pDestTexture, OGLTexture * pOtherSrcBlend, long width, long height); // 0x1401EA2A0
void AppMain::SimpleBoxBlurEffect(OGLTexture * pDestTexture, float blurStrength); // 0x1401EABE0
void AppMain::GaussianBlurEffect(OGLTexture * pSrcTexture, OGLTexture * pDestTexture, float width, float height, float blurStrength); // 0x1401EACD0
void AppMain::DepthOfFieldEffect(float dofNear, float dofFar, float dofStrength, long frameBufferIndex); // 0x1401EAE20
void AppMain::ApplyFXAA(long frameBufferIndex); // 0x1401EB090
void AppMain::ApplyFXAAToShadows(long frameBufferIndex); // 0x1401EB1A0
void AppMain::BlendMasks(); // 0x1401EB2C0
void AppMain::PreFightSceneBlendMasks(long charStackId); // 0x1401EB410
void AppMain::GodRayShader(long frameBufferIndex); // 0x1401EB5B0
void AppMain::CreateWaterMap(); // 0x1401EBC10
void AppMain::DoHeatHaze(); // 0x1401EBE50
void AppMain::HeatHazeShader(float near, float speed, float strength, long frameBufferIndex); // 0x1401EBF00
void AppMain::BlendFrameBuffers(); // 0x1401EBFC0
void AppMain::PreFightSceneBlendFrameBuffers(long charStackId); // 0x1401EC210
void AppMain::ResultScreenBlendFrameBuffers(long frontBuffer, long backBuffer); // 0x1401EC390
void AppMain::ClearMotionBlurFrames(long characterId); // 0x1401EC550
void AppMain::MergeCharacterFrames(long curFrame, long characterId); // 0x1401EC6D0
void AppMain::RenderGameScreen(long frameBufferIndex); // 0x1401EC930
void AppMain::FullScreenQuadRenderSetup(long shader); // 0x1401ECC00
void AppMain::DrawFullScreenTextureToScreen(); // 0x1401ED4A0
void AppMain::setRenderCamera(void * ptr, long no, float * position, float * look, float * up); // 0x1401ED540
void AppMain::setRenderShadowLight(void * ptr, long no, float * position, float * look, float * up); // 0x1401ED6B0
void AppMain::processLightData(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & line, ShaderFxHelper::ShaderFxLightSetting & assetData); // 0x1401ED840
long AppMain::loadBasicLightData(const char * lightFileName, AppMain::_WORLD_LIGHT_DATA * lightData); // 0x1401EF4F0
class std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > :
	std::_Vector_alloc<std::_Vec_base_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
{
	class _Myt;
	class _Mybase;
	class allocator_type;
	struct _Alty;
	class value_type;
	typedef unsigned long long size_type;
	typedef long long difference_type;
	typedef std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > pointer;
	typedef const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const_pointer;
	typedef std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > reference;
	typedef const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const_reference;
	class iterator;
	class const_iterator;
	class reverse_iterator;
	class const_reverse_iterator;
public:
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(std::initializer_list<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, const std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &, const std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(const std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &, const std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(const std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &, const std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(unsigned long long);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al(const std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > &);
	vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::al();
	void _Construct_n(unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *);
	std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > & operator=(const std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
	std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > & operator=(std::initializer_list<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >);
	std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > & operator=(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
	void _Assign_rv(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
	void _Assign_rv(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &, std::integral_constant<bool,0>);
	void _Assign_rv(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &, std::integral_constant<bool,1>);
	void push_back(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	void push_back(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, std::initializer_list<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >);
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	void assign(unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	void assign(std::initializer_list<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >);
	~vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::a();
	void reserve(unsigned long long);
	unsigned long long capacity();
	unsigned long long _Unused_capacity();
	unsigned long long _Has_unused_capacity();
	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > begin();
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > begin();
	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > end();
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > end();
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > _Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >);
	std::reverse_iterator<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > rbegin();
	std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > rbegin();
	std::reverse_iterator<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > rend();
	std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > rend();
	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > cbegin();
	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > cend();
	std::reverse_iterator<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > crbegin();
	std::reverse_iterator<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > crend();
	void shrink_to_fit();
	void resize(unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	void resize(unsigned long long);
	unsigned long long size();
	unsigned long long max_size();
	bool empty();
	std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > get_allocator();
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & at(unsigned long long);
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & at(unsigned long long);
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & operator[](unsigned long long);
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & operator[](unsigned long long);
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > * data();
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > * data();
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & front();
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & front();
	const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & back();
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & back();
	void pop_back();
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >);
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >);
	void _Pop_back_n(unsigned long long);
	void clear();
	void swap(std::vector<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > &);
protected:
	bool _Buy(unsigned long long);
	void _Destroy(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *, std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *);
	unsigned long long _Grow_to(unsigned long long);
	bool _Inside(const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *);
	void _Reallocate(unsigned long long);
	void _Reserve(unsigned long long);
	void _Tidy();
	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > _Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &);
	std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > * _Ufill(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *, unsigned long long, const std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *);
	void _Xlen();
	void _Xran();
	void _Orphan_range(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *, std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > *);
};
extension::BasicFutureObject<OGLMirror,void>::AssetCache extension::BasicFutureObject<OGLMirror,void>::s_cacheManager; // 0x140ACD8D0
void(*??s_cacheManager$initializer$@?$BasicFutureObject@VOGLMirror@@X@extension@@0P6AXXZEA@@3P6AXXZEA)(); // 0x140740820
extension::BasicFutureObject<OGLMotion,void>::AssetCache extension::BasicFutureObject<OGLMotion,void>::s_cacheManager; // 0x140ACD850
void(*??s_cacheManager$initializer$@?$BasicFutureObject@VOGLMotion@@X@extension@@0P6AXXZEA@@3P6AXXZEA)(); // 0x140740818
std::piecewise_construct_t std::piecewise_construct; // 0x1408A0B24
long AppMain::loadCharacterLightData(const char * lightFileName, AppMain::_WORLD_LIGHT_DATA * lightData, long charNo); // 0x1401F0B20
long AppMain::loadCharacterSpecialLightSettings(const char * lightFileName, AppMain::_SPECIAL_LIGHT_SETTINGS * specialSettings); // 0x1401F1F20
void AppMain::processPostProcessData(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & line, AppMain::_POSTPROCESS_SHADER_SETTINGS * postProcessSettings); // 0x1401F3550
long AppMain::loadPostProcessShaderData(const char * filename, AppMain::_POSTPROCESS_SHADER_SETTINGS * postProcessSettings); // 0x1401F7590
void AppMain::processGlobalShaderData(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & line, AppMain::_GLOBAL_SHADER_SETTINGS * globalShaderSettings); // 0x1401F7E80
long AppMain::loadGlobalShaderData(const char * filename, AppMain::_GLOBAL_SHADER_SETTINGS * globalShaderSettings); // 0x1401F88D0//decompilation failure at 140ACD8D0!
//decompilation failure at 140740820!
//decompilation failure at 140ACD850!
//decompilation failure at 140740818!
//decompilation failure at 1408A0B24!
std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *__fastcall std::_List_buy<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<StageResources,extension::FutureStageOption>::Body>>>::_Buynode<std::piecewise_construct_t const &,std::tuple<std::string const &>,std::tuple<>>(
        std::_List_buy<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *this,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *_Next,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *_Prev,
        const std::piecewise_construct_t *<_Val_0>,
        std::tuple<std::string const &> *<_Val_1>)
{
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v5; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v6; // rdi
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *p_Myval; // rbx
  const std::string *Val; // rdx
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *Ptr; // rax

  v5 = std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>::_Buynode0(
         this,
         _Next,
         _Prev);
  v6 = v5;
  p_Myval = &v5->_Myval;
  if ( v5 != (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)-16i64 )
  {
    Val = <_Val_1>->_Myfirst._Val;
    v5->_Myval.first._Mypair._Myval2._Myres = 15i64;
    v5->_Myval.first._Mypair._Myval2._Mysize = 0i64;
    if ( v5->_Myval.first._Mypair._Myval2._Myres < 0x10 )
      Ptr = &v5->_Myval;
    else
      Ptr = (std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *)p_Myval->first._Mypair._Myval2._Bx._Ptr;
    Ptr->first._Mypair._Myval2._Bx._Buf[0] = 0;
    std::string::assign((std::string *)&p_Myval->first, Val, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    p_Myval->second.m_ptr = 0i64;
    p_Myval->second.m_proxy.m_ptr = 0i64;
  }
  return v6;
}

std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >,bool> *__fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>,0>>::_Insert<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this,
        std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >,bool> *result,
        std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *_Val,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > _Pnode)
{
  unsigned __int64 Mysize; // r12
  unsigned __int64 Myres; // r10
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *Ptr; // r9
  __int64 v10; // rdx
  unsigned __int64 i; // rcx
  unsigned __int64 v12; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *Myfirst; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v14; // rsi
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rdi
  char **p_Myval; // rdx
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *v17; // rcx
  size_t v18; // r15
  size_t v19; // r8
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // rcx
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Prev; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *v24; // rdx
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> **p_Next; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v26; // rcx
  unsigned __int64 v27; // [rsp+20h] [rbp-48h]
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *v28; // [rsp+80h] [rbp+18h]

  v28 = _Val;
  Mysize = _Val->first._Mypair._Myval2._Mysize;
  Myres = _Val->first._Mypair._Myval2._Myres;
  if ( Myres < 0x10 )
    Ptr = _Val;
  else
    Ptr = (std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *)_Val->first._Mypair._Myval2._Bx._Ptr;
  v10 = 0xCBF29CE484222325ui64;
  for ( i = 0i64; i < Mysize; ++i )
    v10 = 0x100000001B3i64 * ((unsigned __int8)Ptr->first._Mypair._Myval2._Bx._Buf[i] ^ (unsigned __int64)v10);
  v12 = 16 * (v10 & this->_Mask);
  v27 = v12;
  Myfirst = this->_Vec._Mypair._Myval2._Myfirst;
  v14 = *(std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> **)((char *)&Myfirst->_Ptr + v12);
  if ( v14 == this->_List._Mypair._Myval2._Myhead )
    Myhead = this->_List._Mypair._Myval2._Myhead;
  else
    Myhead = **(std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> ***)((char *)&Myfirst[1]._Ptr + v12);
  if ( Myhead == v14 )
  {
LABEL_27:
    Next = _Pnode._Ptr->_Next;
    if ( Myhead != _Pnode._Ptr->_Next )
    {
      _Pnode._Ptr->_Prev->_Next = Next;
      Next->_Prev->_Next = Myhead;
      Myhead->_Prev->_Next = _Pnode._Ptr;
      Prev = Myhead->_Prev;
      Myhead->_Prev = Next->_Prev;
      Next->_Prev = _Pnode._Ptr->_Prev;
      _Pnode._Ptr->_Prev = Prev;
    }
    v24 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *)((char *)this->_Vec._Mypair._Myval2._Myfirst + v12);
    if ( v24->_Ptr == this->_List._Mypair._Myval2._Myhead )
    {
      v24->_Ptr = _Pnode._Ptr;
      *(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *)((char *)this->_Vec._Mypair._Myval2._Myfirst + v12 + 8) = _Pnode;
    }
    else if ( v24->_Ptr == Myhead )
    {
      v24->_Ptr = _Pnode._Ptr;
    }
    else
    {
      p_Next = &v24[1]._Ptr->_Next;
      v26 = *p_Next;
      v24[1]._Ptr = *p_Next;
      if ( v26 != _Pnode._Ptr )
        *(std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> **)((char *)&this->_Vec._Mypair._Myval2._Myfirst[1]._Ptr + v12) = (*(std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> **)((char *)&this->_Vec._Mypair._Myval2._Myfirst[1]._Ptr + v12))->_Prev;
    }
    std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<Image,extension::FutureImageOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<Image,extension::FutureImageOption>::Body>>>,0>>::_Check_size(this);
    result->first._Ptr = _Pnode._Ptr;
    result->second = 1;
    return result;
  }
  else
  {
    while ( 1 )
    {
      Myhead = Myhead->_Prev;
      p_Myval = (char **)&Myhead->_Myval;
      if ( Myhead->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
        p_Myval = (char **)*p_Myval;
      if ( Myres < 0x10 )
        v17 = _Val;
      else
        v17 = (std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *)_Val->first._Mypair._Myval2._Bx._Ptr;
      v18 = Myhead->_Myval.first._Mypair._Myval2._Mysize;
      v19 = v18;
      if ( Mysize < v18 )
        v19 = Mysize;
      if ( (!v19 || !memcmp(v17, p_Myval, v19)) && Mysize >= v18 && Mysize <= v18 )
        break;
      _Val = v28;
      Myres = v28->first._Mypair._Myval2._Myres;
      if ( Myhead == v14 )
      {
        v12 = v27;
        goto LABEL_27;
      }
    }
    _Pnode._Ptr->_Prev->_Next = _Pnode._Ptr->_Next;
    _Pnode._Ptr->_Next->_Prev = _Pnode._Ptr->_Prev;
    --this->_List._Mypair._Myval2._Mysize;
    m_ptr = _Pnode._Ptr->_Myval.second.m_proxy.m_ptr;
    if ( m_ptr )
    {
      if ( _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
        operator delete(m_ptr, 0x18ui64);
    }
    std::string::~string((std::string *)&_Pnode._Ptr->_Myval.first);
    operator delete(_Pnode._Ptr);
    result->first._Ptr = Myhead;
    result->second = 0;
    return result;
  }
}

void __fastcall std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_First,
        unsigned __int64 _Count,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Pval,
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *_Al)
{
  for ( ; _Count; --_Count )
  {
    if ( _First )
      _First->_Ptr = _Pval->_Ptr;
    ++_First;
  }
}

extension::FutureAssetOptionFileSetting *__fastcall std::_Uninitialized_move_al_unchecked1<extension::FutureAssetOptionFileSetting *,extension::FutureAssetOptionFileSetting *,std::allocator<extension::FutureAssetOptionFileSetting>>(
        extension::FutureAssetOptionFileSetting *_First,
        extension::FutureAssetOptionFileSetting *_Last,
        extension::FutureAssetOptionFileSetting *_Dest,
        std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *_Al)
{
  extension::FutureAssetOptionFileSetting *i; // rdi

  for ( i = _First; i != _Last; ++i )
  {
    if ( _Dest )
    {
      _Dest->fileName._Mypair._Myval2._Myres = 15i64;
      _Dest->fileName._Mypair._Myval2._Mysize = 0i64;
      _Dest->fileName._Mypair._Myval2._Bx._Buf[0] = 0;
      std::string::_Assign_rv(&_Dest->fileName, &i->fileName);
      _Dest->bNoMotion = i->bNoMotion;
    }
    ++_Dest;
  }
  return _Dest;
}

std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *__fastcall std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_First,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Last,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Dest,
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *_Al)
{
  __int64 v4; // r9
  unsigned __int64 v5; // r10
  signed __int64 v6; // rcx

  v4 = 0i64;
  v5 = (unsigned __int64)((char *)_Last - (char *)_First + 7) >> 3;
  if ( _First > _Last )
    v5 = 0i64;
  if ( v5 )
  {
    v6 = (char *)_First - (char *)_Dest;
    do
    {
      if ( _Dest )
        _Dest->_Ptr = *(std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> **)((char *)_Dest + v6);
      ++_Dest;
      ++v4;
    }
    while ( v4 != v5 );
  }
  return _Dest;
}

void __fastcall std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting>>::construct<extension::FutureAssetOptionFileSetting,extension::FutureAssetOptionFileSetting &>(
        std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *this,
        extension::FutureAssetOptionFileSetting *_Ptr,
        extension::FutureAssetOptionFileSetting *<_Args_0>)
{
  extension::FutureAssetOptionFileSetting *Ptr; // rax

  if ( _Ptr )
  {
    _Ptr->fileName._Mypair._Myval2._Myres = 15i64;
    _Ptr->fileName._Mypair._Myval2._Mysize = 0i64;
    if ( _Ptr->fileName._Mypair._Myval2._Myres < 0x10 )
      Ptr = _Ptr;
    else
      Ptr = (extension::FutureAssetOptionFileSetting *)_Ptr->fileName._Mypair._Myval2._Bx._Ptr;
    Ptr->fileName._Mypair._Myval2._Bx._Buf[0] = 0;
    std::string::assign(&_Ptr->fileName, &<_Args_0>->fileName, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    _Ptr->bNoMotion = <_Args_0>->bNoMotion;
  }
}

void __fastcall extension::AsyncContent<OGLSecondary>::AsyncContent<OGLSecondary>(
        extension::AsyncContent<extension::exsound_detail::SoundBankImpl> *this,
        const std::string *name,
        const std::string *optstr)
{
  std::string *p_m_name; // rcx
  std::string *Ptr; // rax
  std::string *p_m_loadOptionString; // rcx
  const std::string *v8; // rax

  this->m_refCount.m_value._My_val = 1i64;
  p_m_name = (std::string *)&this->m_name;
  p_m_name->_Mypair._Myval2._Myres = 15i64;
  p_m_name->_Mypair._Myval2._Mysize = 0i64;
  if ( p_m_name->_Mypair._Myval2._Myres < 0x10 )
    Ptr = p_m_name;
  else
    Ptr = (std::string *)p_m_name->_Mypair._Myval2._Bx._Ptr;
  Ptr->_Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(p_m_name, name, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  p_m_loadOptionString = (std::string *)&this->m_loadOptionString;
  this->m_loadOptionString._Mypair._Myval2._Myres = 15i64;
  this->m_loadOptionString._Mypair._Myval2._Mysize = 0i64;
  if ( this->m_loadOptionString._Mypair._Myval2._Myres < 0x10 )
    v8 = &this->m_loadOptionString;
  else
    v8 = (const std::string *)p_m_loadOptionString->_Mypair._Myval2._Bx._Ptr;
  v8->_Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(p_m_loadOptionString, optstr, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  this->m_data._Mypair._Myval2 = 0i64;
  this->m_status.m_stateFlags.m_value._My_val = 0i64;
  this->m_status.m_stateFlags.m_value._My_val = 0i64;
  this->m_errorCode = 0;
  this->m_isDataReleased = 0;
}

void __fastcall extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>(
        extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> *this,
        extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *asset)
{
  __int64 v4; // rsi
  extension::RefCountablePtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body> *p_m_body; // rbx
  signed __int64 v6; // rdi
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *v7; // rdx
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *m_ptr; // rcx

  this->__vftable = (extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>_vtbl *)&AgSimpleThreadHost::`vftable';
  this->m_abort = 0;
  this->m_running = 1;
  this->__vftable = (extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>_vtbl *)&extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>::`vftable';
  v4 = 6i64;
  `eh vector constructor iterator'(
    this->m_asset,
    0x10ui64,
    6ui64,
    (void (__fastcall *)(void *))extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,
    (void (__fastcall *)(void *))extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::~BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>);
  p_m_body = &this->m_asset[0].m_body;
  v6 = (char *)asset - (char *)this;
  do
  {
    BYTE1(p_m_body[-1].m_ptr) = *((_BYTE *)&p_m_body[-3] + v6 - 7);
    v7 = *(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body **)((char *)&p_m_body[-3].m_ptr + v6);
    if ( v7 )
      _InterlockedExchangeAdd64((volatile signed __int64 *)&v7->m_refCount.m_ptr->m_sharedCount, 1ui64);
    m_ptr = p_m_body->m_ptr;
    p_m_body->m_ptr = v7;
    if ( m_ptr )
    {
      if ( _InterlockedExchangeAdd64(
             (volatile signed __int64 *)&m_ptr->m_refCount.m_ptr->m_sharedCount,
             0xFFFFFFFFFFFFFFFFui64) == 1 )
        ((void (__fastcall *)(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *, __int64))m_ptr->~RefCountableWeakSupportBase)(
          m_ptr,
          1i64);
    }
    p_m_body += 2;
    --v4;
  }
  while ( v4 );
}

void __fastcall std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>(
        std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>> *this)
{
  this->_Traitsobj._Mypair._Myval2._Myval2 = 0.0;
  this->_List._Mypair._Myval2._Myhead = 0i64;
  this->_List._Mypair._Myval2._Mysize = 0i64;
  this->_List._Mypair._Myval2._Myhead = std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>::_Buynode0(
                                          (std::_List_alloc<std::_List_base_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> > *)this,
                                          0i64,
                                          0i64);
  this->_Vec._Mypair._Myval2._Myfirst = 0i64;
  this->_Vec._Mypair._Myval2._Mylast = 0i64;
  this->_Vec._Mypair._Myval2._Myend = 0i64;
  this->_Traitsobj._Mypair._Myval2._Myval2 = 1.0;
  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
    (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
    8ui64);
}

void __fastcall extension::BasicFutureObject<OGLMirror,void>::AssetCache::AssetCache(
        extension::BasicFutureObject<OGLMirror,void>::AssetCache *this)
{
  extension::AssetCacheExpiredEntryCleaner *v1; // rax
  extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode> *v2; // r8

  InitializeCriticalSection((LPCRITICAL_SECTION)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache>);
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_Prev = &extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_Next = &extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.__vftable = (extension::BasicFutureObject<OGLMirror,void>::AssetCache_vtbl *)&extension::asyncjob_detail::AssetCacheBase::`vftable';
  v1 = extension::_anonymous_namespace_::AssetCacheExpiredEntryCleaner::Instance();
  if ( v1 )
    v2 = &v1->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  else
    v2 = 0i64;
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_Next->extension::asyncjob_detail::AssetCacheBase::extension::asyncjob_detail::AssetCacheNode::extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>::m_Prev = v2->m_Prev;
  v2->m_Prev->m_Next = extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_Next;
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_Next = v2;
  v2->m_Prev = &extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.__vftable = (extension::BasicFutureObject<OGLMirror,void>::AssetCache_vtbl *)&extension::BasicFutureObject<OGLMirror,void>::AssetCache::`vftable';
  std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>((std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>> *)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap);
}

void __fastcall extension::BasicFutureObject<OGLMotion,void>::AssetCache::AssetCache(
        extension::BasicFutureObject<OGLMotion,void>::AssetCache *this)
{
  extension::AssetCacheExpiredEntryCleaner *v1; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *v2; // r8
  extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode> *v3; // rdx
  extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode> *m_Prev; // rcx
  unsigned __int64 v5; // rdx

  InitializeCriticalSection((LPCRITICAL_SECTION)&extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.extension::ExSimpleLockable<extension::BasicFutureObject<OGLMotion,void>::AssetCache>);
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_Prev = &extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_Next = &extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.__vftable = (extension::BasicFutureObject<OGLMotion,void>::AssetCache_vtbl *)&extension::asyncjob_detail::AssetCacheBase::`vftable';
  v1 = extension::_anonymous_namespace_::AssetCacheExpiredEntryCleaner::Instance();
  if ( v1 )
    v3 = &v1->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  else
    v3 = 0i64;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_Next->extension::asyncjob_detail::AssetCacheBase::extension::asyncjob_detail::AssetCacheNode::extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>::m_Prev = v3->m_Prev;
  m_Prev = v3->m_Prev;
  v3->m_Prev->m_Next = extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_Next;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_Next = v3;
  v3->m_Prev = &extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.__vftable = (extension::BasicFutureObject<OGLMotion,void>::AssetCache_vtbl *)&extension::BasicFutureObject<OGLMotion,void>::AssetCache::`vftable';
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._Traitsobj._Mypair._Myval2._Myval2 = 0.0;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._List._Mypair._Myval2._Myhead = 0i64;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._List._Mypair._Myval2._Mysize = 0i64;
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._List._Mypair._Myval2._Myhead = std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>::_Buynode0((std::_List_alloc<std::_List_base_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >> > *)m_Prev, (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *)v3, v2);
  extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._Vec._Mypair._Myval2._Myfirst = 0i64;
  *(_OWORD *)&extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._Vec._Mypair._Myval2._Mylast = 0i64;
  LODWORD(extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap._Traitsobj._Mypair._Myval2._Myval2) = FLOAT_1_0;
  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>,0>>::_Init(
    &extension::BasicFutureObject<OGLMotion,void>::s_cacheManager.m_cachedObjectMap,
    v5);
}

void __fastcall extension::BasicFutureObject<OGLMirror,void>::Body::Body(
        extension::BasicFutureObject<OGLMirror,void>::Body *this,
        extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > shared)
{
  volatile signed __int64 *My_val; // rax
  extension::AsyncContent<OGLMirror> *v5; // rbx
  extension::RefCountableWeakSupportBase::WeakProxy *v6; // [rsp+48h] [rbp+10h]

  this->__vftable = (extension::BasicFutureObject<OGLMirror,void>::Body_vtbl *)&extension::RefCountableWeakSupportBase::`vftable';
  v6 = (extension::RefCountableWeakSupportBase::WeakProxy *)operator new(0x18ui64);
  v6->m_refCount.m_value._My_val = 1i64;
  v6->m_principal = this;
  v6->m_sharedCount.m_value._My_val = 0i64;
  v6->m_sharedCount.m_value._My_val = 1i64;
  this->m_refCount.m_ptr = v6;
  this->__vftable = (extension::BasicFutureObject<OGLMirror,void>::Body_vtbl *)&extension::BasicFutureObject<OGLMirror,void>::Body::`vftable';
  My_val = (volatile signed __int64 *)shared.m_ptr->m_refCount.m_value._My_val;
  this->m_content.m_ptr = (extension::AsyncContent<OGLMirror> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( My_val )
    _InterlockedExchangeAdd64(My_val, 1ui64);
  v5 = (extension::AsyncContent<OGLMirror> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( v5 )
  {
    if ( _InterlockedExchangeAdd64((volatile signed __int64 *)v5, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      extension::AsyncContent<OGLMirror>::~AsyncContent<OGLMirror>(v5);
      operator delete(v5, 0x68ui64);
    }
  }
}

void __fastcall extension::BasicFutureObject<OGLMotion,void>::Body::Body(
        extension::BasicFutureObject<OGLMotion,void>::Body *this,
        extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > shared)
{
  volatile signed __int64 *My_val; // rax
  extension::AsyncContent<OGLMotion> *v5; // rbx
  extension::RefCountableWeakSupportBase::WeakProxy *v6; // [rsp+48h] [rbp+10h]

  this->__vftable = (extension::BasicFutureObject<OGLMotion,void>::Body_vtbl *)&extension::RefCountableWeakSupportBase::`vftable';
  v6 = (extension::RefCountableWeakSupportBase::WeakProxy *)operator new(0x18ui64);
  v6->m_refCount.m_value._My_val = 1i64;
  v6->m_principal = this;
  v6->m_sharedCount.m_value._My_val = 0i64;
  v6->m_sharedCount.m_value._My_val = 1i64;
  this->m_refCount.m_ptr = v6;
  this->__vftable = (extension::BasicFutureObject<OGLMotion,void>::Body_vtbl *)&extension::BasicFutureObject<OGLMotion,void>::Body::`vftable';
  My_val = (volatile signed __int64 *)shared.m_ptr->m_refCount.m_value._My_val;
  this->m_content.m_ptr = (extension::AsyncContent<OGLMotion> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( My_val )
    _InterlockedExchangeAdd64(My_val, 1ui64);
  v5 = (extension::AsyncContent<OGLMotion> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( v5 )
  {
    if ( _InterlockedExchangeAdd64((volatile signed __int64 *)v5, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      extension::AsyncContent<OGLMotion>::~AsyncContent<OGLMotion>(v5);
      operator delete(v5, 0x68ui64);
    }
  }
}

void __fastcall extension::ExLockableLock<extension::ExSimpleLockable<extension::BasicFutureObject<OGLCamera,void>::AssetCache>>::~ExLockableLock<extension::ExSimpleLockable<extension::BasicFutureObject<OGLCamera,void>::AssetCache>>(
        extension::ExLockableLock<extension::ExSimpleLockable<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::AssetCache> > *this)
{
  _RTL_CRITICAL_SECTION *m_associated; // rdi
  int v2; // ebx
  __int64 m_ownsLockCount; // rbx

  m_associated = (_RTL_CRITICAL_SECTION *)this->m_associated;
  v2 = -this->m_ownsLockCount;
  if ( v2 < 0 || this->m_ownsLockCount == 0 )
  {
    if ( this->m_ownsLockCount > 0 )
    {
      m_ownsLockCount = (unsigned int)this->m_ownsLockCount;
      do
      {
        LeaveCriticalSection(m_associated);
        --m_ownsLockCount;
      }
      while ( m_ownsLockCount );
    }
  }
  else
  {
    do
    {
      EnterCriticalSection(m_associated);
      --v2;
    }
    while ( v2 );
  }
}

// attributes: thunk
void __stdcall AgMutex::~AgMutex(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

void __fastcall std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>::~list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>(
        std::list<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *this)
{
  std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body>>>::clear(this);
  operator delete(this->_Mypair._Myval2._Myhead);
}

void __fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>>>>>(
        std::vector<unsigned char *> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall extension::BasicFutureObject<OGLMirror,void>::AssetCache::~AssetCache(
        extension::BasicFutureObject<OGLMirror,void>::AssetCache *this)
{
  AgLogger **Myfirst; // rdx

  this->__vftable = (extension::BasicFutureObject<OGLMirror,void>::AssetCache_vtbl *)&extension::BasicFutureObject<OGLMirror,void>::AssetCache::`vftable';
  Myfirst = (AgLogger **)this->m_cachedObjectMap._Vec._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      Myfirst,
      ((char *)this->m_cachedObjectMap._Vec._Mypair._Myval2._Myend - (char *)Myfirst) >> 3);
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Myfirst = 0i64;
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Mylast = 0i64;
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Myend = 0i64;
  }
  std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body>>>::clear((std::list<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *)&this->m_cachedObjectMap._List);
  operator delete(this->m_cachedObjectMap._List._Mypair._Myval2._Myhead);
  this->__vftable = (extension::BasicFutureObject<OGLMirror,void>::AssetCache_vtbl *)&extension::asyncjob_detail::AssetCacheNode::`vftable';
  this->m_Next->extension::asyncjob_detail::AssetCacheBase::extension::asyncjob_detail::AssetCacheNode::extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>::m_Prev = this->m_Prev;
  this->m_Prev->m_Next = this->m_Next;
  this->m_Next = &this->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  this->m_Prev = &this->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache>);
}

void __fastcall extension::BasicFutureObject<OGLMotion,void>::AssetCache::~AssetCache(
        extension::BasicFutureObject<OGLMotion,void>::AssetCache *this)
{
  AgLogger **Myfirst; // rdx

  this->__vftable = (extension::BasicFutureObject<OGLMotion,void>::AssetCache_vtbl *)&extension::BasicFutureObject<OGLMotion,void>::AssetCache::`vftable';
  Myfirst = (AgLogger **)this->m_cachedObjectMap._Vec._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      Myfirst,
      ((char *)this->m_cachedObjectMap._Vec._Mypair._Myval2._Myend - (char *)Myfirst) >> 3);
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Myfirst = 0i64;
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Mylast = 0i64;
    this->m_cachedObjectMap._Vec._Mypair._Myval2._Myend = 0i64;
  }
  std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body>>>::clear((std::list<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *)&this->m_cachedObjectMap._List);
  operator delete(this->m_cachedObjectMap._List._Mypair._Myval2._Myhead);
  this->__vftable = (extension::BasicFutureObject<OGLMotion,void>::AssetCache_vtbl *)&extension::asyncjob_detail::AssetCacheNode::`vftable';
  this->m_Next->extension::asyncjob_detail::AssetCacheBase::extension::asyncjob_detail::AssetCacheNode::extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>::m_Prev = this->m_Prev;
  this->m_Prev->m_Next = this->m_Next;
  this->m_Next = &this->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  this->m_Prev = &this->extension::BiLinkable<extension::asyncjob_detail::AssetCacheNode>;
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->extension::ExSimpleLockable<extension::BasicFutureObject<OGLMotion,void>::AssetCache>);
}

extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *__fastcall extension::BasicFutureObject<OGLSecondary,void>::operator=(
        extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *this,
        const extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *other)
{
  extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body *m_ptr; // r8
  extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body *v4; // rcx

  this->m_isNoCache = other->m_isNoCache;
  m_ptr = other->m_body.m_ptr;
  if ( m_ptr )
    _InterlockedExchangeAdd64((volatile signed __int64 *)&m_ptr->m_refCount.m_ptr->m_sharedCount, 1ui64);
  v4 = this->m_body.m_ptr;
  this->m_body.m_ptr = m_ptr;
  if ( v4
    && _InterlockedExchangeAdd64(
         (volatile signed __int64 *)&v4->m_refCount.m_ptr->m_sharedCount,
         0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    ((void (__fastcall *)(extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body *, __int64))v4->~RefCountableWeakSupportBase)(
      v4,
      1i64);
  }
  return this;
}

extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> *__fastcall std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>::operator[](
        std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>> *this,
        const std::string *_Keyval)
{
  std::_List_buy<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *v4; // rcx
  const std::piecewise_construct_t *v5; // r9
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Ptr; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rdi
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v9; // rdx
  unsigned __int64 Mysize; // rax
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >,bool> v12; // [rsp+30h] [rbp-18h] BYREF
  std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > result; // [rsp+50h] [rbp+8h] BYREF

  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>>>,0>>::lower_bound(
    this,
    &result,
    _Keyval);
  Ptr = result._Ptr;
  if ( result._Ptr == this->_List._Mypair._Myval2._Myhead )
  {
    Myhead = this->_List._Mypair._Myval2._Myhead;
    result._Ptr = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)_Keyval;
    Next = Myhead->_Next;
    v9 = std::_List_buy<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<StageResources,extension::FutureStageOption>::Body>>>::_Buynode<std::piecewise_construct_t const &,std::tuple<std::string const &>,std::tuple<>>(
           v4,
           Myhead->_Next,
           Myhead->_Next->_Prev,
           v5,
           (std::tuple<std::string const &> *)&result);
    Mysize = this->_List._Mypair._Myval2._Mysize;
    if ( Mysize == 0x3FFFFFFFFFFFFFEi64 )
      std::_Xlength_error("list<T> too long");
    this->_List._Mypair._Myval2._Mysize = Mysize + 1;
    Next->_Prev = v9;
    v9->_Prev->_Next = v9;
    std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>,0>>::_Insert<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>(
      this,
      &v12,
      &this->_List._Mypair._Myval2._Myhead->_Next->_Myval,
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >)this->_List._Mypair._Myval2._Myhead->_Next);
    Ptr = v12.first._Ptr;
  }
  return &Ptr->_Myval.second;
}

extension::exsound_detail::SoundBankImpl *__fastcall extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
        extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *this,
        extension::AsyncStatus::Step a2)
{
  extension::AsyncContent<extension::exsound_detail::SoundBankImpl> *m_ptr; // rbx

  m_ptr = this->m_body.m_ptr->m_content.m_ptr;
  if ( !m_ptr || m_ptr->m_isDataReleased )
    return 0i64;
  if ( (m_ptr->m_status.m_stateFlags.m_value._My_val & 1) == 0 )
    extension::AsyncStatus::waitFor(&m_ptr->m_status, a2);
  return m_ptr->m_data._Mypair._Myval2;
}

void __fastcall AppMain::ApplyFXAA(AppMain *this, int frameBufferIndex)
{
  __m128i v3; // xmm1
  OGLRender *m_pRender; // r8
  float v5; // xmm0_4
  __m128i v6; // xmm1
  Vector4Unaligned v7; // [rsp+30h] [rbp-18h]

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "FXAA");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 4, "FXAA");
  v3 = _mm_cvtsi32_si128(this->m_iScreenW);
  m_pRender = this->m_pRender;
  ++markerCount;
  v5 = 1.0 / _mm_cvtepi32_ps(v3).m128_f32[0];
  v6 = _mm_cvtsi32_si128(this->m_iScreenH);
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = v5;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / _mm_cvtepi32_ps(v6).m128_f32[0];
  *(_QWORD *)&v7.x = *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaNormScaleFactor;
  *(_QWORD *)&v7.z = LODWORD(this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaDispRange);
  this->ModelRoomSettings.postfxUniforms.u_postfxFXAA = v7;
  AppMain::RenderFullScreenToTexture(
    this,
    7952,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    0);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::ApplyFXAAToShadows(AppMain *this, int frameBufferIndex)
{
  __int64 v3; // rdi
  __m128i v4; // xmm1
  OGLRender *m_pRender; // r8
  float v6; // xmm0_4
  __m128i v7; // xmm1
  Vector4Unaligned v8; // [rsp+30h] [rbp-18h]

  v3 = frameBufferIndex;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Shadow FXAA");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 11, "Shadow FXAA");
  v4 = _mm_cvtsi32_si128(this->m_iScreenW);
  m_pRender = this->m_pRender;
  ++markerCount;
  v6 = 1.0 / _mm_cvtepi32_ps(v4).m128_f32[0];
  v7 = _mm_cvtsi32_si128(this->m_iScreenH);
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = v6;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / _mm_cvtepi32_ps(v7).m128_f32[0];
  *(_QWORD *)&v8.x = *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaNormScaleFactor;
  *(_QWORD *)&v8.z = LODWORD(this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaDispRange);
  this->ModelRoomSettings.postfxUniforms.u_postfxFXAA = v8;
  AppMain::RenderFullScreenToTexture(
    this,
    7952,
    &m_pRender->m_renderTextures.m_ShadowDepthMap[v3],
    &m_pRender->m_renderTextures.m_ShadowDepthMap[v3],
    v3);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::ApplyShaderToTexture(
        AppMain *this,
        int shader,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        int width,
        int height,
        int srcFrameBufferIndex)
{
  Framework::GLManager *v8; // rdi
  __int64 v11; // r15
  signed int m_targetWidth; // eax
  float v13; // xmm10_4
  float v14; // xmm8_4
  unsigned int v15; // edx
  float v16; // xmm1_4
  unsigned int v17; // edx
  unsigned int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  unsigned int v21; // esi
  unsigned int m_TexID; // edx
  unsigned __int64 v23; // r8
  Framework::GLManager *v24; // rcx
  unsigned int v25; // edx
  unsigned int v26; // ecx
  Framework::GLManager *v27; // rcx
  unsigned int v28; // edx
  Framework::GLManager *v29; // rcx
  bool v30; // zf
  extension::AsyncStatus::Step v31; // edx
  extension::exsound_detail::SoundBankImpl *v32; // rax
  extension::AsyncStatus::Step v33; // edx
  extension::exsound_detail::SoundBankImpl *v34; // r14
  unsigned int Mysize; // edx
  Framework::GLManager *v36; // rcx
  unsigned int v37; // edx
  Framework::GLManager *v38; // rcx
  extension::AsyncStatus::Step v39; // edx
  extension::exsound_detail::SoundBankImpl *v40; // rax
  extension::AsyncStatus::Step v41; // edx
  unsigned int v42; // edx
  Framework::GLManager *v43; // rcx
  unsigned int v44; // edx
  Framework::GLManager *v45; // rcx
  unsigned int v46; // edx
  Framework::GLManager *v47; // rcx
  extension::AsyncStatus::Step v48; // edx
  extension::exsound_detail::SoundBankImpl *v49; // rax
  extension::AsyncStatus::Step v50; // edx
  extension::exsound_detail::SoundBankImpl *v51; // r14
  unsigned int v52; // edx
  Framework::GLManager *v53; // rcx
  unsigned int v54; // edx
  Framework::GLManager *v55; // rcx
  unsigned int v56; // edx
  Framework::GLManager *v57; // rcx
  unsigned int v58; // edx
  Framework::GLManager *v59; // rcx
  unsigned int v60; // ecx
  unsigned int v61; // edx
  __int64 v62; // rax
  Framework::GLManager *v63; // rcx
  unsigned int v64; // edx
  __int64 v65; // rax
  Framework::GLManager *v66; // rcx
  GraphicsOpt *g; // rcx
  int v68; // er12
  OGLMatrix *p_m_Proj; // rcx
  OGLShader *v70; // r12
  Framework::GLManager *v71; // rcx
  int v72; // er14
  unsigned __int64 v73; // r8
  char *v74; // rax
  int *v75; // r8
  char *v76; // r13
  float *v77; // rdx
  __int64 v78; // r9
  float *v79; // rcx
  float v80; // xmm0_4
  __m128 v81; // xmm1
  float v82; // eax
  unsigned __int64 v83; // xmm0_8
  __m128 v84; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v86; // xmm2
  __m128 v87; // xmm3
  __m128 v88; // xmm4
  __m128 v89; // xmm5
  __m128 v90; // xmm6
  __m128 v91; // xmm7
  __m128 v92; // xmm8
  __m128 v93; // xmm9
  int v94; // ecx
  unsigned __int8 v95; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v97; // r15
  __int64 v98; // rcx
  Framework::GLManager *v99; // rsi
  signed int v100; // er10
  int renderSize; // ecx
  int v102; // eax
  int *v103; // rax
  __int64 v104; // rcx
  int v105; // eax
  AppMain *v106; // rcx
  int v107; // edx
  unsigned int v108; // ecx
  float v109; // xmm1_4
  float v110; // xmm1_4
  Framework::GLManager *v111; // rdx
  unsigned int m_buffers; // er8
  unsigned int *systemRenderID; // rcx
  int t; // [rsp+28h] [rbp-E0h]
  unsigned int v115; // [rsp+40h] [rbp-C8h]
  unsigned int renderbuffers[2]; // [rsp+48h] [rbp-C0h] BYREF
  char *v117; // [rsp+50h] [rbp-B8h]
  __int128 v118; // [rsp+58h] [rbp-B0h]
  __int128 v119; // [rsp+68h] [rbp-A0h]
  __int128 v120; // [rsp+78h] [rbp-90h]
  __int128 v121; // [rsp+88h] [rbp-80h]
  __int128 v122; // [rsp+98h] [rbp-70h]
  __int128 v123; // [rsp+A8h] [rbp-60h]
  __int128 v124; // [rsp+B8h] [rbp-50h]
  __int128 v125; // [rsp+C8h] [rbp-40h]
  float v[4]; // [rsp+D8h] [rbp-30h] BYREF
  float value[4]; // [rsp+E8h] [rbp-20h] BYREF
  __int128 v128; // [rsp+F8h] [rbp-10h]
  __int128 v129; // [rsp+108h] [rbp+0h]
  __int128 v130; // [rsp+118h] [rbp+10h]
  float v131[4]; // [rsp+128h] [rbp+20h] BYREF
  __int128 v132; // [rsp+138h] [rbp+30h]
  __int128 v133; // [rsp+148h] [rbp+40h]
  __int128 v134; // [rsp+158h] [rbp+50h]
  int v135; // [rsp+168h] [rbp+60h] BYREF
  __int64 v136; // [rsp+16Ch] [rbp+64h]
  int v137; // [rsp+174h] [rbp+6Ch]
  int v138; // [rsp+178h] [rbp+70h]
  int v139; // [rsp+17Ch] [rbp+74h]
  int v140; // [rsp+180h] [rbp+78h]
  int v141; // [rsp+184h] [rbp+7Ch]
  __int64 v142; // [rsp+188h] [rbp+80h]
  __int64 v143; // [rsp+190h] [rbp+88h] BYREF
  float v144; // [rsp+198h] [rbp+90h]
  int v145; // [rsp+19Ch] [rbp+94h]
  float v146; // [rsp+1A0h] [rbp+98h]
  __int64 v147; // [rsp+1A4h] [rbp+9Ch]
  float v148; // [rsp+1ACh] [rbp+A4h]
  float v149; // [rsp+1B0h] [rbp+A8h]
  int v150; // [rsp+1B4h] [rbp+ACh]
  float v151[4]; // [rsp+1B8h] [rbp+B0h] BYREF

  if ( !pSrcTexture )
    return;
  v8 = Framework::GLManager::glm;
  LODWORD(v117) = srcFrameBufferIndex;
  v11 = shader;
  if ( !pDestTexture )
    return;
  m_targetWidth = Framework::GLManager::glm->m_config.m_targetWidth;
  v13 = (float)width;
  v143 = 0i64;
  v142 = 0i64;
  v147 = 0i64;
  v150 = 0;
  v14 = (float)height;
  v145 = 0;
  v136 = 0i64;
  v135 = 0;
  v139 = 0;
  v140 = 1065353216;
  v138 = 1065353216;
  v141 = 1065353216;
  v137 = 1065353216;
  v149 = (float)height;
  v144 = (float)height;
  v148 = (float)width;
  v146 = (float)width;
  if ( (float)width == (float)((float)m_targetWidth * 0.125) )
  {
    Framework::GLManager::glGenEighthRenderbuffers(Framework::GLManager::glm, shader, renderbuffers);
    Framework::GLManager::glBindEighthRenderbuffer(v8, v15, renderbuffers[0]);
  }
  else
  {
    v16 = (float)m_targetWidth * 0.5;
    if ( v16 <= v13 )
    {
      if ( v13 == v16 )
      {
        Framework::GLManager::glGenHalfRenderbuffers(Framework::GLManager::glm, shader, renderbuffers);
        Framework::GLManager::glBindHalfRenderbuffer(v8, v18, renderbuffers[0]);
      }
      else
      {
        glGenRenderbuffersAG(1, renderbuffers);
        glBindRenderbufferAG(v19, renderbuffers[0]);
      }
    }
    else
    {
      Framework::GLManager::glGenThirdRenderbuffers(Framework::GLManager::glm, shader, renderbuffers);
      Framework::GLManager::glBindThirdRenderbuffer(v8, v17, renderbuffers[0]);
    }
  }
  if ( !pDestTexture->m_TexID )
    glGenTexturesAG(1, &pDestTexture->m_TexID);
  v20 = m_ActiveTexture;
  v21 = 0;
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
    v20 = m_ActiveTexture;
  }
  m_TexID = pSrcTexture->m_TexID;
  v23 = 0x140000000ui64;
  if ( m_TexID != ::m_TexID[v20] || !m_TexID )
  {
    ::m_TexID[v20] = m_TexID;
    v24 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = m_TexID;
    while ( v24->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
    v20 = m_ActiveTexture;
  }
  if ( v20 != 1 )
  {
    m_ActiveTexture = 1;
    _glewActiveTexture(0x84C1u);
    v20 = m_ActiveTexture;
  }
  v25 = pDestTexture->m_TexID;
  v26 = v20;
  if ( v25 != ::m_TexID[v20] || !v25 )
  {
    ::m_TexID[v20] = v25;
    v27 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = v25;
    while ( v27->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v25);
  }
  glsFramebufferTexture2D(v26, 0x8CE1u, v23, pDestTexture->m_TexID, t, width, height, v115);
  if ( (unsigned int)(v11 - 7944) <= 1 )
  {
    v58 = pDestTexture->m_TexID;
    if ( v58 != ::m_TexID[m_ActiveTexture] || !v58 )
    {
      v59 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v58;
      v59->m_textureID = v58;
      while ( v59->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v58);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    v60 = m_ActiveTexture;
    pDestTexture->m_TexParam = 1290;
    if ( v60 != 2 )
    {
      m_ActiveTexture = 2;
      _glewActiveTexture(0x84C2u);
      v60 = m_ActiveTexture;
    }
    v61 = this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_TexID;
    v62 = v60;
    if ( v61 != ::m_TexID[v60] || !v61 )
    {
      v63 = Framework::GLManager::glm;
      ::m_TexID[v62] = v61;
      v63->m_textureID = v61;
      while ( v63->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v61);
      v60 = m_ActiveTexture;
    }
    if ( v60 != 3 )
    {
      m_ActiveTexture = 3;
      _glewActiveTexture(0x84C3u);
      v60 = m_ActiveTexture;
    }
    v64 = this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID;
    v65 = v60;
    if ( v64 != ::m_TexID[v60] || !v64 )
    {
      v66 = Framework::GLManager::glm;
      ::m_TexID[v65] = v64;
      v66->m_textureID = v64;
      while ( v66->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v64);
    }
  }
  else
  {
    switch ( (_DWORD)v11 )
    {
      case 0x1F0F:
        v28 = pDestTexture->m_TexID;
        if ( v28 != ::m_TexID[m_ActiveTexture] || !v28 )
        {
          v29 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v28;
          v29->m_textureID = v28;
          while ( v29->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v28);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v30 = m_ActiveTexture == 2;
        pDestTexture->m_TexParam = 1290;
        if ( !v30 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID);
        if ( m_ActiveTexture != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
        }
        v32 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)this->pTexture._Mypair._Myval2._Myfirst,
                v31);
        glsBindTexture(0xDE1u, v32->m_bankFileDir._Mypair._Myval2._Mysize);
        v34 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)this->pTexture._Mypair._Myval2._Myfirst,
                v33);
        Mysize = v34->m_bankFileDir._Mypair._Myval2._Mysize;
        if ( Mysize != ::m_TexID[m_ActiveTexture] || !Mysize )
        {
          ::m_TexID[m_ActiveTexture] = Mysize;
          v36 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = Mysize;
          while ( v36->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, Mysize);
        }
LABEL_84:
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 10497.0);
        glTexParameterf(0xDE1u, 0x2803u, 10497.0);
        HIDWORD(v34->m_bankFileDir._Mypair._Myval2._Mysize) = 2570;
        break;
      case 0x1F00:
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID);
        if ( m_ActiveTexture != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_TexID);
        if ( m_ActiveTexture != 4 )
        {
          m_ActiveTexture = 4;
          _glewActiveTexture(0x84C4u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_TexID);
        if ( m_ActiveTexture != 5 )
        {
          m_ActiveTexture = 5;
          _glewActiveTexture(0x84C5u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_TexID);
        break;
      case 0x1F01:
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID);
        if ( m_ActiveTexture != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_TexID);
        if ( m_ActiveTexture != 4 )
        {
          m_ActiveTexture = 4;
          _glewActiveTexture(0x84C4u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_TexID);
        if ( m_ActiveTexture != 5 )
        {
          m_ActiveTexture = 5;
          _glewActiveTexture(0x84C5u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_TexID);
        if ( m_ActiveTexture != 6 )
        {
          m_ActiveTexture = 6;
          _glewActiveTexture(0x84C6u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[3].m_TexID);
        if ( m_ActiveTexture != 7 )
        {
          m_ActiveTexture = 7;
          _glewActiveTexture(0x84C7u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[5].m_TexID);
        if ( m_ActiveTexture != 8 )
        {
          m_ActiveTexture = 8;
          _glewActiveTexture(0x84C8u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_TexID);
        if ( m_ActiveTexture != 9 )
        {
          m_ActiveTexture = 9;
          _glewActiveTexture(0x84C9u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_TexID);
        break;
      case 0x1F3C:
        v37 = pDestTexture->m_TexID;
        if ( v37 != ::m_TexID[m_ActiveTexture] || !v37 )
        {
          v38 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v37;
          v38->m_textureID = v37;
          while ( v38->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v37);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 10497.0);
        glTexParameterf(0xDE1u, 0x2803u, 10497.0);
        v30 = m_ActiveTexture == 2;
        pDestTexture->m_TexParam = 2570;
        if ( !v30 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        v40 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)this->pTexture._Mypair._Myval2._Myfirst,
                v39);
        glsBindTexture(0xDE1u, v40->m_bankFileDir._Mypair._Myval2._Mysize);
        v34 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)this->pTexture._Mypair._Myval2._Myfirst,
                v41);
        v42 = v34->m_bankFileDir._Mypair._Myval2._Mysize;
        if ( v42 != ::m_TexID[m_ActiveTexture] || !v42 )
        {
          ::m_TexID[m_ActiveTexture] = v42;
          v43 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v42;
          while ( v43->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v42);
        }
        goto LABEL_84;
      case 0x1F20:
        v44 = pDestTexture->m_TexID;
        if ( v44 != ::m_TexID[m_ActiveTexture] || !v44 )
        {
          v45 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v44;
          v45->m_textureID = v44;
          while ( v45->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v44);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 10497.0);
        glTexParameterf(0xDE1u, 0x2803u, 10497.0);
        pDestTexture->m_TexParam = 2570;
        break;
      case 0x1F3A:
        v46 = pDestTexture->m_TexID;
        if ( v46 != ::m_TexID[m_ActiveTexture] || !v46 )
        {
          v47 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v46;
          v47->m_textureID = v46;
          while ( v47->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v46);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 10497.0);
        glTexParameterf(0xDE1u, 0x2803u, 10497.0);
        v30 = m_ActiveTexture == 2;
        pDestTexture->m_TexParam = 2570;
        if ( !v30 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        v49 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)&this->pTexture._Mypair._Myval2._Myfirst[1],
                v48);
        glsBindTexture(0xDE1u, v49->m_bankFileDir._Mypair._Myval2._Mysize);
        v51 = extension::BasicFutureObject<extension::GFXIMovieData,void>::operator->(
                (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void> *)&this->pTexture._Mypair._Myval2._Myfirst[1],
                v50);
        v52 = v51->m_bankFileDir._Mypair._Myval2._Mysize;
        if ( v52 != ::m_TexID[m_ActiveTexture] || !v52 )
        {
          ::m_TexID[m_ActiveTexture] = v52;
          v53 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v52;
          while ( v53->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v52);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        HIDWORD(v51->m_bankFileDir._Mypair._Myval2._Mysize) = 1290;
        break;
      case 0x1F3D:
        v54 = pDestTexture->m_TexID;
        if ( v54 != ::m_TexID[m_ActiveTexture] || !v54 )
        {
          v55 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v54;
          v55->m_textureID = v54;
          while ( v55->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v54);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v30 = m_ActiveTexture == 2;
        pDestTexture->m_TexParam = 1290;
        if ( !v30 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[(int)v117].m_TexID);
        break;
      case 0x1F36:
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, pSrcTexture->m_TexID);
        if ( m_ActiveTexture != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
        }
        glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_CharacterHighlights[1].m_TexID);
        break;
      case 0x1F38:
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, pSrcTexture->m_TexID);
        break;
      case 0x1F1F:
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
        }
        glsBindTexture(0xDE1u, pSrcTexture->m_TexID);
        if ( m_ActiveTexture != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
        }
        glsBindTexture(0xDE1u, pDestTexture->m_TexID);
        break;
      default:
        v56 = pDestTexture->m_TexID;
        if ( v56 != ::m_TexID[m_ActiveTexture] || !v56 )
        {
          v57 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v56;
          v57->m_textureID = v56;
          while ( v57->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v56);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        pDestTexture->m_TexParam = 1290;
        break;
    }
  }
  if ( m_DepthMask != 1 )
  {
    m_DepthMask = 1;
    glDepthMask(1u);
  }
  glClearAG(0x100u);
  g = this->g;
  if ( width >= v8->m_config.m_targetWidth )
  {
    GraphicsOpt::lock(g);
    v68 = height;
  }
  else
  {
    v68 = height;
    GraphicsOpt::lock(g, width, height);
  }
  if ( m_viewportX || m_viewportY || width != m_viewportW || v68 != m_viewportH )
  {
    m_viewportX = 0;
    m_viewportY = 0;
    m_viewportW = width;
    m_viewportH = v68;
    glViewport(0, 0, width, v68);
  }
  p_m_Proj = &this->m_pRender->m_Proj;
  if ( Framework::GLManager::glm->systemRenderID[Framework::GLManager::glm->m_backBufferIndex] == Framework::GLManager::glm->currentRenderID )
    OGLMatrix::ortho(p_m_Proj, 0.0, v13, 0.0, v14, -1.0, 1.0);
  else
    OGLMatrix::ortho(p_m_Proj, 0.0, v13, v14, 0.0, -1.0, 1.0);
  if ( (_DWORD)v11 == 7936 )
  {
    if ( m_DepthMask )
    {
      m_DepthMask = 0;
      glDepthMask(0);
    }
    if ( m_dMode != 519 )
    {
      m_dMode = 519;
      glDepthFunc(0x207u);
    }
    if ( m_Mode != 32774 )
    {
      m_Mode = 32774;
      m_ModeAlpha = 32774;
      _glewBlendEquation(0x8006u);
    }
    if ( dword_140A9605C != 1 )
    {
      dword_140A9605C = 1;
      glEnable(0xBE2u);
    }
    if ( m_Sfactor != 770 || m_Dfactor != 771 || m_SfactorAlpha != 770 || m_DfactorAlpha != 771 )
    {
      m_Sfactor = 770;
      m_Dfactor = 771;
      m_SfactorAlpha = 770;
      m_DfactorAlpha = 771;
      _glewBlendFuncSeparate(0x302u, 0x303u, 0x302u, 0x303u);
    }
  }
  v70 = this->m_pRender->m_ShaderFXTbl[v11];
  if ( v70 && v70->m_Program )
  {
    KOFShaderManager::useProgramSlot((KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance, v70->m_programSlot);
    v71 = Framework::GLManager::glm;
    v72 = 64;
    Framework::GLManager::glm->renderSize = 64;
    v74 = (char *)AgFrameAllocator<AgAllocator<1>>::allocate(&v71->m_agDrawAllocator, 0x100ui64, v73);
    v75 = &v135;
    v76 = v74;
    v77 = (float *)&v143;
    v78 = 4i64;
    v117 = v74 + 56;
    v79 = (float *)(v74 + 56);
    do
    {
      v80 = *v77;
      v75 += 2;
      v81 = (__m128)*((unsigned int *)v77 - 1);
      v77 += 3;
      v[2] = v80;
      v82 = v80;
      v83 = _mm_unpacklo_ps((__m128)*((unsigned int *)v77 - 5), v81).m128_u64[0];
      v84 = (__m128)(unsigned int)*(v75 - 1);
      *((_QWORD *)v79 - 7) = v83;
      *(_QWORD *)v79 = _mm_unpacklo_ps((__m128)(unsigned int)*(v75 - 2), v84).m128_u64[0];
      *(v79 - 12) = v82;
      *((_OWORD *)v79 - 1) = _xmm;
      v79 += 16;
      --v78;
    }
    while ( v78 );
    v8->m_vertexInfoCount = 4;
    m_pRender = this->m_pRender;
    v86 = *(__m128 *)m_pRender->m_View.m;
    v87 = *(__m128 *)&m_pRender->m_View.m[4];
    v88 = *(__m128 *)&m_pRender->m_View.m[8];
    v89 = *(__m128 *)&m_pRender->m_View.m[12];
    v90 = *(__m128 *)m_pRender->m_Proj.m;
    v91 = *(__m128 *)&m_pRender->m_Proj.m[4];
    v92 = *(__m128 *)&m_pRender->m_Proj.m[8];
    v93 = *(__m128 *)&m_pRender->m_Proj.m[12];
    *(_QWORD *)&v118 = __PAIR64__(v87.m128_u32[0], v86.m128_u32[0]);
    LODWORD(v119) = _mm_shuffle_ps(v86, v86, 85).m128_u32[0];
    LODWORD(v120) = _mm_shuffle_ps(v86, v86, 170).m128_u32[0];
    DWORD1(v119) = _mm_shuffle_ps(v87, v87, 85).m128_u32[0];
    DWORD1(v120) = _mm_shuffle_ps(v87, v87, 170).m128_u32[0];
    DWORD2(v119) = _mm_shuffle_ps(v88, v88, 85).m128_u32[0];
    DWORD2(v120) = _mm_shuffle_ps(v88, v88, 170).m128_u32[0];
    HIDWORD(v119) = _mm_shuffle_ps(v89, v89, 85).m128_u32[0];
    HIDWORD(v120) = _mm_shuffle_ps(v89, v89, 170).m128_u32[0];
    v128 = v119;
    *((_QWORD *)&v118 + 1) = __PAIR64__(v89.m128_u32[0], v88.m128_u32[0]);
    *(_OWORD *)value = v118;
    v129 = v120;
    LODWORD(v123) = _mm_shuffle_ps(v90, v90, 85).m128_u32[0];
    DWORD1(v123) = _mm_shuffle_ps(v91, v91, 85).m128_u32[0];
    LODWORD(v121) = _mm_shuffle_ps(v86, v86, 255).m128_u32[0];
    DWORD1(v121) = _mm_shuffle_ps(v87, v87, 255).m128_u32[0];
    DWORD2(v121) = _mm_shuffle_ps(v88, v88, 255).m128_u32[0];
    HIDWORD(v121) = _mm_shuffle_ps(v89, v89, 255).m128_u32[0];
    v130 = v121;
    LODWORD(v124) = _mm_shuffle_ps(v90, v90, 170).m128_u32[0];
    DWORD1(v124) = _mm_shuffle_ps(v91, v91, 170).m128_u32[0];
    *(_QWORD *)&v122 = __PAIR64__(v91.m128_u32[0], v90.m128_u32[0]);
    *((_QWORD *)&v122 + 1) = __PAIR64__(v93.m128_u32[0], v92.m128_u32[0]);
    DWORD2(v125) = _mm_shuffle_ps(v92, v92, 255).m128_u32[0];
    LODWORD(v125) = _mm_shuffle_ps(v90, v90, 255).m128_u32[0];
    DWORD1(v125) = _mm_shuffle_ps(v91, v91, 255).m128_u32[0];
    DWORD2(v123) = _mm_shuffle_ps(v92, v92, 85).m128_u32[0];
    DWORD2(v124) = _mm_shuffle_ps(v92, v92, 170).m128_u32[0];
    v94 = *v70->m_piGLUniform;
    HIDWORD(v123) = _mm_shuffle_ps(v93, v93, 85).m128_u32[0];
    HIDWORD(v124) = _mm_shuffle_ps(v93, v93, 170).m128_u32[0];
    *(_OWORD *)v131 = v122;
    v132 = v123;
    HIDWORD(v125) = _mm_shuffle_ps(v93, v93, 255).m128_u32[0];
    v133 = v124;
    v134 = v125;
    glUniformMatrix4fvAG(v94, 1, (unsigned __int8)v75, value);
    glUniformMatrix4fvAG(v70->m_piGLUniform[1], 1, v95, v131);
    m_piGLUniform = v70->m_piGLUniform;
    *(_OWORD *)v = _xmm;
    glUniform4fvAG(m_piGLUniform[5], 1, v);
    v97 = AgSingleton<KOFShaderManager>::ms_instance;
    v98 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                    * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                    + 7].onSingletonInit;
    if ( (unsigned int)v98 < g_maxEnabledVertexAttribArrays )
    {
      g_pendingVertexAttribArrays |= 1 << v98;
      g_vertexAttribIndex[v98] = 0;
    }
    v99 = Framework::GLManager::glm;
    v100 = *(_DWORD *)v97[11 * SLODWORD(v97[360450].__vftable) + 7].onSingletonInit;
    renderSize = Framework::GLManager::glm->renderSize;
    switch ( renderSize )
    {
      case 64:
        v102 = 64;
        break;
      case 280:
        v102 = 136;
        break;
      case 208:
        v102 = 64;
        break;
      default:
        v102 = 88;
        if ( renderSize == 144 )
          v102 = 144;
        break;
    }
    if ( v100 >= 0 )
    {
      _glewVertexAttribPointer(v100, 3, 0x1406u, 0, v102, v76);
      v99 = Framework::GLManager::glm;
      v97 = AgSingleton<KOFShaderManager>::ms_instance;
    }
    v103 = v70->m_piGLUniform;
    *(_OWORD *)v151 = _xmm;
    glUniform4fvAG(v103[5], 1, v151);
    v104 = *((unsigned int *)v97[11 * SLODWORD(v97[360450].__vftable) + 7].onSingletonInit + 4);
    if ( (unsigned int)v104 < g_maxEnabledVertexAttribArrays )
    {
      g_pendingVertexAttribArrays |= 1 << v104;
      g_vertexAttribIndex[v104] = 4;
    }
    v105 = v99->renderSize;
    v106 = (AppMain *)*((unsigned int *)v97[11 * SLODWORD(v97[360450].__vftable) + 7].onSingletonInit + 4);
    if ( v105 != 64 )
    {
      if ( v105 == 280 )
      {
        v72 = 8;
LABEL_209:
        if ( (int)v106 >= 0 )
          _glewVertexAttribPointer((unsigned int)v106, 2, 0x1406u, 0, v72, v76);
        AppMain::SetPostFXUniforms(
          v106,
          v70,
          &this->ModelRoomSettings.postfxUniforms,
          &this->ModelRoomSettings.filterUniforms);
        glDrawArraysAG(v108, v107, 4);
        Graphics::drawStack(this->g->g);
        v109 = (float)(int)v8->m_config.m_targetWidth;
        if ( v13 == (float)(v109 * 0.125) )
        {
          if ( (int)renderbuffers[0] > 0 )
            v8->m_eighthBuffer.m_freeIDs[v8->m_eighthBuffer.m_firstOccupiedIndex++] = renderbuffers[0];
        }
        else
        {
          v110 = v109 * 0.5;
          if ( v110 <= v13 )
          {
            if ( v13 == v110 )
            {
              if ( (int)renderbuffers[0] > 0 )
                v8->m_halfBuffer.m_freeIDs[v8->m_halfBuffer.m_firstOccupiedIndex++] = renderbuffers[0];
            }
            else
            {
              glDeleteRenderbuffersAG(1, renderbuffers);
            }
          }
          else if ( (int)renderbuffers[0] > 0 )
          {
            v8->m_thirdBuffer.m_freeIDs[v8->m_thirdBuffer.m_firstOccupiedIndex++] = renderbuffers[0];
          }
        }
        return;
      }
      if ( v105 != 208 )
      {
        if ( v105 == 144 )
        {
          v72 = 144;
          goto LABEL_209;
        }
        v72 = 88;
      }
    }
    v76 = v117;
    goto LABEL_209;
  }
  v111 = Framework::GLManager::glm;
  if ( (int)renderbuffers[0] > 0 )
  {
    m_buffers = Framework::GLManager::glm->m_config.m_buffers;
    if ( m_buffers )
    {
      systemRenderID = Framework::GLManager::glm->systemRenderID;
      do
      {
        if ( *systemRenderID == renderbuffers[0] )
          break;
        ++v21;
        ++systemRenderID;
      }
      while ( v21 < m_buffers );
    }
    if ( v21 == m_buffers )
    {
      Framework::GLManager::glm->m_buffer.m_freeIDs[Framework::GLManager::glm->m_buffer.m_firstOccupiedIndex] = renderbuffers[0];
      ++v111->m_buffer.m_firstOccupiedIndex;
    }
  }
}

void __fastcall AppMain::BlendFrameBuffers(AppMain *this, int a2)
{
  void (__fastcall *v2)(int, const char *); // r8
  void (__fastcall *v4)(unsigned int, unsigned int, int, const char *); // r10
  char v5; // di
  OGLRender *m_pRender; // rax
  OGLTexture *pSrcBlend2; // rbp
  OGLTexture *v8; // rsi
  int v9; // edx
  OGLRender *v10; // r8
  OGLTexture *m_MergedTexture; // rcx
  OGLTexture *v12; // r9
  int height; // [rsp+30h] [rbp-28h]
  int v14; // [rsp+38h] [rbp-20h]
  int v15; // [rsp+40h] [rbp-18h]

  v2 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Blend FrameBuffers");
    v2 = _glewPushGroupMarkerEXT;
  }
  v4 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 18, "Blend FrameBuffers");
    v2 = _glewPushGroupMarkerEXT;
    v4 = _glewPushDebugGroup;
  }
  ++markerCount;
  v5 = 0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  if ( this->ModelRoomSettings.postprocessSettings.motionBlurSettings[0].motionBlurOn
    && (m_pRender = this->m_pRender, m_pRender->m_renderTextures.m_MergedDepthTexture[0].m_TexID) )
  {
    pSrcBlend2 = m_pRender->m_renderTextures.m_MergedDepthTexture;
    v5 = 1;
  }
  else
  {
    m_pRender = this->m_pRender;
    pSrcBlend2 = &m_pRender->m_renderTextures.m_DepthMapTexture[3];
  }
  if ( this->ModelRoomSettings.postprocessSettings.motionBlurSettings[1].motionBlurOn
    && m_pRender->m_renderTextures.m_MergedDepthTexture[1].m_TexID )
  {
    v8 = &m_pRender->m_renderTextures.m_MergedDepthTexture[1];
    v5 = 1;
  }
  else
  {
    v8 = &m_pRender->m_renderTextures.m_DepthMapTexture[5];
  }
  if ( v2 )
  {
    v2(0, "Combine Depths1");
    v4 = _glewPushDebugGroup;
  }
  if ( v4 )
    v4(33354u, 1u, 15, "Combine Depths1");
  ++markerCount;
  if ( v5 )
    AppMain::BlendTwoTexturesExt(
      this,
      a2,
      &this->m_pRender->m_renderTextures.m_DepthMapTexture[1],
      v8,
      pSrcBlend2,
      this->m_iScreenW,
      this->m_iScreenH);
  else
    AppMain::CombineTwoDepthTexturesCS(this, v8, pSrcBlend2, &this->m_pRender->m_renderTextures.m_DepthMapTexture[1]);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
  if ( this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.transparencyOn[0]
    || this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.transparencyOn[1] )
  {
    v9 = 7961;
  }
  else
  {
    v9 = 7960;
    if ( v5 )
      v9 = 7962;
  }
  if ( this->ModelRoomSettings.postprocessSettings.motionBlurSettings[0].motionBlurOn
    && (v10 = this->m_pRender, v10->m_renderTextures.m_MergedTexture[0].m_TexID) )
  {
    m_MergedTexture = v10->m_renderTextures.m_MergedTexture;
  }
  else
  {
    v10 = this->m_pRender;
    m_MergedTexture = &v10->m_renderTextures.m_FullScreenTexture[3];
  }
  if ( !this->ModelRoomSettings.postprocessSettings.motionBlurSettings[1].motionBlurOn
    || (v12 = &v10->m_renderTextures.m_MergedTexture[1], !v10->m_renderTextures.m_MergedTexture[1].m_TexID) )
  {
    v12 = &v10->m_renderTextures.m_FullScreenTexture[5];
  }
  AppMain::BlendThreeTexturesUsingDepth(
    this,
    v9,
    v10->m_renderTextures.m_FullScreenTexture,
    v12,
    m_MergedTexture,
    &v10->m_renderTextures.m_FullScreenTexture[6],
    height,
    v14,
    v15);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::BlendMasks(AppMain *this)
{
  void (__fastcall *v1)(int, const char *); // rax
  void (__fastcall *v3)(unsigned int, unsigned int, int, const char *); // r10
  OGLRender *m_pRender; // r8
  void (*v5)(void); // rdx
  void (*v6)(void); // rcx
  int v7; // eax

  v1 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Blend Masks");
    v1 = _glewPushGroupMarkerEXT;
  }
  v3 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 11, "Blend Masks");
    v1 = _glewPushGroupMarkerEXT;
    v3 = _glewPushDebugGroup;
  }
  ++markerCount;
  if ( v1 )
  {
    v1(0, "Combine 3 Masks");
    v3 = _glewPushDebugGroup;
  }
  if ( v3 )
    v3(33354u, 1u, 15, "Combine 3 Masks");
  m_pRender = this->m_pRender;
  ++markerCount;
  AppMain::BlendThreeTexturesCS(
    this,
    (_DWORD)m_pRender + 781072,
    &m_pRender->m_renderTextures.m_CombinedMaskTexture[3],
    m_pRender->m_renderTextures.m_CombinedMaskTexture,
    &m_pRender->m_renderTextures.m_FullScreenMaskTexture[3],
    &m_pRender->m_renderTextures.m_FullScreenMaskTexture[5],
    &m_pRender->m_renderTextures.m_FullScreenMaskTexture[6]);
  v5 = _glewPopGroupMarkerEXT;
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v5 = _glewPopGroupMarkerEXT;
  }
  v6 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v5 = _glewPopGroupMarkerEXT;
    v6 = _glewPopDebugGroup;
  }
  v7 = --markerCount;
  if ( v5 )
  {
    v5();
    v7 = markerCount;
    v6 = _glewPopDebugGroup;
  }
  if ( v6 )
  {
    v6();
    --markerCount;
  }
  else
  {
    markerCount = v7 - 1;
  }
}

void __fastcall AppMain::BlendThreeTexturesCS(
        AppMain *this,
        int computeShaderID,
        OGLTexture *pDest1,
        OGLTexture *pDest2,
        OGLTexture *pSrcBlend1,
        OGLTexture *pSrcBlend2,
        OGLTexture *pSrcBlend3)
{
  Framework::GLManager *v8; // rsi
  int m_iScreenW; // ebp
  int height; // er14
  unsigned int m_TexID; // edx
  Framework::GLManager *v14; // rcx
  unsigned int v15; // edx
  Framework::GLManager *v16; // rcx
  unsigned int v17; // ecx
  unsigned int v18; // edx
  __int64 v19; // rax
  Framework::GLManager *v20; // rcx
  unsigned int v21; // edx
  __int64 v22; // rax
  Framework::GLManager *v23; // rcx
  unsigned int v24; // er8
  Framework::GLManager *v25; // rdx

  v8 = Framework::GLManager::glm;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Blend Three Textures");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 20, "Blend Three Textures");
  m_iScreenW = this->m_iScreenW;
  height = this->m_iScreenH;
  if ( !pDest1->m_TexID )
  {
    glGenTexturesAG(1, &pDest1->m_TexID);
    m_TexID = pDest1->m_TexID;
    if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
    {
      v14 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = m_TexID;
      v14->m_textureID = m_TexID;
      while ( v14->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  if ( !pDest2->m_TexID )
  {
    glGenTexturesAG(1, &pDest2->m_TexID);
    v15 = pDest2->m_TexID;
    if ( v15 != ::m_TexID[m_ActiveTexture] || !v15 )
    {
      v16 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v15;
      v16->m_textureID = v15;
      while ( v16->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v15);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  v17 = m_ActiveTexture;
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
    v17 = m_ActiveTexture;
  }
  v18 = pSrcBlend1->m_TexID;
  v19 = v17;
  if ( v18 != ::m_TexID[v17] || !v18 )
  {
    v20 = Framework::GLManager::glm;
    ::m_TexID[v19] = v18;
    v20->m_textureID = v18;
    while ( v20->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v18);
    v17 = m_ActiveTexture;
  }
  if ( v17 != 1 )
  {
    m_ActiveTexture = 1;
    _glewActiveTexture(0x84C1u);
    v17 = m_ActiveTexture;
  }
  v21 = pSrcBlend2->m_TexID;
  v22 = v17;
  if ( v21 != ::m_TexID[v17] || !v21 )
  {
    v23 = Framework::GLManager::glm;
    ::m_TexID[v22] = v21;
    v23->m_textureID = v21;
    while ( v23->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v21);
    v17 = m_ActiveTexture;
  }
  if ( v17 != 2 )
  {
    m_ActiveTexture = 2;
    _glewActiveTexture(0x84C2u);
    v17 = m_ActiveTexture;
  }
  v24 = pSrcBlend3->m_TexID;
  if ( v24 != ::m_TexID[v17] || !v24 )
  {
    v25 = Framework::GLManager::glm;
    ::m_TexID[v17] = v24;
    v25->m_textureID = v24;
    while ( v25->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v24);
  }
  _glewBindImageTexture(3u, pDest1->m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  _glewBindImageTexture(4u, pDest2->m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  KOFShaderManager::useProgramSlot(
    (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
    this->m_pRender->m_ComputeShaderTbl[8]->m_programSlot);
  while ( v8->m_bOpenGLBlocked )
    ;
  _glewDispatchCompute((m_iScreenW + 255) / 256, height, 1u);
  _glewMemoryBarrier(0x20u);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
}

void __fastcall AppMain::BlendThreeTexturesInOrder(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pBlend1Texture,
        OGLTexture *pBlend2Texture,
        OGLTexture *pBlend3Texture)
{
  __int64 v9; // r15
  bool v10; // zf
  float m_iScreenH; // xmm0_4
  int v12; // ecx
  float m_iScreenW; // xmm0_4
  unsigned int v14; // ecx
  unsigned int v15; // er8
  unsigned int m_TexID; // edx
  Framework::GLManager *v17; // rcx
  GraphicsOpt *v18; // rcx
  OGLShader *v19; // r12
  Framework::GLManager *v20; // rcx
  int v21; // ebx
  unsigned __int64 v22; // r8
  _QWORD *v23; // rax
  int *v24; // r8
  char *v25; // rdi
  float *v26; // rdx
  __int64 v27; // r9
  float *v28; // rcx
  float v29; // xmm0_4
  __m128 v30; // xmm1
  float v31; // eax
  unsigned __int64 v32; // xmm0_8
  __m128 v33; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v35; // xmm1
  __int128 v36; // xmm0
  __int128 v37; // xmm1
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  unsigned __int8 v42; // r8
  unsigned __int8 v43; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v45; // r15
  signed int v46; // er10
  int renderSize; // ecx
  int v48; // eax
  int *v49; // rax
  signed int v50; // ecx
  int v51; // eax
  unsigned int v52; // edx
  Framework::GLManager *v53; // rcx
  unsigned int v54; // edx
  Framework::GLManager *v55; // rcx
  unsigned int v56; // edx
  Framework::GLManager *v57; // rcx
  AppMain *v58; // rcx
  int v59; // edx
  unsigned int v60; // ecx
  int v61; // [rsp+20h] [rbp-E0h]
  unsigned int v62; // [rsp+38h] [rbp-C8h]
  Framework::GLManager *v63; // [rsp+40h] [rbp-C0h]
  float v[4]; // [rsp+58h] [rbp-A8h] BYREF
  OGLMatrix v65; // [rsp+70h] [rbp-90h] BYREF
  OGLMatrix v66; // [rsp+B0h] [rbp-50h] BYREF
  int v67; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v68; // [rsp+F4h] [rbp-Ch]
  int v69; // [rsp+FCh] [rbp-4h]
  int v70; // [rsp+100h] [rbp+0h]
  int v71; // [rsp+104h] [rbp+4h]
  int v72; // [rsp+108h] [rbp+8h]
  int v73; // [rsp+10Ch] [rbp+Ch]
  __int64 v74; // [rsp+118h] [rbp+18h]
  __int64 v75; // [rsp+120h] [rbp+20h] BYREF
  float v76; // [rsp+128h] [rbp+28h]
  int v77; // [rsp+12Ch] [rbp+2Ch]
  float v78; // [rsp+130h] [rbp+30h]
  __int64 v79; // [rsp+134h] [rbp+34h]
  float v80; // [rsp+13Ch] [rbp+3Ch]
  float v81; // [rsp+140h] [rbp+40h]
  int v82; // [rsp+144h] [rbp+44h]
  float v83[4]; // [rsp+150h] [rbp+50h] BYREF

  v63 = Framework::GLManager::glm;
  v9 = shader;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Blend 3 In Order");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 16, "Blend 3 In Order");
  ++markerCount;
  if ( pDestTexture && pBlend1Texture && pBlend2Texture && pBlend3Texture )
  {
    v10 = pDestTexture->m_FrameBufferID == 0;
    m_iScreenH = (float)this->m_iScreenH;
    v75 = 0i64;
    v74 = 0i64;
    v79 = 0i64;
    v12 = (int)m_iScreenH;
    v82 = 0;
    v77 = 0;
    v68 = 0i64;
    v67 = 0;
    v71 = 0;
    v72 = 1065353216;
    v70 = 1065353216;
    m_iScreenW = (float)this->m_iScreenW;
    v73 = 1065353216;
    v69 = 1065353216;
    v81 = (float)v12;
    v76 = (float)v12;
    v14 = (int)m_iScreenW;
    v80 = (float)(int)m_iScreenW;
    v78 = v80;
    if ( v10 )
      glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
    if ( !pDestTexture->m_TexID )
      glGenTexturesAG(1, &pDestTexture->m_TexID);
    glBindRenderbufferAG(v14, pDestTexture->m_FrameBufferID);
    if ( m_ActiveTexture )
    {
      m_ActiveTexture = 0;
      _glewActiveTexture(0x84C0u);
    }
    glsBindTexture(0xDE1u, pDestTexture->m_TexID);
    glsFramebufferTexture2D(
      AppMain::pApp,
      0x8CE0u,
      v15,
      pDestTexture->m_TexID,
      v61,
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
      v62);
    m_TexID = pDestTexture->m_TexID;
    if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
    {
      ::m_TexID[m_ActiveTexture] = m_TexID;
      v17 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = m_TexID;
      while ( v17->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    pDestTexture->m_TexParam = 1290;
    GraphicsOpt::clearDepth(v18);
    GraphicsOpt::lock(this->g);
    v19 = this->m_pRender->m_ShaderFXTbl[v9];
    if ( v19 )
    {
      if ( v19->m_Program )
      {
        KOFShaderManager::useProgramSlot(
          (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
          v19->m_programSlot);
        v20 = Framework::GLManager::glm;
        v21 = 64;
        Framework::GLManager::glm->renderSize = 64;
        v23 = AgFrameAllocator<AgAllocator<1>>::allocate(&v20->m_agDrawAllocator, 0x100ui64, v22);
        v24 = &v67;
        v25 = (char *)v23;
        v26 = (float *)&v75;
        v27 = 4i64;
        v28 = (float *)(v23 + 7);
        do
        {
          v29 = *v26;
          v24 += 2;
          v30 = (__m128)*((unsigned int *)v26 - 1);
          v26 += 3;
          v[2] = v29;
          v31 = v29;
          v32 = _mm_unpacklo_ps((__m128)*((unsigned int *)v26 - 5), v30).m128_u64[0];
          v33 = (__m128)(unsigned int)*(v24 - 1);
          *((_QWORD *)v28 - 7) = v32;
          *(_QWORD *)v28 = _mm_unpacklo_ps((__m128)(unsigned int)*(v24 - 2), v33).m128_u64[0];
          *(v28 - 12) = v31;
          *((_OWORD *)v28 - 1) = _xmm;
          v28 += 16;
          --v27;
        }
        while ( v27 );
        v63->m_vertexInfoCount = 4;
        m_pRender = this->m_pRender;
        v35 = *(_OWORD *)&m_pRender->m_View.m[4];
        *(_OWORD *)v65.m = *(_OWORD *)m_pRender->m_View.m;
        v36 = *(_OWORD *)&m_pRender->m_View.m[8];
        *(_OWORD *)&v65.m[4] = v35;
        v37 = *(_OWORD *)&m_pRender->m_View.m[12];
        *(_OWORD *)&v65.m[8] = v36;
        v38 = *(_OWORD *)m_pRender->m_Proj.m;
        *(_OWORD *)&v65.m[12] = v37;
        v39 = *(_OWORD *)&m_pRender->m_Proj.m[4];
        *(_OWORD *)v66.m = v38;
        v40 = *(_OWORD *)&m_pRender->m_Proj.m[8];
        *(_OWORD *)&v66.m[4] = v39;
        v41 = *(_OWORD *)&m_pRender->m_Proj.m[12];
        *(_OWORD *)&v66.m[8] = v40;
        *(_OWORD *)&v66.m[12] = v41;
        OGLMatrix::transpose(&v65);
        OGLMatrix::transpose(&v66);
        glUniformMatrix4fvAG(*v19->m_piGLUniform, 1, v42, v65.m);
        glUniformMatrix4fvAG(v19->m_piGLUniform[1], 1, v43, v66.m);
        m_piGLUniform = v19->m_piGLUniform;
        *(_OWORD *)v = _xmm;
        glUniform4fvAG(m_piGLUniform[5], 1, v);
        glEnableVertexAttribArrayAG(0);
        v45 = AgSingleton<KOFShaderManager>::ms_instance;
        v46 = *(_DWORD *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                  * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                  + 7].onSingletonInit;
        renderSize = Framework::GLManager::glm->renderSize;
        switch ( renderSize )
        {
          case 64:
            v48 = 64;
            break;
          case 280:
            v48 = 136;
            break;
          case 208:
            v48 = 64;
            break;
          default:
            v48 = 88;
            if ( renderSize == 144 )
              v48 = 144;
            break;
        }
        if ( v46 >= 0 )
        {
          _glewVertexAttribPointer(v46, 3, 0x1406u, 0, v48, v25);
          v45 = AgSingleton<KOFShaderManager>::ms_instance;
        }
        v49 = v19->m_piGLUniform;
        *(_OWORD *)v83 = _xmm;
        glUniform4fvAG(v49[5], 1, v83);
        glEnableVertexAttribArrayAG(4u);
        v50 = *((_DWORD *)v45[11 * SLODWORD(v45[360450].__vftable) + 7].onSingletonInit + 4);
        v51 = Framework::GLManager::glm->renderSize;
        if ( v51 != 64 )
        {
          if ( v51 == 280 )
          {
            v21 = 8;
LABEL_42:
            if ( v50 >= 0 )
              _glewVertexAttribPointer(v50, 2, 0x1406u, 0, v21, v25);
            if ( m_ActiveTexture != 1 )
            {
              m_ActiveTexture = 1;
              _glewActiveTexture(0x84C1u);
            }
            glsBindTexture(0xDE1u, pBlend1Texture->m_TexID);
            v52 = pBlend1Texture->m_TexID;
            if ( v52 != ::m_TexID[m_ActiveTexture] || !v52 )
            {
              v53 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v52;
              v53->m_textureID = v52;
              while ( v53->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v52);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v10 = m_ActiveTexture == 2;
            pBlend1Texture->m_TexParam = 1290;
            if ( !v10 )
            {
              m_ActiveTexture = 2;
              _glewActiveTexture(0x84C2u);
            }
            glsBindTexture(0xDE1u, pBlend2Texture->m_TexID);
            v54 = pBlend2Texture->m_TexID;
            if ( v54 != ::m_TexID[m_ActiveTexture] || !v54 )
            {
              v55 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v54;
              v55->m_textureID = v54;
              while ( v55->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v54);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v10 = m_ActiveTexture == 3;
            pBlend2Texture->m_TexParam = 1290;
            if ( !v10 )
            {
              m_ActiveTexture = 3;
              _glewActiveTexture(0x84C3u);
            }
            glsBindTexture(0xDE1u, pBlend3Texture->m_TexID);
            v56 = pBlend3Texture->m_TexID;
            if ( v56 != ::m_TexID[m_ActiveTexture] || !v56 )
            {
              v57 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v56;
              v57->m_textureID = v56;
              while ( v57->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v56);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            pBlend3Texture->m_TexParam = 1290;
            AppMain::SetPostFXUniforms(
              v58,
              v19,
              &this->ModelRoomSettings.postfxUniforms,
              &this->ModelRoomSettings.filterUniforms);
            glDrawArraysAG(v60, v59, 4);
            Graphics::drawStack(this->g->g);
            if ( _glewPopGroupMarkerEXT )
              _glewPopGroupMarkerEXT();
            if ( _glewPopDebugGroup )
              _glewPopDebugGroup();
            --markerCount;
            return;
          }
          if ( v51 != 208 )
          {
            if ( v51 == 144 )
            {
              v21 = 144;
              goto LABEL_42;
            }
            v21 = 88;
          }
        }
        v25 += 56;
        goto LABEL_42;
      }
    }
  }
}

void __fastcall AppMain::BlendThreeTexturesUsingDepth(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pBlend1Texture,
        OGLTexture *pBlend2Texture,
        OGLTexture *pBlend3Texture)
{
  Framework::GLManager *v9; // r12
  __int64 v10; // r15
  bool v11; // zf
  float m_iScreenH; // xmm0_4
  int v13; // ecx
  float m_iScreenW; // xmm0_4
  unsigned int v15; // ecx
  unsigned int v16; // er8
  unsigned int m_TexID; // edx
  Framework::GLManager *v18; // rcx
  GraphicsOpt *v19; // rcx
  OGLShader *v20; // r15
  Framework::GLManager *v21; // rcx
  int v22; // edi
  unsigned __int64 v23; // r8
  _QWORD *v24; // rax
  int *v25; // r8
  char *v26; // rsi
  float *v27; // rdx
  __int64 v28; // r9
  float *v29; // rcx
  float v30; // xmm0_4
  __m128 v31; // xmm1
  float v32; // eax
  unsigned __int64 v33; // xmm0_8
  __m128 v34; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v36; // xmm1
  __int128 v37; // xmm0
  __int128 v38; // xmm1
  __int128 v39; // xmm0
  __int128 v40; // xmm1
  __int128 v41; // xmm0
  __int128 v42; // xmm1
  unsigned __int8 v43; // r8
  unsigned __int8 v44; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v46; // r15
  Framework::GLManager *v47; // r12
  signed int v48; // er10
  int renderSize; // ecx
  int v50; // eax
  int v51; // eax
  signed int v52; // ecx
  unsigned int v53; // edx
  Framework::GLManager *v54; // rcx
  unsigned int v55; // edx
  Framework::GLManager *v56; // rcx
  unsigned int v57; // edx
  Framework::GLManager *v58; // rcx
  unsigned int v59; // edx
  unsigned int v60; // edx
  AppMain *v61; // rcx
  int v62; // edx
  unsigned int v63; // ecx
  int v64; // [rsp+20h] [rbp-E0h]
  unsigned int v65; // [rsp+38h] [rbp-C8h]
  OGLShader *pShader; // [rsp+40h] [rbp-C0h]
  float v[4]; // [rsp+58h] [rbp-A8h] BYREF
  OGLMatrix v68; // [rsp+70h] [rbp-90h] BYREF
  OGLMatrix v69; // [rsp+B0h] [rbp-50h] BYREF
  int v70; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v71; // [rsp+F4h] [rbp-Ch]
  int v72; // [rsp+FCh] [rbp-4h]
  int v73; // [rsp+100h] [rbp+0h]
  int v74; // [rsp+104h] [rbp+4h]
  int v75; // [rsp+108h] [rbp+8h]
  int v76; // [rsp+10Ch] [rbp+Ch]
  __int64 v77; // [rsp+118h] [rbp+18h]
  __int64 v78; // [rsp+120h] [rbp+20h] BYREF
  float v79; // [rsp+128h] [rbp+28h]
  int v80; // [rsp+12Ch] [rbp+2Ch]
  float v81; // [rsp+130h] [rbp+30h]
  __int64 v82; // [rsp+134h] [rbp+34h]
  float v83; // [rsp+13Ch] [rbp+3Ch]
  float v84; // [rsp+140h] [rbp+40h]
  int v85; // [rsp+144h] [rbp+44h]
  float v86[4]; // [rsp+150h] [rbp+50h] BYREF

  v9 = Framework::GLManager::glm;
  v10 = shader;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Blend 3 Depths");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 14, "Blend 3 Depths");
  ++markerCount;
  if ( pDestTexture && pBlend1Texture && pBlend2Texture && pBlend3Texture )
  {
    v11 = pDestTexture->m_FrameBufferID == 0;
    m_iScreenH = (float)this->m_iScreenH;
    v78 = 0i64;
    v77 = 0i64;
    v82 = 0i64;
    v85 = 0;
    v13 = (int)m_iScreenH;
    v80 = 0;
    v71 = 0i64;
    v70 = 0;
    v74 = 0;
    v75 = 1065353216;
    v73 = 1065353216;
    v76 = 1065353216;
    m_iScreenW = (float)this->m_iScreenW;
    v72 = 1065353216;
    v84 = (float)v13;
    v79 = (float)v13;
    v15 = (int)m_iScreenW;
    v83 = (float)(int)m_iScreenW;
    v81 = v83;
    if ( v11 )
      glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
    if ( !pDestTexture->m_TexID )
      glGenTexturesAG(1, &pDestTexture->m_TexID);
    glBindRenderbufferAG(v15, pDestTexture->m_FrameBufferID);
    if ( m_ActiveTexture )
    {
      m_ActiveTexture = 0;
      _glewActiveTexture(0x84C0u);
    }
    glsBindTexture(0xDE1u, pDestTexture->m_TexID);
    glsFramebufferTexture2D(
      AppMain::pApp,
      0x8CE0u,
      v16,
      pDestTexture->m_TexID,
      v64,
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
      v65);
    m_TexID = pDestTexture->m_TexID;
    if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
    {
      ::m_TexID[m_ActiveTexture] = m_TexID;
      v18 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = m_TexID;
      while ( v18->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    pDestTexture->m_TexParam = 1290;
    GraphicsOpt::clearDepth(v19);
    GraphicsOpt::lock(this->g);
    v20 = this->m_pRender->m_ShaderFXTbl[v10];
    pShader = v20;
    if ( v20 )
    {
      if ( v20->m_Program )
      {
        KOFShaderManager::useProgramSlot(
          (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
          v20->m_programSlot);
        v21 = Framework::GLManager::glm;
        v22 = 64;
        Framework::GLManager::glm->renderSize = 64;
        v24 = AgFrameAllocator<AgAllocator<1>>::allocate(&v21->m_agDrawAllocator, 0x100ui64, v23);
        v25 = &v70;
        v26 = (char *)v24;
        v27 = (float *)&v78;
        v28 = 4i64;
        v29 = (float *)(v24 + 7);
        do
        {
          v30 = *v27;
          v25 += 2;
          v31 = (__m128)*((unsigned int *)v27 - 1);
          v27 += 3;
          v[2] = v30;
          v32 = v30;
          v33 = _mm_unpacklo_ps((__m128)*((unsigned int *)v27 - 5), v31).m128_u64[0];
          v34 = (__m128)(unsigned int)*(v25 - 1);
          *((_QWORD *)v29 - 7) = v33;
          *(_QWORD *)v29 = _mm_unpacklo_ps((__m128)(unsigned int)*(v25 - 2), v34).m128_u64[0];
          *(v29 - 12) = v32;
          *((_OWORD *)v29 - 1) = _xmm;
          v29 += 16;
          --v28;
        }
        while ( v28 );
        v9->m_vertexInfoCount = 4;
        m_pRender = this->m_pRender;
        v36 = *(_OWORD *)&m_pRender->m_View.m[4];
        *(_OWORD *)v68.m = *(_OWORD *)m_pRender->m_View.m;
        v37 = *(_OWORD *)&m_pRender->m_View.m[8];
        *(_OWORD *)&v68.m[4] = v36;
        v38 = *(_OWORD *)&m_pRender->m_View.m[12];
        *(_OWORD *)&v68.m[8] = v37;
        v39 = *(_OWORD *)m_pRender->m_Proj.m;
        *(_OWORD *)&v68.m[12] = v38;
        v40 = *(_OWORD *)&m_pRender->m_Proj.m[4];
        *(_OWORD *)v69.m = v39;
        v41 = *(_OWORD *)&m_pRender->m_Proj.m[8];
        *(_OWORD *)&v69.m[4] = v40;
        v42 = *(_OWORD *)&m_pRender->m_Proj.m[12];
        *(_OWORD *)&v69.m[8] = v41;
        *(_OWORD *)&v69.m[12] = v42;
        OGLMatrix::transpose(&v68);
        OGLMatrix::transpose(&v69);
        glUniformMatrix4fvAG(*v20->m_piGLUniform, 1, v43, v68.m);
        glUniformMatrix4fvAG(v20->m_piGLUniform[1], 1, v44, v69.m);
        m_piGLUniform = v20->m_piGLUniform;
        *(_OWORD *)v = _xmm;
        glUniform4fvAG(m_piGLUniform[5], 1, v);
        glEnableVertexAttribArrayAG(0);
        v46 = AgSingleton<KOFShaderManager>::ms_instance;
        v47 = Framework::GLManager::glm;
        v48 = *(_DWORD *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                  * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                  + 7].onSingletonInit;
        renderSize = Framework::GLManager::glm->renderSize;
        switch ( renderSize )
        {
          case 64:
            v50 = 64;
            break;
          case 280:
            v50 = 136;
            break;
          case 208:
            v50 = 64;
            break;
          default:
            v50 = 88;
            if ( renderSize == 144 )
              v50 = 144;
            break;
        }
        if ( v48 >= 0 )
        {
          _glewVertexAttribPointer(v48, 3, 0x1406u, 0, v50, v26);
          v47 = Framework::GLManager::glm;
          v46 = AgSingleton<KOFShaderManager>::ms_instance;
        }
        *(_OWORD *)v86 = _xmm;
        glUniform4fvAG(pShader->m_piGLUniform[5], 1, v86);
        glEnableVertexAttribArrayAG(4u);
        v51 = v47->renderSize;
        v52 = *((_DWORD *)v46[11 * SLODWORD(v46[360450].__vftable) + 7].onSingletonInit + 4);
        if ( v51 != 64 )
        {
          if ( v51 == 280 )
          {
            v22 = 8;
LABEL_42:
            if ( v52 >= 0 )
              _glewVertexAttribPointer(v52, 2, 0x1406u, 0, v22, v26);
            if ( m_ActiveTexture != 1 )
            {
              m_ActiveTexture = 1;
              _glewActiveTexture(0x84C1u);
            }
            glsBindTexture(0xDE1u, pBlend1Texture->m_TexID);
            v53 = pBlend1Texture->m_TexID;
            if ( v53 != ::m_TexID[m_ActiveTexture] || !v53 )
            {
              v54 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v53;
              v54->m_textureID = v53;
              while ( v54->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v53);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v11 = m_ActiveTexture == 2;
            pBlend1Texture->m_TexParam = 1290;
            if ( !v11 )
            {
              m_ActiveTexture = 2;
              _glewActiveTexture(0x84C2u);
            }
            glsBindTexture(0xDE1u, pBlend2Texture->m_TexID);
            v55 = pBlend2Texture->m_TexID;
            if ( v55 != ::m_TexID[m_ActiveTexture] || !v55 )
            {
              v56 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v55;
              v56->m_textureID = v55;
              while ( v56->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v55);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v11 = m_ActiveTexture == 3;
            pBlend2Texture->m_TexParam = 1290;
            if ( !v11 )
            {
              m_ActiveTexture = 3;
              _glewActiveTexture(0x84C3u);
            }
            glsBindTexture(0xDE1u, pBlend3Texture->m_TexID);
            v57 = pBlend3Texture->m_TexID;
            if ( v57 != ::m_TexID[m_ActiveTexture] || !v57 )
            {
              v58 = Framework::GLManager::glm;
              ::m_TexID[m_ActiveTexture] = v57;
              v58->m_textureID = v57;
              while ( v58->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v57);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v11 = m_ActiveTexture == 4;
            pBlend3Texture->m_TexParam = 1290;
            if ( !v11 )
            {
              m_ActiveTexture = 4;
              _glewActiveTexture(0x84C4u);
            }
            if ( !this->ModelRoomSettings.postprocessSettings.motionBlurSettings[1].motionBlurOn
              || (v59 = this->m_pRender->m_renderTextures.m_MergedDepthTexture[1].m_TexID) == 0 )
            {
              v59 = this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_TexID;
            }
            glsBindTexture(0xDE1u, v59);
            if ( m_ActiveTexture != 5 )
            {
              m_ActiveTexture = 5;
              _glewActiveTexture(0x84C5u);
            }
            if ( !this->ModelRoomSettings.postprocessSettings.motionBlurSettings[0].motionBlurOn
              || (v60 = this->m_pRender->m_renderTextures.m_MergedDepthTexture[0].m_TexID) == 0 )
            {
              v60 = this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_TexID;
            }
            glsBindTexture(0xDE1u, v60);
            if ( m_ActiveTexture != 6 )
            {
              m_ActiveTexture = 6;
              _glewActiveTexture(0x84C6u);
            }
            glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID);
            if ( m_ActiveTexture != 7 )
            {
              m_ActiveTexture = 7;
              _glewActiveTexture(0x84C7u);
            }
            glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_TexID);
            if ( m_ActiveTexture != 8 )
            {
              m_ActiveTexture = 8;
              _glewActiveTexture(0x84C8u);
            }
            glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_TexID);
            AppMain::SetPostFXUniforms(
              v61,
              pShader,
              &this->ModelRoomSettings.postfxUniforms,
              &this->ModelRoomSettings.filterUniforms);
            glDrawArraysAG(v63, v62, 4);
            Graphics::drawStack(this->g->g);
            if ( _glewPopGroupMarkerEXT )
              _glewPopGroupMarkerEXT();
            if ( _glewPopDebugGroup )
              _glewPopDebugGroup();
            --markerCount;
            return;
          }
          if ( v51 != 208 )
          {
            if ( v51 == 144 )
            {
              v22 = 144;
              goto LABEL_42;
            }
            v22 = 88;
          }
        }
        v26 += 56;
        goto LABEL_42;
      }
    }
  }
}

void __fastcall AppMain::BlendTwoTextures(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pBlend1Texture,
        OGLTexture *pBlend2Texture)
{
  bool v8; // zf
  float m_iScreenH; // xmm0_4
  int v10; // ecx
  float m_iScreenW; // xmm0_4
  unsigned int v12; // ecx
  unsigned int v13; // er8
  unsigned int v14; // eax
  unsigned int m_TexID; // edx
  Framework::GLManager *v16; // rcx
  unsigned int v17; // edx
  Framework::GLManager *v18; // rcx
  OGLShader *v19; // r13
  Framework::GLManager *v20; // rcx
  int v21; // ebx
  unsigned __int64 v22; // r8
  _QWORD *v23; // rax
  int *v24; // r8
  char *v25; // rsi
  __int64 *v26; // rdx
  __int64 v27; // r9
  _QWORD *v28; // rcx
  int v29; // xmm0_4
  __m128 v30; // xmm1
  int v31; // eax
  unsigned __int64 v32; // xmm0_8
  __m128 v33; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v35; // xmm1
  __int128 v36; // xmm0
  __int128 v37; // xmm1
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  unsigned __int8 v42; // r8
  unsigned __int8 v43; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v45; // rdi
  __int64 v46; // rcx
  signed int v47; // er10
  int renderSize; // ecx
  int v49; // eax
  int *v50; // rax
  __int64 v51; // rcx
  int v52; // eax
  signed int v53; // ecx
  unsigned int v54; // eax
  unsigned int v55; // edx
  Framework::GLManager *v56; // rcx
  unsigned int v57; // edx
  Framework::GLManager *v58; // rcx
  unsigned int v59; // eax
  unsigned int v60; // edx
  Framework::GLManager *v61; // rcx
  unsigned int v62; // edx
  Framework::GLManager *v63; // rcx
  AppMain *v64; // rcx
  int v65; // edx
  unsigned int v66; // ecx
  int v67; // [rsp+28h] [rbp-E0h]
  unsigned int v68; // [rsp+40h] [rbp-C8h]
  Framework::GLManager *v69; // [rsp+48h] [rbp-C0h]
  __int128 v_8; // [rsp+58h] [rbp-B0h] BYREF
  OGLMatrix v71; // [rsp+68h] [rbp-A0h] BYREF
  OGLMatrix v72; // [rsp+A8h] [rbp-60h] BYREF
  int v73; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v74; // [rsp+ECh] [rbp-1Ch]
  int v75; // [rsp+F4h] [rbp-14h]
  int v76; // [rsp+F8h] [rbp-10h]
  int v77; // [rsp+FCh] [rbp-Ch]
  int v78; // [rsp+100h] [rbp-8h]
  int v79; // [rsp+104h] [rbp-4h]
  __int64 v80; // [rsp+110h] [rbp+8h]
  __int64 v81; // [rsp+118h] [rbp+10h] BYREF
  float v82; // [rsp+120h] [rbp+18h]
  int v83; // [rsp+124h] [rbp+1Ch]
  float v84; // [rsp+128h] [rbp+20h]
  __int64 v85; // [rsp+12Ch] [rbp+24h]
  float v86; // [rsp+134h] [rbp+2Ch]
  float v87; // [rsp+138h] [rbp+30h]
  int v88; // [rsp+13Ch] [rbp+34h]
  float v89[4]; // [rsp+148h] [rbp+40h] BYREF

  if ( pDestTexture )
  {
    v69 = Framework::GLManager::glm;
    if ( pBlend1Texture )
    {
      if ( pBlend2Texture )
      {
        v8 = pDestTexture->m_FrameBufferID == 0;
        m_iScreenH = (float)this->m_iScreenH;
        v81 = 0i64;
        v10 = (int)m_iScreenH;
        v80 = 0i64;
        v85 = 0i64;
        v88 = 0;
        v83 = 0;
        v74 = 0i64;
        v73 = 0;
        v77 = 0;
        m_iScreenW = (float)this->m_iScreenW;
        v78 = 1065353216;
        v76 = 1065353216;
        v79 = 1065353216;
        v75 = 1065353216;
        v87 = (float)v10;
        v82 = (float)v10;
        v12 = (int)m_iScreenW;
        v86 = (float)(int)m_iScreenW;
        v84 = v86;
        if ( v8 )
          glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
        if ( !pDestTexture->m_TexID )
          glGenTexturesAG(1, &pDestTexture->m_TexID);
        glBindRenderbufferAG(v12, pDestTexture->m_FrameBufferID);
        v14 = m_ActiveTexture;
        if ( m_ActiveTexture )
        {
          m_ActiveTexture = 0;
          _glewActiveTexture(0x84C0u);
          v14 = m_ActiveTexture;
        }
        m_TexID = pDestTexture->m_TexID;
        if ( m_TexID != ::m_TexID[v14] || !m_TexID )
        {
          ::m_TexID[v14] = m_TexID;
          v16 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = m_TexID;
          while ( v16->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, m_TexID);
        }
        glsFramebufferTexture2D(
          AppMain::pApp,
          0x8CE0u,
          v13,
          pDestTexture->m_TexID,
          v67,
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
          v68);
        v17 = pDestTexture->m_TexID;
        if ( v17 != ::m_TexID[m_ActiveTexture] || !v17 )
        {
          v18 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v17;
          v18->m_textureID = v17;
          while ( v18->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v17);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v8 = m_DepthMask == 1;
        pDestTexture->m_TexParam = 1290;
        if ( !v8 )
        {
          m_DepthMask = 1;
          glDepthMask(1u);
        }
        glClearAG(0x100u);
        GraphicsOpt::lock(this->g);
        v19 = this->m_pRender->m_ShaderFXTbl[7966];
        if ( v19 )
        {
          if ( v19->m_Program )
          {
            KOFShaderManager::useProgramSlot(
              (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
              v19->m_programSlot);
            v20 = Framework::GLManager::glm;
            v21 = 64;
            Framework::GLManager::glm->renderSize = 64;
            v23 = AgFrameAllocator<AgAllocator<1>>::allocate(&v20->m_agDrawAllocator, 0x100ui64, v22);
            v24 = &v73;
            v25 = (char *)v23;
            v26 = &v81;
            v27 = 4i64;
            v28 = v23 + 7;
            do
            {
              v29 = *(_DWORD *)v26;
              v24 += 2;
              v30 = (__m128)*((unsigned int *)v26 - 1);
              v26 = (__int64 *)((char *)v26 + 12);
              DWORD2(v_8) = v29;
              v31 = v29;
              v32 = _mm_unpacklo_ps((__m128)*((unsigned int *)v26 - 5), v30).m128_u64[0];
              v33 = (__m128)(unsigned int)*(v24 - 1);
              *(v28 - 7) = v32;
              *v28 = _mm_unpacklo_ps((__m128)(unsigned int)*(v24 - 2), v33).m128_u64[0];
              *((_DWORD *)v28 - 12) = v31;
              *((_OWORD *)v28 - 1) = _xmm;
              v28 += 8;
              --v27;
            }
            while ( v27 );
            v69->m_vertexInfoCount = 4;
            m_pRender = this->m_pRender;
            v35 = *(_OWORD *)&m_pRender->m_View.m[4];
            *(_OWORD *)v71.m = *(_OWORD *)m_pRender->m_View.m;
            v36 = *(_OWORD *)&m_pRender->m_View.m[8];
            *(_OWORD *)&v71.m[4] = v35;
            v37 = *(_OWORD *)&m_pRender->m_View.m[12];
            *(_OWORD *)&v71.m[8] = v36;
            v38 = *(_OWORD *)m_pRender->m_Proj.m;
            *(_OWORD *)&v71.m[12] = v37;
            v39 = *(_OWORD *)&m_pRender->m_Proj.m[4];
            *(_OWORD *)v72.m = v38;
            v40 = *(_OWORD *)&m_pRender->m_Proj.m[8];
            *(_OWORD *)&v72.m[4] = v39;
            v41 = *(_OWORD *)&m_pRender->m_Proj.m[12];
            *(_OWORD *)&v72.m[8] = v40;
            *(_OWORD *)&v72.m[12] = v41;
            OGLMatrix::transpose(&v71);
            OGLMatrix::transpose(&v72);
            glUniformMatrix4fvAG(*v19->m_piGLUniform, 1, v42, v71.m);
            glUniformMatrix4fvAG(v19->m_piGLUniform[1], 1, v43, v72.m);
            m_piGLUniform = v19->m_piGLUniform;
            v_8 = _xmm;
            glUniform4fvAG(m_piGLUniform[5], 1, (const float *)&v_8);
            v45 = AgSingleton<KOFShaderManager>::ms_instance;
            v46 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                            * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                            + 7].onSingletonInit;
            if ( (unsigned int)v46 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v46;
              g_vertexAttribIndex[v46] = 0;
            }
            v47 = *(_DWORD *)v45[11 * SLODWORD(v45[360450].__vftable) + 7].onSingletonInit;
            renderSize = Framework::GLManager::glm->renderSize;
            switch ( renderSize )
            {
              case 64:
                v49 = 64;
                break;
              case 280:
                v49 = 136;
                break;
              case 208:
                v49 = 64;
                break;
              default:
                v49 = 88;
                if ( renderSize == 144 )
                  v49 = 144;
                break;
            }
            if ( v47 >= 0 )
            {
              _glewVertexAttribPointer(v47, 3, 0x1406u, 0, v49, v25);
              v45 = AgSingleton<KOFShaderManager>::ms_instance;
            }
            v50 = v19->m_piGLUniform;
            *(_OWORD *)v89 = _xmm;
            glUniform4fvAG(v50[5], 1, v89);
            v51 = *((unsigned int *)v45[11 * SLODWORD(v45[360450].__vftable) + 7].onSingletonInit + 4);
            if ( (unsigned int)v51 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v51;
              g_vertexAttribIndex[v51] = 4;
            }
            v52 = Framework::GLManager::glm->renderSize;
            v53 = *((_DWORD *)v45[11 * SLODWORD(v45[360450].__vftable) + 7].onSingletonInit + 4);
            if ( v52 != 64 )
            {
              if ( v52 == 280 )
              {
                v21 = 8;
LABEL_48:
                if ( v53 >= 0 )
                  _glewVertexAttribPointer(v53, 2, 0x1406u, 0, v21, v25);
                v54 = m_ActiveTexture;
                if ( m_ActiveTexture != 1 )
                {
                  m_ActiveTexture = 1;
                  _glewActiveTexture(0x84C1u);
                  v54 = m_ActiveTexture;
                }
                v55 = pBlend1Texture->m_TexID;
                if ( v55 != ::m_TexID[v54] || !v55 )
                {
                  ::m_TexID[v54] = v55;
                  v56 = Framework::GLManager::glm;
                  Framework::GLManager::glm->m_textureID = v55;
                  while ( v56->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v55);
                  v54 = m_ActiveTexture;
                }
                v57 = pBlend1Texture->m_TexID;
                if ( v57 != ::m_TexID[v54] || !v57 )
                {
                  ::m_TexID[v54] = v57;
                  v58 = Framework::GLManager::glm;
                  Framework::GLManager::glm->m_textureID = v57;
                  while ( v58->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v57);
                }
                glTexParameterf(0xDE1u, 0x2801u, 9729.0);
                glTexParameterf(0xDE1u, 0x2800u, 9729.0);
                glTexParameterf(0xDE1u, 0x2802u, 33071.0);
                glTexParameterf(0xDE1u, 0x2803u, 33071.0);
                v59 = m_ActiveTexture;
                pBlend1Texture->m_TexParam = 1290;
                if ( v59 != 2 )
                {
                  m_ActiveTexture = 2;
                  _glewActiveTexture(0x84C2u);
                  v59 = m_ActiveTexture;
                }
                v60 = pBlend2Texture->m_TexID;
                if ( v60 != ::m_TexID[v59] || !v60 )
                {
                  ::m_TexID[v59] = v60;
                  v61 = Framework::GLManager::glm;
                  Framework::GLManager::glm->m_textureID = v60;
                  while ( v61->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v60);
                  v59 = m_ActiveTexture;
                }
                v62 = pBlend2Texture->m_TexID;
                if ( v62 != ::m_TexID[v59] || !v62 )
                {
                  ::m_TexID[v59] = v62;
                  v63 = Framework::GLManager::glm;
                  Framework::GLManager::glm->m_textureID = v62;
                  while ( v63->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v62);
                }
                glTexParameterf(0xDE1u, 0x2801u, 9729.0);
                glTexParameterf(0xDE1u, 0x2800u, 9729.0);
                glTexParameterf(0xDE1u, 0x2802u, 33071.0);
                glTexParameterf(0xDE1u, 0x2803u, 33071.0);
                pBlend2Texture->m_TexParam = 1290;
                AppMain::SetPostFXUniforms(
                  v64,
                  v19,
                  &this->ModelRoomSettings.postfxUniforms,
                  &this->ModelRoomSettings.filterUniforms);
                glDrawArraysAG(v66, v65, 4);
                Graphics::drawStack(this->g->g);
                return;
              }
              if ( v52 != 208 )
              {
                if ( v52 == 144 )
                {
                  v21 = 144;
                  goto LABEL_48;
                }
                v21 = 88;
              }
            }
            v25 += 56;
            goto LABEL_48;
          }
        }
      }
    }
  }
}

void __fastcall AppMain::BlendTwoTexturesCS(
        AppMain *this,
        int computeShaderID,
        OGLTexture *pDest1,
        OGLTexture *pDest2,
        OGLTexture *pSrcBlend1,
        OGLTexture *pSrcBlend2)
{
  int m_iScreenW; // edi
  unsigned int *p_m_TexID; // r14
  int height; // esi
  GLuint v11; // edx
  Framework::GLManager *v12; // rcx
  unsigned int m_TexID; // edx
  Framework::GLManager *v14; // rcx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  __int64 v17; // rax
  Framework::GLManager *v18; // rcx
  unsigned int v19; // er8
  Framework::GLManager *v20; // rdx

  m_iScreenW = this->m_iScreenW;
  p_m_TexID = &pDest1->m_TexID;
  height = this->m_iScreenH;
  if ( !pDest1->m_TexID )
  {
    glGenTexturesAG(1, &pDest1->m_TexID);
    v11 = *p_m_TexID;
    if ( *p_m_TexID != ::m_TexID[m_ActiveTexture] || !v11 )
    {
      v12 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v11;
      v12->m_textureID = v11;
      while ( v12->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v11);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  if ( !pDest2->m_TexID )
  {
    glGenTexturesAG(1, &pDest2->m_TexID);
    m_TexID = pDest2->m_TexID;
    if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
    {
      v14 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = m_TexID;
      v14->m_textureID = m_TexID;
      while ( v14->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  v15 = m_ActiveTexture;
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
    v15 = m_ActiveTexture;
  }
  v16 = pSrcBlend1->m_TexID;
  v17 = v15;
  if ( v16 != ::m_TexID[v15] || !v16 )
  {
    v18 = Framework::GLManager::glm;
    ::m_TexID[v17] = v16;
    v18->m_textureID = v16;
    while ( v18->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v16);
    v15 = m_ActiveTexture;
  }
  if ( v15 != 1 )
  {
    m_ActiveTexture = 1;
    _glewActiveTexture(0x84C1u);
    v15 = m_ActiveTexture;
  }
  v19 = pSrcBlend2->m_TexID;
  if ( v19 != ::m_TexID[v15] || !v19 )
  {
    v20 = Framework::GLManager::glm;
    ::m_TexID[v15] = v19;
    v20->m_textureID = v19;
    while ( v20->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v19);
  }
  _glewBindImageTexture(2u, *p_m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  _glewBindImageTexture(3u, pDest2->m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  KOFShaderManager::useProgramSlot(
    (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
    this->m_pRender->m_ComputeShaderTbl[9]->m_programSlot);
  while ( Framework::GLManager::glm->m_bOpenGLBlocked )
    ;
  _glewDispatchCompute((m_iScreenW + 255) / 256, height, 1u);
  _glewMemoryBarrier(0x20u);
}

void __fastcall AppMain::BlendTwoTexturesExt(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pSrcBlend1,
        OGLTexture *pSrcBlend2,
        int width,
        int height)
{
  unsigned int *p_m_FrameBufferID; // rdx
  bool v11; // zf
  unsigned int *p_m_TexID; // rdx
  unsigned int v13; // ecx
  unsigned int m_TexID; // edx
  __int64 v15; // rax
  unsigned __int64 v16; // rcx
  Framework::GLManager *v17; // rcx
  unsigned int v18; // er8
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // ecx
  Framework::GLManager *v22; // rcx
  unsigned int v23; // edx
  Framework::GLManager *v24; // rcx
  unsigned int v25; // eax
  unsigned int v26; // edx
  Framework::GLManager *v27; // rcx
  unsigned int v28; // edx
  Framework::GLManager *v29; // rcx
  unsigned int v30; // eax
  unsigned int v31; // edx
  Framework::GLManager *v32; // rcx
  unsigned int v33; // edx
  Framework::GLManager *v34; // rcx
  OGLShader *v35; // r15
  Framework::GLManager *v36; // rcx
  int v37; // ebx
  unsigned __int64 v38; // r8
  _QWORD *v39; // rax
  int *v40; // r8
  char *v41; // r14
  __int64 *v42; // rdx
  __int64 v43; // r9
  _QWORD *v44; // rcx
  int v45; // xmm0_4
  __m128 v46; // xmm1
  int v47; // eax
  unsigned __int64 v48; // xmm0_8
  __m128 v49; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v51; // xmm1
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  __int128 v54; // xmm0
  __int128 v55; // xmm1
  __int128 v56; // xmm0
  __int128 v57; // xmm1
  unsigned __int8 v58; // r8
  unsigned __int8 v59; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v61; // rsi
  __int64 v62; // rcx
  Framework::GLManager *v63; // r13
  signed int v64; // er10
  int renderSize; // ecx
  int v66; // eax
  int *v67; // rax
  __int64 v68; // rcx
  int v69; // eax
  AppMain *v70; // rcx
  int v71; // edx
  unsigned int v72; // ecx
  int v73; // [rsp+28h] [rbp-E0h]
  unsigned int v74; // [rsp+40h] [rbp-C8h]
  _QWORD v[3]; // [rsp+48h] [rbp-C0h] BYREF
  _QWORD v76[9]; // [rsp+60h] [rbp-A8h] BYREF
  OGLMatrix v77; // [rsp+A8h] [rbp-60h] BYREF
  int v78; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v79; // [rsp+ECh] [rbp-1Ch]
  int v80; // [rsp+F4h] [rbp-14h]
  int v81; // [rsp+F8h] [rbp-10h]
  int v82; // [rsp+FCh] [rbp-Ch]
  int v83; // [rsp+100h] [rbp-8h]
  int v84; // [rsp+104h] [rbp-4h]
  __int64 v85; // [rsp+110h] [rbp+8h]
  __int64 v86; // [rsp+118h] [rbp+10h] BYREF
  float v87; // [rsp+120h] [rbp+18h]
  int v88; // [rsp+124h] [rbp+1Ch]
  float v89; // [rsp+128h] [rbp+20h]
  __int64 v90; // [rsp+12Ch] [rbp+24h]
  float v91; // [rsp+134h] [rbp+2Ch]
  float v92; // [rsp+138h] [rbp+30h]
  int v93; // [rsp+13Ch] [rbp+34h]
  float v94[4]; // [rsp+148h] [rbp+40h] BYREF

  if ( pSrcBlend1 )
  {
    v[0] = Framework::GLManager::glm;
    if ( pSrcBlend2 )
    {
      if ( pDestTexture )
      {
        p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
        v11 = *p_m_FrameBufferID == 0;
        v86 = 0i64;
        v85 = 0i64;
        v90 = 0i64;
        v93 = 0;
        v88 = 0;
        v79 = 0i64;
        v78 = 0;
        v82 = 0;
        v91 = (float)width;
        v89 = (float)width;
        v92 = (float)height;
        v87 = (float)height;
        v83 = 1065353216;
        v81 = 1065353216;
        v84 = 1065353216;
        v80 = 1065353216;
        if ( v11 )
          glGenRenderbuffersAG(1, p_m_FrameBufferID);
        p_m_TexID = &this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
        if ( !*p_m_TexID )
          glGenTexturesAG(1, p_m_TexID);
        if ( !pDestTexture->m_TexID )
          glGenTexturesAG(1, &pDestTexture->m_TexID);
        v13 = m_ActiveTexture;
        if ( m_ActiveTexture )
        {
          m_ActiveTexture = 0;
          _glewActiveTexture(0x84C0u);
          v13 = m_ActiveTexture;
        }
        m_TexID = this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
        v15 = v13;
        v16 = 0x140000000ui64;
        if ( m_TexID != ::m_TexID[v15] || !m_TexID )
        {
          ::m_TexID[v15] = m_TexID;
          v17 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = m_TexID;
          while ( v17->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, m_TexID);
        }
        glBindRenderbufferAG(v16, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
        v19 = m_ActiveTexture;
        if ( m_ActiveTexture != 1 )
        {
          m_ActiveTexture = 1;
          _glewActiveTexture(0x84C1u);
          v19 = m_ActiveTexture;
        }
        v20 = pDestTexture->m_TexID;
        v21 = v19;
        if ( v20 != ::m_TexID[v19] || !v20 )
        {
          ::m_TexID[v19] = v20;
          v22 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v20;
          while ( v22->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v20);
        }
        glsFramebufferTexture2D(v21, 0x8CE1u, v18, pDestTexture->m_TexID, v73, width, height, v74);
        v23 = pDestTexture->m_TexID;
        if ( v23 != ::m_TexID[m_ActiveTexture] || !v23 )
        {
          v24 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v23;
          v24->m_textureID = v23;
          while ( v24->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v23);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v25 = m_ActiveTexture;
        pDestTexture->m_TexParam = 1290;
        if ( v25 != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
          v25 = m_ActiveTexture;
        }
        v26 = pSrcBlend1->m_TexID;
        if ( v26 != ::m_TexID[v25] || !v26 )
        {
          ::m_TexID[v25] = v26;
          v27 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v26;
          while ( v27->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v26);
          v25 = m_ActiveTexture;
        }
        v28 = pSrcBlend1->m_TexID;
        if ( v28 != ::m_TexID[v25] || !v28 )
        {
          ::m_TexID[v25] = v28;
          v29 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v28;
          while ( v29->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v28);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v30 = m_ActiveTexture;
        pSrcBlend1->m_TexParam = 1290;
        if ( v30 != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
          v30 = m_ActiveTexture;
        }
        v31 = pSrcBlend2->m_TexID;
        if ( v31 != ::m_TexID[v30] || !v31 )
        {
          ::m_TexID[v30] = v31;
          v32 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v31;
          while ( v32->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v31);
          v30 = m_ActiveTexture;
        }
        v33 = pSrcBlend2->m_TexID;
        if ( v33 != ::m_TexID[v30] || !v33 )
        {
          ::m_TexID[v30] = v33;
          v34 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v33;
          while ( v34->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v33);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v11 = m_DepthMask == 1;
        pSrcBlend2->m_TexParam = 1290;
        if ( !v11 )
        {
          m_DepthMask = 1;
          glDepthMask(1u);
        }
        glClearAG(0x100u);
        GraphicsOpt::lock(this->g);
        v35 = this->m_pRender->m_ShaderFXTbl[7975];
        if ( v35 )
        {
          if ( v35->m_Program )
          {
            KOFShaderManager::useProgramSlot(
              (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
              v35->m_programSlot);
            v36 = Framework::GLManager::glm;
            v37 = 64;
            Framework::GLManager::glm->renderSize = 64;
            v39 = AgFrameAllocator<AgAllocator<1>>::allocate(&v36->m_agDrawAllocator, 0x100ui64, v38);
            v40 = &v78;
            v41 = (char *)v39;
            v42 = &v86;
            v43 = 4i64;
            v44 = v39 + 7;
            do
            {
              v45 = *(_DWORD *)v42;
              v40 += 2;
              v46 = (__m128)*((unsigned int *)v42 - 1);
              v42 = (__int64 *)((char *)v42 + 12);
              LODWORD(v[2]) = v45;
              v47 = v45;
              v48 = _mm_unpacklo_ps((__m128)*((unsigned int *)v42 - 5), v46).m128_u64[0];
              v49 = (__m128)(unsigned int)*(v40 - 1);
              *(v44 - 7) = v48;
              *v44 = _mm_unpacklo_ps((__m128)(unsigned int)*(v40 - 2), v49).m128_u64[0];
              *((_DWORD *)v44 - 12) = v47;
              *((_OWORD *)v44 - 1) = _xmm;
              v44 += 8;
              --v43;
            }
            while ( v43 );
            *(_DWORD *)(v[0] + 9928i64) = 4;
            m_pRender = this->m_pRender;
            v51 = *(_OWORD *)&m_pRender->m_View.m[4];
            *(_OWORD *)&v76[1] = *(_OWORD *)m_pRender->m_View.m;
            v52 = *(_OWORD *)&m_pRender->m_View.m[8];
            *(_OWORD *)&v76[3] = v51;
            v53 = *(_OWORD *)&m_pRender->m_View.m[12];
            *(_OWORD *)&v76[5] = v52;
            v54 = *(_OWORD *)m_pRender->m_Proj.m;
            *(_OWORD *)&v76[7] = v53;
            v55 = *(_OWORD *)&m_pRender->m_Proj.m[4];
            *(_OWORD *)v77.m = v54;
            v56 = *(_OWORD *)&m_pRender->m_Proj.m[8];
            *(_OWORD *)&v77.m[4] = v55;
            v57 = *(_OWORD *)&m_pRender->m_Proj.m[12];
            *(_OWORD *)&v77.m[8] = v56;
            *(_OWORD *)&v77.m[12] = v57;
            OGLMatrix::transpose((OGLMatrix *)&v76[1]);
            OGLMatrix::transpose(&v77);
            glUniformMatrix4fvAG(*v35->m_piGLUniform, 1, v58, (const float *)&v76[1]);
            glUniformMatrix4fvAG(v35->m_piGLUniform[1], 1, v59, v77.m);
            m_piGLUniform = v35->m_piGLUniform;
            *(_OWORD *)&v[1] = _xmm;
            glUniform4fvAG(m_piGLUniform[5], 1, (const float *)&v[1]);
            v61 = AgSingleton<KOFShaderManager>::ms_instance;
            v62 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                            * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                            + 7].onSingletonInit;
            if ( (unsigned int)v62 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v62;
              g_vertexAttribIndex[v62] = 0;
            }
            v63 = Framework::GLManager::glm;
            v64 = *(_DWORD *)v61[11 * SLODWORD(v61[360450].__vftable) + 7].onSingletonInit;
            renderSize = Framework::GLManager::glm->renderSize;
            switch ( renderSize )
            {
              case 64:
                v66 = 64;
                break;
              case 280:
                v66 = 136;
                break;
              case 208:
                v66 = 64;
                break;
              default:
                v66 = 88;
                if ( renderSize == 144 )
                  v66 = 144;
                break;
            }
            if ( v64 >= 0 )
            {
              _glewVertexAttribPointer(v64, 3, 0x1406u, 0, v66, v41);
              v63 = Framework::GLManager::glm;
              v61 = AgSingleton<KOFShaderManager>::ms_instance;
            }
            v67 = v35->m_piGLUniform;
            *(_OWORD *)v94 = _xmm;
            glUniform4fvAG(v67[5], 1, v94);
            v68 = *((unsigned int *)v61[11 * SLODWORD(v61[360450].__vftable) + 7].onSingletonInit + 4);
            if ( (unsigned int)v68 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v68;
              g_vertexAttribIndex[v68] = 4;
            }
            v69 = v63->renderSize;
            v70 = (AppMain *)*((unsigned int *)v61[11 * SLODWORD(v61[360450].__vftable) + 7].onSingletonInit + 4);
            if ( v69 != 64 )
            {
              if ( v69 == 280 )
              {
                v37 = 8;
LABEL_81:
                if ( (int)v70 >= 0 )
                  _glewVertexAttribPointer((unsigned int)v70, 2, 0x1406u, 0, v37, v41);
                AppMain::SetPostFXUniforms(
                  v70,
                  v35,
                  &this->ModelRoomSettings.postfxUniforms,
                  &this->ModelRoomSettings.filterUniforms);
                glDrawArraysAG(v72, v71, 4);
                Graphics::drawStack(this->g->g);
                glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
                this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
                return;
              }
              if ( v69 != 208 )
              {
                if ( v69 == 144 )
                {
                  v37 = 144;
                  goto LABEL_81;
                }
                v37 = 88;
              }
            }
            v41 += 56;
            goto LABEL_81;
          }
        }
      }
    }
  }
}

void __fastcall AppMain::BlendTwoTexturesUsingDepth(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pBlend1Texture,
        OGLTexture *pBlend2Texture,
        int blendBuffer1)
{
  Framework::GLManager *v8; // r12
  bool v10; // zf
  float m_iScreenH; // xmm0_4
  int v12; // ecx
  float m_iScreenW; // xmm0_4
  unsigned int v14; // ecx
  unsigned int v15; // er8
  unsigned int v16; // eax
  unsigned int m_TexID; // edx
  Framework::GLManager *v18; // rcx
  unsigned int v19; // edx
  Framework::GLManager *v20; // rcx
  OGLShader *v21; // rdi
  Framework::GLManager *v22; // rcx
  int v23; // ebx
  unsigned __int64 v24; // r8
  _QWORD *v25; // rax
  int *v26; // r8
  char *v27; // rsi
  float *v28; // rdx
  __int64 v29; // r9
  float *v30; // rcx
  float v31; // xmm0_4
  __m128 v32; // xmm1
  float v33; // eax
  unsigned __int64 v34; // xmm0_8
  __m128 v35; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v37; // xmm1
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  __int128 v42; // xmm0
  __int128 v43; // xmm1
  unsigned __int8 v44; // r8
  unsigned __int8 v45; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v47; // rdi
  __int64 v48; // rcx
  signed int v49; // er10
  int renderSize; // ecx
  int v51; // eax
  __int64 v52; // rcx
  int v53; // eax
  signed int v54; // ecx
  unsigned int v55; // eax
  unsigned int v56; // edx
  Framework::GLManager *v57; // rcx
  unsigned int v58; // edx
  Framework::GLManager *v59; // rcx
  unsigned int v60; // eax
  unsigned int v61; // edx
  Framework::GLManager *v62; // rcx
  unsigned int v63; // edx
  Framework::GLManager *v64; // rcx
  AppMain *v65; // rcx
  unsigned int v66; // edx
  __int64 v67; // rax
  Framework::GLManager *v68; // rcx
  unsigned int v69; // edx
  __int64 v70; // rax
  Framework::GLManager *v71; // rcx
  unsigned int v72; // edx
  Framework::GLManager *v73; // r9
  int v74; // edx
  unsigned int v75; // ecx
  int v76; // [rsp+20h] [rbp-E0h]
  unsigned int v77; // [rsp+38h] [rbp-C8h]
  OGLShader *pShader; // [rsp+48h] [rbp-B8h]
  float v[4]; // [rsp+58h] [rbp-A8h] BYREF
  OGLMatrix v80; // [rsp+70h] [rbp-90h] BYREF
  OGLMatrix v81; // [rsp+B0h] [rbp-50h] BYREF
  int v82; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v83; // [rsp+F4h] [rbp-Ch]
  int v84; // [rsp+FCh] [rbp-4h]
  int v85; // [rsp+100h] [rbp+0h]
  int v86; // [rsp+104h] [rbp+4h]
  int v87; // [rsp+108h] [rbp+8h]
  int v88; // [rsp+10Ch] [rbp+Ch]
  __int64 v89; // [rsp+118h] [rbp+18h]
  __int64 v90; // [rsp+120h] [rbp+20h] BYREF
  float v91; // [rsp+128h] [rbp+28h]
  int v92; // [rsp+12Ch] [rbp+2Ch]
  float v93; // [rsp+130h] [rbp+30h]
  __int64 v94; // [rsp+134h] [rbp+34h]
  float v95; // [rsp+13Ch] [rbp+3Ch]
  float v96; // [rsp+140h] [rbp+40h]
  int v97; // [rsp+144h] [rbp+44h]
  float v98[4]; // [rsp+150h] [rbp+50h] BYREF

  v8 = Framework::GLManager::glm;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Blend 3 Depths");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 14, "Blend 3 Depths");
  ++markerCount;
  if ( pDestTexture && pBlend1Texture && pBlend2Texture )
  {
    v10 = pDestTexture->m_FrameBufferID == 0;
    m_iScreenH = (float)this->m_iScreenH;
    v90 = 0i64;
    v89 = 0i64;
    v94 = 0i64;
    v12 = (int)m_iScreenH;
    v97 = 0;
    v92 = 0;
    v83 = 0i64;
    v82 = 0;
    v86 = 0;
    v87 = 1065353216;
    v85 = 1065353216;
    m_iScreenW = (float)this->m_iScreenW;
    v88 = 1065353216;
    v84 = 1065353216;
    v96 = (float)v12;
    v91 = (float)v12;
    v14 = (int)m_iScreenW;
    v95 = (float)(int)m_iScreenW;
    v93 = v95;
    if ( v10 )
      glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
    if ( !pDestTexture->m_TexID )
      glGenTexturesAG(1, &pDestTexture->m_TexID);
    glBindRenderbufferAG(v14, pDestTexture->m_FrameBufferID);
    v16 = m_ActiveTexture;
    if ( m_ActiveTexture )
    {
      m_ActiveTexture = 0;
      _glewActiveTexture(0x84C0u);
      v16 = m_ActiveTexture;
    }
    m_TexID = pDestTexture->m_TexID;
    if ( m_TexID != ::m_TexID[v16] || !m_TexID )
    {
      ::m_TexID[v16] = m_TexID;
      v18 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = m_TexID;
      while ( v18->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glsFramebufferTexture2D(
      AppMain::pApp,
      0x8CE0u,
      v15,
      pDestTexture->m_TexID,
      v76,
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
      *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
      v77);
    v19 = pDestTexture->m_TexID;
    if ( v19 != ::m_TexID[m_ActiveTexture] || !v19 )
    {
      v20 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v19;
      v20->m_textureID = v19;
      while ( v20->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v19);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    v10 = m_DepthMask == 1;
    pDestTexture->m_TexParam = 1290;
    if ( !v10 )
    {
      m_DepthMask = 1;
      glDepthMask(1u);
    }
    glClearAG(0x100u);
    GraphicsOpt::lock(this->g);
    v21 = this->m_pRender->m_ShaderFXTbl[7958];
    pShader = v21;
    if ( v21 )
    {
      if ( v21->m_Program )
      {
        KOFShaderManager::useProgramSlot(
          (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
          v21->m_programSlot);
        v22 = Framework::GLManager::glm;
        v23 = 64;
        Framework::GLManager::glm->renderSize = 64;
        v25 = AgFrameAllocator<AgAllocator<1>>::allocate(&v22->m_agDrawAllocator, 0x100ui64, v24);
        v26 = &v82;
        v27 = (char *)v25;
        v28 = (float *)&v90;
        v29 = 4i64;
        v30 = (float *)(v25 + 7);
        do
        {
          v31 = *v28;
          v26 += 2;
          v32 = (__m128)*((unsigned int *)v28 - 1);
          v28 += 3;
          v[2] = v31;
          v33 = v31;
          v34 = _mm_unpacklo_ps((__m128)*((unsigned int *)v28 - 5), v32).m128_u64[0];
          v35 = (__m128)(unsigned int)*(v26 - 1);
          *((_QWORD *)v30 - 7) = v34;
          *(_QWORD *)v30 = _mm_unpacklo_ps((__m128)(unsigned int)*(v26 - 2), v35).m128_u64[0];
          *(v30 - 12) = v33;
          *((_OWORD *)v30 - 1) = _xmm;
          v30 += 16;
          --v29;
        }
        while ( v29 );
        v8->m_vertexInfoCount = 4;
        m_pRender = this->m_pRender;
        v37 = *(_OWORD *)&m_pRender->m_View.m[4];
        *(_OWORD *)v80.m = *(_OWORD *)m_pRender->m_View.m;
        v38 = *(_OWORD *)&m_pRender->m_View.m[8];
        *(_OWORD *)&v80.m[4] = v37;
        v39 = *(_OWORD *)&m_pRender->m_View.m[12];
        *(_OWORD *)&v80.m[8] = v38;
        v40 = *(_OWORD *)m_pRender->m_Proj.m;
        *(_OWORD *)&v80.m[12] = v39;
        v41 = *(_OWORD *)&m_pRender->m_Proj.m[4];
        *(_OWORD *)v81.m = v40;
        v42 = *(_OWORD *)&m_pRender->m_Proj.m[8];
        *(_OWORD *)&v81.m[4] = v41;
        v43 = *(_OWORD *)&m_pRender->m_Proj.m[12];
        *(_OWORD *)&v81.m[8] = v42;
        *(_OWORD *)&v81.m[12] = v43;
        OGLMatrix::transpose(&v80);
        OGLMatrix::transpose(&v81);
        glUniformMatrix4fvAG(*v21->m_piGLUniform, 1, v44, v80.m);
        glUniformMatrix4fvAG(v21->m_piGLUniform[1], 1, v45, v81.m);
        m_piGLUniform = v21->m_piGLUniform;
        *(_OWORD *)v = _xmm;
        glUniform4fvAG(m_piGLUniform[5], 1, v);
        v47 = AgSingleton<KOFShaderManager>::ms_instance;
        v48 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                        * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                        + 7].onSingletonInit;
        if ( (unsigned int)v48 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v48;
          g_vertexAttribIndex[v48] = 0;
        }
        v49 = *(_DWORD *)v47[11 * SLODWORD(v47[360450].__vftable) + 7].onSingletonInit;
        renderSize = Framework::GLManager::glm->renderSize;
        switch ( renderSize )
        {
          case 64:
            v51 = 64;
            break;
          case 280:
            v51 = 136;
            break;
          case 208:
            v51 = 64;
            break;
          default:
            v51 = 88;
            if ( renderSize == 144 )
              v51 = 144;
            break;
        }
        if ( v49 >= 0 )
        {
          _glewVertexAttribPointer(v49, 3, 0x1406u, 0, v51, v27);
          v47 = AgSingleton<KOFShaderManager>::ms_instance;
        }
        *(_OWORD *)v98 = _xmm;
        glUniform4fvAG(pShader->m_piGLUniform[5], 1, v98);
        v52 = *((unsigned int *)v47[11 * SLODWORD(v47[360450].__vftable) + 7].onSingletonInit + 4);
        if ( (unsigned int)v52 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v52;
          g_vertexAttribIndex[v52] = 4;
        }
        v53 = Framework::GLManager::glm->renderSize;
        v54 = *((_DWORD *)v47[11 * SLODWORD(v47[360450].__vftable) + 7].onSingletonInit + 4);
        if ( v53 != 64 )
        {
          if ( v53 == 280 )
          {
            v23 = 8;
LABEL_52:
            if ( v54 >= 0 )
              _glewVertexAttribPointer(v54, 2, 0x1406u, 0, v23, v27);
            v55 = m_ActiveTexture;
            if ( m_ActiveTexture != 1 )
            {
              m_ActiveTexture = 1;
              _glewActiveTexture(0x84C1u);
              v55 = m_ActiveTexture;
            }
            v56 = pBlend1Texture->m_TexID;
            if ( v56 != ::m_TexID[v55] || !v56 )
            {
              ::m_TexID[v55] = v56;
              v57 = Framework::GLManager::glm;
              Framework::GLManager::glm->m_textureID = v56;
              while ( v57->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v56);
              v55 = m_ActiveTexture;
            }
            v58 = pBlend1Texture->m_TexID;
            if ( v58 != ::m_TexID[v55] || !v58 )
            {
              ::m_TexID[v55] = v58;
              v59 = Framework::GLManager::glm;
              Framework::GLManager::glm->m_textureID = v58;
              while ( v59->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v58);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v60 = m_ActiveTexture;
            pBlend1Texture->m_TexParam = 1290;
            if ( v60 != 2 )
            {
              m_ActiveTexture = 2;
              _glewActiveTexture(0x84C2u);
              v60 = m_ActiveTexture;
            }
            v61 = pBlend2Texture->m_TexID;
            if ( v61 != ::m_TexID[v60] || !v61 )
            {
              ::m_TexID[v60] = v61;
              v62 = Framework::GLManager::glm;
              Framework::GLManager::glm->m_textureID = v61;
              while ( v62->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v61);
              v60 = m_ActiveTexture;
            }
            v63 = pBlend2Texture->m_TexID;
            if ( v63 != ::m_TexID[v60] || !v63 )
            {
              ::m_TexID[v60] = v63;
              v64 = Framework::GLManager::glm;
              Framework::GLManager::glm->m_textureID = v63;
              while ( v64->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v63);
            }
            glTexParameterf(0xDE1u, 0x2801u, 9729.0);
            glTexParameterf(0xDE1u, 0x2800u, 9729.0);
            glTexParameterf(0xDE1u, 0x2802u, 33071.0);
            glTexParameterf(0xDE1u, 0x2803u, 33071.0);
            v65 = (AppMain *)m_ActiveTexture;
            pBlend2Texture->m_TexParam = 1290;
            if ( (_DWORD)v65 != 3 )
            {
              m_ActiveTexture = 3;
              _glewActiveTexture(0x84C3u);
              v65 = (AppMain *)m_ActiveTexture;
            }
            v66 = this->m_pRender->m_renderTextures.m_DepthMapTexture[blendBuffer1].m_TexID;
            v67 = (unsigned int)v65;
            if ( v66 != ::m_TexID[(unsigned int)v65] || !v66 )
            {
              v68 = Framework::GLManager::glm;
              ::m_TexID[v67] = v66;
              v68->m_textureID = v66;
              while ( v68->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v66);
              v65 = (AppMain *)m_ActiveTexture;
            }
            if ( (_DWORD)v65 != 4 )
            {
              m_ActiveTexture = 4;
              _glewActiveTexture(0x84C4u);
              v65 = (AppMain *)m_ActiveTexture;
            }
            v69 = this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID;
            v70 = (unsigned int)v65;
            if ( v69 != ::m_TexID[(unsigned int)v65] || !v69 )
            {
              v71 = Framework::GLManager::glm;
              ::m_TexID[v70] = v69;
              v71->m_textureID = v69;
              while ( v71->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v69);
              v65 = (AppMain *)m_ActiveTexture;
            }
            if ( (_DWORD)v65 != 5 )
            {
              m_ActiveTexture = 5;
              _glewActiveTexture(0x84C5u);
              v65 = (AppMain *)m_ActiveTexture;
            }
            v72 = this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[blendBuffer1].m_TexID;
            if ( v72 != ::m_TexID[(unsigned int)v65] || !v72 )
            {
              v73 = Framework::GLManager::glm;
              ::m_TexID[(unsigned int)v65] = v72;
              v73->m_textureID = v72;
              while ( v73->m_bOpenGLBlocked )
                ;
              glBindTexture(0xDE1u, v72);
            }
            AppMain::SetPostFXUniforms(
              v65,
              pShader,
              &this->ModelRoomSettings.postfxUniforms,
              &this->ModelRoomSettings.filterUniforms);
            glDrawArraysAG(v75, v74, 4);
            Graphics::drawStack(this->g->g);
            if ( _glewPopGroupMarkerEXT )
              _glewPopGroupMarkerEXT();
            if ( _glewPopDebugGroup )
              _glewPopDebugGroup();
            --markerCount;
            return;
          }
          if ( v53 != 208 )
          {
            if ( v53 == 144 )
            {
              v23 = 144;
              goto LABEL_52;
            }
            v23 = 88;
          }
        }
        v27 += 56;
        goto LABEL_52;
      }
    }
  }
}

void __fastcall AppMain::BloomEffectBlend(AppMain *this, int frameBufferIndex)
{
  OGLRender *m_pRender; // r8
  float m_fBloomStrength; // xmm3_4
  float v5; // xmm1_4
  float v6; // xmm0_4
  float v7; // xmm3_4

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Bloom Effect Blend");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 18, "Bloom Effect Blend");
  m_pRender = this->m_pRender;
  ++markerCount;
  m_fBloomStrength = m_pRender->m_fBloomStrength;
  v5 = (float)(m_fBloomStrength * this->ModelRoomSettings.postprocessSettings.bgBloomSettings.baseSaturation)
     + (float)(1.0 - m_fBloomStrength);
  this->ModelRoomSettings.postfxUniforms.u_postfxBloomSatIntBaseSatInt.x = (float)(m_fBloomStrength
                                                                                 * this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomSaturation)
                                                                         + (float)(1.0 - m_fBloomStrength);
  v6 = m_fBloomStrength * this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomIntensity;
  v7 = (float)(m_fBloomStrength * this->ModelRoomSettings.postprocessSettings.bgBloomSettings.baseIntensity)
     + (float)(1.0 - m_fBloomStrength);
  this->ModelRoomSettings.postfxUniforms.u_postfxBloomSatIntBaseSatInt.z = v5;
  this->ModelRoomSettings.postfxUniforms.u_postfxBloomSatIntBaseSatInt.y = v6;
  this->ModelRoomSettings.postfxUniforms.u_postfxBloomSatIntBaseSatInt.w = v7;
  AppMain::RenderFullScreenToTexture(
    this,
    7935,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    0);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::BloomEffectPass(AppMain *this, int frameBufferIndex)
{
  int downsampleScale; // eax
  __m128i v4; // xmm1
  __m128i v5; // xmm3
  OGLRender *m_pRender; // rdx
  float v7; // xmm3_4
  OGLTexture *m_BloomMapDownSampleTexture; // r8
  OGLTexture *p_m_BloomMapTexture; // rdx
  int v10; // edx
  float height; // [rsp+20h] [rbp-18h]

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 17, "Bloom Effect Pass");
  downsampleScale = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  v4 = _mm_cvtsi32_si128(this->m_iScreenH);
  v5 = _mm_cvtsi32_si128(this->m_iScreenW);
  ++markerCount;
  m_pRender = this->m_pRender;
  v7 = _mm_cvtepi32_ps(v5).m128_f32[0] / (float)downsampleScale;
  height = _mm_cvtepi32_ps(v4).m128_f32[0] / (float)downsampleScale;
  if ( downsampleScale == 1 )
  {
    m_BloomMapDownSampleTexture = m_pRender->m_renderTextures.m_BloomMapDownSampleTexture;
    p_m_BloomMapTexture = &m_pRender->m_renderTextures.m_BloomMapTexture;
  }
  else
  {
    p_m_BloomMapTexture = m_pRender->m_renderTextures.m_BloomMapDownSampleTexture;
    m_BloomMapDownSampleTexture = p_m_BloomMapTexture;
  }
  AppMain::GaussianBlurEffect(
    this,
    p_m_BloomMapTexture,
    m_BloomMapDownSampleTexture,
    v7,
    height,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  AppMain::BloomEffectBlend(this, v10);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::_MODELROOM_SETTINGS::CalcBlendProjParam(AppMain::_MODELROOM_SETTINGS *this)
{
  OGLVec3 *p_vCamLookNormal; // rbx
  __m128 v3; // xmm3
  __m128 v4; // xmm5
  __m128 v5; // xmm2
  __m128 v6; // xmm4
  float v7; // eax
  float z; // eax
  float v9; // xmm0_4
  float v10; // xmm4_4
  float v11; // [rsp+38h] [rbp-10h]

  p_vCamLookNormal = &this->vCamLookNormal;
  v3 = (__m128)LODWORD(this->fCamPos[0]);
  v4 = (__m128)LODWORD(this->fCamLook[0]);
  v5 = (__m128)LODWORD(this->fCamPos[1]);
  v4.m128_f32[0] = v4.m128_f32[0] - v3.m128_f32[0];
  v6 = (__m128)LODWORD(this->fCamLook[1]);
  v6.m128_f32[0] = v6.m128_f32[0] - v5.m128_f32[0];
  v7 = this->fCamPos[2];
  v11 = this->fCamLook[2] - v7;
  *(_QWORD *)&this->vCamPosVec3.x = _mm_unpacklo_ps(v3, v5).m128_u64[0];
  this->vCamPosVec3.z = v7;
  *(_QWORD *)&this->vCamLookNormal.x = _mm_unpacklo_ps(v4, v6).m128_u64[0];
  this->vCamLookNormal.z = v11;
  OGLVec3::normalize(&this->vCamLookNormal, &this->vCamLookNormal);
  z = p_vCamLookNormal->z;
  *(_QWORD *)&this->vCamLookPerpNormal.x = *(_QWORD *)&p_vCamLookNormal->x;
  this->vCamLookPerpNormal.z = z;
  v5.m128_i32[0] = LODWORD(this->vCamLookPerpNormal.z);
  v9 = this->vCamLookPerpNormal.y * 0.0;
  v10 = this->vCamLookPerpNormal.x - v9;
  this->vCamLookPerpNormal.y = (float)(v5.m128_f32[0] * 0.0) - (float)(this->vCamLookPerpNormal.x * 0.0);
  this->vCamLookPerpNormal.z = v10;
  this->vCamLookPerpNormal.x = v9 - v5.m128_f32[0];
  OGLVec3::normalize(&this->vCamLookPerpNormal, &this->vCamLookPerpNormal);
}

float __fastcall AppMain::_MODELROOM_SETTINGS::CalcCamDotFromFront(AppMain::_MODELROOM_SETTINGS *this)
{
  float v1; // xmm7_4
  float v2; // xmm8_4
  float v3; // xmm6_4
  float v4; // xmm0_4

  v1 = this->fCamLook[0] - this->fCamPos[0];
  v2 = this->fCamLook[2] - this->fCamPos[2];
  v3 = 0.0;
  v4 = sqrtf((float)((float)(v1 * v1) + 0.0) + (float)(v2 * v2));
  if ( v4 != 0.0 )
  {
    v3 = 0.0 / v4;
    v1 = v1 / v4;
    v2 = v2 / v4;
  }
  return (float)((float)(v3 * 0.0) + (float)(v1 * 0.0)) - (float)(v2 * 1.0);
}

void __fastcall AppMain::CharHighlightExtractionTwoBuffers(
        AppMain *this,
        OGLTexture *pSrcTexture1,
        OGLTexture *pSrcTexture2,
        OGLTexture *pDestTexture,
        int width,
        int height)
{
  Framework::GLManager *v6; // rbx
  unsigned int *p_m_FrameBufferID; // rdx
  bool v12; // zf
  float v13; // xmm7_4
  float m_targetWidth; // xmm1_4
  unsigned int v15; // edx
  float v16; // xmm1_4
  unsigned int v17; // edx
  unsigned int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  unsigned int m_TexID; // edx
  unsigned int v22; // ecx
  Framework::GLManager *v23; // rcx
  unsigned int v24; // edx
  Framework::GLManager *v25; // rcx
  unsigned int v26; // ecx
  unsigned int v27; // edx
  __int64 v28; // rax
  Framework::GLManager *v29; // rcx
  unsigned int v30; // edx
  __int64 v31; // rax
  Framework::GLManager *v32; // rcx
  unsigned int v33; // edx
  __int64 v34; // rax
  Framework::GLManager *v35; // rcx
  unsigned int v36; // edx
  __int64 v37; // rax
  Framework::GLManager *v38; // rcx
  unsigned int v39; // edx
  Framework::GLManager *v40; // r8
  OGLShader *v41; // r13
  Framework::GLManager *v42; // rcx
  int v43; // esi
  unsigned __int64 v44; // r8
  _QWORD *v45; // rax
  int *v46; // r8
  char *v47; // r15
  float *v48; // rdx
  __int64 v49; // r9
  float *v50; // rcx
  float v51; // xmm0_4
  __m128 v52; // xmm1
  float v53; // eax
  unsigned __int64 v54; // xmm0_8
  __m128 v55; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v57; // xmm1
  __int128 v58; // xmm0
  __int128 v59; // xmm1
  __int128 v60; // xmm0
  __int128 v61; // xmm1
  __int128 v62; // xmm0
  __int128 v63; // xmm1
  unsigned __int8 v64; // r8
  unsigned __int8 v65; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v67; // r14
  __int64 v68; // rcx
  signed int v69; // er10
  int renderSize; // ecx
  int v71; // eax
  int *v72; // rax
  __int64 v73; // rcx
  AppMain *v74; // rcx
  int v75; // eax
  int v76; // edx
  unsigned int v77; // ecx
  float v78; // xmm1_4
  signed int m_FrameBufferID; // ecx
  float v80; // xmm1_4
  signed int v81; // ecx
  signed int v82; // ecx
  int v83; // [rsp+20h] [rbp-E0h]
  unsigned int v84; // [rsp+38h] [rbp-C8h]
  float v[4]; // [rsp+40h] [rbp-C0h] BYREF
  OGLMatrix v86; // [rsp+50h] [rbp-B0h] BYREF
  OGLMatrix v87; // [rsp+90h] [rbp-70h] BYREF
  int v88; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v89; // [rsp+D4h] [rbp-2Ch]
  int v90; // [rsp+DCh] [rbp-24h]
  int v91; // [rsp+E0h] [rbp-20h]
  int v92; // [rsp+E4h] [rbp-1Ch]
  int v93; // [rsp+E8h] [rbp-18h]
  int v94; // [rsp+ECh] [rbp-14h]
  __int64 v95; // [rsp+F8h] [rbp-8h]
  __int64 v96; // [rsp+100h] [rbp+0h] BYREF
  float v97; // [rsp+108h] [rbp+8h]
  int v98; // [rsp+10Ch] [rbp+Ch]
  float v99; // [rsp+110h] [rbp+10h]
  __int64 v100; // [rsp+114h] [rbp+14h]
  float v101; // [rsp+11Ch] [rbp+1Ch]
  float v102; // [rsp+120h] [rbp+20h]
  int v103; // [rsp+124h] [rbp+24h]
  float v104[4]; // [rsp+130h] [rbp+30h] BYREF

  if ( pSrcTexture1 )
  {
    v6 = Framework::GLManager::glm;
    if ( pSrcTexture2 )
    {
      if ( pDestTexture )
      {
        p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
        v12 = *p_m_FrameBufferID == 0;
        v13 = (float)width;
        v96 = 0i64;
        v95 = 0i64;
        v100 = 0i64;
        v103 = 0;
        v98 = 0;
        v89 = 0i64;
        v88 = 0;
        v92 = 0;
        v101 = (float)width;
        v102 = (float)height;
        v97 = (float)height;
        v99 = (float)width;
        v93 = 1065353216;
        v91 = 1065353216;
        v94 = 1065353216;
        v90 = 1065353216;
        if ( v12 )
        {
          m_targetWidth = (float)(int)Framework::GLManager::glm->m_config.m_targetWidth;
          if ( v13 == (float)(m_targetWidth * 0.125) )
          {
            Framework::GLManager::glGenEighthRenderbuffers(
              Framework::GLManager::glm,
              (int)p_m_FrameBufferID,
              p_m_FrameBufferID);
            Framework::GLManager::glBindEighthRenderbuffer(
              v6,
              v15,
              this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
          }
          else
          {
            v16 = m_targetWidth * 0.5;
            if ( v16 <= v13 )
            {
              if ( v13 == v16 )
              {
                Framework::GLManager::glGenHalfRenderbuffers(
                  Framework::GLManager::glm,
                  (int)p_m_FrameBufferID,
                  p_m_FrameBufferID);
                Framework::GLManager::glBindHalfRenderbuffer(
                  v6,
                  v18,
                  this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
              }
              else
              {
                glGenRenderbuffersAG(1, p_m_FrameBufferID);
                glBindRenderbufferAG(v19, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
              }
            }
            else
            {
              Framework::GLManager::glGenThirdRenderbuffers(
                Framework::GLManager::glm,
                (int)p_m_FrameBufferID,
                p_m_FrameBufferID);
              Framework::GLManager::glBindThirdRenderbuffer(
                v6,
                v17,
                this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
            }
          }
        }
        if ( !pDestTexture->m_TexID )
          glGenTexturesAG(1, &pDestTexture->m_TexID);
        v20 = m_ActiveTexture;
        if ( m_ActiveTexture != 1 )
        {
          m_ActiveTexture = 1;
          _glewActiveTexture(0x84C1u);
          v20 = m_ActiveTexture;
        }
        m_TexID = pDestTexture->m_TexID;
        v22 = v20;
        if ( m_TexID != ::m_TexID[v20] || !m_TexID )
        {
          ::m_TexID[v20] = m_TexID;
          v23 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = m_TexID;
          while ( v23->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, m_TexID);
        }
        glsFramebufferTexture2D(
          v22,
          0x8CE1u,
          (unsigned int)pSrcTexture2,
          pDestTexture->m_TexID,
          v83,
          width,
          height,
          v84);
        v24 = pDestTexture->m_TexID;
        if ( v24 != ::m_TexID[m_ActiveTexture] || !v24 )
        {
          v25 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v24;
          v25->m_textureID = v24;
          while ( v25->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v24);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v26 = m_ActiveTexture;
        pDestTexture->m_TexParam = 1290;
        if ( v26 != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
          v26 = m_ActiveTexture;
        }
        v27 = pSrcTexture1->m_TexID;
        v28 = v26;
        if ( v27 != ::m_TexID[v26] || !v27 )
        {
          v29 = Framework::GLManager::glm;
          ::m_TexID[v28] = v27;
          v29->m_textureID = v27;
          while ( v29->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v27);
          v26 = m_ActiveTexture;
        }
        if ( v26 != 3 )
        {
          m_ActiveTexture = 3;
          _glewActiveTexture(0x84C3u);
          v26 = m_ActiveTexture;
        }
        v30 = pSrcTexture2->m_TexID;
        v31 = v26;
        if ( v30 != ::m_TexID[v26] || !v30 )
        {
          v32 = Framework::GLManager::glm;
          ::m_TexID[v31] = v30;
          v32->m_textureID = v30;
          while ( v32->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v30);
          v26 = m_ActiveTexture;
        }
        if ( v26 != 4 )
        {
          m_ActiveTexture = 4;
          _glewActiveTexture(0x84C4u);
          v26 = m_ActiveTexture;
        }
        v33 = this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_TexID;
        v34 = v26;
        if ( v33 != ::m_TexID[v26] || !v33 )
        {
          v35 = Framework::GLManager::glm;
          ::m_TexID[v34] = v33;
          v35->m_textureID = v33;
          while ( v35->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v33);
          v26 = m_ActiveTexture;
        }
        if ( v26 != 5 )
        {
          m_ActiveTexture = 5;
          _glewActiveTexture(0x84C5u);
          v26 = m_ActiveTexture;
        }
        v36 = this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_TexID;
        v37 = v26;
        if ( v36 != ::m_TexID[v26] || !v36 )
        {
          v38 = Framework::GLManager::glm;
          ::m_TexID[v37] = v36;
          v38->m_textureID = v36;
          while ( v38->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v36);
          v26 = m_ActiveTexture;
        }
        if ( v26 != 6 )
        {
          m_ActiveTexture = 6;
          _glewActiveTexture(0x84C6u);
          v26 = m_ActiveTexture;
        }
        v39 = this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID;
        if ( v39 != ::m_TexID[v26] || !v39 )
        {
          v40 = Framework::GLManager::glm;
          ::m_TexID[v26] = v39;
          v40->m_textureID = v39;
          while ( v40->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v39);
        }
        if ( m_DepthMask != 1 )
        {
          m_DepthMask = 1;
          glDepthMask(1u);
        }
        glClearAG(0x100u);
        GraphicsOpt::lock(this->g, width, height);
        if ( m_DepthMask )
        {
          m_DepthMask = 0;
          glDepthMask(0);
        }
        if ( m_Mode != 32774 )
        {
          m_Mode = 32774;
          m_ModeAlpha = 32774;
          _glewBlendEquation(0x8006u);
        }
        if ( dword_140A9605C != 1 )
        {
          dword_140A9605C = 1;
          glEnable(0xBE2u);
        }
        if ( m_Sfactor != 770 || m_Dfactor != 771 || m_SfactorAlpha != 770 || m_DfactorAlpha != 771 )
        {
          m_Sfactor = 770;
          m_Dfactor = 771;
          m_SfactorAlpha = 770;
          m_DfactorAlpha = 771;
          _glewBlendFuncSeparate(0x302u, 0x303u, 0x302u, 0x303u);
        }
        if ( m_dMode != 519 )
        {
          m_dMode = 519;
          glDepthFunc(0x207u);
        }
        v41 = this->m_pRender->m_ShaderFXTbl[7932];
        if ( v41 )
        {
          if ( v41->m_Program )
          {
            KOFShaderManager::useProgramSlot(
              (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
              v41->m_programSlot);
            v42 = Framework::GLManager::glm;
            v43 = 64;
            Framework::GLManager::glm->renderSize = 64;
            v45 = AgFrameAllocator<AgAllocator<1>>::allocate(&v42->m_agDrawAllocator, 0x100ui64, v44);
            v46 = &v88;
            v47 = (char *)v45;
            v48 = (float *)&v96;
            v49 = 4i64;
            v50 = (float *)(v45 + 7);
            do
            {
              v51 = *v48;
              v46 += 2;
              v52 = (__m128)*((unsigned int *)v48 - 1);
              v48 += 3;
              v[2] = v51;
              v53 = v51;
              v54 = _mm_unpacklo_ps((__m128)*((unsigned int *)v48 - 5), v52).m128_u64[0];
              v55 = (__m128)(unsigned int)*(v46 - 1);
              *((_QWORD *)v50 - 7) = v54;
              *(_QWORD *)v50 = _mm_unpacklo_ps((__m128)(unsigned int)*(v46 - 2), v55).m128_u64[0];
              *(v50 - 12) = v53;
              *((_OWORD *)v50 - 1) = _xmm;
              v50 += 16;
              --v49;
            }
            while ( v49 );
            v6->m_vertexInfoCount = 4;
            m_pRender = this->m_pRender;
            v57 = *(_OWORD *)&m_pRender->m_View.m[4];
            *(_OWORD *)v86.m = *(_OWORD *)m_pRender->m_View.m;
            v58 = *(_OWORD *)&m_pRender->m_View.m[8];
            *(_OWORD *)&v86.m[4] = v57;
            v59 = *(_OWORD *)&m_pRender->m_View.m[12];
            *(_OWORD *)&v86.m[8] = v58;
            v60 = *(_OWORD *)m_pRender->m_Proj.m;
            *(_OWORD *)&v86.m[12] = v59;
            v61 = *(_OWORD *)&m_pRender->m_Proj.m[4];
            *(_OWORD *)v87.m = v60;
            v62 = *(_OWORD *)&m_pRender->m_Proj.m[8];
            *(_OWORD *)&v87.m[4] = v61;
            v63 = *(_OWORD *)&m_pRender->m_Proj.m[12];
            *(_OWORD *)&v87.m[8] = v62;
            *(_OWORD *)&v87.m[12] = v63;
            OGLMatrix::transpose(&v86);
            OGLMatrix::transpose(&v87);
            glUniformMatrix4fvAG(*v41->m_piGLUniform, 1, v64, v86.m);
            glUniformMatrix4fvAG(v41->m_piGLUniform[1], 1, v65, v87.m);
            m_piGLUniform = v41->m_piGLUniform;
            *(_OWORD *)v = _xmm;
            glUniform4fvAG(m_piGLUniform[5], 1, v);
            v67 = AgSingleton<KOFShaderManager>::ms_instance;
            v68 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                            * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                            + 7].onSingletonInit;
            if ( (unsigned int)v68 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v68;
              g_vertexAttribIndex[v68] = 0;
            }
            v69 = *(_DWORD *)v67[11 * SLODWORD(v67[360450].__vftable) + 7].onSingletonInit;
            renderSize = Framework::GLManager::glm->renderSize;
            switch ( renderSize )
            {
              case 64:
                v71 = 64;
                break;
              case 280:
                v71 = 136;
                break;
              case 208:
                v71 = 64;
                break;
              default:
                v71 = 88;
                if ( renderSize == 144 )
                  v71 = 144;
                break;
            }
            if ( v69 >= 0 )
            {
              _glewVertexAttribPointer(v69, 3, 0x1406u, 0, v71, v47);
              v67 = AgSingleton<KOFShaderManager>::ms_instance;
            }
            v72 = v41->m_piGLUniform;
            *(_OWORD *)v104 = _xmm;
            glUniform4fvAG(v72[5], 1, v104);
            v73 = *((unsigned int *)v67[11 * SLODWORD(v67[360450].__vftable) + 7].onSingletonInit + 4);
            if ( (unsigned int)v73 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v73;
              g_vertexAttribIndex[v73] = 4;
            }
            v74 = (AppMain *)*((unsigned int *)v67[11 * SLODWORD(v67[360450].__vftable) + 7].onSingletonInit + 4);
            v75 = Framework::GLManager::glm->renderSize;
            if ( v75 != 64 )
            {
              if ( v75 == 280 )
              {
                v43 = 8;
LABEL_102:
                if ( (int)v74 >= 0 )
                  _glewVertexAttribPointer((unsigned int)v74, 2, 0x1406u, 0, v43, v47);
                AppMain::SetPostFXUniforms(
                  v74,
                  v41,
                  &this->ModelRoomSettings.postfxUniforms,
                  &this->ModelRoomSettings.filterUniforms);
                glDrawArraysAG(v77, v76, 4);
                Graphics::drawStack(this->g->g);
                v78 = (float)(int)v6->m_config.m_targetWidth;
                if ( v13 == (float)(v78 * 0.125) )
                {
                  m_FrameBufferID = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                  if ( m_FrameBufferID > 0 )
                    v6->m_eighthBuffer.m_freeIDs[v6->m_eighthBuffer.m_firstOccupiedIndex++] = m_FrameBufferID;
                }
                else
                {
                  v80 = v78 * 0.5;
                  if ( v80 <= v13 )
                  {
                    if ( v13 == v80 )
                    {
                      v82 = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                      if ( v82 > 0 )
                        v6->m_halfBuffer.m_freeIDs[v6->m_halfBuffer.m_firstOccupiedIndex++] = v82;
                    }
                    else
                    {
                      glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
                    }
                  }
                  else
                  {
                    v81 = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                    if ( v81 > 0 )
                      v6->m_thirdBuffer.m_freeIDs[v6->m_thirdBuffer.m_firstOccupiedIndex++] = v81;
                  }
                }
                this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
                return;
              }
              if ( v75 != 208 )
              {
                if ( v75 == 144 )
                {
                  v43 = 144;
                  goto LABEL_102;
                }
                v43 = 88;
              }
            }
            v47 += 56;
            goto LABEL_102;
          }
        }
      }
    }
  }
}

void __fastcall AppMain::CharHighlightExtractionWithoutDepth(
        AppMain *this,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        int width,
        int height)
{
  Framework::GLManager *v5; // r13
  unsigned int *p_m_FrameBufferID; // rdx
  bool v11; // zf
  unsigned int v12; // eax
  unsigned int m_TexID; // edx
  unsigned int v14; // ecx
  Framework::GLManager *v15; // rcx
  unsigned int v16; // er8
  unsigned int v17; // eax
  unsigned int v18; // edx
  unsigned int v19; // ecx
  Framework::GLManager *v20; // rcx
  unsigned int v21; // edx
  Framework::GLManager *v22; // rcx
  Graphics *v23; // rcx
  OGLShader *v24; // r15
  Framework::GLManager *v25; // rcx
  int v26; // ebx
  unsigned __int64 v27; // r8
  _QWORD *v28; // rax
  int *v29; // r8
  char *v30; // r14
  float *v31; // rdx
  __int64 v32; // r9
  float *v33; // rcx
  float v34; // xmm0_4
  __m128 v35; // xmm1
  float v36; // eax
  unsigned __int64 v37; // xmm0_8
  __m128 v38; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v40; // xmm2
  __m128 v41; // xmm3
  __m128 v42; // xmm4
  __m128 v43; // xmm5
  __m128 v44; // xmm6
  __m128 v45; // xmm7
  __m128 v46; // xmm8
  __m128 v47; // xmm9
  int v48; // ecx
  unsigned __int8 v49; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v51; // rsi
  __int64 v52; // rcx
  Framework::GLManager *v53; // r13
  signed int v54; // er10
  int renderSize; // ecx
  int v56; // eax
  int *v57; // rax
  __int64 v58; // rcx
  int v59; // eax
  AppMain *v60; // rcx
  int v61; // edx
  unsigned int v62; // ecx
  int v63; // [rsp+28h] [rbp-E0h]
  unsigned int v64; // [rsp+40h] [rbp-C8h]
  __int128 v65; // [rsp+48h] [rbp-C0h]
  __int128 v66; // [rsp+58h] [rbp-B0h]
  __int128 v67; // [rsp+68h] [rbp-A0h]
  __int128 v68; // [rsp+78h] [rbp-90h]
  __int128 v69; // [rsp+88h] [rbp-80h]
  __int128 v70; // [rsp+98h] [rbp-70h]
  __int128 v71; // [rsp+A8h] [rbp-60h]
  __int128 v72; // [rsp+B8h] [rbp-50h]
  float v[4]; // [rsp+C8h] [rbp-40h] BYREF
  float value[4]; // [rsp+D8h] [rbp-30h] BYREF
  __int128 v75; // [rsp+E8h] [rbp-20h]
  __int128 v76; // [rsp+F8h] [rbp-10h]
  __int128 v77; // [rsp+108h] [rbp+0h]
  float v78[4]; // [rsp+118h] [rbp+10h] BYREF
  __int128 v79; // [rsp+128h] [rbp+20h]
  __int128 v80; // [rsp+138h] [rbp+30h]
  __int128 v81; // [rsp+148h] [rbp+40h]
  int v82; // [rsp+158h] [rbp+50h] BYREF
  __int64 v83; // [rsp+15Ch] [rbp+54h]
  int v84; // [rsp+164h] [rbp+5Ch]
  int v85; // [rsp+168h] [rbp+60h]
  int v86; // [rsp+16Ch] [rbp+64h]
  int v87; // [rsp+170h] [rbp+68h]
  int v88; // [rsp+174h] [rbp+6Ch]
  __int64 v89; // [rsp+180h] [rbp+78h]
  __int64 v90; // [rsp+188h] [rbp+80h] BYREF
  float v91; // [rsp+190h] [rbp+88h]
  int v92; // [rsp+194h] [rbp+8Ch]
  float v93; // [rsp+198h] [rbp+90h]
  __int64 v94; // [rsp+19Ch] [rbp+94h]
  float v95; // [rsp+1A4h] [rbp+9Ch]
  float v96; // [rsp+1A8h] [rbp+A0h]
  int v97; // [rsp+1ACh] [rbp+A4h]
  float v98[4]; // [rsp+1B8h] [rbp+B0h] BYREF

  if ( pSrcTexture )
  {
    v5 = Framework::GLManager::glm;
    if ( pDestTexture )
    {
      p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
      v11 = *p_m_FrameBufferID == 0;
      v90 = 0i64;
      v89 = 0i64;
      v94 = 0i64;
      v97 = 0;
      v92 = 0;
      v83 = 0i64;
      v82 = 0;
      v86 = 0;
      v95 = (float)width;
      v96 = (float)height;
      v91 = (float)height;
      v93 = (float)width;
      v87 = 1065353216;
      v85 = 1065353216;
      v88 = 1065353216;
      v84 = 1065353216;
      if ( v11 )
        glGenRenderbuffersAG(1, p_m_FrameBufferID);
      if ( !pDestTexture->m_TexID )
        glGenTexturesAG(1, &pDestTexture->m_TexID);
      v12 = m_ActiveTexture;
      if ( m_ActiveTexture )
      {
        m_ActiveTexture = 0;
        _glewActiveTexture(0x84C0u);
        v12 = m_ActiveTexture;
      }
      m_TexID = pSrcTexture->m_TexID;
      v14 = v12;
      if ( m_TexID != ::m_TexID[v12] || !m_TexID )
      {
        ::m_TexID[v12] = m_TexID;
        v15 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = m_TexID;
        while ( v15->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, m_TexID);
      }
      glBindRenderbufferAG(v14, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
      v17 = m_ActiveTexture;
      if ( m_ActiveTexture != 1 )
      {
        m_ActiveTexture = 1;
        _glewActiveTexture(0x84C1u);
        v17 = m_ActiveTexture;
      }
      v18 = pDestTexture->m_TexID;
      v19 = v17;
      if ( v18 != ::m_TexID[v17] || !v18 )
      {
        ::m_TexID[v17] = v18;
        v20 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v18;
        while ( v20->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v18);
      }
      glsFramebufferTexture2D(v19, 0x8CE1u, v16, pDestTexture->m_TexID, v63, width, height, v64);
      v21 = pDestTexture->m_TexID;
      if ( v21 != ::m_TexID[m_ActiveTexture] || !v21 )
      {
        v22 = Framework::GLManager::glm;
        ::m_TexID[m_ActiveTexture] = v21;
        v22->m_textureID = v21;
        while ( v22->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v21);
      }
      glTexParameterf(0xDE1u, 0x2801u, 9729.0);
      glTexParameterf(0xDE1u, 0x2800u, 9729.0);
      glTexParameterf(0xDE1u, 0x2802u, 33071.0);
      glTexParameterf(0xDE1u, 0x2803u, 33071.0);
      pDestTexture->m_TexParam = 1290;
      Graphics::clearScreen(v23, 0);
      if ( m_DepthMask != 1 )
      {
        m_DepthMask = 1;
        glDepthMask(1u);
      }
      glClearAG(0x100u);
      GraphicsOpt::lock(this->g);
      v24 = this->m_pRender->m_ShaderFXTbl[7933];
      if ( v24 )
      {
        if ( v24->m_Program )
        {
          KOFShaderManager::useProgramSlot(
            (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
            v24->m_programSlot);
          v25 = Framework::GLManager::glm;
          v26 = 64;
          Framework::GLManager::glm->renderSize = 64;
          v28 = AgFrameAllocator<AgAllocator<1>>::allocate(&v25->m_agDrawAllocator, 0x100ui64, v27);
          v29 = &v82;
          v30 = (char *)v28;
          v31 = (float *)&v90;
          v32 = 4i64;
          v33 = (float *)(v28 + 7);
          do
          {
            v34 = *v31;
            v29 += 2;
            v35 = (__m128)*((unsigned int *)v31 - 1);
            v31 += 3;
            v[2] = v34;
            v36 = v34;
            v37 = _mm_unpacklo_ps((__m128)*((unsigned int *)v31 - 5), v35).m128_u64[0];
            v38 = (__m128)(unsigned int)*(v29 - 1);
            *((_QWORD *)v33 - 7) = v37;
            *(_QWORD *)v33 = _mm_unpacklo_ps((__m128)(unsigned int)*(v29 - 2), v38).m128_u64[0];
            *(v33 - 12) = v36;
            *((_OWORD *)v33 - 1) = _xmm;
            v33 += 16;
            --v32;
          }
          while ( v32 );
          v5->m_vertexInfoCount = 4;
          m_pRender = this->m_pRender;
          v40 = *(__m128 *)m_pRender->m_View.m;
          v41 = *(__m128 *)&m_pRender->m_View.m[4];
          v42 = *(__m128 *)&m_pRender->m_View.m[8];
          v43 = *(__m128 *)&m_pRender->m_View.m[12];
          v44 = *(__m128 *)m_pRender->m_Proj.m;
          v45 = *(__m128 *)&m_pRender->m_Proj.m[4];
          v46 = *(__m128 *)&m_pRender->m_Proj.m[8];
          v47 = *(__m128 *)&m_pRender->m_Proj.m[12];
          *(_QWORD *)&v65 = __PAIR64__(v41.m128_u32[0], v40.m128_u32[0]);
          LODWORD(v66) = _mm_shuffle_ps(v40, v40, 85).m128_u32[0];
          LODWORD(v67) = _mm_shuffle_ps(v40, v40, 170).m128_u32[0];
          DWORD1(v66) = _mm_shuffle_ps(v41, v41, 85).m128_u32[0];
          DWORD1(v67) = _mm_shuffle_ps(v41, v41, 170).m128_u32[0];
          DWORD2(v66) = _mm_shuffle_ps(v42, v42, 85).m128_u32[0];
          DWORD2(v67) = _mm_shuffle_ps(v42, v42, 170).m128_u32[0];
          HIDWORD(v66) = _mm_shuffle_ps(v43, v43, 85).m128_u32[0];
          HIDWORD(v67) = _mm_shuffle_ps(v43, v43, 170).m128_u32[0];
          v75 = v66;
          *((_QWORD *)&v65 + 1) = __PAIR64__(v43.m128_u32[0], v42.m128_u32[0]);
          *(_OWORD *)value = v65;
          v76 = v67;
          LODWORD(v70) = _mm_shuffle_ps(v44, v44, 85).m128_u32[0];
          DWORD1(v70) = _mm_shuffle_ps(v45, v45, 85).m128_u32[0];
          LODWORD(v68) = _mm_shuffle_ps(v40, v40, 255).m128_u32[0];
          DWORD1(v68) = _mm_shuffle_ps(v41, v41, 255).m128_u32[0];
          DWORD2(v68) = _mm_shuffle_ps(v42, v42, 255).m128_u32[0];
          HIDWORD(v68) = _mm_shuffle_ps(v43, v43, 255).m128_u32[0];
          v77 = v68;
          LODWORD(v71) = _mm_shuffle_ps(v44, v44, 170).m128_u32[0];
          DWORD1(v71) = _mm_shuffle_ps(v45, v45, 170).m128_u32[0];
          *(_QWORD *)&v69 = __PAIR64__(v45.m128_u32[0], v44.m128_u32[0]);
          *((_QWORD *)&v69 + 1) = __PAIR64__(v47.m128_u32[0], v46.m128_u32[0]);
          DWORD2(v72) = _mm_shuffle_ps(v46, v46, 255).m128_u32[0];
          LODWORD(v72) = _mm_shuffle_ps(v44, v44, 255).m128_u32[0];
          DWORD1(v72) = _mm_shuffle_ps(v45, v45, 255).m128_u32[0];
          DWORD2(v70) = _mm_shuffle_ps(v46, v46, 85).m128_u32[0];
          DWORD2(v71) = _mm_shuffle_ps(v46, v46, 170).m128_u32[0];
          v48 = *v24->m_piGLUniform;
          HIDWORD(v70) = _mm_shuffle_ps(v47, v47, 85).m128_u32[0];
          HIDWORD(v71) = _mm_shuffle_ps(v47, v47, 170).m128_u32[0];
          *(_OWORD *)v78 = v69;
          v79 = v70;
          HIDWORD(v72) = _mm_shuffle_ps(v47, v47, 255).m128_u32[0];
          v80 = v71;
          v81 = v72;
          glUniformMatrix4fvAG(v48, 1, (unsigned __int8)v29, value);
          glUniformMatrix4fvAG(v24->m_piGLUniform[1], 1, v49, v78);
          m_piGLUniform = v24->m_piGLUniform;
          *(_OWORD *)v = _xmm;
          glUniform4fvAG(m_piGLUniform[5], 1, v);
          v51 = AgSingleton<KOFShaderManager>::ms_instance;
          v52 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                          * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                          + 7].onSingletonInit;
          if ( (unsigned int)v52 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v52;
            g_vertexAttribIndex[v52] = 0;
          }
          v53 = Framework::GLManager::glm;
          v54 = *(_DWORD *)v51[11 * SLODWORD(v51[360450].__vftable) + 7].onSingletonInit;
          renderSize = Framework::GLManager::glm->renderSize;
          switch ( renderSize )
          {
            case 64:
              v56 = 64;
              break;
            case 280:
              v56 = 136;
              break;
            case 208:
              v56 = 64;
              break;
            default:
              v56 = 88;
              if ( renderSize == 144 )
                v56 = 144;
              break;
          }
          if ( v54 >= 0 )
          {
            _glewVertexAttribPointer(v54, 3, 0x1406u, 0, v56, v30);
            v53 = Framework::GLManager::glm;
            v51 = AgSingleton<KOFShaderManager>::ms_instance;
          }
          v57 = v24->m_piGLUniform;
          *(_OWORD *)v98 = _xmm;
          glUniform4fvAG(v57[5], 1, v98);
          v58 = *((unsigned int *)v51[11 * SLODWORD(v51[360450].__vftable) + 7].onSingletonInit + 4);
          if ( (unsigned int)v58 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v58;
            g_vertexAttribIndex[v58] = 4;
          }
          v59 = v53->renderSize;
          v60 = (AppMain *)*((unsigned int *)v51[11 * SLODWORD(v51[360450].__vftable) + 7].onSingletonInit + 4);
          if ( v59 != 64 )
          {
            if ( v59 == 280 )
            {
              v26 = 8;
LABEL_54:
              if ( (int)v60 >= 0 )
                _glewVertexAttribPointer((unsigned int)v60, 2, 0x1406u, 0, v26, v30);
              AppMain::SetPostFXUniforms(
                v60,
                v24,
                &this->ModelRoomSettings.postfxUniforms,
                &this->ModelRoomSettings.filterUniforms);
              glDrawArraysAG(v62, v61, 4);
              Graphics::drawStack(this->g->g);
              glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
              this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
              return;
            }
            if ( v59 != 208 )
            {
              if ( v59 == 144 )
              {
                v26 = 144;
                goto LABEL_54;
              }
              v26 = 88;
            }
          }
          v30 += 56;
          goto LABEL_54;
        }
      }
    }
  }
}

void __fastcall AppMain::CharHighlightExtractionWithoutDepthWithMask(
        AppMain *this,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        OGLTexture *pMaskTexture,
        int width,
        int height)
{
  unsigned int *p_m_FrameBufferID; // rdx
  bool v11; // zf
  unsigned int v12; // eax
  unsigned int m_TexID; // edx
  unsigned int v14; // ecx
  Framework::GLManager *v15; // rcx
  unsigned int v16; // er8
  unsigned int v17; // eax
  unsigned int v18; // edx
  unsigned int v19; // ecx
  Framework::GLManager *v20; // rcx
  unsigned int v21; // edx
  Framework::GLManager *v22; // rcx
  Graphics *v23; // rcx
  unsigned int v24; // eax
  unsigned int v25; // edx
  Framework::GLManager *v26; // r8
  OGLShader *v27; // r15
  Framework::GLManager *v28; // rcx
  int v29; // ebx
  unsigned __int64 v30; // r8
  _QWORD *v31; // rax
  int *v32; // r8
  char *v33; // rsi
  float *v34; // rdx
  __int64 v35; // r9
  float *v36; // rcx
  float v37; // xmm0_4
  __m128 v38; // xmm1
  float v39; // eax
  unsigned __int64 v40; // xmm0_8
  __m128 v41; // xmm1
  OGLRender *m_pRender; // rax
  __int128 v43; // xmm1
  __int128 v44; // xmm0
  __int128 v45; // xmm1
  __int128 v46; // xmm0
  __int128 v47; // xmm1
  __int128 v48; // xmm0
  __int128 v49; // xmm1
  unsigned __int8 v50; // r8
  unsigned __int8 v51; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v53; // r14
  __int64 v54; // rcx
  Framework::GLManager *v55; // r13
  signed int v56; // er10
  int renderSize; // ecx
  int v58; // eax
  int *v59; // rax
  __int64 v60; // rcx
  int v61; // eax
  AppMain *v62; // rcx
  int v63; // edx
  unsigned int v64; // ecx
  int v65; // [rsp+20h] [rbp-E0h]
  unsigned int v66; // [rsp+38h] [rbp-C8h]
  Framework::GLManager *v67; // [rsp+40h] [rbp-C0h]
  float v[4]; // [rsp+48h] [rbp-B8h] BYREF
  OGLMatrix v69; // [rsp+60h] [rbp-A0h] BYREF
  OGLMatrix v70; // [rsp+A0h] [rbp-60h] BYREF
  int v71; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v72; // [rsp+E4h] [rbp-1Ch]
  int v73; // [rsp+ECh] [rbp-14h]
  int v74; // [rsp+F0h] [rbp-10h]
  int v75; // [rsp+F4h] [rbp-Ch]
  int v76; // [rsp+F8h] [rbp-8h]
  int v77; // [rsp+FCh] [rbp-4h]
  __int64 v78; // [rsp+108h] [rbp+8h]
  __int64 v79; // [rsp+110h] [rbp+10h] BYREF
  float v80; // [rsp+118h] [rbp+18h]
  int v81; // [rsp+11Ch] [rbp+1Ch]
  float v82; // [rsp+120h] [rbp+20h]
  __int64 v83; // [rsp+124h] [rbp+24h]
  float v84; // [rsp+12Ch] [rbp+2Ch]
  float v85; // [rsp+130h] [rbp+30h]
  int v86; // [rsp+134h] [rbp+34h]
  float v87[4]; // [rsp+140h] [rbp+40h] BYREF

  if ( pSrcTexture )
  {
    v67 = Framework::GLManager::glm;
    if ( pDestTexture )
    {
      if ( pMaskTexture )
      {
        p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
        v11 = *p_m_FrameBufferID == 0;
        v79 = 0i64;
        v78 = 0i64;
        v83 = 0i64;
        v86 = 0;
        v81 = 0;
        v72 = 0i64;
        v71 = 0;
        v75 = 0;
        v84 = (float)width;
        v85 = (float)height;
        v80 = (float)height;
        v82 = (float)width;
        v76 = 1065353216;
        v74 = 1065353216;
        v77 = 1065353216;
        v73 = 1065353216;
        if ( v11 )
          glGenRenderbuffersAG(1, p_m_FrameBufferID);
        if ( !pDestTexture->m_TexID )
          glGenTexturesAG(1, &pDestTexture->m_TexID);
        v12 = m_ActiveTexture;
        if ( m_ActiveTexture )
        {
          m_ActiveTexture = 0;
          _glewActiveTexture(0x84C0u);
          v12 = m_ActiveTexture;
        }
        m_TexID = pSrcTexture->m_TexID;
        v14 = v12;
        if ( m_TexID != ::m_TexID[v12] || !m_TexID )
        {
          ::m_TexID[v12] = m_TexID;
          v15 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = m_TexID;
          while ( v15->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, m_TexID);
        }
        glBindRenderbufferAG(v14, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
        v17 = m_ActiveTexture;
        if ( m_ActiveTexture != 1 )
        {
          m_ActiveTexture = 1;
          _glewActiveTexture(0x84C1u);
          v17 = m_ActiveTexture;
        }
        v18 = pDestTexture->m_TexID;
        v19 = v17;
        if ( v18 != ::m_TexID[v17] || !v18 )
        {
          ::m_TexID[v17] = v18;
          v20 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v18;
          while ( v20->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v18);
        }
        glsFramebufferTexture2D(v19, 0x8CE1u, v16, pDestTexture->m_TexID, v65, width, height, v66);
        v21 = pDestTexture->m_TexID;
        if ( v21 != ::m_TexID[m_ActiveTexture] || !v21 )
        {
          v22 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v21;
          v22->m_textureID = v21;
          while ( v22->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v21);
        }
        glTexParameterf(0xDE1u, 0x2801u, 9729.0);
        glTexParameterf(0xDE1u, 0x2800u, 9729.0);
        glTexParameterf(0xDE1u, 0x2802u, 33071.0);
        glTexParameterf(0xDE1u, 0x2803u, 33071.0);
        v24 = m_ActiveTexture;
        pDestTexture->m_TexParam = 1290;
        if ( v24 != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
          v24 = m_ActiveTexture;
        }
        v25 = pMaskTexture->m_TexID;
        if ( v25 != ::m_TexID[v24] || !v25 )
        {
          ::m_TexID[v24] = v25;
          v26 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v25;
          while ( v26->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v25);
        }
        Graphics::clearScreen(v23, 0);
        if ( m_DepthMask != 1 )
        {
          m_DepthMask = 1;
          glDepthMask(1u);
        }
        glClearAG(0x100u);
        GraphicsOpt::lock(this->g);
        v27 = this->m_pRender->m_ShaderFXTbl[7934];
        if ( v27 )
        {
          if ( v27->m_Program )
          {
            KOFShaderManager::useProgramSlot(
              (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
              v27->m_programSlot);
            v28 = Framework::GLManager::glm;
            v29 = 64;
            Framework::GLManager::glm->renderSize = 64;
            v31 = AgFrameAllocator<AgAllocator<1>>::allocate(&v28->m_agDrawAllocator, 0x100ui64, v30);
            v32 = &v71;
            v33 = (char *)v31;
            v34 = (float *)&v79;
            v35 = 4i64;
            v36 = (float *)(v31 + 7);
            do
            {
              v37 = *v34;
              v32 += 2;
              v38 = (__m128)*((unsigned int *)v34 - 1);
              v34 += 3;
              v[2] = v37;
              v39 = v37;
              v40 = _mm_unpacklo_ps((__m128)*((unsigned int *)v34 - 5), v38).m128_u64[0];
              v41 = (__m128)(unsigned int)*(v32 - 1);
              *((_QWORD *)v36 - 7) = v40;
              *(_QWORD *)v36 = _mm_unpacklo_ps((__m128)(unsigned int)*(v32 - 2), v41).m128_u64[0];
              *(v36 - 12) = v39;
              *((_OWORD *)v36 - 1) = _xmm;
              v36 += 16;
              --v35;
            }
            while ( v35 );
            v67->m_vertexInfoCount = 4;
            m_pRender = this->m_pRender;
            v43 = *(_OWORD *)&m_pRender->m_View.m[4];
            *(_OWORD *)v69.m = *(_OWORD *)m_pRender->m_View.m;
            v44 = *(_OWORD *)&m_pRender->m_View.m[8];
            *(_OWORD *)&v69.m[4] = v43;
            v45 = *(_OWORD *)&m_pRender->m_View.m[12];
            *(_OWORD *)&v69.m[8] = v44;
            v46 = *(_OWORD *)m_pRender->m_Proj.m;
            *(_OWORD *)&v69.m[12] = v45;
            v47 = *(_OWORD *)&m_pRender->m_Proj.m[4];
            *(_OWORD *)v70.m = v46;
            v48 = *(_OWORD *)&m_pRender->m_Proj.m[8];
            *(_OWORD *)&v70.m[4] = v47;
            v49 = *(_OWORD *)&m_pRender->m_Proj.m[12];
            *(_OWORD *)&v70.m[8] = v48;
            *(_OWORD *)&v70.m[12] = v49;
            OGLMatrix::transpose(&v69);
            OGLMatrix::transpose(&v70);
            glUniformMatrix4fvAG(*v27->m_piGLUniform, 1, v50, v69.m);
            glUniformMatrix4fvAG(v27->m_piGLUniform[1], 1, v51, v70.m);
            m_piGLUniform = v27->m_piGLUniform;
            *(_OWORD *)v = _xmm;
            glUniform4fvAG(m_piGLUniform[5], 1, v);
            v53 = AgSingleton<KOFShaderManager>::ms_instance;
            v54 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                            * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                            + 7].onSingletonInit;
            if ( (unsigned int)v54 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v54;
              g_vertexAttribIndex[v54] = 0;
            }
            v55 = Framework::GLManager::glm;
            v56 = *(_DWORD *)v53[11 * SLODWORD(v53[360450].__vftable) + 7].onSingletonInit;
            renderSize = Framework::GLManager::glm->renderSize;
            switch ( renderSize )
            {
              case 64:
                v58 = 64;
                break;
              case 280:
                v58 = 136;
                break;
              case 208:
                v58 = 64;
                break;
              default:
                v58 = 88;
                if ( renderSize == 144 )
                  v58 = 144;
                break;
            }
            if ( v56 >= 0 )
            {
              _glewVertexAttribPointer(v56, 3, 0x1406u, 0, v58, v33);
              v55 = Framework::GLManager::glm;
              v53 = AgSingleton<KOFShaderManager>::ms_instance;
            }
            v59 = v27->m_piGLUniform;
            *(_OWORD *)v87 = _xmm;
            glUniform4fvAG(v59[5], 1, v87);
            v60 = *((unsigned int *)v53[11 * SLODWORD(v53[360450].__vftable) + 7].onSingletonInit + 4);
            if ( (unsigned int)v60 < g_maxEnabledVertexAttribArrays )
            {
              g_pendingVertexAttribArrays |= 1 << v60;
              g_vertexAttribIndex[v60] = 4;
            }
            v61 = v55->renderSize;
            v62 = (AppMain *)*((unsigned int *)v53[11 * SLODWORD(v53[360450].__vftable) + 7].onSingletonInit + 4);
            if ( v61 != 64 )
            {
              if ( v61 == 280 )
              {
                v29 = 8;
LABEL_62:
                if ( (int)v62 >= 0 )
                  _glewVertexAttribPointer((unsigned int)v62, 2, 0x1406u, 0, v29, v33);
                AppMain::SetPostFXUniforms(
                  v62,
                  v27,
                  &this->ModelRoomSettings.postfxUniforms,
                  &this->ModelRoomSettings.filterUniforms);
                glDrawArraysAG(v64, v63, 4);
                Graphics::drawStack(this->g->g);
                glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
                this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
                return;
              }
              if ( v61 != 208 )
              {
                if ( v61 == 144 )
                {
                  v29 = 144;
                  goto LABEL_62;
                }
                v29 = 88;
              }
            }
            v33 += 56;
            goto LABEL_62;
          }
        }
      }
    }
  }
}

void __fastcall extension::BasicFutureObject<OGLCamera,void>::AssetCache::CleanupExpiredEntry(
        extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::AssetCache *this)
{
  _RTL_CRITICAL_SECTION *v1; // rsi
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rbx
  std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > v5; // r8
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // rax
  std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > result; // [rsp+30h] [rbp+8h] BYREF

  v1 = (_RTL_CRITICAL_SECTION *)&this->extension::ExSimpleLockable<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::AssetCache>;
  if ( !this )
    v1 = 0i64;
  EnterCriticalSection(v1);
  Myhead = this->m_cachedObjectMap._List._Mypair._Myval2._Myhead;
  Next = Myhead->_Next;
  if ( Myhead->_Next != Myhead )
  {
    do
    {
      v5._Ptr = Next;
      Next = Next->_Next;
      m_ptr = v5._Ptr->_Myval.second.m_proxy.m_ptr;
      if ( !m_ptr || !m_ptr->m_sharedCount.m_value._My_val )
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>>,0>>::erase(
          &this->m_cachedObjectMap,
          &result,
          v5);
    }
    while ( Next != this->m_cachedObjectMap._List._Mypair._Myval2._Myhead );
  }
  LeaveCriticalSection(v1);
}

void __fastcall AppMain::ClearMotionBlurFrames(AppMain *this, int characterId)
{
  __int64 v2; // r14
  __int64 v3; // r15
  __int64 v4; // rdi
  unsigned int *v6; // rbx
  __int64 v7; // rsi
  unsigned int *v8; // rax
  __int64 v9; // rcx
  unsigned int *p_m_TexID; // rdx
  GLuint v11; // er8
  __int64 v12; // rcx
  unsigned int *v13; // rax
  unsigned int *v14; // rdx
  GLuint v15; // er8
  __int64 v16; // rdi
  unsigned int *v17; // rdx
  unsigned int *v18; // rax
  __int64 v19; // rcx
  GLuint v20; // er8
  unsigned int *v21; // rdx
  GLuint v22; // eax

  v2 = 5i64;
  v3 = characterId;
  v4 = 5i64 * characterId;
  v6 = m_TexID;
  v7 = 32i64;
  do
  {
    v8 = m_TexID;
    v9 = 32i64;
    p_m_TexID = &this->m_pRender->m_renderTextures.m_CharacterFrames[0][v4].m_TexID;
    v11 = *p_m_TexID;
    do
    {
      if ( v11 == *v8 )
        *v8 = 0;
      ++v8;
      --v9;
    }
    while ( v9 );
    glDeleteTextures(1, p_m_TexID);
    v12 = 32i64;
    this->m_pRender->m_renderTextures.m_CharacterFrames[0][v4].m_TexID = 0;
    v13 = m_TexID;
    v14 = &this->m_pRender->m_renderTextures.m_CharacterFramesDepth[0][v4].m_TexID;
    v15 = *v14;
    do
    {
      if ( v15 == *v13 )
        *v13 = 0;
      ++v13;
      --v12;
    }
    while ( v12 );
    glDeleteTextures(1, v14);
    this->m_pRender->m_renderTextures.m_CharacterFramesDepth[0][v4++].m_TexID = 0;
    --v2;
  }
  while ( v2 );
  v16 = v3;
  v17 = &this->m_pRender->m_renderTextures.m_MergedTexture[v3].m_TexID;
  v18 = m_TexID;
  v19 = 32i64;
  v20 = *v17;
  do
  {
    if ( v20 == *v18 )
      *v18 = 0;
    ++v18;
    --v19;
  }
  while ( v19 );
  glDeleteTextures(1, v17);
  this->m_pRender->m_renderTextures.m_MergedTexture[v16].m_TexID = 0;
  v21 = &this->m_pRender->m_renderTextures.m_MergedDepthTexture[v16].m_TexID;
  v22 = *v21;
  do
  {
    if ( v22 == *v6 )
      *v6 = 0;
    ++v6;
    --v7;
  }
  while ( v7 );
  glDeleteTextures(1, v21);
  this->m_pRender->m_renderTextures.m_MergedDepthTexture[v16].m_TexID = 0;
}

void __fastcall AppMain::CombineTwoDepthTexturesCS(
        AppMain *this,
        OGLTexture *pOGLDepthTexture1,
        OGLTexture *pOGLDepthTexture2,
        OGLTexture *pOGLDestTexture)
{
  Framework::GLManager *v5; // rsi
  int m_iScreenW; // er15
  int height; // er13
  unsigned int m_TexID; // edx
  Framework::GLManager *v12; // rcx
  unsigned int v13; // eax
  unsigned int v14; // edx
  Framework::GLManager *v15; // rcx
  unsigned int v16; // edx
  Framework::GLManager *v17; // r8
  OGLShader *v18; // rbx
  AppMain *v19; // rcx

  v5 = Framework::GLManager::glm;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Combine Depth");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 13, "Combine Depth");
  ++markerCount;
  m_iScreenW = this->m_iScreenW;
  height = this->m_iScreenH;
  if ( !pOGLDestTexture->m_TexID )
  {
    glGenTexturesAG(1, &pOGLDestTexture->m_TexID);
    m_TexID = pOGLDestTexture->m_TexID;
    if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
    {
      v12 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = m_TexID;
      v12->m_textureID = m_TexID;
      while ( v12->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
  }
  _glewBindImageTexture(0, pOGLDestTexture->m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  v13 = m_ActiveTexture;
  if ( m_ActiveTexture != 1 )
  {
    m_ActiveTexture = 1;
    _glewActiveTexture(0x84C1u);
    v13 = m_ActiveTexture;
  }
  v14 = pOGLDepthTexture1->m_TexID;
  if ( v14 != ::m_TexID[v13] || !v14 )
  {
    ::m_TexID[v13] = v14;
    v15 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = v14;
    while ( v15->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v14);
    v13 = m_ActiveTexture;
  }
  if ( v13 != 2 )
  {
    m_ActiveTexture = 2;
    _glewActiveTexture(0x84C2u);
    v13 = m_ActiveTexture;
  }
  v16 = pOGLDepthTexture2->m_TexID;
  if ( v16 != ::m_TexID[v13] || !v16 )
  {
    ::m_TexID[v13] = v16;
    v17 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = v16;
    while ( v17->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v16);
  }
  v18 = this->m_pRender->m_ComputeShaderTbl[7];
  KOFShaderManager::useProgramSlot((KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance, v18->m_programSlot);
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  AppMain::SetPostFXUniforms(v19, v18, &this->ModelRoomSettings.postfxUniforms, &this->ModelRoomSettings.filterUniforms);
  while ( v5->m_bOpenGLBlocked )
    ;
  _glewDispatchCompute((m_iScreenW + 15) / 16, (height + 15) / 16, 1u);
  _glewMemoryBarrier(0x20u);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::CopyDepthTextureCS(AppMain *this, OGLTexture *pOGLDepthTexture1, OGLTexture *pOGLDestTexture)
{
  int m_iScreenW; // ebp
  unsigned int *p_m_TexID; // rbx
  int height; // er14
  GLuint v8; // edx
  Framework::GLManager *v9; // rcx
  __int64 v10; // rax
  unsigned int m_TexID; // edx
  Framework::GLManager *v12; // r8

  m_iScreenW = this->m_iScreenW;
  p_m_TexID = &pOGLDestTexture->m_TexID;
  height = this->m_iScreenH;
  if ( !pOGLDestTexture->m_TexID )
  {
    glGenTexturesAG(1, &pOGLDestTexture->m_TexID);
    v8 = *p_m_TexID;
    if ( *p_m_TexID != ::m_TexID[m_ActiveTexture] || !v8 )
    {
      v9 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v8;
      v9->m_textureID = v8;
      while ( v9->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v8);
    }
    glTexParameteri(0xDE1u, 0x813Cu, 0);
    glTexParameteri(0xDE1u, 0x813Du, 0);
    while ( Framework::GLManager::glm->m_bOpenGLBlocked )
      ;
    glTexImage2D(0xDE1u, 0, 32856, m_iScreenW, height, 0, 0x1908u, 0x1401u, 0i64);
  }
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
  }
  _glewBindImageTexture(0, *p_m_TexID, 0, 0, 0, 0x88B9u, 0x8058u);
  v10 = m_ActiveTexture;
  if ( m_ActiveTexture != 1 )
  {
    m_ActiveTexture = 1;
    _glewActiveTexture(0x84C1u);
    v10 = m_ActiveTexture;
  }
  m_TexID = pOGLDepthTexture1->m_TexID;
  if ( m_TexID != ::m_TexID[v10] || !m_TexID )
  {
    v12 = Framework::GLManager::glm;
    ::m_TexID[v10] = m_TexID;
    v12->m_textureID = m_TexID;
    while ( v12->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
  }
  KOFShaderManager::useProgramSlot(
    (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
    this->m_pRender->m_ComputeShaderTbl[3]->m_programSlot);
  while ( Framework::GLManager::glm->m_bOpenGLBlocked )
    ;
  _glewDispatchCompute((m_iScreenW + 255) / 256, height, 1u);
  _glewMemoryBarrier(0x20u);
}

void __fastcall AppMain::CreateWaterMap(AppMain *this)
{
  __int64 v1; // r10
  OGLModel **i; // r9
  unsigned __int64 v4; // rdx
  int m_ucMaterialCount; // er8
  OGLMaterial *m_pMaterial; // rax
  OGLModel *v7; // rcx
  float v8; // xmm1_4
  float v9; // eax
  float v10; // xmm2_4
  int v11; // edx
  int v12; // er8
  float v13; // xmm0_4
  OGLRender *m_pRender; // r8
  Vector4Unaligned v15; // xmm0
  __m128 v16; // xmm1
  float z; // eax
  __m128i v18; // xmm1
  __m128i v19; // xmm0
  void *v20; // rdx
  int v21; // er8
  float look[2]; // [rsp+40h] [rbp-28h] BYREF
  float v23; // [rsp+48h] [rbp-20h]
  Vector4Unaligned position; // [rsp+50h] [rbp-18h] BYREF

  v1 = 0i64;
  for ( i = this->pModel; ; ++i )
  {
    if ( *i )
    {
      v4 = 0i64;
      m_ucMaterialCount = (*i)->m_ucMaterialCount;
      if ( (*i)->m_ucMaterialCount )
        break;
    }
LABEL_8:
    if ( ++v1 >= 44 )
      return;
  }
  m_pMaterial = (*i)->m_pMaterial;
  while ( !m_pMaterial || (m_pMaterial->m_ucEffectFlg & 0x1000000) == 0 )
  {
    v4 = (unsigned int)(v4 + 1);
    ++m_pMaterial;
    if ( (int)v4 >= m_ucMaterialCount )
      goto LABEL_8;
  }
  v7 = this->pModel[v1];
  if ( v7 )
  {
    v8 = this->ModelRoomSettings.fCamPos[1];
    v9 = this->ModelRoomSettings.fCamPos[2];
    *(_QWORD *)&position.x = *(_QWORD *)this->ModelRoomSettings.fCamPos;
    position.z = v9;
    v10 = v7->m_pfVertexCoord[1];
    v23 = this->ModelRoomSettings.fCamLook[2];
    *(_QWORD *)look = *(_QWORD *)this->ModelRoomSettings.fCamLook;
    position.y = v8 - (float)((float)(v8 - v10) + (float)(v8 - v10));
    look[1] = this->ModelRoomSettings.fCamLook[1]
            - (float)((float)(this->ModelRoomSettings.fCamLook[1] - v10)
                    + (float)(this->ModelRoomSettings.fCamLook[1] - v10));
    AppMain::setRenderCamera(this, (void *)v4, m_ucMaterialCount, &position.x, look, this->ModelRoomSettings.fCamUp);
    AppMain::RenderReflectionToTexturePass(this, v11, v12);
    v13 = this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterTranslation
        + this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.currentWaterTrans;
    this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.currentWaterTrans = v13;
    m_pRender = this->m_pRender;
    this->ModelRoomSettings.postfxUniforms.u_postfxWaterTranslation = v13;
    this->ModelRoomSettings.postfxUniforms.u_postfxWaterReflectScale = this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.reflectScale;
    v15 = *(Vector4Unaligned *)this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.windDirection;
    this->ModelRoomSettings.postfxUniforms.u_postfxWindDir = v15;
    v16 = (__m128)LODWORD(this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterCol[1]);
    position = v15;
    position.z = this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterCol[2];
    z = position.z;
    *(_QWORD *)&v15.x = _mm_unpacklo_ps(
                          (__m128)LODWORD(this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterCol[0]),
                          v16).m128_u64[0];
    v18 = _mm_cvtsi32_si128(this->m_iScreenW);
    *(_QWORD *)&this->ModelRoomSettings.postfxUniforms.u_postfxWaterTint.x = *(_QWORD *)&v15.x;
    v19 = _mm_cvtsi32_si128(this->m_iScreenH);
    this->ModelRoomSettings.postfxUniforms.u_postfxWaterTint.z = z;
    this->ModelRoomSettings.postfxUniforms.u_postfxWaterUseReflection = this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.useReflection;
    AppMain::ApplyShaderToTexture(
      this,
      7996,
      m_pRender->m_renderTextures.m_ReflectionTexture,
      &m_pRender->m_renderTextures.m_ReflectionTexture[1],
      (int)_mm_cvtepi32_ps(v18).m128_f32[0],
      (int)_mm_cvtepi32_ps(v19).m128_f32[0],
      0);
    AppMain::setRenderCamera(
      this,
      v20,
      v21,
      this->ModelRoomSettings.fCamPos,
      this->ModelRoomSettings.fCamLook,
      this->ModelRoomSettings.fCamUp);
  }
}

void __fastcall AppMain::DepthFilterBloom(AppMain *this)
{
  __m128i v2; // xmm0
  __m128i v3; // xmm1
  OGLRender *m_pRender; // r8

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Depth Filter");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 12, "Depth Filter");
  v2 = _mm_cvtsi32_si128(this->m_iScreenH);
  v3 = _mm_cvtsi32_si128(this->m_iScreenW);
  m_pRender = this->m_pRender;
  ++markerCount;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  AppMain::ApplyShaderToTexture(
    this,
    7936,
    &m_pRender->m_renderTextures.m_BloomMapTexture,
    &m_pRender->m_renderTextures.m_BloomMapTexture,
    (int)_mm_cvtepi32_ps(v3).m128_f32[0],
    (int)_mm_cvtepi32_ps(v2).m128_f32[0],
    1);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::DepthOfFieldEffect(AppMain *this, float dofNear, float dofFar, float dofStrength)
{
  void (__fastcall *v4)(int, const char *); // r8
  void (__fastcall *v6)(unsigned int, unsigned int, int, const char *); // rax
  __m128i v7; // xmm7
  __m128i v8; // xmm6
  float v9; // xmm6_4
  float v10; // xmm7_4
  OGLRender *m_pRender; // r8
  OGLRender *v12; // r8
  void (*v13)(void); // rdx
  void (*v14)(void); // rcx
  int v15; // eax

  v4 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "DOF");
    v4 = _glewPushGroupMarkerEXT;
  }
  v6 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 3, "DOF");
    v4 = _glewPushGroupMarkerEXT;
    v6 = _glewPushDebugGroup;
  }
  ++markerCount;
  this->ModelRoomSettings.postfxUniforms.u_postfxDOFNearFarStr.y = dofFar;
  v7 = _mm_cvtsi32_si128(this->m_iScreenH);
  this->ModelRoomSettings.postfxUniforms.u_postfxDOFNearFarStr.z = dofStrength;
  v8 = _mm_cvtsi32_si128(this->m_iScreenW);
  this->ModelRoomSettings.postfxUniforms.u_postfxDOFNearFarStr.x = dofNear;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  v9 = _mm_cvtepi32_ps(v8).m128_f32[0];
  v10 = _mm_cvtepi32_ps(v7).m128_f32[0];
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v9;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v10;
  if ( v4 )
  {
    v4(0, "DOF Horiz");
    v6 = _glewPushDebugGroup;
  }
  if ( v6 )
    v6(33354u, 1u, 9, "DOF Horiz");
  m_pRender = this->m_pRender;
  ++markerCount;
  AppMain::ApplyShaderToTexture(
    this,
    7944,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    (int)v9,
    (int)v10,
    0);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "DOF Vert");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 8, "DOF Vert");
  v12 = this->m_pRender;
  ++markerCount;
  AppMain::ApplyShaderToTexture(
    this,
    7945,
    v12->m_renderTextures.m_FullScreenTexture,
    v12->m_renderTextures.m_FullScreenTexture,
    (int)v9,
    (int)v10,
    0);
  v13 = _glewPopGroupMarkerEXT;
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v13 = _glewPopGroupMarkerEXT;
  }
  v14 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v13 = _glewPopGroupMarkerEXT;
    v14 = _glewPopDebugGroup;
  }
  v15 = --markerCount;
  if ( v13 )
  {
    v13();
    v15 = markerCount;
    v14 = _glewPopDebugGroup;
  }
  if ( v14 )
  {
    v14();
    --markerCount;
  }
  else
  {
    markerCount = v15 - 1;
  }
}

void __fastcall AppMain::DoHeatHaze(AppMain *this)
{
  float v2; // xmm0_4
  float v3; // xmm3_4
  int v4; // [rsp+20h] [rbp-18h]

  if ( this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeOn
    && this->SaveDataMain.GraphicsOptionData.bHeatHazeEnabled )
  {
    v2 = AppMain::_MODELROOM_SETTINGS::CalcCamDotFromFront(&this->ModelRoomSettings);
    if ( v2 > 0.4 )
    {
      v3 = *(float *)&FLOAT_1_0;
      if ( v2 < 0.7 )
        v3 = (v2 - 0.4) / 0.2999999999999999 + 0.0;
      AppMain::HeatHazeShader(
        this,
        this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeNear,
        this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeSpeed,
        v3 * this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeStrength,
        v4);
    }
  }
}

void __fastcall AppMain::DownsampleTexture(
        AppMain *this,
        int shader,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        int width,
        int height)
{
  Framework::GLManager *v6; // rbx
  unsigned int u_postfxBlurSize; // eax
  __int64 v10; // r14
  unsigned int *p_m_FrameBufferID; // rdx
  bool v12; // zf
  float v13; // xmm10_4
  float m_targetWidth; // xmm1_4
  unsigned int v15; // edx
  float v16; // xmm1_4
  unsigned int v17; // edx
  unsigned int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  unsigned __int64 v21; // r8
  unsigned int v22; // edx
  Framework::GLManager *v23; // rcx
  unsigned int m_TexID; // edx
  unsigned int v25; // ecx
  Framework::GLManager *v26; // rcx
  unsigned int v27; // edx
  Framework::GLManager *v28; // rcx
  Graphics *v29; // rcx
  OGLShader *v30; // r13
  Framework::GLManager *v31; // rcx
  int v32; // esi
  unsigned __int64 v33; // r8
  _QWORD *v34; // rax
  int *v35; // r8
  char *v36; // r15
  float *v37; // rdx
  __int64 v38; // r9
  float *v39; // rcx
  float v40; // xmm0_4
  __m128 v41; // xmm1
  float v42; // eax
  unsigned __int64 v43; // xmm0_8
  __m128 v44; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v46; // xmm2
  __m128 v47; // xmm3
  __m128 v48; // xmm4
  __m128 v49; // xmm5
  __m128 v50; // xmm6
  __m128 v51; // xmm7
  __m128 v52; // xmm8
  __m128 v53; // xmm9
  int v54; // ecx
  unsigned __int8 v55; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v57; // r14
  __int64 v58; // rcx
  signed int v59; // er10
  int renderSize; // ecx
  int v61; // eax
  int *v62; // rax
  __int64 v63; // rcx
  AppMain *v64; // rcx
  int v65; // eax
  int v66; // edx
  unsigned int v67; // ecx
  float v68; // xmm1_4
  signed int m_FrameBufferID; // ecx
  float v70; // xmm1_4
  signed int v71; // ecx
  signed int v72; // ecx
  int v73; // [rsp+28h] [rbp-E0h]
  unsigned int v74; // [rsp+40h] [rbp-C8h]
  __int128 v75; // [rsp+48h] [rbp-C0h]
  __int128 v76; // [rsp+58h] [rbp-B0h]
  __int128 v77; // [rsp+68h] [rbp-A0h]
  __int128 v78; // [rsp+78h] [rbp-90h]
  __int128 v79; // [rsp+88h] [rbp-80h]
  __int128 v80; // [rsp+98h] [rbp-70h]
  __int128 v81; // [rsp+A8h] [rbp-60h]
  __int128 v82; // [rsp+B8h] [rbp-50h]
  float v[4]; // [rsp+C8h] [rbp-40h] BYREF
  float value[4]; // [rsp+D8h] [rbp-30h] BYREF
  __int128 v85; // [rsp+E8h] [rbp-20h]
  __int128 v86; // [rsp+F8h] [rbp-10h]
  __int128 v87; // [rsp+108h] [rbp+0h]
  float v88[4]; // [rsp+118h] [rbp+10h] BYREF
  __int128 v89; // [rsp+128h] [rbp+20h]
  __int128 v90; // [rsp+138h] [rbp+30h]
  __int128 v91; // [rsp+148h] [rbp+40h]
  int v92; // [rsp+158h] [rbp+50h] BYREF
  __int64 v93; // [rsp+15Ch] [rbp+54h]
  int v94; // [rsp+164h] [rbp+5Ch]
  int v95; // [rsp+168h] [rbp+60h]
  int v96; // [rsp+16Ch] [rbp+64h]
  int v97; // [rsp+170h] [rbp+68h]
  int v98; // [rsp+174h] [rbp+6Ch]
  __int64 v99; // [rsp+180h] [rbp+78h]
  __int64 v100; // [rsp+188h] [rbp+80h] BYREF
  float v101; // [rsp+190h] [rbp+88h]
  int v102; // [rsp+194h] [rbp+8Ch]
  float v103; // [rsp+198h] [rbp+90h]
  __int64 v104; // [rsp+19Ch] [rbp+94h]
  float v105; // [rsp+1A4h] [rbp+9Ch]
  float v106; // [rsp+1A8h] [rbp+A0h]
  int v107; // [rsp+1ACh] [rbp+A4h]
  float v108[4]; // [rsp+1B8h] [rbp+B0h] BYREF

  if ( pSrcTexture )
  {
    v6 = Framework::GLManager::glm;
    *(_QWORD *)v = pSrcTexture;
    if ( pDestTexture )
    {
      u_postfxBlurSize = this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize;
      if ( u_postfxBlurSize == 1 )
      {
        v10 = 7928i64;
      }
      else if ( u_postfxBlurSize == 2 )
      {
        v10 = 7929i64;
      }
      else
      {
        v10 = 7927i64;
        if ( u_postfxBlurSize == 4 )
          v10 = 7930i64;
      }
      p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
      v100 = 0i64;
      v99 = 0i64;
      v12 = *p_m_FrameBufferID == 0;
      v104 = 0i64;
      v107 = 0;
      v13 = (float)width;
      v102 = 0;
      v93 = 0i64;
      v92 = 0;
      v96 = 0;
      v106 = (float)height;
      v101 = (float)height;
      v105 = (float)width;
      v103 = (float)width;
      v97 = 1065353216;
      v95 = 1065353216;
      v98 = 1065353216;
      v94 = 1065353216;
      if ( v12 )
      {
        m_targetWidth = (float)(int)Framework::GLManager::glm->m_config.m_targetWidth;
        if ( v13 == (float)(m_targetWidth * 0.125) )
        {
          Framework::GLManager::glGenEighthRenderbuffers(
            Framework::GLManager::glm,
            (int)p_m_FrameBufferID,
            p_m_FrameBufferID);
          Framework::GLManager::glBindEighthRenderbuffer(
            v6,
            v15,
            this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
        }
        else
        {
          v16 = m_targetWidth * 0.5;
          if ( v16 <= v13 )
          {
            if ( v13 == v16 )
            {
              Framework::GLManager::glGenHalfRenderbuffers(
                Framework::GLManager::glm,
                (int)p_m_FrameBufferID,
                p_m_FrameBufferID);
              Framework::GLManager::glBindHalfRenderbuffer(
                v6,
                v18,
                this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
            }
            else
            {
              glGenRenderbuffersAG(1, p_m_FrameBufferID);
              glBindRenderbufferAG(v19, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
            }
          }
          else
          {
            Framework::GLManager::glGenThirdRenderbuffers(
              Framework::GLManager::glm,
              (int)p_m_FrameBufferID,
              p_m_FrameBufferID);
            Framework::GLManager::glBindThirdRenderbuffer(
              v6,
              v17,
              this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
          }
        }
      }
      if ( !pDestTexture->m_TexID )
        glGenTexturesAG(1, &pDestTexture->m_TexID);
      v20 = m_ActiveTexture;
      if ( m_ActiveTexture )
      {
        m_ActiveTexture = 0;
        _glewActiveTexture(0x84C0u);
        v20 = m_ActiveTexture;
      }
      v21 = 0x140000000ui64;
      v22 = *(_DWORD *)(*(_QWORD *)v + 16i64);
      if ( v22 != ::m_TexID[v20] || !v22 )
      {
        ::m_TexID[v20] = v22;
        v23 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v22;
        while ( v23->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v22);
        v20 = m_ActiveTexture;
      }
      if ( v20 != 1 )
      {
        m_ActiveTexture = 1;
        _glewActiveTexture(0x84C1u);
        v20 = m_ActiveTexture;
      }
      m_TexID = pDestTexture->m_TexID;
      v25 = v20;
      if ( m_TexID != ::m_TexID[v20] || !m_TexID )
      {
        ::m_TexID[v20] = m_TexID;
        v26 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = m_TexID;
        while ( v26->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, m_TexID);
      }
      glsFramebufferTexture2D(v25, 0x8CE1u, v21, pDestTexture->m_TexID, v73, width, height, v74);
      v27 = pDestTexture->m_TexID;
      if ( v27 != ::m_TexID[m_ActiveTexture] || !v27 )
      {
        ::m_TexID[m_ActiveTexture] = v27;
        v28 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v27;
        while ( v28->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v27);
      }
      glTexParameterf(0xDE1u, 0x2801u, 9729.0);
      glTexParameterf(0xDE1u, 0x2800u, 9729.0);
      glTexParameterf(0xDE1u, 0x2802u, 33071.0);
      glTexParameterf(0xDE1u, 0x2803u, 33071.0);
      pDestTexture->m_TexParam = 1290;
      Graphics::clearScreen(v29, 0);
      if ( m_DepthMask != 1 )
      {
        m_DepthMask = 1;
        glDepthMask(1u);
      }
      glClearAG(0x100u);
      GraphicsOpt::lock(this->g, width, height);
      v30 = this->m_pRender->m_ShaderFXTbl[v10];
      if ( v30 )
      {
        if ( v30->m_Program )
        {
          KOFShaderManager::useProgramSlot(
            (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
            v30->m_programSlot);
          v31 = Framework::GLManager::glm;
          v32 = 64;
          Framework::GLManager::glm->renderSize = 64;
          v34 = AgFrameAllocator<AgAllocator<1>>::allocate(&v31->m_agDrawAllocator, 0x100ui64, v33);
          v35 = &v92;
          v36 = (char *)v34;
          v37 = (float *)&v100;
          v38 = 4i64;
          v39 = (float *)(v34 + 7);
          do
          {
            v40 = *v37;
            v35 += 2;
            v41 = (__m128)*((unsigned int *)v37 - 1);
            v37 += 3;
            v[2] = v40;
            v42 = v40;
            v43 = _mm_unpacklo_ps((__m128)*((unsigned int *)v37 - 5), v41).m128_u64[0];
            v44 = (__m128)(unsigned int)*(v35 - 1);
            *((_QWORD *)v39 - 7) = v43;
            *(_QWORD *)v39 = _mm_unpacklo_ps((__m128)(unsigned int)*(v35 - 2), v44).m128_u64[0];
            *(v39 - 12) = v42;
            *((_OWORD *)v39 - 1) = _xmm;
            v39 += 16;
            --v38;
          }
          while ( v38 );
          v6->m_vertexInfoCount = 4;
          m_pRender = this->m_pRender;
          v46 = *(__m128 *)m_pRender->m_View.m;
          v47 = *(__m128 *)&m_pRender->m_View.m[4];
          v48 = *(__m128 *)&m_pRender->m_View.m[8];
          v49 = *(__m128 *)&m_pRender->m_View.m[12];
          v50 = *(__m128 *)m_pRender->m_Proj.m;
          v51 = *(__m128 *)&m_pRender->m_Proj.m[4];
          v52 = *(__m128 *)&m_pRender->m_Proj.m[8];
          v53 = *(__m128 *)&m_pRender->m_Proj.m[12];
          *(_QWORD *)&v75 = __PAIR64__(v47.m128_u32[0], v46.m128_u32[0]);
          LODWORD(v76) = _mm_shuffle_ps(v46, v46, 85).m128_u32[0];
          LODWORD(v77) = _mm_shuffle_ps(v46, v46, 170).m128_u32[0];
          DWORD1(v76) = _mm_shuffle_ps(v47, v47, 85).m128_u32[0];
          DWORD1(v77) = _mm_shuffle_ps(v47, v47, 170).m128_u32[0];
          DWORD2(v76) = _mm_shuffle_ps(v48, v48, 85).m128_u32[0];
          DWORD2(v77) = _mm_shuffle_ps(v48, v48, 170).m128_u32[0];
          HIDWORD(v76) = _mm_shuffle_ps(v49, v49, 85).m128_u32[0];
          HIDWORD(v77) = _mm_shuffle_ps(v49, v49, 170).m128_u32[0];
          v85 = v76;
          *((_QWORD *)&v75 + 1) = __PAIR64__(v49.m128_u32[0], v48.m128_u32[0]);
          *(_OWORD *)value = v75;
          v86 = v77;
          LODWORD(v80) = _mm_shuffle_ps(v50, v50, 85).m128_u32[0];
          DWORD1(v80) = _mm_shuffle_ps(v51, v51, 85).m128_u32[0];
          LODWORD(v78) = _mm_shuffle_ps(v46, v46, 255).m128_u32[0];
          DWORD1(v78) = _mm_shuffle_ps(v47, v47, 255).m128_u32[0];
          DWORD2(v78) = _mm_shuffle_ps(v48, v48, 255).m128_u32[0];
          HIDWORD(v78) = _mm_shuffle_ps(v49, v49, 255).m128_u32[0];
          v87 = v78;
          LODWORD(v81) = _mm_shuffle_ps(v50, v50, 170).m128_u32[0];
          DWORD1(v81) = _mm_shuffle_ps(v51, v51, 170).m128_u32[0];
          *(_QWORD *)&v79 = __PAIR64__(v51.m128_u32[0], v50.m128_u32[0]);
          *((_QWORD *)&v79 + 1) = __PAIR64__(v53.m128_u32[0], v52.m128_u32[0]);
          DWORD2(v82) = _mm_shuffle_ps(v52, v52, 255).m128_u32[0];
          LODWORD(v82) = _mm_shuffle_ps(v50, v50, 255).m128_u32[0];
          DWORD1(v82) = _mm_shuffle_ps(v51, v51, 255).m128_u32[0];
          DWORD2(v80) = _mm_shuffle_ps(v52, v52, 85).m128_u32[0];
          DWORD2(v81) = _mm_shuffle_ps(v52, v52, 170).m128_u32[0];
          v54 = *v30->m_piGLUniform;
          HIDWORD(v80) = _mm_shuffle_ps(v53, v53, 85).m128_u32[0];
          HIDWORD(v81) = _mm_shuffle_ps(v53, v53, 170).m128_u32[0];
          *(_OWORD *)v88 = v79;
          v89 = v80;
          HIDWORD(v82) = _mm_shuffle_ps(v53, v53, 255).m128_u32[0];
          v90 = v81;
          v91 = v82;
          glUniformMatrix4fvAG(v54, 1, (unsigned __int8)v35, value);
          glUniformMatrix4fvAG(v30->m_piGLUniform[1], 1, v55, v88);
          m_piGLUniform = v30->m_piGLUniform;
          *(_OWORD *)v = _xmm;
          glUniform4fvAG(m_piGLUniform[5], 1, v);
          v57 = AgSingleton<KOFShaderManager>::ms_instance;
          v58 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                          * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                          + 7].onSingletonInit;
          if ( (unsigned int)v58 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v58;
            g_vertexAttribIndex[v58] = 0;
          }
          v59 = *(_DWORD *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit;
          renderSize = Framework::GLManager::glm->renderSize;
          switch ( renderSize )
          {
            case 64:
              v61 = 64;
              break;
            case 280:
              v61 = 136;
              break;
            case 208:
              v61 = 64;
              break;
            default:
              v61 = 88;
              if ( renderSize == 144 )
                v61 = 144;
              break;
          }
          if ( v59 >= 0 )
          {
            _glewVertexAttribPointer(v59, 3, 0x1406u, 0, v61, v36);
            v57 = AgSingleton<KOFShaderManager>::ms_instance;
          }
          v62 = v30->m_piGLUniform;
          *(_OWORD *)v108 = _xmm;
          glUniform4fvAG(v62[5], 1, v108);
          v63 = *((unsigned int *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit + 4);
          if ( (unsigned int)v63 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v63;
            g_vertexAttribIndex[v63] = 4;
          }
          v64 = (AppMain *)*((unsigned int *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit + 4);
          v65 = Framework::GLManager::glm->renderSize;
          if ( v65 != 64 )
          {
            if ( v65 == 280 )
            {
              v32 = 8;
LABEL_66:
              if ( (int)v64 >= 0 )
                _glewVertexAttribPointer((unsigned int)v64, 2, 0x1406u, 0, v32, v36);
              AppMain::SetPostFXUniforms(
                v64,
                v30,
                &this->ModelRoomSettings.postfxUniforms,
                &this->ModelRoomSettings.filterUniforms);
              glDrawArraysAG(v67, v66, 4);
              Graphics::drawStack(this->g->g);
              v68 = (float)(int)v6->m_config.m_targetWidth;
              if ( v13 == (float)(v68 * 0.125) )
              {
                m_FrameBufferID = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                if ( m_FrameBufferID > 0 )
                  v6->m_eighthBuffer.m_freeIDs[v6->m_eighthBuffer.m_firstOccupiedIndex++] = m_FrameBufferID;
              }
              else
              {
                v70 = v68 * 0.5;
                if ( v70 <= v13 )
                {
                  if ( v13 == v70 )
                  {
                    v72 = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                    if ( v72 > 0 )
                      v6->m_halfBuffer.m_freeIDs[v6->m_halfBuffer.m_firstOccupiedIndex++] = v72;
                  }
                  else
                  {
                    glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
                  }
                }
                else
                {
                  v71 = this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
                  if ( v71 > 0 )
                    v6->m_thirdBuffer.m_freeIDs[v6->m_thirdBuffer.m_firstOccupiedIndex++] = v71;
                }
              }
              this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
              return;
            }
            if ( v65 != 208 )
            {
              if ( v65 == 144 )
              {
                v32 = 144;
                goto LABEL_66;
              }
              v32 = 88;
            }
          }
          v36 += 56;
          goto LABEL_66;
        }
      }
    }
  }
}

void __fastcall AppMain::DrawFullScreenTextureToScreen(AppMain *this)
{
  Framework::GLManager *v2; // rbx
  int v3; // edx

  v2 = Framework::GLManager::glm;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Draw To Screen");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 14, "Draw To Screen");
  glBindRenderbufferAG((unsigned int)this, v2->systemRenderID[v2->m_backBufferIndex]);
  glClearAG(0x4000u);
  AppMain::FullScreenQuadRenderSetup(this, v3);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
}

void __fastcall extension::FutureObjectJobManager<OGLMirror,void>::EnqueueAsyncJob(
        extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > shared)
{
  extension::AsyncContent<OGLMirror> *My_val; // rax
  extension::AsyncContent<OGLMirror> *v3; // rbx
  extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > shareda; // [rsp+48h] [rbp+10h] BYREF

  My_val = (extension::AsyncContent<OGLMirror> *)shared.m_ptr->m_refCount.m_value._My_val;
  shareda.m_ptr = My_val;
  if ( My_val )
    _InterlockedExchangeAdd64((volatile signed __int64 *)My_val, 1ui64);
  extension::future_asset_detail::EnqueueFutureMirrorJob((extension::RefCountablePtr<extension::AsyncContent<OGLMirror> >)&shareda);
  v3 = (extension::AsyncContent<OGLMirror> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd64((volatile signed __int64 *)v3, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      extension::AsyncContent<OGLMirror>::~AsyncContent<OGLMirror>(v3);
      operator delete(v3, 0x68ui64);
    }
  }
}

void __fastcall extension::FutureObjectJobManager<OGLMotion,void>::EnqueueAsyncJob(
        extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > shared)
{
  extension::AsyncContent<OGLMotion> *My_val; // rax
  extension::AsyncContent<OGLMotion> *v3; // rbx
  extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > shareda; // [rsp+48h] [rbp+10h] BYREF

  My_val = (extension::AsyncContent<OGLMotion> *)shared.m_ptr->m_refCount.m_value._My_val;
  shareda.m_ptr = My_val;
  if ( My_val )
    _InterlockedExchangeAdd64((volatile signed __int64 *)My_val, 1ui64);
  extension::future_asset_detail::EnqueueFutureMotionJob((extension::RefCountablePtr<extension::AsyncContent<OGLMotion> >)&shareda);
  v3 = (extension::AsyncContent<OGLMotion> *)shared.m_ptr->m_refCount.m_value._My_val;
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd64((volatile signed __int64 *)v3, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      extension::AsyncContent<OGLMotion>::~AsyncContent<OGLMotion>(v3);
      operator delete(v3, 0x68ui64);
    }
  }
}

void __fastcall AppMain::FadeFrameBuffers(
        AppMain *this,
        int curFrame,
        int numFrames,
        int charId,
        OGLTexture *pDestTexture)
{
  __int64 v6; // rsi
  __int64 v7; // r13
  bool v8; // zf
  __m128i v9; // xmm6
  float m_iScreenH; // xmm7_4
  unsigned int v11; // xmm6_4
  unsigned int v12; // er8
  __int64 v13; // r12
  unsigned int m_TexID; // edx
  unsigned __int64 v15; // rcx
  Framework::GLManager *v16; // rcx
  unsigned int v17; // er8
  unsigned int v18; // eax
  unsigned int v19; // edx
  Framework::GLManager *v20; // rcx
  unsigned int v21; // edx
  Framework::GLManager *v22; // rcx
  int v23; // ebx
  int v24; // ebx
  unsigned int v25; // edx
  Framework::GLManager *v26; // rcx
  int v27; // eax
  int v28; // er14
  unsigned int v29; // ecx
  unsigned int v30; // edx
  Framework::GLManager *v31; // rcx
  int v32; // er14
  unsigned int v33; // ecx
  int v34; // esi
  unsigned int v35; // ecx
  __int64 v36; // rsi
  int v37; // ebx
  int v38; // ebx
  int v39; // ebx
  __int64 v40; // rcx
  unsigned int v41; // edx
  Framework::GLManager *v42; // r8
  OGLShader *v43; // r14
  Framework::GLManager *v44; // rcx
  int v45; // esi
  unsigned __int64 v46; // r8
  _QWORD *v47; // rax
  int *v48; // r8
  char *v49; // r13
  __int64 *v50; // rdx
  __int64 v51; // r9
  _QWORD *v52; // rcx
  int v53; // xmm0_4
  __m128 v54; // xmm1
  int v55; // eax
  unsigned __int64 v56; // xmm0_8
  __m128 v57; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v59; // xmm2
  __m128 v60; // xmm3
  __m128 v61; // xmm4
  __m128 v62; // xmm5
  __m128 v63; // xmm6
  __m128 v64; // xmm7
  __m128 v65; // xmm8
  __m128 v66; // xmm9
  KOFShaderManager *v67; // rbx
  __int64 v68; // rcx
  __int64 v69; // rdx
  AgSingleton<KOFShaderManager>_vtbl *v70; // rax
  __int64 v71; // rcx
  __int64 v72; // rax
  __int128 *v73; // rax
  __int64 m_currentProgramSlot; // rdx
  __int128 *v75; // rax
  int v76; // er8
  _QWORD *v77; // rcx
  __int64 v78; // rcx
  int v79; // er11
  Framework::GLManager *v80; // r9
  signed int v81; // er10
  int renderSize; // ecx
  int v83; // eax
  int v84; // er8
  _QWORD *v85; // rcx
  __int64 v86; // rcx
  int v87; // eax
  AppMain *v88; // rcx
  int v89; // edx
  unsigned int v90; // ecx
  int v91; // [rsp+28h] [rbp-E0h]
  unsigned int v92; // [rsp+40h] [rbp-C8h]
  int locationa; // [rsp+48h] [rbp-C0h]
  int locationb; // [rsp+48h] [rbp-C0h]
  AgSingleton<KOFShaderManager>_vtbl *v97; // [rsp+50h] [rbp-B8h]
  void **v98; // [rsp+50h] [rbp-B8h]
  Framework::GLManager *v99; // [rsp+60h] [rbp-A8h]
  __int64 v100; // [rsp+60h] [rbp-A8h]
  __int64 index; // [rsp+60h] [rbp-A8h]
  __int128 v102; // [rsp+68h] [rbp-A0h]
  __int128 v103; // [rsp+78h] [rbp-90h]
  __int128 v104; // [rsp+88h] [rbp-80h]
  __int128 v105; // [rsp+98h] [rbp-70h]
  __int128 v106; // [rsp+A8h] [rbp-60h]
  __int128 v107; // [rsp+B8h] [rbp-50h]
  __int128 v108; // [rsp+C8h] [rbp-40h]
  __int128 v109; // [rsp+D8h] [rbp-30h]
  __int128 Buf2[4]; // [rsp+E8h] [rbp-20h] BYREF
  __int128 v111[4]; // [rsp+128h] [rbp+20h] BYREF
  int v112; // [rsp+168h] [rbp+60h] BYREF
  __int64 v113; // [rsp+16Ch] [rbp+64h]
  int v114; // [rsp+174h] [rbp+6Ch]
  int v115; // [rsp+178h] [rbp+70h]
  int v116; // [rsp+17Ch] [rbp+74h]
  int v117; // [rsp+180h] [rbp+78h]
  int v118; // [rsp+184h] [rbp+7Ch]
  __int64 v119; // [rsp+190h] [rbp+88h]
  __int64 v120; // [rsp+198h] [rbp+90h] BYREF
  float v121; // [rsp+1A0h] [rbp+98h]
  int v122; // [rsp+1A4h] [rbp+9Ch]
  unsigned int v123; // [rsp+1A8h] [rbp+A0h]
  __int64 v124; // [rsp+1ACh] [rbp+A4h]
  unsigned int v125; // [rsp+1B4h] [rbp+ACh]
  float v126; // [rsp+1B8h] [rbp+B0h]
  int v127; // [rsp+1BCh] [rbp+B4h]

  v6 = charId;
  v7 = curFrame;
  v99 = Framework::GLManager::glm;
  if ( pDestTexture )
  {
    v8 = pDestTexture->m_FrameBufferID == 0;
    v9 = _mm_cvtsi32_si128(this->m_iScreenW);
    m_iScreenH = (float)this->m_iScreenH;
    v120 = 0i64;
    v119 = 0i64;
    v124 = 0i64;
    v127 = 0;
    v11 = _mm_cvtepi32_ps(v9).m128_u32[0];
    v122 = 0;
    v113 = 0i64;
    v112 = 0;
    v116 = 0;
    v126 = m_iScreenH;
    v121 = m_iScreenH;
    v125 = v11;
    v123 = v11;
    v117 = 1065353216;
    v115 = 1065353216;
    v118 = 1065353216;
    v114 = 1065353216;
    if ( v8 )
      glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
    if ( !pDestTexture->m_TexID )
      glGenTexturesAG(1, &pDestTexture->m_TexID);
    v12 = m_ActiveTexture;
    if ( m_ActiveTexture )
    {
      m_ActiveTexture = 0;
      _glewActiveTexture(0x84C0u);
      v12 = m_ActiveTexture;
    }
    v13 = v6;
    m_TexID = this->m_pRender->m_renderTextures.m_CharacterFrames[v6][v7].m_TexID;
    v15 = 0x140000000ui64;
    if ( m_TexID != ::m_TexID[v12] || !m_TexID )
    {
      ::m_TexID[v12] = m_TexID;
      v16 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = m_TexID;
      while ( v16->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glBindRenderbufferAG(v15, pDestTexture->m_FrameBufferID);
    v18 = m_ActiveTexture;
    if ( m_ActiveTexture != 1 )
    {
      m_ActiveTexture = 1;
      _glewActiveTexture(0x84C1u);
      v18 = m_ActiveTexture;
    }
    v19 = pDestTexture->m_TexID;
    if ( v19 != ::m_TexID[v18] || !v19 )
    {
      ::m_TexID[v18] = v19;
      v20 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = v19;
      while ( v20->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v19);
    }
    glsFramebufferTexture2D(
      (int)*(float *)&v11,
      0x8CE1u,
      v17,
      pDestTexture->m_TexID,
      v91,
      (int)*(float *)&v11,
      (int)m_iScreenH,
      v92);
    v21 = pDestTexture->m_TexID;
    if ( v21 != ::m_TexID[m_ActiveTexture] || !v21 )
    {
      ::m_TexID[m_ActiveTexture] = v21;
      v22 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = v21;
      while ( v22->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v21);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    v23 = 0;
    pDestTexture->m_TexParam = 1290;
    if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 1) != 0 )
    {
      v24 = v7 - 1;
      if ( (int)v7 - 1 < 0 )
        v24 += this->ModelRoomSettings.motionBlurMaxFrames;
      if ( m_ActiveTexture != 2 )
      {
        m_ActiveTexture = 2;
        _glewActiveTexture(0x84C2u);
      }
      v25 = this->m_pRender->m_renderTextures.m_CharacterFrames[v13][v24].m_TexID;
      if ( v25 != ::m_TexID[m_ActiveTexture] || !v25 )
      {
        v26 = Framework::GLManager::glm;
        ::m_TexID[m_ActiveTexture] = v25;
        v26->m_textureID = v25;
        while ( v26->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v25);
      }
      v23 = 1;
    }
    v27 = numFrames;
    if ( numFrames > 2 )
    {
      if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 2) != 0 )
      {
        v28 = v7 - 2;
        if ( (int)v7 - 2 < 0 )
          v28 += this->ModelRoomSettings.motionBlurMaxFrames;
        v29 = GL_TEXTUREINDEX[v23];
        if ( v29 - 33984 != m_ActiveTexture )
        {
          m_ActiveTexture = v29 - 33984;
          _glewActiveTexture(v29);
        }
        v30 = this->m_pRender->m_renderTextures.m_CharacterFrames[v13][v28].m_TexID;
        if ( v30 != ::m_TexID[m_ActiveTexture] || !v30 )
        {
          v31 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v30;
          v31->m_textureID = v30;
          while ( v31->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v30);
        }
        v27 = numFrames;
        ++v23;
      }
      if ( v27 > 3 )
      {
        if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 4) != 0 )
        {
          v32 = v7 - 3;
          if ( (int)v7 - 3 < 0 )
            v32 += this->ModelRoomSettings.motionBlurMaxFrames;
          v33 = GL_TEXTUREINDEX[v23];
          if ( v33 - 33984 != m_ActiveTexture )
          {
            m_ActiveTexture = v33 - 33984;
            _glewActiveTexture(v33);
          }
          glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_CharacterFrames[v13][v32].m_TexID);
          v27 = numFrames;
          ++v23;
        }
        if ( v27 > 4 && (this->ModelRoomSettings.motionBlurShowBit[v6] & 8) != 0 )
        {
          v34 = v7 - 4;
          if ( (int)v7 - 4 < 0 )
            v34 += this->ModelRoomSettings.motionBlurMaxFrames;
          v35 = GL_TEXTUREINDEX[v23];
          if ( v35 - 33984 != m_ActiveTexture )
          {
            m_ActiveTexture = v35 - 33984;
            _glewActiveTexture(v35);
          }
          glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_CharacterFrames[v13][v34].m_TexID);
          ++v23;
        }
      }
    }
    v36 = 7986i64;
    v37 = v23 - 1;
    if ( v37 )
    {
      v38 = v37 - 1;
      if ( v38 )
      {
        v39 = v38 - 1;
        if ( v39 )
        {
          if ( v39 == 1 )
            v36 = 7989i64;
        }
        else
        {
          v36 = 7988i64;
        }
      }
      else
      {
        v36 = 7987i64;
      }
    }
    if ( m_ActiveTexture != 6 )
    {
      m_ActiveTexture = 6;
      _glewActiveTexture(0x84C6u);
    }
    v40 = 5i64;
    if ( charId != 1 )
      v40 = 3i64;
    v41 = this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[v40].m_TexID;
    if ( v41 != ::m_TexID[m_ActiveTexture] || !v41 )
    {
      v42 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v41;
      v42->m_textureID = v41;
      while ( v42->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v41);
    }
    if ( m_DepthMask != 1 )
    {
      m_DepthMask = 1;
      glDepthMask(1u);
    }
    glClearAG(0x100u);
    GraphicsOpt::lock(this->g);
    v43 = this->m_pRender->m_ShaderFXTbl[v36];
    if ( v43 )
    {
      if ( v43->m_Program )
      {
        KOFShaderManager::useProgramSlot(
          (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
          v43->m_programSlot);
        v44 = Framework::GLManager::glm;
        v45 = 64;
        Framework::GLManager::glm->renderSize = 64;
        v47 = AgFrameAllocator<AgAllocator<1>>::allocate(&v44->m_agDrawAllocator, 0x100ui64, v46);
        v48 = &v112;
        v49 = (char *)v47;
        v50 = &v120;
        v51 = 4i64;
        v52 = v47 + 7;
        do
        {
          v53 = *(_DWORD *)v50;
          v48 += 2;
          v54 = (__m128)*((unsigned int *)v50 - 1);
          v50 = (__int64 *)((char *)v50 + 12);
          v55 = v53;
          v56 = _mm_unpacklo_ps((__m128)*((unsigned int *)v50 - 5), v54).m128_u64[0];
          v57 = (__m128)(unsigned int)*(v48 - 1);
          *(v52 - 7) = v56;
          *v52 = _mm_unpacklo_ps((__m128)(unsigned int)*(v48 - 2), v57).m128_u64[0];
          *((_DWORD *)v52 - 12) = v55;
          *((_OWORD *)v52 - 1) = _xmm;
          v52 += 8;
          --v51;
        }
        while ( v51 );
        v99->m_vertexInfoCount = 4;
        m_pRender = this->m_pRender;
        v59 = *(__m128 *)m_pRender->m_View.m;
        v60 = *(__m128 *)&m_pRender->m_View.m[4];
        v61 = *(__m128 *)&m_pRender->m_View.m[8];
        v62 = *(__m128 *)&m_pRender->m_View.m[12];
        v63 = *(__m128 *)m_pRender->m_Proj.m;
        v64 = *(__m128 *)&m_pRender->m_Proj.m[4];
        v65 = *(__m128 *)&m_pRender->m_Proj.m[8];
        v66 = *(__m128 *)&m_pRender->m_Proj.m[12];
        *(_QWORD *)&v102 = __PAIR64__(v60.m128_u32[0], v59.m128_u32[0]);
        LODWORD(v103) = _mm_shuffle_ps(v59, v59, 85).m128_u32[0];
        LODWORD(v104) = _mm_shuffle_ps(v59, v59, 170).m128_u32[0];
        DWORD1(v103) = _mm_shuffle_ps(v60, v60, 85).m128_u32[0];
        DWORD1(v104) = _mm_shuffle_ps(v60, v60, 170).m128_u32[0];
        DWORD2(v103) = _mm_shuffle_ps(v61, v61, 85).m128_u32[0];
        DWORD2(v104) = _mm_shuffle_ps(v61, v61, 170).m128_u32[0];
        HIDWORD(v103) = _mm_shuffle_ps(v62, v62, 85).m128_u32[0];
        HIDWORD(v104) = _mm_shuffle_ps(v62, v62, 170).m128_u32[0];
        LODWORD(v107) = _mm_shuffle_ps(v63, v63, 85).m128_u32[0];
        LODWORD(v108) = _mm_shuffle_ps(v63, v63, 170).m128_u32[0];
        *((_QWORD *)&v102 + 1) = __PAIR64__(v62.m128_u32[0], v61.m128_u32[0]);
        DWORD1(v107) = _mm_shuffle_ps(v64, v64, 85).m128_u32[0];
        DWORD1(v108) = _mm_shuffle_ps(v64, v64, 170).m128_u32[0];
        LODWORD(v105) = _mm_shuffle_ps(v59, v59, 255).m128_u32[0];
        DWORD1(v105) = _mm_shuffle_ps(v60, v60, 255).m128_u32[0];
        DWORD2(v105) = _mm_shuffle_ps(v61, v61, 255).m128_u32[0];
        HIDWORD(v105) = _mm_shuffle_ps(v62, v62, 255).m128_u32[0];
        *(_QWORD *)&v106 = __PAIR64__(v64.m128_u32[0], v63.m128_u32[0]);
        *((_QWORD *)&v106 + 1) = __PAIR64__(v66.m128_u32[0], v65.m128_u32[0]);
        DWORD2(v107) = _mm_shuffle_ps(v65, v65, 85).m128_u32[0];
        DWORD2(v108) = _mm_shuffle_ps(v65, v65, 170).m128_u32[0];
        LODWORD(v109) = _mm_shuffle_ps(v63, v63, 255).m128_u32[0];
        DWORD1(v109) = _mm_shuffle_ps(v64, v64, 255).m128_u32[0];
        Buf2[0] = v102;
        Buf2[1] = v103;
        Buf2[2] = v104;
        Buf2[3] = v105;
        v67 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
        v68 = *v43->m_piGLUniform;
        v69 = 11i64 * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable);
        DWORD2(v109) = _mm_shuffle_ps(v65, v65, 255).m128_u32[0];
        HIDWORD(v107) = _mm_shuffle_ps(v66, v66, 85).m128_u32[0];
        locationa = *v43->m_piGLUniform;
        HIDWORD(v108) = _mm_shuffle_ps(v66, v66, 170).m128_u32[0];
        HIDWORD(v109) = _mm_shuffle_ps(v66, v66, 255).m128_u32[0];
        v70 = AgSingleton<KOFShaderManager>::ms_instance[v69 + 11].__vftable;
        v111[0] = v106;
        v111[1] = v107;
        v71 = *((int *)&v70->~AgSingleton<KOFShaderManager> + 4 * v68);
        v72 = SHIDWORD(AgSingleton<KOFShaderManager>::ms_instance[v69 + 5].__vftable);
        v100 = v71;
        v111[2] = v108;
        v111[3] = v109;
        v97 = AgSingleton<KOFShaderManager>::ms_instance[v72 + 494188].__vftable;
        if ( memcmp(*((const void **)&v97->~AgSingleton<KOFShaderManager> + v71), Buf2, 0x40ui64) )
        {
          v73 = (__int128 *)*((_QWORD *)&v97->~AgSingleton<KOFShaderManager> + v100);
          *v73 = v102;
          v73[1] = v103;
          v73[2] = v104;
          v73[3] = v105;
          KOFShaderManager::setUniformWriteMask(v67, locationa);
        }
        m_currentProgramSlot = v67->m_currentProgramSlot;
        locationb = v43->m_piGLUniform[1];
        index = v67->m_program[m_currentProgramSlot].m_uniformAttrib[locationb].index;
        v98 = v67->m_shaderUniformPtr[v67->m_program[m_currentProgramSlot].m_linkID];
        if ( memcmp(v98[index], v111, 0x40ui64) )
        {
          v75 = (__int128 *)v98[index];
          *v75 = v106;
          v75[1] = v107;
          v75[2] = v108;
          v75[3] = v109;
          KOFShaderManager::setUniformWriteMask(v67, locationb);
        }
        v76 = v43->m_piGLUniform[5];
        v77 = v67->m_shaderUniformPtr[v67->m_program[v67->m_currentProgramSlot].m_linkID][v67->m_program[v67->m_currentProgramSlot].m_uniformAttrib[v76].index];
        if ( *v77 != (_QWORD)_xmm || v77[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
        {
          *(_OWORD *)v77 = _xmm;
          KOFShaderManager::setUniformWriteMask(v67, v76);
        }
        v78 = *(unsigned int *)v67->m_program[v67->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
        if ( (unsigned int)v78 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v78;
          g_vertexAttribIndex[v78] = 0;
        }
        v79 = 144;
        v80 = Framework::GLManager::glm;
        v81 = *v67->m_program[v67->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
        renderSize = Framework::GLManager::glm->renderSize;
        switch ( renderSize )
        {
          case 64:
            v83 = 64;
            break;
          case 280:
            v83 = 136;
            break;
          case 208:
            v83 = 64;
            break;
          default:
            v83 = 88;
            if ( renderSize == 144 )
              v83 = 144;
            break;
        }
        if ( v81 >= 0 )
        {
          _glewVertexAttribPointer(v81, 3, 0x1406u, 0, v83, v49);
          v80 = Framework::GLManager::glm;
          v79 = 144;
          v67 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
        }
        v84 = v43->m_piGLUniform[5];
        v85 = v67->m_shaderUniformPtr[v67->m_program[v67->m_currentProgramSlot].m_linkID][v67->m_program[v67->m_currentProgramSlot].m_uniformAttrib[v84].index];
        if ( *v85 != (_QWORD)_xmm || v85[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
        {
          *(_OWORD *)v85 = _xmm;
          KOFShaderManager::setUniformWriteMask(v67, v84);
        }
        v86 = *((unsigned int *)v67->m_program[v67->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue + 4);
        if ( (unsigned int)v86 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v86;
          g_vertexAttribIndex[v86] = 4;
        }
        v87 = v80->renderSize;
        v88 = (AppMain *)*((unsigned int *)v67->m_program[v67->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue
                         + 4);
        if ( v87 != 64 )
        {
          if ( v87 == 280 )
          {
            v45 = 8;
LABEL_116:
            if ( (int)v88 >= 0 )
              _glewVertexAttribPointer((unsigned int)v88, 2, 0x1406u, 0, v45, v49);
            this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
            this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
            AppMain::SetPostFXUniforms(
              v88,
              v43,
              &this->ModelRoomSettings.postfxUniforms,
              &this->ModelRoomSettings.filterUniforms);
            glDrawArraysAG(v90, v89, 4);
            Graphics::drawStack(this->g->g);
            return;
          }
          if ( v87 != 208 )
          {
            if ( v87 == v79 )
            {
              v45 = v79;
              goto LABEL_116;
            }
            v45 = 88;
          }
        }
        v49 += 56;
        goto LABEL_116;
      }
    }
  }
}

void __fastcall AppMain::FadeFrameDepthBuffers(
        AppMain *this,
        int curFrame,
        int numFrames,
        int charId,
        OGLTexture *pDestTexture)
{
  __int64 v6; // rsi
  __int64 v7; // r13
  bool v8; // zf
  __m128i v9; // xmm6
  float m_iScreenH; // xmm7_4
  unsigned int v11; // xmm6_4
  unsigned int v12; // er8
  __int64 v13; // r12
  unsigned int m_TexID; // edx
  unsigned __int64 v15; // rcx
  Framework::GLManager *v16; // rcx
  unsigned int v17; // er8
  unsigned int v18; // eax
  unsigned int v19; // edx
  Framework::GLManager *v20; // rcx
  unsigned int v21; // edx
  Framework::GLManager *v22; // rcx
  int v23; // ebx
  int v24; // ebx
  unsigned int v25; // edx
  Framework::GLManager *v26; // rcx
  int v27; // eax
  int v28; // er14
  unsigned int v29; // ecx
  unsigned int v30; // edx
  Framework::GLManager *v31; // rcx
  int v32; // er14
  unsigned int v33; // ecx
  int v34; // esi
  unsigned int v35; // ecx
  __int64 v36; // rsi
  int v37; // ebx
  int v38; // ebx
  int v39; // ebx
  OGLShader *v40; // r14
  Framework::GLManager *v41; // rcx
  int v42; // esi
  unsigned __int64 v43; // r8
  _QWORD *v44; // rax
  int *v45; // r8
  char *v46; // r13
  __int64 *v47; // rdx
  __int64 v48; // r9
  _QWORD *v49; // rcx
  int v50; // xmm0_4
  __m128 v51; // xmm1
  int v52; // eax
  unsigned __int64 v53; // xmm0_8
  __m128 v54; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v56; // xmm2
  __m128 v57; // xmm3
  __m128 v58; // xmm4
  __m128 v59; // xmm5
  __m128 v60; // xmm6
  __m128 v61; // xmm7
  __m128 v62; // xmm8
  __m128 v63; // xmm9
  KOFShaderManager *v64; // rbx
  __int64 v65; // rcx
  __int64 v66; // rdx
  AgSingleton<KOFShaderManager>_vtbl *v67; // rax
  __int64 v68; // rcx
  __int64 v69; // rax
  __int128 *v70; // rax
  __int64 m_currentProgramSlot; // rdx
  __int128 *v72; // rax
  int v73; // er8
  _QWORD *v74; // rcx
  __int64 v75; // rcx
  int v76; // er11
  Framework::GLManager *v77; // r9
  signed int v78; // er10
  int renderSize; // ecx
  int v80; // eax
  int v81; // er8
  _QWORD *v82; // rcx
  __int64 v83; // rcx
  int v84; // eax
  AppMain *v85; // rcx
  int v86; // edx
  unsigned int v87; // ecx
  int v88; // [rsp+28h] [rbp-E0h]
  unsigned int v89; // [rsp+40h] [rbp-C8h]
  int locationa; // [rsp+48h] [rbp-C0h]
  int locationb; // [rsp+48h] [rbp-C0h]
  Framework::GLManager *v93; // [rsp+50h] [rbp-B8h]
  __int64 v94; // [rsp+50h] [rbp-B8h]
  void **v95; // [rsp+50h] [rbp-B8h]
  AgSingleton<KOFShaderManager>_vtbl *v96; // [rsp+58h] [rbp-B0h]
  AgSingleton<KOFShaderManager>_vtbl *index; // [rsp+58h] [rbp-B0h]
  __int128 v98; // [rsp+68h] [rbp-A0h]
  __int128 v99; // [rsp+78h] [rbp-90h]
  __int128 v100; // [rsp+88h] [rbp-80h]
  __int128 v101; // [rsp+98h] [rbp-70h]
  __int128 v102; // [rsp+A8h] [rbp-60h]
  __int128 v103; // [rsp+B8h] [rbp-50h]
  __int128 v104; // [rsp+C8h] [rbp-40h]
  __int128 v105; // [rsp+D8h] [rbp-30h]
  __int128 Buf2[4]; // [rsp+E8h] [rbp-20h] BYREF
  __int128 v107[4]; // [rsp+128h] [rbp+20h] BYREF
  int v108; // [rsp+168h] [rbp+60h] BYREF
  __int64 v109; // [rsp+16Ch] [rbp+64h]
  int v110; // [rsp+174h] [rbp+6Ch]
  int v111; // [rsp+178h] [rbp+70h]
  int v112; // [rsp+17Ch] [rbp+74h]
  int v113; // [rsp+180h] [rbp+78h]
  int v114; // [rsp+184h] [rbp+7Ch]
  __int64 v115; // [rsp+190h] [rbp+88h]
  __int64 v116; // [rsp+198h] [rbp+90h] BYREF
  float v117; // [rsp+1A0h] [rbp+98h]
  int v118; // [rsp+1A4h] [rbp+9Ch]
  unsigned int v119; // [rsp+1A8h] [rbp+A0h]
  __int64 v120; // [rsp+1ACh] [rbp+A4h]
  unsigned int v121; // [rsp+1B4h] [rbp+ACh]
  float v122; // [rsp+1B8h] [rbp+B0h]
  int v123; // [rsp+1BCh] [rbp+B4h]

  v6 = charId;
  v7 = curFrame;
  v93 = Framework::GLManager::glm;
  if ( pDestTexture )
  {
    v8 = pDestTexture->m_FrameBufferID == 0;
    v9 = _mm_cvtsi32_si128(this->m_iScreenW);
    m_iScreenH = (float)this->m_iScreenH;
    v116 = 0i64;
    v115 = 0i64;
    v120 = 0i64;
    v123 = 0;
    v11 = _mm_cvtepi32_ps(v9).m128_u32[0];
    v118 = 0;
    v109 = 0i64;
    v108 = 0;
    v112 = 0;
    v122 = m_iScreenH;
    v117 = m_iScreenH;
    v121 = v11;
    v119 = v11;
    v113 = 1065353216;
    v111 = 1065353216;
    v114 = 1065353216;
    v110 = 1065353216;
    if ( v8 )
      glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
    if ( !pDestTexture->m_TexID )
      glGenTexturesAG(1, &pDestTexture->m_TexID);
    v12 = m_ActiveTexture;
    if ( m_ActiveTexture )
    {
      m_ActiveTexture = 0;
      _glewActiveTexture(0x84C0u);
      v12 = m_ActiveTexture;
    }
    v13 = v6;
    m_TexID = this->m_pRender->m_renderTextures.m_CharacterFramesDepth[v6][v7].m_TexID;
    v15 = 0x140000000ui64;
    if ( m_TexID != ::m_TexID[v12] || !m_TexID )
    {
      ::m_TexID[v12] = m_TexID;
      v16 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = m_TexID;
      while ( v16->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
    glBindRenderbufferAG(v15, pDestTexture->m_FrameBufferID);
    v18 = m_ActiveTexture;
    if ( m_ActiveTexture != 1 )
    {
      m_ActiveTexture = 1;
      _glewActiveTexture(0x84C1u);
      v18 = m_ActiveTexture;
    }
    v19 = pDestTexture->m_TexID;
    if ( v19 != ::m_TexID[v18] || !v19 )
    {
      ::m_TexID[v18] = v19;
      v20 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = v19;
      while ( v20->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v19);
    }
    glsFramebufferTexture2D(
      (int)*(float *)&v11,
      0x8CE1u,
      v17,
      pDestTexture->m_TexID,
      v88,
      (int)*(float *)&v11,
      (int)m_iScreenH,
      v89);
    v21 = pDestTexture->m_TexID;
    if ( v21 != ::m_TexID[m_ActiveTexture] || !v21 )
    {
      ::m_TexID[m_ActiveTexture] = v21;
      v22 = Framework::GLManager::glm;
      Framework::GLManager::glm->m_textureID = v21;
      while ( v22->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v21);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    v23 = 0;
    pDestTexture->m_TexParam = 1290;
    if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 1) != 0 )
    {
      v24 = v7 - 1;
      if ( (int)v7 - 1 < 0 )
        v24 += this->ModelRoomSettings.motionBlurMaxFrames;
      if ( m_ActiveTexture != 2 )
      {
        m_ActiveTexture = 2;
        _glewActiveTexture(0x84C2u);
      }
      v25 = this->m_pRender->m_renderTextures.m_CharacterFramesDepth[v13][v24].m_TexID;
      if ( v25 != ::m_TexID[m_ActiveTexture] || !v25 )
      {
        v26 = Framework::GLManager::glm;
        ::m_TexID[m_ActiveTexture] = v25;
        v26->m_textureID = v25;
        while ( v26->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v25);
      }
      v23 = 1;
    }
    v27 = numFrames;
    if ( numFrames > 2 )
    {
      if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 2) != 0 )
      {
        v28 = v7 - 2;
        if ( (int)v7 - 2 < 0 )
          v28 += this->ModelRoomSettings.motionBlurMaxFrames;
        v29 = GL_TEXTUREINDEX[v23];
        if ( v29 - 33984 != m_ActiveTexture )
        {
          m_ActiveTexture = v29 - 33984;
          _glewActiveTexture(v29);
        }
        v30 = this->m_pRender->m_renderTextures.m_CharacterFramesDepth[v13][v28].m_TexID;
        if ( v30 != ::m_TexID[m_ActiveTexture] || !v30 )
        {
          v31 = Framework::GLManager::glm;
          ::m_TexID[m_ActiveTexture] = v30;
          v31->m_textureID = v30;
          while ( v31->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v30);
        }
        v27 = numFrames;
        ++v23;
      }
      if ( v27 > 3 )
      {
        if ( (this->ModelRoomSettings.motionBlurShowBit[v6] & 4) != 0 )
        {
          v32 = v7 - 3;
          if ( (int)v7 - 3 < 0 )
            v32 += this->ModelRoomSettings.motionBlurMaxFrames;
          v33 = GL_TEXTUREINDEX[v23];
          if ( v33 - 33984 != m_ActiveTexture )
          {
            m_ActiveTexture = v33 - 33984;
            _glewActiveTexture(v33);
          }
          glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_CharacterFramesDepth[v13][v32].m_TexID);
          v27 = numFrames;
          ++v23;
        }
        if ( v27 > 4 && (this->ModelRoomSettings.motionBlurShowBit[v6] & 8) != 0 )
        {
          v34 = v7 - 4;
          if ( (int)v7 - 4 < 0 )
            v34 += this->ModelRoomSettings.motionBlurMaxFrames;
          v35 = GL_TEXTUREINDEX[v23];
          if ( v35 - 33984 != m_ActiveTexture )
          {
            m_ActiveTexture = v35 - 33984;
            _glewActiveTexture(v35);
          }
          glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_CharacterFramesDepth[v13][v34].m_TexID);
          ++v23;
        }
      }
    }
    v36 = 7982i64;
    v37 = v23 - 1;
    if ( v37 )
    {
      v38 = v37 - 1;
      if ( v38 )
      {
        v39 = v38 - 1;
        if ( v39 )
        {
          if ( v39 == 1 )
            v36 = 7985i64;
        }
        else
        {
          v36 = 7984i64;
        }
      }
      else
      {
        v36 = 7983i64;
      }
    }
    if ( m_DepthMask != 1 )
    {
      m_DepthMask = 1;
      glDepthMask(1u);
    }
    glClearAG(0x100u);
    GraphicsOpt::lock(this->g);
    v40 = this->m_pRender->m_ShaderFXTbl[v36];
    if ( v40 )
    {
      if ( v40->m_Program )
      {
        KOFShaderManager::useProgramSlot(
          (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
          v40->m_programSlot);
        v41 = Framework::GLManager::glm;
        v42 = 64;
        Framework::GLManager::glm->renderSize = 64;
        v44 = AgFrameAllocator<AgAllocator<1>>::allocate(&v41->m_agDrawAllocator, 0x100ui64, v43);
        v45 = &v108;
        v46 = (char *)v44;
        v47 = &v116;
        v48 = 4i64;
        v49 = v44 + 7;
        do
        {
          v50 = *(_DWORD *)v47;
          v45 += 2;
          v51 = (__m128)*((unsigned int *)v47 - 1);
          v47 = (__int64 *)((char *)v47 + 12);
          v52 = v50;
          v53 = _mm_unpacklo_ps((__m128)*((unsigned int *)v47 - 5), v51).m128_u64[0];
          v54 = (__m128)(unsigned int)*(v45 - 1);
          *(v49 - 7) = v53;
          *v49 = _mm_unpacklo_ps((__m128)(unsigned int)*(v45 - 2), v54).m128_u64[0];
          *((_DWORD *)v49 - 12) = v52;
          *((_OWORD *)v49 - 1) = _xmm;
          v49 += 8;
          --v48;
        }
        while ( v48 );
        v93->m_vertexInfoCount = 4;
        m_pRender = this->m_pRender;
        v56 = *(__m128 *)m_pRender->m_View.m;
        v57 = *(__m128 *)&m_pRender->m_View.m[4];
        v58 = *(__m128 *)&m_pRender->m_View.m[8];
        v59 = *(__m128 *)&m_pRender->m_View.m[12];
        v60 = *(__m128 *)m_pRender->m_Proj.m;
        v61 = *(__m128 *)&m_pRender->m_Proj.m[4];
        v62 = *(__m128 *)&m_pRender->m_Proj.m[8];
        v63 = *(__m128 *)&m_pRender->m_Proj.m[12];
        *(_QWORD *)&v98 = __PAIR64__(v57.m128_u32[0], v56.m128_u32[0]);
        LODWORD(v99) = _mm_shuffle_ps(v56, v56, 85).m128_u32[0];
        LODWORD(v100) = _mm_shuffle_ps(v56, v56, 170).m128_u32[0];
        DWORD1(v99) = _mm_shuffle_ps(v57, v57, 85).m128_u32[0];
        DWORD1(v100) = _mm_shuffle_ps(v57, v57, 170).m128_u32[0];
        DWORD2(v99) = _mm_shuffle_ps(v58, v58, 85).m128_u32[0];
        DWORD2(v100) = _mm_shuffle_ps(v58, v58, 170).m128_u32[0];
        HIDWORD(v99) = _mm_shuffle_ps(v59, v59, 85).m128_u32[0];
        HIDWORD(v100) = _mm_shuffle_ps(v59, v59, 170).m128_u32[0];
        LODWORD(v103) = _mm_shuffle_ps(v60, v60, 85).m128_u32[0];
        LODWORD(v104) = _mm_shuffle_ps(v60, v60, 170).m128_u32[0];
        *((_QWORD *)&v98 + 1) = __PAIR64__(v59.m128_u32[0], v58.m128_u32[0]);
        DWORD1(v103) = _mm_shuffle_ps(v61, v61, 85).m128_u32[0];
        DWORD1(v104) = _mm_shuffle_ps(v61, v61, 170).m128_u32[0];
        LODWORD(v101) = _mm_shuffle_ps(v56, v56, 255).m128_u32[0];
        DWORD1(v101) = _mm_shuffle_ps(v57, v57, 255).m128_u32[0];
        DWORD2(v101) = _mm_shuffle_ps(v58, v58, 255).m128_u32[0];
        HIDWORD(v101) = _mm_shuffle_ps(v59, v59, 255).m128_u32[0];
        *(_QWORD *)&v102 = __PAIR64__(v61.m128_u32[0], v60.m128_u32[0]);
        *((_QWORD *)&v102 + 1) = __PAIR64__(v63.m128_u32[0], v62.m128_u32[0]);
        DWORD2(v103) = _mm_shuffle_ps(v62, v62, 85).m128_u32[0];
        DWORD2(v104) = _mm_shuffle_ps(v62, v62, 170).m128_u32[0];
        LODWORD(v105) = _mm_shuffle_ps(v60, v60, 255).m128_u32[0];
        DWORD1(v105) = _mm_shuffle_ps(v61, v61, 255).m128_u32[0];
        Buf2[0] = v98;
        Buf2[1] = v99;
        Buf2[2] = v100;
        Buf2[3] = v101;
        v64 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
        v65 = *v40->m_piGLUniform;
        v66 = 11i64 * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable);
        DWORD2(v105) = _mm_shuffle_ps(v62, v62, 255).m128_u32[0];
        HIDWORD(v103) = _mm_shuffle_ps(v63, v63, 85).m128_u32[0];
        locationa = *v40->m_piGLUniform;
        HIDWORD(v104) = _mm_shuffle_ps(v63, v63, 170).m128_u32[0];
        HIDWORD(v105) = _mm_shuffle_ps(v63, v63, 255).m128_u32[0];
        v67 = AgSingleton<KOFShaderManager>::ms_instance[v66 + 11].__vftable;
        v107[0] = v102;
        v107[1] = v103;
        v68 = *((int *)&v67->~AgSingleton<KOFShaderManager> + 4 * v65);
        v69 = SHIDWORD(AgSingleton<KOFShaderManager>::ms_instance[v66 + 5].__vftable);
        v94 = v68;
        v107[2] = v104;
        v107[3] = v105;
        v96 = AgSingleton<KOFShaderManager>::ms_instance[v69 + 494188].__vftable;
        if ( memcmp(*((const void **)&v96->~AgSingleton<KOFShaderManager> + v68), Buf2, 0x40ui64) )
        {
          v70 = (__int128 *)*((_QWORD *)&v96->~AgSingleton<KOFShaderManager> + v94);
          *v70 = v98;
          v70[1] = v99;
          v70[2] = v100;
          v70[3] = v101;
          KOFShaderManager::setUniformWriteMask(v64, locationa);
        }
        m_currentProgramSlot = v64->m_currentProgramSlot;
        locationb = v40->m_piGLUniform[1];
        index = (AgSingleton<KOFShaderManager>_vtbl *)v64->m_program[m_currentProgramSlot].m_uniformAttrib[locationb].index;
        v95 = v64->m_shaderUniformPtr[v64->m_program[m_currentProgramSlot].m_linkID];
        if ( memcmp(v95[(_QWORD)index], v107, 0x40ui64) )
        {
          v72 = (__int128 *)v95[(_QWORD)index];
          *v72 = v102;
          v72[1] = v103;
          v72[2] = v104;
          v72[3] = v105;
          KOFShaderManager::setUniformWriteMask(v64, locationb);
        }
        v73 = v40->m_piGLUniform[5];
        v74 = v64->m_shaderUniformPtr[v64->m_program[v64->m_currentProgramSlot].m_linkID][v64->m_program[v64->m_currentProgramSlot].m_uniformAttrib[v73].index];
        if ( *v74 != (_QWORD)_xmm || v74[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
        {
          *(_OWORD *)v74 = _xmm;
          KOFShaderManager::setUniformWriteMask(v64, v73);
        }
        v75 = *(unsigned int *)v64->m_program[v64->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
        if ( (unsigned int)v75 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v75;
          g_vertexAttribIndex[v75] = 0;
        }
        v76 = 144;
        v77 = Framework::GLManager::glm;
        v78 = *v64->m_program[v64->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
        renderSize = Framework::GLManager::glm->renderSize;
        switch ( renderSize )
        {
          case 64:
            v80 = 64;
            break;
          case 280:
            v80 = 136;
            break;
          case 208:
            v80 = 64;
            break;
          default:
            v80 = 88;
            if ( renderSize == 144 )
              v80 = 144;
            break;
        }
        if ( v78 >= 0 )
        {
          _glewVertexAttribPointer(v78, 3, 0x1406u, 0, v80, v46);
          v77 = Framework::GLManager::glm;
          v76 = 144;
          v64 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
        }
        v81 = v40->m_piGLUniform[5];
        v82 = v64->m_shaderUniformPtr[v64->m_program[v64->m_currentProgramSlot].m_linkID][v64->m_program[v64->m_currentProgramSlot].m_uniformAttrib[v81].index];
        if ( *v82 != (_QWORD)_xmm || v82[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
        {
          *(_OWORD *)v82 = _xmm;
          KOFShaderManager::setUniformWriteMask(v64, v81);
        }
        v83 = *((unsigned int *)v64->m_program[v64->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue + 4);
        if ( (unsigned int)v83 < g_maxEnabledVertexAttribArrays )
        {
          g_pendingVertexAttribArrays |= 1 << v83;
          g_vertexAttribIndex[v83] = 4;
        }
        v84 = v77->renderSize;
        v85 = (AppMain *)*((unsigned int *)v64->m_program[v64->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue
                         + 4);
        if ( v84 != 64 )
        {
          if ( v84 == 280 )
          {
            v42 = 8;
LABEL_107:
            if ( (int)v85 >= 0 )
              _glewVertexAttribPointer((unsigned int)v85, 2, 0x1406u, 0, v42, v46);
            AppMain::SetPostFXUniforms(
              v85,
              v40,
              &this->ModelRoomSettings.postfxUniforms,
              &this->ModelRoomSettings.filterUniforms);
            glDrawArraysAG(v87, v86, 4);
            Graphics::drawStack(this->g->g);
            return;
          }
          if ( v84 != 208 )
          {
            if ( v84 == v76 )
            {
              v42 = v76;
              goto LABEL_107;
            }
            v42 = 88;
          }
        }
        v46 += 56;
        goto LABEL_107;
      }
    }
  }
}

void __fastcall AppMain::FullScreenQuadRenderSetup(AppMain *this, int shader)
{
  __m128i v2; // xmm2
  Framework::GLManager *v3; // rbx
  float m_iScreenW; // xmm0_4
  GraphicsOpt *g; // rcx
  OGLShader *v7; // r15
  Framework::GLManager *v8; // rcx
  int v9; // edi
  unsigned __int64 v10; // r8
  _QWORD *v11; // rax
  int *v12; // r8
  char *v13; // r14
  __int64 *v14; // rdx
  __int64 v15; // r9
  _QWORD *v16; // rcx
  int v17; // xmm0_4
  __m128 v18; // xmm1
  int v19; // eax
  unsigned __int64 v20; // xmm0_8
  __m128 v21; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v23; // xmm2
  __m128 v24; // xmm3
  __m128 v25; // xmm4
  __m128 v26; // xmm5
  __m128 v27; // xmm6
  __m128 v28; // xmm7
  __m128 v29; // xmm8
  __m128 v30; // xmm9
  KOFShaderManager *v31; // rbx
  __int64 v32; // r13
  __int64 v33; // rdx
  AgSingleton<KOFShaderManager>_vtbl *v34; // rax
  __int128 *v35; // rax
  int v36; // er13
  __int64 m_currentProgramSlot; // rdx
  __int128 *v38; // rax
  int v39; // er8
  _QWORD *v40; // rcx
  __int64 v41; // rcx
  int v42; // er11
  signed int v43; // er10
  int renderSize; // ecx
  int v45; // eax
  int v46; // er8
  _QWORD *v47; // rcx
  __int64 v48; // rcx
  int v49; // eax
  signed int v50; // ecx
  unsigned int v51; // ecx
  unsigned int m_TexID; // edx
  __int64 v53; // rax
  Framework::GLManager *v54; // rcx
  Framework::GLManager *v55; // r9
  __int64 v56; // [rsp+38h] [rbp-D0h]
  void **v57; // [rsp+38h] [rbp-D0h]
  AgSingleton<KOFShaderManager>_vtbl *v58; // [rsp+40h] [rbp-C8h]
  __int64 index; // [rsp+40h] [rbp-C8h]
  __int128 v60; // [rsp+58h] [rbp-B0h]
  __int128 v61; // [rsp+68h] [rbp-A0h]
  __int128 v62; // [rsp+78h] [rbp-90h]
  __int128 v63; // [rsp+88h] [rbp-80h]
  __int128 v64; // [rsp+98h] [rbp-70h]
  __int128 v65; // [rsp+A8h] [rbp-60h]
  __int128 v66; // [rsp+B8h] [rbp-50h]
  __int128 v67; // [rsp+C8h] [rbp-40h]
  __int128 Buf2[4]; // [rsp+D8h] [rbp-30h] BYREF
  __int128 v69[4]; // [rsp+118h] [rbp+10h] BYREF
  int v70[6]; // [rsp+158h] [rbp+50h] BYREF
  float v71; // [rsp+170h] [rbp+68h]
  float v72; // [rsp+174h] [rbp+6Ch]
  __int64 v73; // [rsp+180h] [rbp+78h]
  __int64 v74; // [rsp+188h] [rbp+80h] BYREF
  float v75; // [rsp+190h] [rbp+88h]
  int v76; // [rsp+194h] [rbp+8Ch]
  float v77; // [rsp+198h] [rbp+90h]
  __int64 v78; // [rsp+19Ch] [rbp+94h]
  float v79; // [rsp+1A4h] [rbp+9Ch]
  float v80; // [rsp+1A8h] [rbp+A0h]
  int v81; // [rsp+1ACh] [rbp+A4h]

  v2 = _mm_cvtsi32_si128(this->m_iScreenH);
  v3 = Framework::GLManager::glm;
  m_iScreenW = (float)this->m_iScreenW;
  g = this->g;
  v74 = 0i64;
  v73 = 0i64;
  v78 = 0i64;
  *(float *)v2.m128i_i32 = _mm_cvtepi32_ps(v2).m128_f32[0];
  v81 = 0;
  v76 = 0;
  v79 = m_iScreenW + 0.0;
  v77 = m_iScreenW + 0.0;
  *(float *)&v70[2] = 0.0 / m_iScreenW;
  *(float *)v70 = 0.0 / m_iScreenW;
  *(float *)&v70[5] = 0.0 / *(float *)v2.m128i_i32;
  *(float *)&v70[1] = 0.0 / *(float *)v2.m128i_i32;
  v71 = (float)(m_iScreenW + 0.0) / m_iScreenW;
  v80 = *(float *)v2.m128i_i32 + 0.0;
  v75 = *(float *)v2.m128i_i32 + 0.0;
  v72 = (float)(*(float *)v2.m128i_i32 + 0.0) / *(float *)v2.m128i_i32;
  *(float *)&v70[3] = v72;
  *(float *)&v70[4] = v71;
  GraphicsOpt::lock(g);
  v7 = this->m_pRender->m_ShaderFXTbl[7922];
  if ( !v7 || !v7->m_Program )
    return;
  KOFShaderManager::useProgramSlot((KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance, v7->m_programSlot);
  v8 = Framework::GLManager::glm;
  v9 = 64;
  Framework::GLManager::glm->renderSize = 64;
  v11 = AgFrameAllocator<AgAllocator<1>>::allocate(&v8->m_agDrawAllocator, 0x100ui64, v10);
  v12 = v70;
  v13 = (char *)v11;
  v14 = &v74;
  v15 = 4i64;
  v16 = v11 + 7;
  do
  {
    v17 = *(_DWORD *)v14;
    v12 += 2;
    v18 = (__m128)*((unsigned int *)v14 - 1);
    v14 = (__int64 *)((char *)v14 + 12);
    v19 = v17;
    v20 = _mm_unpacklo_ps((__m128)*((unsigned int *)v14 - 5), v18).m128_u64[0];
    v21 = (__m128)(unsigned int)*(v12 - 1);
    *(v16 - 7) = v20;
    *v16 = _mm_unpacklo_ps((__m128)(unsigned int)*(v12 - 2), v21).m128_u64[0];
    *((_DWORD *)v16 - 12) = v19;
    *((_OWORD *)v16 - 1) = _xmm;
    v16 += 8;
    --v15;
  }
  while ( v15 );
  v3->m_vertexInfoCount = 4;
  m_pRender = this->m_pRender;
  v23 = *(__m128 *)m_pRender->m_View.m;
  v24 = *(__m128 *)&m_pRender->m_View.m[4];
  v25 = *(__m128 *)&m_pRender->m_View.m[8];
  v26 = *(__m128 *)&m_pRender->m_View.m[12];
  v27 = *(__m128 *)m_pRender->m_Proj.m;
  v28 = *(__m128 *)&m_pRender->m_Proj.m[4];
  v29 = *(__m128 *)&m_pRender->m_Proj.m[8];
  v30 = *(__m128 *)&m_pRender->m_Proj.m[12];
  *(_QWORD *)&v60 = __PAIR64__(v24.m128_u32[0], v23.m128_u32[0]);
  LODWORD(v61) = _mm_shuffle_ps(v23, v23, 85).m128_u32[0];
  LODWORD(v62) = _mm_shuffle_ps(v23, v23, 170).m128_u32[0];
  DWORD1(v61) = _mm_shuffle_ps(v24, v24, 85).m128_u32[0];
  DWORD1(v62) = _mm_shuffle_ps(v24, v24, 170).m128_u32[0];
  DWORD2(v61) = _mm_shuffle_ps(v25, v25, 85).m128_u32[0];
  DWORD2(v62) = _mm_shuffle_ps(v25, v25, 170).m128_u32[0];
  HIDWORD(v61) = _mm_shuffle_ps(v26, v26, 85).m128_u32[0];
  HIDWORD(v62) = _mm_shuffle_ps(v26, v26, 170).m128_u32[0];
  LODWORD(v65) = _mm_shuffle_ps(v27, v27, 85).m128_u32[0];
  LODWORD(v66) = _mm_shuffle_ps(v27, v27, 170).m128_u32[0];
  DWORD1(v65) = _mm_shuffle_ps(v28, v28, 85).m128_u32[0];
  DWORD1(v66) = _mm_shuffle_ps(v28, v28, 170).m128_u32[0];
  *((_QWORD *)&v60 + 1) = __PAIR64__(v26.m128_u32[0], v25.m128_u32[0]);
  LODWORD(v63) = _mm_shuffle_ps(v23, v23, 255).m128_u32[0];
  DWORD1(v63) = _mm_shuffle_ps(v24, v24, 255).m128_u32[0];
  DWORD2(v63) = _mm_shuffle_ps(v25, v25, 255).m128_u32[0];
  HIDWORD(v63) = _mm_shuffle_ps(v26, v26, 255).m128_u32[0];
  *(_QWORD *)&v64 = __PAIR64__(v28.m128_u32[0], v27.m128_u32[0]);
  *((_QWORD *)&v64 + 1) = __PAIR64__(v30.m128_u32[0], v29.m128_u32[0]);
  DWORD2(v67) = _mm_shuffle_ps(v29, v29, 255).m128_u32[0];
  LODWORD(v67) = _mm_shuffle_ps(v27, v27, 255).m128_u32[0];
  DWORD1(v67) = _mm_shuffle_ps(v28, v28, 255).m128_u32[0];
  DWORD2(v65) = _mm_shuffle_ps(v29, v29, 85).m128_u32[0];
  DWORD2(v66) = _mm_shuffle_ps(v29, v29, 170).m128_u32[0];
  Buf2[0] = v60;
  Buf2[1] = v61;
  Buf2[2] = v62;
  Buf2[3] = v63;
  v31 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
  v32 = *v7->m_piGLUniform;
  v33 = 11i64 * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable);
  HIDWORD(v65) = _mm_shuffle_ps(v30, v30, 85).m128_u32[0];
  HIDWORD(v66) = _mm_shuffle_ps(v30, v30, 170).m128_u32[0];
  HIDWORD(v67) = _mm_shuffle_ps(v30, v30, 255).m128_u32[0];
  v69[0] = v64;
  v34 = AgSingleton<KOFShaderManager>::ms_instance[v33 + 11].__vftable;
  v69[1] = v65;
  v69[2] = v66;
  v69[3] = v67;
  v56 = *((int *)&v34->~AgSingleton<KOFShaderManager> + 4 * v32);
  v58 = AgSingleton<KOFShaderManager>::ms_instance[SHIDWORD(AgSingleton<KOFShaderManager>::ms_instance[v33 + 5].__vftable)
                                                 + 494188].__vftable;
  if ( memcmp(*((const void **)&v58->~AgSingleton<KOFShaderManager> + v56), Buf2, 0x40ui64) )
  {
    v35 = (__int128 *)*((_QWORD *)&v58->~AgSingleton<KOFShaderManager> + v56);
    *v35 = v60;
    v35[1] = v61;
    v35[2] = v62;
    v35[3] = v63;
    KOFShaderManager::setUniformWriteMask(v31, v32);
  }
  v36 = v7->m_piGLUniform[1];
  m_currentProgramSlot = v31->m_currentProgramSlot;
  index = v31->m_program[m_currentProgramSlot].m_uniformAttrib[v36].index;
  v57 = v31->m_shaderUniformPtr[v31->m_program[m_currentProgramSlot].m_linkID];
  if ( memcmp(v57[index], v69, 0x40ui64) )
  {
    v38 = (__int128 *)v57[index];
    *v38 = v64;
    v38[1] = v65;
    v38[2] = v66;
    v38[3] = v67;
    KOFShaderManager::setUniformWriteMask(v31, v36);
  }
  v39 = v7->m_piGLUniform[5];
  v40 = v31->m_shaderUniformPtr[v31->m_program[v31->m_currentProgramSlot].m_linkID][v31->m_program[v31->m_currentProgramSlot].m_uniformAttrib[v39].index];
  if ( *v40 != (_QWORD)_xmm || v40[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
  {
    *(_OWORD *)v40 = _xmm;
    KOFShaderManager::setUniformWriteMask(v31, v39);
  }
  v41 = *(unsigned int *)v31->m_program[v31->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
  if ( (unsigned int)v41 < g_maxEnabledVertexAttribArrays )
  {
    g_vertexAttribIndex[v41] = 0;
    g_pendingVertexAttribArrays |= 1 << v41;
  }
  v42 = 144;
  v43 = *v31->m_program[v31->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue;
  renderSize = Framework::GLManager::glm->renderSize;
  switch ( renderSize )
  {
    case 64:
      v45 = 64;
      break;
    case 280:
      v45 = 136;
      break;
    case 208:
      v45 = 64;
      break;
    default:
      v45 = 88;
      if ( renderSize == 144 )
        v45 = 144;
      break;
  }
  if ( v43 >= 0 )
  {
    _glewVertexAttribPointer(v43, 3, 0x1406u, 0, v45, v13);
    v31 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
    v42 = 144;
  }
  v46 = v7->m_piGLUniform[5];
  v47 = v31->m_shaderUniformPtr[v31->m_program[v31->m_currentProgramSlot].m_linkID][v31->m_program[v31->m_currentProgramSlot].m_uniformAttrib[v46].index];
  if ( *v47 != (_QWORD)_xmm || v47[1] != _mm_srli_si128((__m128i)_xmm, 8).m128i_u64[0] )
  {
    *(_OWORD *)v47 = _xmm;
    KOFShaderManager::setUniformWriteMask(v31, v46);
  }
  v48 = *((unsigned int *)v31->m_program[v31->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue + 4);
  if ( (unsigned int)v48 < g_maxEnabledVertexAttribArrays )
  {
    g_vertexAttribIndex[v48] = 4;
    g_pendingVertexAttribArrays |= 1 << v48;
  }
  v49 = Framework::GLManager::glm->renderSize;
  v50 = v31->m_program[v31->m_currentProgramSlot].m_pOglShader->m_piGLAttrib.glValue[4];
  if ( v49 == 64 )
    goto LABEL_36;
  if ( v49 != 280 )
  {
    if ( v49 != 208 )
    {
      if ( v49 == v42 )
      {
        v9 = v42;
        goto LABEL_37;
      }
      v9 = 88;
    }
LABEL_36:
    v13 += 56;
    goto LABEL_37;
  }
  v9 = 8;
LABEL_37:
  if ( v50 >= 0 )
    _glewVertexAttribPointer(v50, 2, 0x1406u, 0, v9, v13);
  v51 = m_ActiveTexture;
  if ( m_ActiveTexture )
  {
    m_ActiveTexture = 0;
    _glewActiveTexture(0x84C0u);
    v51 = m_ActiveTexture;
  }
  m_TexID = this->m_pRender->m_renderTextures.m_FullScreenTexture[0].m_TexID;
  v53 = v51;
  if ( m_TexID != ::m_TexID[v51] || !m_TexID )
  {
    v54 = Framework::GLManager::glm;
    ::m_TexID[v53] = m_TexID;
    v54->m_textureID = m_TexID;
    while ( v54->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
    v51 = m_ActiveTexture;
  }
  if ( this->m_pRender->m_renderTextures.m_DownsampledTexture.m_TexID )
  {
    if ( v51 != 1 )
    {
      m_ActiveTexture = 1;
      _glewActiveTexture(0x84C1u);
      v51 = m_ActiveTexture;
    }
    m_TexID = this->m_pRender->m_renderTextures.m_DownsampledTexture.m_TexID;
    if ( m_TexID != ::m_TexID[v51] || !m_TexID )
    {
      v55 = Framework::GLManager::glm;
      ::m_TexID[v51] = m_TexID;
      v55->m_textureID = m_TexID;
      while ( v55->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, m_TexID);
    }
  }
  glDrawArraysAG(v51, m_TexID, 4);
  Graphics::drawStack(this->g->g);
}

void __fastcall AppMain::GaussianBlurEffect(
        AppMain *this,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        float width,
        float height,
        float blurStrength)
{
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Gaussian Blur");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 13, "Gaussian Blur");
  ++markerCount;
  if ( pDestTexture )
  {
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / width;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurStrength = blurStrength;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / height;
    AppMain::ApplyShaderToTexture(this, 7942, pSrcTexture, pDestTexture, (int)width, (int)height, 1);
    AppMain::ApplyShaderToTexture(this, 7943, pDestTexture, pSrcTexture, (int)width, (int)height, 1);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    if ( _glewPopDebugGroup )
      _glewPopDebugGroup();
    --markerCount;
  }
}

void __fastcall AppMain::GodRayShader(AppMain *this, int frameBufferIndex)
{
  void (__fastcall *v3)(int, const char *); // rax
  void (__fastcall *v4)(unsigned int, unsigned int, int, const char *); // r10
  OGLRender *m_pRender; // r8
  int height; // eax
  void (*v7)(void); // rdi
  void (*v8)(void); // rsi
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  void (__fastcall *v17)(int, const char *); // r8
  void (__fastcall *v18)(unsigned int, unsigned int, int, const char *); // r10
  float x; // xmm5_4
  float y; // xmm4_4
  __m128i v21; // xmm10
  __m128i v22; // xmm9
  __m128 v23; // xmm2
  float weight; // eax
  float v25; // xmm10_4
  float v26; // xmm9_4
  __m128 v27; // xmm8
  float v28; // xmm1_4
  float v29; // xmm3_4
  float v30; // xmm0_4
  __m128d v31; // xmm0
  __m128 v32; // xmm2
  __m128d v33; // xmm0
  OGLRender *v34; // r8
  int v35; // edx
  float blurStrength; // xmm0_4
  OGLTexture *p_m_ScreenBlurTexture; // rdx
  OGLRender *v38; // rax
  OGLRender *v39; // rdx
  OGLMatrix v40; // [rsp+48h] [rbp-C0h] BYREF
  OGLMatrix In2; // [rsp+88h] [rbp-80h] BYREF
  OGLMatrix In1; // [rsp+C8h] [rbp-40h] BYREF
  Vector2Unaligned v43; // [rsp+158h] [rbp+50h]

  v3 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "God Ray Shader");
    v3 = _glewPushGroupMarkerEXT;
  }
  v4 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 14, "God Ray Shader");
    v3 = _glewPushGroupMarkerEXT;
    v4 = _glewPushDebugGroup;
  }
  ++markerCount;
  if ( v3 )
  {
    v3(0, "Blend Masks");
    v4 = _glewPushDebugGroup;
  }
  if ( v4 )
    v4(33354u, 1u, 11, "Blend Masks");
  m_pRender = this->m_pRender;
  height = this->m_iScreenH;
  ++markerCount;
  AppMain::MaskTwoTexturesExt(
    this,
    frameBufferIndex,
    &m_pRender->m_renderTextures.m_FullScreenTexture[7],
    m_pRender->m_renderTextures.m_CombinedMaskTexture,
    this->m_iScreenW,
    height);
  v7 = _glewPopGroupMarkerEXT;
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v7 = _glewPopGroupMarkerEXT;
  }
  v8 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v7 = _glewPopGroupMarkerEXT;
    v8 = _glewPopDebugGroup;
  }
  v9 = *(_OWORD *)this->ModelRoomSettings.mProj[0].m;
  --markerCount;
  v10 = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[4];
  *(_QWORD *)v40.m = 1065353216i64;
  *(_OWORD *)In2.m = v9;
  v11 = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[8];
  v40.m[4] = 0.0;
  *(_OWORD *)&In2.m[4] = v10;
  v12 = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[12];
  *(_QWORD *)&v40.m[8] = 0i64;
  *(_OWORD *)&In2.m[8] = v11;
  v13 = *(_OWORD *)this->ModelRoomSettings.mView.m;
  *(_QWORD *)&v40.m[12] = 0i64;
  *(_OWORD *)&In2.m[12] = v12;
  v14 = *(_OWORD *)&this->ModelRoomSettings.mView.m[4];
  v40.m[5] = 1.0;
  *(_OWORD *)In1.m = v13;
  v15 = *(_OWORD *)&this->ModelRoomSettings.mView.m[8];
  v40.m[3] = 0.0;
  *(_OWORD *)&In1.m[4] = v14;
  v16 = *(_OWORD *)&this->ModelRoomSettings.mView.m[12];
  v40.m[7] = 0.0;
  *(_OWORD *)&In1.m[8] = v15;
  *(_OWORD *)&In1.m[12] = v16;
  v40.m[11] = 0.0;
  v40.m[15] = 1.0;
  OGLMatrix::multiply(&v40, &In1, &In2);
  if ( this->ModelRoomSettings.postprocessSettings.godRaySettings.sunPosSet )
  {
    v17 = _glewPushGroupMarkerEXT;
    if ( _glewPushGroupMarkerEXT )
    {
      _glewPushGroupMarkerEXT(0, "Shader Effect");
      v17 = _glewPushGroupMarkerEXT;
    }
    v18 = _glewPushDebugGroup;
    if ( _glewPushDebugGroup )
    {
      _glewPushDebugGroup(0x824Au, 1u, 13, "Shader Effect");
      v17 = _glewPushGroupMarkerEXT;
      v18 = _glewPushDebugGroup;
    }
    x = this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.x;
    y = this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.y;
    v21 = _mm_cvtsi32_si128(this->m_iScreenH);
    v22 = _mm_cvtsi32_si128(this->m_iScreenW);
    v23 = (__m128)LODWORD(v40.m[4]);
    weight = this->ModelRoomSettings.postprocessSettings.godRaySettings.weight;
    ++markerCount;
    v25 = _mm_cvtepi32_ps(v21).m128_f32[0] * 0.125;
    v26 = _mm_cvtepi32_ps(v22).m128_f32[0] * 0.125;
    v27 = (__m128)LODWORD(v40.m[5]);
    v27.m128_f32[0] = (float)((float)((float)(v40.m[5] * y) + (float)(v40.m[1] * x))
                            + (float)(v40.m[9] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.z))
                    + (float)(v40.m[13] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.w);
    v28 = v40.m[8] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.z;
    v29 = (float)((float)((float)(v40.m[7] * y) + (float)(v40.m[3] * x))
                + (float)(v40.m[11] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.z))
        + (float)(v40.m[15] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.w);
    v23.m128_f32[0] = (float)(v40.m[4] * y) + (float)(v40.m[0] * x);
    v30 = v40.m[12] * this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.w;
    this->ModelRoomSettings.postfxUniforms.u_postfxGodRaySettings.x = weight;
    this->ModelRoomSettings.postfxUniforms.u_postfxGodRaySettings.y = this->ModelRoomSettings.postprocessSettings.godRaySettings.density;
    this->ModelRoomSettings.postfxUniforms.u_postfxGodRaySettings.z = this->ModelRoomSettings.postprocessSettings.godRaySettings.decay;
    this->ModelRoomSettings.postfxUniforms.u_postfxGodRaySettings.w = this->ModelRoomSettings.postprocessSettings.godRaySettings.exposure;
    v27.m128_f32[0] = v27.m128_f32[0] / v29;
    v23.m128_f32[0] = (float)((float)(v23.m128_f32[0] + v28) + v30) / v29;
    v31 = _mm_cvtps_pd(v23);
    v31.m128d_f64[0] = v31.m128d_f64[0] * 0.5 + 0.5;
    v32 = _mm_cvtpd_ps(v31);
    v33 = _mm_cvtps_pd(v27);
    v33.m128d_f64[0] = v33.m128d_f64[0] * 0.5 + 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxSunPos = (Vector2Unaligned)_mm_unpacklo_ps(v32, _mm_cvtpd_ps(v33)).m128_u64[0];
    if ( v17 )
    {
      v17(0, "Actual God Ray Shader");
      v18 = _glewPushDebugGroup;
    }
    if ( v18 )
      v18(33354u, 1u, 21, "Actual God Ray Shader");
    v34 = this->m_pRender;
    ++markerCount;
    AppMain::ApplyShaderToTexture(
      this,
      7994,
      &v34->m_renderTextures.m_FullScreenTexture[7],
      &v34->m_renderTextures.m_ScreenBlurTexture,
      (int)v26,
      (int)v25,
      1);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    if ( _glewPopDebugGroup )
      _glewPopDebugGroup();
    --markerCount;
    if ( this->ModelRoomSettings.postprocessSettings.godRaySettings.blurStrength > 0.0 )
    {
      if ( _glewPushGroupMarkerEXT )
        _glewPushGroupMarkerEXT(0, "God Ray Blur");
      if ( _glewPushDebugGroup )
        _glewPushDebugGroup(0x824Au, 1u, 12, "God Ray Blur");
      blurStrength = this->ModelRoomSettings.postprocessSettings.godRaySettings.blurStrength;
      p_m_ScreenBlurTexture = &this->m_pRender->m_renderTextures.m_ScreenBlurTexture;
      ++markerCount;
      AppMain::GaussianBlurEffect(this, p_m_ScreenBlurTexture, p_m_ScreenBlurTexture, v26, v25, blurStrength);
      if ( _glewPopGroupMarkerEXT )
        _glewPopGroupMarkerEXT();
      if ( _glewPopDebugGroup )
        _glewPopDebugGroup();
      --markerCount;
    }
    if ( _glewPushGroupMarkerEXT )
      _glewPushGroupMarkerEXT(0, "Blend To FullScreen");
    if ( _glewPushDebugGroup )
      _glewPushDebugGroup(0x824Au, 1u, 19, "Blend To FullScreen");
    v38 = this->m_pRender;
    ++markerCount;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlendFactor = 0.5;
    v43.x = 1.0 / v26;
    v43.y = 1.0 / v25;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize = v43;
    AppMain::BlendTwoTextures(
      this,
      v35,
      v38->m_renderTextures.m_FullScreenTexture,
      v38->m_renderTextures.m_FullScreenTexture,
      &v38->m_renderTextures.m_ScreenBlurTexture);
    v7 = _glewPopGroupMarkerEXT;
    if ( _glewPopGroupMarkerEXT )
    {
      _glewPopGroupMarkerEXT();
      v7 = _glewPopGroupMarkerEXT;
    }
    v8 = _glewPopDebugGroup;
    if ( _glewPopDebugGroup )
    {
      _glewPopDebugGroup();
      v7 = _glewPopGroupMarkerEXT;
      v8 = _glewPopDebugGroup;
    }
    v39 = this->m_pRender;
    --markerCount;
    glDeleteRenderbuffersAG(1, &v39->m_renderTextures.m_ScreenBlurTexture.m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_ScreenBlurTexture.m_FrameBufferID = 0;
    if ( v7 )
    {
      v7();
      v7 = _glewPopGroupMarkerEXT;
      v8 = _glewPopDebugGroup;
    }
    if ( v8 )
    {
      v8();
      v7 = _glewPopGroupMarkerEXT;
      v8 = _glewPopDebugGroup;
    }
    --markerCount;
  }
  if ( v7 )
  {
    v7();
    v8 = _glewPopDebugGroup;
  }
  if ( v8 )
    v8();
  --markerCount;
}

void __fastcall AppMain::HeatHazeShader(AppMain *this, float near, float speed, float strength)
{
  float m_iScreenW; // xmm4_4
  OGLTexture *v5; // r9
  long double m_secondsElapsedActual; // xmm0_8
  __m128i v7; // xmm2

  m_iScreenW = (float)this->m_iScreenW;
  v5 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[6];
  m_secondsElapsedActual = Framework::GLManager::glm->m_secondsElapsedActual;
  this->ModelRoomSettings.postfxUniforms.u_postfxHazeFilter.y = speed;
  v7 = _mm_cvtsi32_si128(this->m_iScreenH);
  this->ModelRoomSettings.postfxUniforms.u_postfxHazeFilter.x = near;
  *(float *)&m_secondsElapsedActual = m_secondsElapsedActual;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  *(float *)v7.m128i_i32 = _mm_cvtepi32_ps(v7).m128_f32[0];
  this->ModelRoomSettings.postfxUniforms.u_postfxElapsedTime = *(float *)&m_secondsElapsedActual;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / m_iScreenW;
  this->ModelRoomSettings.postfxUniforms.u_postfxHazeFilter.z = strength;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / *(float *)v7.m128i_i32;
  AppMain::ApplyShaderToTexture(this, 7951, v5, v5, (int)m_iScreenW, (int)*(float *)v7.m128i_i32, 6);
}

void __fastcall AppMain::HighlightExtractionTwoBuffersPass(AppMain *this)
{
  int downsampleScale; // ecx
  __m128i v3; // xmm2
  __m128i v4; // xmm1
  float highlightThreshold; // eax
  OGLRender *m_pRender; // rdx
  OGLTexture *p_m_BloomMapTexture; // r9
  int width; // [rsp+20h] [rbp-28h]
  int height; // [rsp+28h] [rbp-20h]

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Highlight Extraction Two Buffers Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 37, "Highlight Extraction Two Buffers Pass");
  downsampleScale = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  v3 = _mm_cvtsi32_si128(this->m_iScreenH);
  v4 = _mm_cvtsi32_si128(this->m_iScreenW);
  highlightThreshold = this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightThreshold;
  m_pRender = this->m_pRender;
  ++markerCount;
  this->ModelRoomSettings.postfxUniforms.u_postfxHighlightThresholdBrightness.x = highlightThreshold;
  p_m_BloomMapTexture = &m_pRender->m_renderTextures.m_BloomMapTexture;
  this->ModelRoomSettings.postfxUniforms.u_postfxHighlightThresholdBrightness.y = this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightBrightness;
  height = (int)(float)(_mm_cvtepi32_ps(v3).m128_f32[0] / (float)downsampleScale);
  width = (int)(float)(_mm_cvtepi32_ps(v4).m128_f32[0] / (float)downsampleScale);
  if ( downsampleScale != 1 )
    p_m_BloomMapTexture = m_pRender->m_renderTextures.m_BloomMapDownSampleTexture;
  AppMain::CharHighlightExtractionTwoBuffers(
    this,
    &m_pRender->m_renderTextures.m_FullScreenTexture[3],
    &m_pRender->m_renderTextures.m_FullScreenTexture[5],
    p_m_BloomMapTexture,
    width,
    height);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > *__fastcall extension::FutureObjectJobManager<OGLMirror,void>::LoadStart(
        extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > *result,
        const std::string *name,
        const std::string *optstr,
        const void *__formal)
{
  extension::AsyncContent<OGLMirror> *v7; // rax
  extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > shared; // [rsp+58h] [rbp+20h] BYREF

  shared.m_ptr = (extension::AsyncContent<OGLMirror> *)__formal;
  shared.m_ptr = (extension::AsyncContent<OGLMirror> *)operator new(0x68ui64);
  extension::AsyncContent<OGLSecondary>::AsyncContent<OGLSecondary>(
    (extension::AsyncContent<extension::exsound_detail::SoundBankImpl> *)shared.m_ptr,
    name,
    optstr);
  result->m_ptr = v7;
  shared.m_ptr = v7;
  if ( v7 )
    _InterlockedExchangeAdd64((volatile signed __int64 *)v7, 1ui64);
  extension::FutureObjectJobManager<OGLMirror,void>::EnqueueAsyncJob((extension::RefCountablePtr<extension::AsyncContent<OGLMirror> >)&shared);
  return result;
}

extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > *__fastcall extension::FutureObjectJobManager<OGLMotion,void>::LoadStart(
        extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > *result,
        const std::string *name,
        const std::string *optstr,
        const void *__formal)
{
  extension::AsyncContent<OGLMotion> *v7; // rax
  extension::RefCountablePtr<extension::AsyncContent<OGLMotion> > shared; // [rsp+58h] [rbp+20h] BYREF

  shared.m_ptr = (extension::AsyncContent<OGLMotion> *)__formal;
  shared.m_ptr = (extension::AsyncContent<OGLMotion> *)operator new(0x68ui64);
  extension::AsyncContent<OGLSecondary>::AsyncContent<OGLSecondary>(
    (extension::AsyncContent<extension::exsound_detail::SoundBankImpl> *)shared.m_ptr,
    name,
    optstr);
  result->m_ptr = v7;
  shared.m_ptr = v7;
  if ( v7 )
    _InterlockedExchangeAdd64((volatile signed __int64 *)v7, 1ui64);
  extension::FutureObjectJobManager<OGLMotion,void>::EnqueueAsyncJob((extension::RefCountablePtr<extension::AsyncContent<OGLMotion> >)&shared);
  return result;
}

void __fastcall AppMain::MaskTwoTexturesExt(
        AppMain *this,
        int shader,
        OGLTexture *pDestTexture,
        OGLTexture *pOtherSrcBlend,
        int width,
        int height)
{
  Framework::GLManager *v6; // r13
  unsigned int *p_m_FrameBufferID; // rdx
  bool v11; // zf
  unsigned int *p_m_TexID; // rdx
  unsigned int v13; // ecx
  unsigned int m_TexID; // edx
  __int64 v15; // rax
  unsigned __int64 v16; // rcx
  Framework::GLManager *v17; // rcx
  unsigned int v18; // er8
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // ecx
  Framework::GLManager *v22; // rcx
  unsigned int v23; // edx
  Framework::GLManager *v24; // rcx
  unsigned int v25; // eax
  unsigned int v26; // edx
  Framework::GLManager *v27; // rcx
  unsigned int v28; // edx
  Framework::GLManager *v29; // rcx
  OGLShader *v30; // r15
  Framework::GLManager *v31; // rcx
  int v32; // edi
  unsigned __int64 v33; // r8
  _QWORD *v34; // rax
  int *v35; // r8
  char *v36; // r14
  float *v37; // rdx
  __int64 v38; // r9
  float *v39; // rcx
  float v40; // xmm0_4
  __m128 v41; // xmm1
  float v42; // eax
  unsigned __int64 v43; // xmm0_8
  __m128 v44; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v46; // xmm2
  __m128 v47; // xmm3
  __m128 v48; // xmm4
  __m128 v49; // xmm5
  __m128 v50; // xmm6
  __m128 v51; // xmm7
  __m128 v52; // xmm8
  __m128 v53; // xmm9
  int v54; // ecx
  unsigned __int8 v55; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v57; // rsi
  __int64 v58; // rcx
  Framework::GLManager *v59; // r13
  signed int v60; // er10
  int renderSize; // ecx
  int v62; // eax
  int *v63; // rax
  __int64 v64; // rcx
  int v65; // eax
  AppMain *v66; // rcx
  int v67; // edx
  unsigned int v68; // ecx
  int v69; // [rsp+28h] [rbp-E0h]
  unsigned int v70; // [rsp+40h] [rbp-C8h]
  __int128 v71; // [rsp+48h] [rbp-C0h]
  __int128 v72; // [rsp+58h] [rbp-B0h]
  __int128 v73; // [rsp+68h] [rbp-A0h]
  __int128 v74; // [rsp+78h] [rbp-90h]
  __int128 v75; // [rsp+88h] [rbp-80h]
  __int128 v76; // [rsp+98h] [rbp-70h]
  __int128 v77; // [rsp+A8h] [rbp-60h]
  __int128 v78; // [rsp+B8h] [rbp-50h]
  float v[4]; // [rsp+C8h] [rbp-40h] BYREF
  float value[4]; // [rsp+D8h] [rbp-30h] BYREF
  __int128 v81; // [rsp+E8h] [rbp-20h]
  __int128 v82; // [rsp+F8h] [rbp-10h]
  __int128 v83; // [rsp+108h] [rbp+0h]
  float v84[4]; // [rsp+118h] [rbp+10h] BYREF
  __int128 v85; // [rsp+128h] [rbp+20h]
  __int128 v86; // [rsp+138h] [rbp+30h]
  __int128 v87; // [rsp+148h] [rbp+40h]
  int v88; // [rsp+158h] [rbp+50h] BYREF
  __int64 v89; // [rsp+15Ch] [rbp+54h]
  int v90; // [rsp+164h] [rbp+5Ch]
  int v91; // [rsp+168h] [rbp+60h]
  int v92; // [rsp+16Ch] [rbp+64h]
  int v93; // [rsp+170h] [rbp+68h]
  int v94; // [rsp+174h] [rbp+6Ch]
  __int64 v95; // [rsp+180h] [rbp+78h]
  __int64 v96; // [rsp+188h] [rbp+80h] BYREF
  float v97; // [rsp+190h] [rbp+88h]
  int v98; // [rsp+194h] [rbp+8Ch]
  float v99; // [rsp+198h] [rbp+90h]
  __int64 v100; // [rsp+19Ch] [rbp+94h]
  float v101; // [rsp+1A4h] [rbp+9Ch]
  float v102; // [rsp+1A8h] [rbp+A0h]
  int v103; // [rsp+1ACh] [rbp+A4h]
  float v104[4]; // [rsp+1B8h] [rbp+B0h] BYREF

  if ( pOtherSrcBlend )
  {
    v6 = Framework::GLManager::glm;
    if ( pDestTexture )
    {
      p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
      v11 = *p_m_FrameBufferID == 0;
      v96 = 0i64;
      v95 = 0i64;
      v100 = 0i64;
      v103 = 0;
      v98 = 0;
      v89 = 0i64;
      v88 = 0;
      v92 = 0;
      v102 = (float)height;
      v97 = (float)height;
      v101 = (float)width;
      v99 = (float)width;
      v93 = 1065353216;
      v91 = 1065353216;
      v94 = 1065353216;
      v90 = 1065353216;
      if ( v11 )
        glGenRenderbuffersAG(1, p_m_FrameBufferID);
      p_m_TexID = &this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
      if ( !*p_m_TexID )
        glGenTexturesAG(1, p_m_TexID);
      if ( !pDestTexture->m_TexID )
        glGenTexturesAG(1, &pDestTexture->m_TexID);
      v13 = m_ActiveTexture;
      if ( m_ActiveTexture )
      {
        m_ActiveTexture = 0;
        _glewActiveTexture(0x84C0u);
        v13 = m_ActiveTexture;
      }
      m_TexID = this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
      v15 = v13;
      v16 = 0x140000000ui64;
      if ( m_TexID != ::m_TexID[v15] || !m_TexID )
      {
        ::m_TexID[v15] = m_TexID;
        v17 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = m_TexID;
        while ( v17->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, m_TexID);
      }
      glBindRenderbufferAG(v16, this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
      v19 = m_ActiveTexture;
      if ( m_ActiveTexture != 1 )
      {
        m_ActiveTexture = 1;
        _glewActiveTexture(0x84C1u);
        v19 = m_ActiveTexture;
      }
      v20 = pDestTexture->m_TexID;
      v21 = v19;
      if ( v20 != ::m_TexID[v19] || !v20 )
      {
        ::m_TexID[v19] = v20;
        v22 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v20;
        while ( v22->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v20);
      }
      glsFramebufferTexture2D(v21, 0x8CE1u, v18, pDestTexture->m_TexID, v69, width, height, v70);
      v23 = pDestTexture->m_TexID;
      if ( v23 != ::m_TexID[m_ActiveTexture] || !v23 )
      {
        v24 = Framework::GLManager::glm;
        ::m_TexID[m_ActiveTexture] = v23;
        v24->m_textureID = v23;
        while ( v24->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v23);
      }
      glTexParameterf(0xDE1u, 0x2801u, 9729.0);
      glTexParameterf(0xDE1u, 0x2800u, 9729.0);
      glTexParameterf(0xDE1u, 0x2802u, 33071.0);
      glTexParameterf(0xDE1u, 0x2803u, 33071.0);
      v25 = m_ActiveTexture;
      pDestTexture->m_TexParam = 1290;
      if ( v25 != 2 )
      {
        m_ActiveTexture = 2;
        _glewActiveTexture(0x84C2u);
        v25 = m_ActiveTexture;
      }
      v26 = pOtherSrcBlend->m_TexID;
      if ( v26 != ::m_TexID[v25] || !v26 )
      {
        ::m_TexID[v25] = v26;
        v27 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v26;
        while ( v27->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v26);
        v25 = m_ActiveTexture;
      }
      v28 = pOtherSrcBlend->m_TexID;
      if ( v28 != ::m_TexID[v25] || !v28 )
      {
        ::m_TexID[v25] = v28;
        v29 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v28;
        while ( v29->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v28);
      }
      glTexParameterf(0xDE1u, 0x2801u, 9729.0);
      glTexParameterf(0xDE1u, 0x2800u, 9729.0);
      glTexParameterf(0xDE1u, 0x2802u, 33071.0);
      glTexParameterf(0xDE1u, 0x2803u, 33071.0);
      v11 = m_DepthMask == 1;
      pOtherSrcBlend->m_TexParam = 1290;
      if ( !v11 )
      {
        m_DepthMask = 1;
        glDepthMask(1u);
      }
      glClearAG(0x100u);
      GraphicsOpt::lock(this->g);
      v30 = this->m_pRender->m_ShaderFXTbl[7970];
      if ( v30 )
      {
        if ( v30->m_Program )
        {
          KOFShaderManager::useProgramSlot(
            (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
            v30->m_programSlot);
          v31 = Framework::GLManager::glm;
          v32 = 64;
          Framework::GLManager::glm->renderSize = 64;
          v34 = AgFrameAllocator<AgAllocator<1>>::allocate(&v31->m_agDrawAllocator, 0x100ui64, v33);
          v35 = &v88;
          v36 = (char *)v34;
          v37 = (float *)&v96;
          v38 = 4i64;
          v39 = (float *)(v34 + 7);
          do
          {
            v40 = *v37;
            v35 += 2;
            v41 = (__m128)*((unsigned int *)v37 - 1);
            v37 += 3;
            v[2] = v40;
            v42 = v40;
            v43 = _mm_unpacklo_ps((__m128)*((unsigned int *)v37 - 5), v41).m128_u64[0];
            v44 = (__m128)(unsigned int)*(v35 - 1);
            *((_QWORD *)v39 - 7) = v43;
            *(_QWORD *)v39 = _mm_unpacklo_ps((__m128)(unsigned int)*(v35 - 2), v44).m128_u64[0];
            *(v39 - 12) = v42;
            *((_OWORD *)v39 - 1) = _xmm;
            v39 += 16;
            --v38;
          }
          while ( v38 );
          v6->m_vertexInfoCount = 4;
          m_pRender = this->m_pRender;
          v46 = *(__m128 *)m_pRender->m_View.m;
          v47 = *(__m128 *)&m_pRender->m_View.m[4];
          v48 = *(__m128 *)&m_pRender->m_View.m[8];
          v49 = *(__m128 *)&m_pRender->m_View.m[12];
          v50 = *(__m128 *)m_pRender->m_Proj.m;
          v51 = *(__m128 *)&m_pRender->m_Proj.m[4];
          v52 = *(__m128 *)&m_pRender->m_Proj.m[8];
          v53 = *(__m128 *)&m_pRender->m_Proj.m[12];
          *(_QWORD *)&v71 = __PAIR64__(v47.m128_u32[0], v46.m128_u32[0]);
          LODWORD(v72) = _mm_shuffle_ps(v46, v46, 85).m128_u32[0];
          LODWORD(v73) = _mm_shuffle_ps(v46, v46, 170).m128_u32[0];
          DWORD1(v72) = _mm_shuffle_ps(v47, v47, 85).m128_u32[0];
          DWORD1(v73) = _mm_shuffle_ps(v47, v47, 170).m128_u32[0];
          DWORD2(v72) = _mm_shuffle_ps(v48, v48, 85).m128_u32[0];
          DWORD2(v73) = _mm_shuffle_ps(v48, v48, 170).m128_u32[0];
          HIDWORD(v72) = _mm_shuffle_ps(v49, v49, 85).m128_u32[0];
          HIDWORD(v73) = _mm_shuffle_ps(v49, v49, 170).m128_u32[0];
          v81 = v72;
          *((_QWORD *)&v71 + 1) = __PAIR64__(v49.m128_u32[0], v48.m128_u32[0]);
          *(_OWORD *)value = v71;
          v82 = v73;
          LODWORD(v76) = _mm_shuffle_ps(v50, v50, 85).m128_u32[0];
          DWORD1(v76) = _mm_shuffle_ps(v51, v51, 85).m128_u32[0];
          LODWORD(v74) = _mm_shuffle_ps(v46, v46, 255).m128_u32[0];
          DWORD1(v74) = _mm_shuffle_ps(v47, v47, 255).m128_u32[0];
          DWORD2(v74) = _mm_shuffle_ps(v48, v48, 255).m128_u32[0];
          HIDWORD(v74) = _mm_shuffle_ps(v49, v49, 255).m128_u32[0];
          v83 = v74;
          LODWORD(v77) = _mm_shuffle_ps(v50, v50, 170).m128_u32[0];
          DWORD1(v77) = _mm_shuffle_ps(v51, v51, 170).m128_u32[0];
          *(_QWORD *)&v75 = __PAIR64__(v51.m128_u32[0], v50.m128_u32[0]);
          *((_QWORD *)&v75 + 1) = __PAIR64__(v53.m128_u32[0], v52.m128_u32[0]);
          DWORD2(v78) = _mm_shuffle_ps(v52, v52, 255).m128_u32[0];
          LODWORD(v78) = _mm_shuffle_ps(v50, v50, 255).m128_u32[0];
          DWORD1(v78) = _mm_shuffle_ps(v51, v51, 255).m128_u32[0];
          DWORD2(v76) = _mm_shuffle_ps(v52, v52, 85).m128_u32[0];
          DWORD2(v77) = _mm_shuffle_ps(v52, v52, 170).m128_u32[0];
          v54 = *v30->m_piGLUniform;
          HIDWORD(v76) = _mm_shuffle_ps(v53, v53, 85).m128_u32[0];
          HIDWORD(v77) = _mm_shuffle_ps(v53, v53, 170).m128_u32[0];
          *(_OWORD *)v84 = v75;
          v85 = v76;
          HIDWORD(v78) = _mm_shuffle_ps(v53, v53, 255).m128_u32[0];
          v86 = v77;
          v87 = v78;
          glUniformMatrix4fvAG(v54, 1, (unsigned __int8)v35, value);
          glUniformMatrix4fvAG(v30->m_piGLUniform[1], 1, v55, v84);
          m_piGLUniform = v30->m_piGLUniform;
          *(_OWORD *)v = _xmm;
          glUniform4fvAG(m_piGLUniform[5], 1, v);
          v57 = AgSingleton<KOFShaderManager>::ms_instance;
          v58 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                          * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                          + 7].onSingletonInit;
          if ( (unsigned int)v58 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v58;
            g_vertexAttribIndex[v58] = 0;
          }
          v59 = Framework::GLManager::glm;
          v60 = *(_DWORD *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit;
          renderSize = Framework::GLManager::glm->renderSize;
          switch ( renderSize )
          {
            case 64:
              v62 = 64;
              break;
            case 280:
              v62 = 136;
              break;
            case 208:
              v62 = 64;
              break;
            default:
              v62 = 88;
              if ( renderSize == 144 )
                v62 = 144;
              break;
          }
          if ( v60 >= 0 )
          {
            _glewVertexAttribPointer(v60, 3, 0x1406u, 0, v62, v36);
            v59 = Framework::GLManager::glm;
            v57 = AgSingleton<KOFShaderManager>::ms_instance;
          }
          v63 = v30->m_piGLUniform;
          *(_OWORD *)v104 = _xmm;
          glUniform4fvAG(v63[5], 1, v104);
          v64 = *((unsigned int *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit + 4);
          if ( (unsigned int)v64 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v64;
            g_vertexAttribIndex[v64] = 4;
          }
          v65 = v59->renderSize;
          v66 = (AppMain *)*((unsigned int *)v57[11 * SLODWORD(v57[360450].__vftable) + 7].onSingletonInit + 4);
          if ( v65 != 64 )
          {
            if ( v65 == 280 )
            {
              v32 = 8;
LABEL_68:
              if ( (int)v66 >= 0 )
                _glewVertexAttribPointer((unsigned int)v66, 2, 0x1406u, 0, v32, v36);
              AppMain::SetPostFXUniforms(
                v66,
                v30,
                &this->ModelRoomSettings.postfxUniforms,
                &this->ModelRoomSettings.filterUniforms);
              glDrawArraysAG(v68, v67, 4);
              Graphics::drawStack(this->g->g);
              glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID);
              this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
              return;
            }
            if ( v65 != 208 )
            {
              if ( v65 == 144 )
              {
                v32 = 144;
                goto LABEL_68;
              }
              v32 = 88;
            }
          }
          v36 += 56;
          goto LABEL_68;
        }
      }
    }
  }
}

void __fastcall AppMain::MergeCharacterFrames(AppMain *this, int curFrame, int characterId)
{
  __int64 v5; // rbp
  OGLRender *m_pRender; // rdx
  __m128i v7; // xmm7
  float m_iScreenW; // xmm6_4
  char v9; // r8
  float v10; // xmm7_4
  unsigned int v11; // edi
  unsigned int v12; // eax
  __int64 v13; // rbx
  __int64 v14; // rax

  v5 = characterId;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Motion Blur");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 11, "Motion Blur");
  ++markerCount;
  m_pRender = this->m_pRender;
  v7 = _mm_cvtsi32_si128(this->m_iScreenH);
  m_iScreenW = (float)this->m_iScreenW;
  this->ModelRoomSettings.postfxUniforms.u_postfxBlendFactor = 0.60000002;
  v9 = this->ModelRoomSettings.motionBlurShowBit[v5];
  LODWORD(v10) = _mm_cvtepi32_ps(v7).m128_u32[0];
  v11 = (m_pRender->m_renderTextures.m_CharacterFrames[v5][0].m_TexID != 0)
      + (m_pRender->m_renderTextures.m_CharacterFrames[v5][1].m_TexID != 0)
      + (m_pRender->m_renderTextures.m_CharacterFrames[v5][2].m_TexID != 0)
      + (m_pRender->m_renderTextures.m_CharacterFrames[v5][3].m_TexID != 0)
      + (m_pRender->m_renderTextures.m_CharacterFrames[v5][4].m_TexID != 0);
  v12 = v9 & 1;
  if ( (v9 & 1) == 0 )
  {
    v12 = v9 & 2;
    if ( (v9 & 2) == 0 )
    {
      v12 = (v9 & 4) != 0 ? 3 : 0;
      if ( !v12 )
        v12 = ((unsigned int)v9 >> 1) & 4;
    }
  }
  if ( v11 > v12 && v9 > 0 )
  {
    v13 = v5;
    AppMain::FadeFrameBuffers(this, curFrame, v11, v5, &m_pRender->m_renderTextures.m_MergedTexture[v5]);
    v14 = 5i64;
    if ( (_DWORD)v5 != 1 )
      v14 = 3i64;
    AppMain::ApplyShaderToTexture(
      this,
      7923,
      &this->m_pRender->m_renderTextures.m_MergedTexture[v13],
      &this->m_pRender->m_renderTextures.m_FullScreenTexture[v14],
      (int)m_iScreenW,
      (int)v10,
      1);
    AppMain::FadeFrameDepthBuffers(
      this,
      curFrame,
      v11,
      v5,
      &this->m_pRender->m_renderTextures.m_MergedDepthTexture[v13]);
    glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_MergedDepthTexture[v13].m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_MergedDepthTexture[v13].m_FrameBufferID = 0;
    glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_MergedTexture[v13].m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_MergedTexture[v13].m_FrameBufferID = 0;
  }
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::ModelDepthPass(AppMain *this, int textureIndex, int stack)
{
  OGLRender *m_pRender; // rax
  unsigned __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 v7; // rdx
  bool v8; // zf
  unsigned int *v9; // rdx
  unsigned __int64 v10; // rdi
  unsigned int *p_m_TexID; // rdx
  OGLRender *v12; // rsi
  unsigned int m_TexID; // edx
  Framework::GLManager *v14; // rcx
  __int64 v15; // rcx
  unsigned int v16; // er8
  OGLMatrix *v17; // rcx
  OGLRender *v18; // rax
  OGLRender *v19; // rcx
  int v20; // [rsp+20h] [rbp-28h]
  unsigned int v21; // [rsp+38h] [rbp-10h]

  m_pRender = this->m_pRender;
  v5 = textureIndex;
  v6 = stack;
  v7 = textureIndex + 194398i64;
  v8 = *(&m_pRender->m_Width + v7) == 0;
  v9 = (unsigned int *)(&m_pRender->m_Width + v7);
  if ( v8 )
    glGenRenderbuffersAG(1, v9);
  v10 = v5;
  p_m_TexID = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[v5].m_TexID;
  if ( !*p_m_TexID )
    glGenTexturesAG(1, p_m_TexID);
  glBindRenderbufferAG((unsigned int)this, this->m_pRender->m_renderTextures.m_RenderBufferDepthID[v5]);
  v12 = this->m_pRender;
  m_TexID = v12->m_renderTextures.m_DepthMapForAlphaTexture[v10].m_TexID;
  if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
  {
    ::m_TexID[m_ActiveTexture] = m_TexID;
    v14 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = m_TexID;
    while ( v14->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
  }
  glTexParameterf(0xDE1u, 0x2801u, 9729.0);
  glTexParameterf(0xDE1u, 0x2800u, 9729.0);
  glTexParameterf(0xDE1u, 0x2802u, 33071.0);
  glTexParameterf(0xDE1u, 0x2803u, 33071.0);
  v15 = *(_QWORD *)&AppMain::pApp;
  v12->m_renderTextures.m_DepthMapForAlphaTexture[v10].m_TexParam = 1290;
  glsFramebufferTexture2D(
    v15,
    0x8D00u,
    v16,
    this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[v10].m_TexID,
    v20,
    *(_DWORD *)(v15 + 28),
    *(_DWORD *)(v15 + 32),
    v21);
  if ( m_DepthMask != 1 )
  {
    m_DepthMask = 1;
    glDepthMask(1u);
  }
  glClearAG(0x100u);
  GraphicsOpt::lock(this->g);
  if ( dword_140A9606C != 1 )
  {
    dword_140A9606C = 1;
    glEnable(0xB71u);
  }
  glDepthFunc(0x203u);
  if ( m_DepthMask != 1 )
  {
    m_DepthMask = 1;
    glDepthMask(1u);
  }
  if ( dword_140A96054 != 1 )
  {
    dword_140A96054 = 1;
    glEnable(0xB44u);
  }
  glCullFace(0x405u);
  this->m_pRender->m_DepthPassFlg = 1;
  v17 = &this->ModelRoomSettings.mProj[v6];
  v18 = this->m_pRender;
  if ( v17 )
  {
    *(_OWORD *)v18->m_Proj.m = *(_OWORD *)v17->m;
    *(_OWORD *)&v18->m_Proj.m[4] = *(_OWORD *)&v17->m[4];
    *(_OWORD *)&v18->m_Proj.m[8] = *(_OWORD *)&v17->m[8];
    *(_OWORD *)&v18->m_Proj.m[12] = *(_OWORD *)&v17->m[12];
  }
  else
  {
    *(_QWORD *)v18->m_Proj.m = 1065353216i64;
    v18->m_Proj.m[4] = 0.0;
    *(_QWORD *)&v18->m_Proj.m[8] = 0i64;
    *(_QWORD *)&v18->m_Proj.m[12] = 0i64;
    *(_QWORD *)&v18->m_Proj.m[2] = 0i64;
    v18->m_Proj.m[14] = 0.0;
    v18->m_Proj.m[7] = 0.0;
    *(_QWORD *)&v18->m_Proj.m[5] = 1065353216i64;
    *(_QWORD *)&v18->m_Proj.m[10] = 1065353216i64;
    v18->m_Proj.m[15] = 1.0;
  }
  OGLRender::setViewTrans(this->m_pRender, &this->ModelRoomSettings.mView);
  OGLRender::setInvViewTrans(this->m_pRender, &this->ModelRoomSettings.mInvView);
  v19 = this->m_pRender;
  if ( v19->m_RenderStackNo < 8 )
    v19->m_RenderStackNo = v6;
  OGLRender::drawStack(this->m_pRender, 0, 1u);
  this->m_pRender->m_DepthPassFlg = 0;
  Graphics::drawStack(this->g->g);
}

void __fastcall AppMain::ModelRoomDrawTPose(AppMain *this, float scale)
{
  unsigned __int8 v3; // r8
  OGLModel **Myval2; // rax
  bool v5; // r15
  bool v6; // r12
  bool v7; // r13
  OGLModel *v8; // rax
  OGLModel **v9; // rax
  OGLModel **v10; // rax
  OGLModel **v11; // rax
  int v12; // ebx
  int v13; // ebp
  __int64 v14; // rdi
  int v15; // ebp
  __int64 v16; // rdi
  int v17; // ebp
  __int64 v18; // rdi
  int v19; // ebp
  __int64 v20; // rdi
  unsigned __int8 v21; // r8
  int v22; // er9
  int v23; // er9
  int v24; // er8
  __int64 v25; // rdx
  int v26; // er8
  __int64 v27; // rdx
  int v28; // er8
  unsigned __int8 v29; // r9
  __int64 v30; // rdx
  __int64 v31; // rdx
  OGLRender *m_pRender; // rax
  float v33; // xmm6_4
  float v34; // xmm7_4
  OGLRender *v35; // r8
  Framework::GLManager *v36; // rbx
  unsigned int v37; // ecx
  unsigned int v38; // [rsp+B0h] [rbp+8h] BYREF
  int v39; // [rsp+B8h] [rbp+10h]

  AppMain::_MODELROOM_SETTINGS::CalcBlendProjParam(&this->ModelRoomSettings);
  Myval2 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2;
  v5 = 1;
  v39 = 16843009;
  v6 = 1;
  v7 = 1;
  if ( Myval2 )
  {
    v8 = *Myval2;
    if ( v8 )
    {
      v5 = v8->m_receiveShadowsFlg != 0;
      LOBYTE(v39) = v5;
    }
  }
  v9 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
  if ( v9 && *v9 )
  {
    v6 = (*v9)->m_receiveShadowsFlg != 0;
    BYTE2(v39) = v6;
  }
  v10 = this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2;
  if ( v10 && *v10 )
    BYTE1(v39) = (*v10)->m_receiveShadowsFlg != 0;
  v11 = this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
  if ( v11 && *v11 )
  {
    v7 = (*v11)->m_receiveShadowsFlg != 0;
    HIBYTE(v39) = v7;
  }
  v12 = 0;
  v13 = 0;
  if ( this->ModelRoomSettings.CharaInfo[0].iModelCount > 0 )
  {
    v14 = 0i64;
    do
    {
      AppMain::_MODELROOM_SETTINGS::SetBlendProjection(
        &this->ModelRoomSettings,
        this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v14++]);
      ++v13;
      this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v14 - 1]->m_receiveShadowsFlg = 0;
    }
    while ( v13 < this->ModelRoomSettings.CharaInfo[0].iModelCount );
  }
  v15 = 0;
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v16 = 0i64;
    do
    {
      AppMain::_MODELROOM_SETTINGS::SetBlendProjection(
        &this->ModelRoomSettings,
        this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v16++]);
      ++v15;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v16 - 1]->m_receiveShadowsFlg = 0;
    }
    while ( v15 < this->ModelRoomSettings.CharaInfo[2].iModelCount );
  }
  v17 = 0;
  if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
  {
    v18 = 0i64;
    do
    {
      AppMain::_MODELROOM_SETTINGS::SetBlendProjection(
        &this->ModelRoomSettings,
        this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v18++]);
      ++v17;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v18 - 1]->m_receiveShadowsFlg = 0;
    }
    while ( v17 < this->ModelRoomSettings.CharaInfo[1].iModelCount );
  }
  v19 = 0;
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v20 = 0i64;
    do
    {
      AppMain::_MODELROOM_SETTINGS::SetBlendProjection(
        &this->ModelRoomSettings,
        this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v20++]);
      ++v19;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v20 - 1]->m_receiveShadowsFlg = 0;
    }
    while ( v19 < this->ModelRoomSettings.CharaInfo[3].iModelCount );
  }
  AppMain::ModelRoomShadowPass(this, 2, v3);
  AppMain::ModelRoomShadowPass(this, 3, v21);
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Render P1 TPose");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 15, "Render P1 TPose");
  ++markerCount;
  AppMain::RenderToTexturePass(this, 3, 2, v22);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Render P2 TPose");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 15, "Render P2 TPose");
  ++markerCount;
  AppMain::RenderToTexturePass(this, 5, 3, v23);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
  v24 = 0;
  if ( this->ModelRoomSettings.CharaInfo[0].iModelCount > 0 )
  {
    v25 = 0i64;
    do
    {
      ++v25;
      ++v24;
      this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v25 - 1]->m_receiveShadowsFlg = v5;
    }
    while ( v24 < this->ModelRoomSettings.CharaInfo[0].iModelCount );
  }
  v26 = 0;
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v27 = 0i64;
    do
    {
      ++v27;
      ++v26;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v27 - 1]->m_receiveShadowsFlg = v6;
    }
    while ( v26 < this->ModelRoomSettings.CharaInfo[2].iModelCount );
  }
  v28 = 0;
  if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
  {
    v29 = BYTE1(v39);
    v30 = 0i64;
    do
    {
      ++v30;
      ++v28;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v30 - 1]->m_receiveShadowsFlg = v29;
    }
    while ( v28 < this->ModelRoomSettings.CharaInfo[1].iModelCount );
  }
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v31 = 0i64;
    do
    {
      ++v31;
      ++v12;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v31 - 1]->m_receiveShadowsFlg = v7;
    }
    while ( v12 < this->ModelRoomSettings.CharaInfo[3].iModelCount );
  }
  m_pRender = this->m_pRender;
  *(_QWORD *)m_pRender->m_sModelStackCount = 0i64;
  *(_QWORD *)&m_pRender->m_sModelStackCount[2] = 0i64;
  *(_QWORD *)&m_pRender->m_sModelStackCount[4] = 0i64;
  *(_QWORD *)&m_pRender->m_sModelStackCount[6] = 0i64;
  v33 = (float)this->m_iScreenW / scale;
  v34 = (float)this->m_iScreenH / scale;
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Copy TPose");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 10, "Copy TPose");
  v35 = this->m_pRender;
  ++markerCount;
  AppMain::ApplyShaderToTexture(
    this,
    7923,
    &v35->m_renderTextures.m_FullScreenTexture[3],
    v35->m_renderTextures.m_CharacterTexture,
    (int)v33,
    (int)v34,
    1);
  AppMain::ApplyShaderToTexture(
    this,
    7923,
    &this->m_pRender->m_renderTextures.m_FullScreenTexture[5],
    &this->m_pRender->m_renderTextures.m_CharacterTexture[1],
    (int)v33,
    (int)v34,
    1);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  v36 = Framework::GLManager::glm;
  --markerCount;
  v37 = Framework::GLManager::glm->systemRenderID[Framework::GLManager::glm->m_backBufferIndex];
  Framework::GLManager::glm->currentRenderID = v37;
  v36->m_bOpenGLBlocked = 1;
  _glewBindFramebuffer(0x8D40u, *(_DWORD *)&v36->m_buffer.m_freeIDs[12 * (unsigned __int8)v37 + 15]);
  v36->m_bOpenGLBlocked = 0;
  v38 = 36064;
  _glewDrawBuffers(1, &v38);
  v36->m_outputMask = 1;
}

void __fastcall AppMain::ModelRoomLoadStage(AppMain *this, STAGE_ID stageID, char *a3, int a4)
{
  extension::FutureAssetOptionFileSetting *v5; // rcx
  unsigned __int64 v6; // r8
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::AssetCache *v7; // rcx
  __int64 v8; // rdx
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *m_ptr; // r8
  __int64 v10; // rcx
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *v11; // rcx
  __int64 v12; // rdx
  std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *v13; // r8
  std::integral_constant<bool,0> v14; // r9
  extension::RefCountablePtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body> v15; // [rsp+28h] [rbp-D8h] BYREF
  std::string v16; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v17; // [rsp+50h] [rbp-B0h]
  extension::FutureAssetOptionFileSetting v18; // [rsp+60h] [rbp-A0h] BYREF
  extension::FutureAssetOptionFileSetting v19; // [rsp+88h] [rbp-78h] BYREF
  extension::FutureAssetOptionFileSetting v20; // [rsp+B0h] [rbp-50h] BYREF
  std::string _Right; // [rsp+D8h] [rbp-28h] BYREF
  extension::FutureAssetOption v22; // [rsp+100h] [rbp+0h] BYREF

  v17 = -2i64;
  StageProjectData::GetStageModelFilePath(*(StageProjectData **)(*(_QWORD *)&AppMain::pApp + 11056i64), stageID, a3, a4);
  v22.playerNo = 1;
  *(_WORD *)&v22.disableShaderFXMaterialLight = 0;
  v22.effectPath._Mypair._Myval2._Myres = 15i64;
  v22.effectPath._Mypair._Myval2._Mysize = 0i64;
  v22.effectPath._Mypair._Myval2._Bx._Buf[0] = 0;
  v22.baseDataFlag = 0;
  v22.baseCharaPath._Mypair._Myval2._Myres = 15i64;
  v22.baseCharaPath._Mypair._Myval2._Mysize = 0i64;
  v22.baseCharaPath._Mypair._Myval2._Bx._Buf[0] = 0;
  memset(&v22.fileSetting, 0, sizeof(v22.fileSetting));
  v22.bNoMotion = 1;
  switch ( stageID )
  {
    case STAGE_ID_BAD:
      v19.fileName._Mypair._Myval2._Myres = 15i64;
      v19.fileName._Mypair._Myval2._Mysize = 0i64;
      v19.fileName._Mypair._Myval2._Bx._Buf[0] = 0;
      v19.bNoMotion = 0;
      std::string::assign(&v19.fileName, "BAD_OBJCAGE.obac", 0x10ui64);
      v19.bNoMotion = 0;
      std::vector<extension::FutureAssetOptionFileSetting>::push_back(&v22.fileSetting, &v19);
      v5 = &v19;
      break;
    case STAGE_ID_STH:
      v20.fileName._Mypair._Myval2._Myres = 15i64;
      v20.fileName._Mypair._Myval2._Mysize = 0i64;
      v20.fileName._Mypair._Myval2._Bx._Buf[0] = 0;
      v20.bNoMotion = 0;
      std::string::assign(&v20.fileName, "STH_04FAR.obac", 0xEui64);
      v20.bNoMotion = 0;
      std::vector<extension::FutureAssetOptionFileSetting>::push_back(&v22.fileSetting, &v20);
      v5 = &v20;
      break;
    case STAGE_ID_PSY:
      v18.fileName._Mypair._Myval2._Myres = 15i64;
      v18.fileName._Mypair._Myval2._Mysize = 0i64;
      v18.fileName._Mypair._Myval2._Bx._Buf[0] = 0;
      v18.bNoMotion = 0;
      std::string::assign(&v18.fileName, "PSY_10WAVEA.obac", 0x10ui64);
      v18.bNoMotion = 0;
      std::vector<extension::FutureAssetOptionFileSetting>::push_back(&v22.fileSetting, &v18);
      std::string::assign(&v18.fileName, "PSY_10WAVEB.obac", 0x10ui64);
      v18.bNoMotion = 0;
      std::vector<extension::FutureAssetOptionFileSetting>::push_back(&v22.fileSetting, &v18);
      v5 = &v18;
      break;
    default:
      goto LABEL_8;
  }
  std::string::~string(&v5->fileName);
LABEL_8:
  _Right._Mypair._Myval2._Myres = 15i64;
  _Right._Mypair._Myval2._Mysize = 0i64;
  _Right._Mypair._Myval2._Bx._Buf[0] = 0;
  if ( Buffer[0] )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( Buffer[v6] );
  }
  else
  {
    v6 = 0i64;
  }
  std::string::assign(&_Right, Buffer, v6);
  v16._Mypair._Myval2._Myres = 15i64;
  v16._Mypair._Myval2._Mysize = 0i64;
  v16._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&v16, &_Right, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::AssetCache::getCachedOrLoadStart(
    v7,
    &v15,
    &v16,
    &v22);
  v8 = *(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64);
  *(_BYTE *)(v8 + 1) = 0;
  m_ptr = v15.m_ptr;
  if ( v15.m_ptr )
    _InterlockedExchangeAdd64((volatile signed __int64 *)&v15.m_ptr->m_refCount.m_ptr->m_sharedCount, 1ui64);
  v10 = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = m_ptr;
  if ( v10
    && _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(v10 + 8) + 16i64), 0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    (**(void (__fastcall ***)(__int64, __int64))v10)(v10, 1i64);
  }
  v11 = v15.m_ptr;
  if ( v15.m_ptr
    && _InterlockedExchangeAdd64(
         (volatile signed __int64 *)&v15.m_ptr->m_refCount.m_ptr->m_sharedCount,
         0xFFFFFFFFFFFFFFFFui64) == 1 )
  {
    ((void (__fastcall *)(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *, __int64))v11->~RefCountableWeakSupportBase)(
      v11,
      1i64);
  }
  std::string::~string(&_Right);
  extension::FutureAssetOption::~FutureAssetOption(&v22, v12, v13, v14);
}

void __fastcall AppMain::ModelRoomReleaseBufferTPose(AppMain *this)
{
  unsigned int v2; // edx
  Framework::GLManager *v3; // rcx
  int v4; // er9
  unsigned int m_buffers; // er8
  unsigned int *systemRenderID; // rax

  v2 = 0;
  v3 = Framework::GLManager::glm;
  v4 = this->m_pRender->m_renderTextures.m_RenderBufferID[3];
  if ( v4 > 0 )
  {
    m_buffers = Framework::GLManager::glm->m_config.m_buffers;
    if ( m_buffers )
    {
      systemRenderID = Framework::GLManager::glm->systemRenderID;
      do
      {
        if ( *systemRenderID == v4 )
          break;
        ++v2;
        ++systemRenderID;
      }
      while ( v2 < m_buffers );
    }
    if ( v2 == m_buffers )
    {
      Framework::GLManager::glm->m_buffer.m_freeIDs[Framework::GLManager::glm->m_buffer.m_firstOccupiedIndex] = v4;
      ++v3->m_buffer.m_firstOccupiedIndex;
    }
  }
  this->m_pRender->m_renderTextures.m_RenderBufferID[3] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[5]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[5] = 0;
}

void __fastcall AppMain::ModelRoomRenderToTexturePass(AppMain *this, int frame, int stackId, int a4)
{
  void (__fastcall *v4)(int, const char *); // rax
  void (__fastcall *v7)(unsigned int, unsigned int, int, const char *); // r10
  int v8; // er9
  void (*v9)(void); // rax

  v4 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "First Render Pass");
    v4 = _glewPushGroupMarkerEXT;
  }
  v7 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 17, "First Render Pass");
    v4 = _glewPushGroupMarkerEXT;
    v7 = _glewPushDebugGroup;
  }
  ++markerCount;
  if ( this->ModelRoomSettings.postprocessSettings.godRaySettings.shaderOn )
  {
    if ( v4 )
    {
      v4(0, "Render Sun");
      v7 = _glewPushDebugGroup;
    }
    if ( v7 )
      v7(33354u, 1u, 10, "Render Sun");
    ++markerCount;
    AppMain::RenderToTexturePass(this, 7, 1, a4);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    if ( _glewPopDebugGroup )
      _glewPopDebugGroup();
    --markerCount;
    v4 = _glewPushGroupMarkerEXT;
    v7 = _glewPushDebugGroup;
  }
  if ( v4 )
  {
    v4(0, "Render Background");
    v7 = _glewPushDebugGroup;
  }
  if ( v7 )
    v7(33354u, 1u, 17, "Render Background");
  ++markerCount;
  AppMain::RenderToTexturePass(this, 6, 0, a4);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  v9 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v9 = _glewPopDebugGroup;
  }
  --markerCount;
  if ( stackId != 3 )
  {
    if ( _glewPushGroupMarkerEXT )
      _glewPushGroupMarkerEXT(0, "Render P1");
    if ( _glewPushDebugGroup )
      _glewPushDebugGroup(0x824Au, 1u, 9, "Render P1");
    ++markerCount;
    AppMain::RenderToTexturePass(this, 3, 2, v8);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    v9 = _glewPopDebugGroup;
    if ( _glewPopDebugGroup )
    {
      _glewPopDebugGroup();
      v9 = _glewPopDebugGroup;
    }
    --markerCount;
  }
  if ( stackId != 2 )
  {
    if ( _glewPushGroupMarkerEXT )
      _glewPushGroupMarkerEXT(0, "Render P2");
    if ( _glewPushDebugGroup )
      _glewPushDebugGroup(0x824Au, 1u, 9, "Render P2");
    ++markerCount;
    AppMain::RenderToTexturePass(this, 5, 3, v8);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    v9 = _glewPopDebugGroup;
    if ( _glewPopDebugGroup )
    {
      _glewPopDebugGroup();
      v9 = _glewPopDebugGroup;
    }
    --markerCount;
  }
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v9 = _glewPopDebugGroup;
  }
  if ( v9 )
    v9();
  --markerCount;
}

void __fastcall AppMain::ModelRoomShadowPass(AppMain *this, int charStack, unsigned __int8 bSync)
{
  OGLRender *m_pRender; // rax
  float v6; // xmm1_4
  OGLRender *v7; // rax
  OGLTexture *m_ShadowDepthMap; // rdi
  OGLTexture *m_ShadowTransparencyMap; // rsi
  unsigned int v10; // eax
  unsigned int *m_ShadowRenderBufferID; // rdx
  __int64 v12; // r15
  bool v13; // zf
  unsigned int *v14; // rdx
  unsigned int *p_m_TexID; // r14
  GLuint v16; // edx
  Framework::GLManager *v17; // rcx
  unsigned int *m_ShadowTransRenderBufferID; // rdx
  unsigned int *v19; // rdx
  unsigned int *v20; // rdi
  GLuint v21; // edx
  Framework::GLManager *v22; // rcx
  unsigned int v23; // ecx
  OGLRender *v24; // rdx
  OGLLightNode *i; // rax
  unsigned int v26; // er8
  unsigned int *v27; // rdx
  unsigned int v28; // ecx
  unsigned int m_TexID; // edx
  __int64 v30; // rax
  Framework::GLManager *v31; // rcx
  GLuint v32; // edx
  __int64 v33; // rax
  Framework::GLManager *v34; // rcx
  unsigned int v35; // eax
  unsigned int v36; // edx
  unsigned int v37; // er8
  Framework::GLManager *v38; // r8
  OGLRender *v39; // rax
  int v40; // [rsp+28h] [rbp-39h]
  int v41; // [rsp+28h] [rbp-39h]
  unsigned int v42; // [rsp+40h] [rbp-21h]
  unsigned int v43; // [rsp+40h] [rbp-21h]
  __int128 v44; // [rsp+58h] [rbp-9h]
  __int128 v45; // [rsp+68h] [rbp+7h]
  __int128 v46; // [rsp+78h] [rbp+17h]

  m_pRender = this->m_pRender;
  if ( m_pRender->m_bDoShadowPass )
  {
    LODWORD(v44) = 0;
    HIDWORD(v44) = 0;
    *(_QWORD *)&v45 = 0i64;
    *(_QWORD *)((char *)&v44 + 4) = 1056964608i64;
    *((_QWORD *)&v45 + 1) = 1056964608i64;
    *((_QWORD *)&v46 + 1) = 0x3F8000003F000000i64;
    *(float *)&v46 = (float)(0.5 / (float)this->m_iScreenW) + 0.5;
    v6 = 0.5 / (float)this->m_iScreenH;
    *(_OWORD *)m_pRender->m_WorldLightManager.m_ScaleBias.m = 0x3F000000ui64;
    *((float *)&v46 + 1) = v6 + 0.5;
    *(_OWORD *)&m_pRender->m_WorldLightManager.m_ScaleBias.m[4] = v44;
    *(_OWORD *)&m_pRender->m_WorldLightManager.m_ScaleBias.m[8] = v45;
    *(_OWORD *)&m_pRender->m_WorldLightManager.m_ScaleBias.m[12] = v46;
    v7 = this->m_pRender;
    if ( charStack == 2 || charStack != 3 )
    {
      m_ShadowDepthMap = v7->m_renderTextures.m_ShadowDepthMap;
      m_ShadowTransparencyMap = v7->m_renderTextures.m_ShadowTransparencyMap;
      v10 = 0;
    }
    else
    {
      m_ShadowDepthMap = &v7->m_renderTextures.m_ShadowDepthMap[1];
      m_ShadowTransparencyMap = &v7->m_renderTextures.m_ShadowTransparencyMap[1];
      v10 = 1;
    }
    m_ShadowRenderBufferID = this->m_pRender->m_renderTextures.m_ShadowRenderBufferID;
    v12 = v10;
    v13 = m_ShadowRenderBufferID[v10] == 0;
    v14 = &m_ShadowRenderBufferID[v10];
    if ( v13 )
      glGenRenderbuffersAG(1, v14);
    p_m_TexID = &m_ShadowDepthMap->m_TexID;
    if ( !m_ShadowDepthMap->m_TexID )
      glGenTexturesAG(1, &m_ShadowDepthMap->m_TexID);
    v16 = *p_m_TexID;
    if ( *p_m_TexID != ::m_TexID[m_ActiveTexture] || !v16 )
    {
      v17 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v16;
      v17->m_textureID = v16;
      while ( v17->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v16);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    m_ShadowDepthMap->m_TexParam = 1290;
    m_ShadowTransRenderBufferID = this->m_pRender->m_renderTextures.m_ShadowTransRenderBufferID;
    v13 = m_ShadowTransRenderBufferID[v12] == 0;
    v19 = &m_ShadowTransRenderBufferID[v12];
    if ( v13 )
      glGenRenderbuffersAG(1, v19);
    v20 = &m_ShadowTransparencyMap->m_TexID;
    if ( !m_ShadowTransparencyMap->m_TexID )
      glGenTexturesAG(1, &m_ShadowTransparencyMap->m_TexID);
    v21 = *v20;
    if ( *v20 != ::m_TexID[m_ActiveTexture] || !v21 )
    {
      v22 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v21;
      v22->m_textureID = v21;
      while ( v22->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v21);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9728.0);
    glTexParameterf(0xDE1u, 0x2800u, 9728.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    m_ShadowTransparencyMap->m_TexParam = 1285;
    v23 = this->ModelRoomSettings.worldLightId[0];
    if ( v23 != -1 )
    {
      v24 = this->m_pRender;
      for ( i = v24->m_WorldLightManager.m_pLightNodeList; i && i->m_light.m_nId != v23; i = i->next )
        ;
      if ( i->m_light.m_bCastsShadows )
      {
        glBindRenderbufferAG(v23, v24->m_renderTextures.m_ShadowRenderBufferID[v12]);
        v27 = &this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
        if ( !*v27 )
          glGenTexturesAG(1, v27);
        v28 = m_ActiveTexture;
        if ( m_ActiveTexture )
        {
          m_ActiveTexture = 0;
          _glewActiveTexture(0x84C0u);
          v28 = m_ActiveTexture;
        }
        m_TexID = this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
        v30 = v28;
        if ( m_TexID != ::m_TexID[v28] || !m_TexID )
        {
          v31 = Framework::GLManager::glm;
          ::m_TexID[v30] = m_TexID;
          v31->m_textureID = m_TexID;
          while ( v31->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, m_TexID);
          v28 = m_ActiveTexture;
        }
        if ( v28 != 1 )
        {
          m_ActiveTexture = 1;
          _glewActiveTexture(0x84C1u);
          v28 = m_ActiveTexture;
        }
        v32 = *p_m_TexID;
        v33 = v28;
        if ( *p_m_TexID != ::m_TexID[v28] || !v32 )
        {
          v34 = Framework::GLManager::glm;
          ::m_TexID[v33] = v32;
          v34->m_textureID = v32;
          while ( v34->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v32);
        }
        glsFramebufferTexture2D(
          AppMain::pApp,
          0x8CE1u,
          v26,
          *p_m_TexID,
          v40,
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
          v42);
        v35 = m_ActiveTexture;
        if ( m_ActiveTexture != 2 )
        {
          m_ActiveTexture = 2;
          _glewActiveTexture(0x84C2u);
          v35 = m_ActiveTexture;
        }
        v36 = *v20;
        v37 = v35;
        if ( *v20 != ::m_TexID[v35] || !v36 )
        {
          ::m_TexID[v35] = v36;
          v38 = Framework::GLManager::glm;
          Framework::GLManager::glm->m_textureID = v36;
          while ( v38->m_bOpenGLBlocked )
            ;
          glBindTexture(0xDE1u, v36);
        }
        glsFramebufferTexture2D(
          AppMain::pApp,
          0x8CE2u,
          v37,
          *v20,
          v41,
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
          *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
          v43);
        Framework::GLManager::glm->currentFramebufferID = Framework::GLManager::glm->systemBufferID[Framework::GLManager::glm->m_backBufferIndex];
        glClearColor(1.0, 1.0, 1.0, 0.0);
        glClearAG(0x4100u);
        GraphicsOpt::lock(this->g);
        glPolygonOffset(1.1, 4.0);
        if ( dword_140A96054 != 1 )
        {
          dword_140A96054 = 1;
          glEnable(0xB44u);
        }
        glCullFace(0x405u);
        this->m_pRender->m_ShadowMapFlg = 1;
        this->m_pRender->m_ShadowCastingLight = this->ModelRoomSettings.worldLightId[0];
        v39 = this->m_pRender;
        if ( v39->m_RenderStackNo < 8 )
          v39->m_RenderStackNo = charStack;
        OGLRender::drawStack(this->m_pRender, 0, 1u);
        Graphics::drawStack(this->g->g);
      }
    }
    this->m_pRender->m_ShadowMapFlg = 0;
    glPolygonOffset(0.0, 0.0);
  }
}

void __fastcall AppMain::NewBloomEffectPass(AppMain *this, int frameBufferIndex)
{
  int downsampleScale; // eax
  __m128i v4; // xmm6
  __m128i v5; // xmm7
  float v6; // xmm6_4
  float v7; // xmm7_4
  OGLRender *m_pRender; // r8
  OGLRender *v9; // r8
  float v10; // xmm6_4
  float v11; // xmm7_4
  int v12; // edx
  int v13; // edx
  OGLRender *v14; // r8
  float v15; // xmm6_4
  float v16; // xmm7_4
  int v17; // edx

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "New Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 21, "New Bloom Effect Pass");
  downsampleScale = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  v4 = _mm_cvtsi32_si128(this->m_iScreenW);
  v5 = _mm_cvtsi32_si128(this->m_iScreenH);
  ++markerCount;
  v6 = _mm_cvtepi32_ps(v4).m128_f32[0] / (float)downsampleScale;
  v7 = _mm_cvtepi32_ps(v5).m128_f32[0] / (float)downsampleScale;
  if ( downsampleScale == 1 )
  {
    m_pRender = this->m_pRender;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v6;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v7;
    AppMain::DownsampleTexture(
      this,
      frameBufferIndex,
      &m_pRender->m_renderTextures.m_BloomMapTexture,
      m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)v6,
      (int)v7);
  }
  AppMain::GaussianBlurEffect(
    this,
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    v6,
    v7,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  v9 = this->m_pRender;
  v10 = v6 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
  v11 = v7 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v10;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v11;
  AppMain::DownsampleTexture(
    this,
    v12,
    v9->m_renderTextures.m_BloomMapDownSampleTexture,
    &v9->m_renderTextures.m_BloomMapDownSampleTexture[1],
    (int)v10,
    (int)v11);
  AppMain::GaussianBlurEffect(
    this,
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    v10,
    v11,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  if ( this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomQuality == 1 )
  {
    v14 = this->m_pRender;
    v15 = v10 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
    v16 = v11 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v15;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v16;
    AppMain::DownsampleTexture(
      this,
      v13,
      &v14->m_renderTextures.m_BloomMapDownSampleTexture[1],
      &v14->m_renderTextures.m_BloomMapDownSampleTexture[2],
      (int)v15,
      (int)v16);
    AppMain::GaussianBlurEffect(
      this,
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      v15,
      v16,
      this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
    AppMain::ApplyShaderToTexture(
      this,
      7967,
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
      (int)(float)((float)((float)this->m_iScreenW
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      (int)(float)((float)((float)this->m_iScreenH
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      1);
  }
  AppMain::ApplyShaderToTexture(
    this,
    7967,
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    (int)(float)((float)this->m_iScreenW
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    (int)(float)((float)this->m_iScreenH
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    1);
  AppMain::BloomEffectBlend(this, v17);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::PreBloomEffectPass(AppMain *this, int frameBufferIndex)
{
  int downsampleScale; // eax
  __m128i v4; // xmm3
  __m128i v5; // xmm2
  OGLRender *m_pRender; // r8

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Pre Bloom Effect Pass Light");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 27, "Pre Bloom Effect Pass Light");
  ++markerCount;
  downsampleScale = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  if ( downsampleScale != 1 )
  {
    v4 = _mm_cvtsi32_si128(this->m_iScreenW);
    v5 = _mm_cvtsi32_si128(this->m_iScreenH);
    m_pRender = this->m_pRender;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
    *(float *)v4.m128i_i32 = _mm_cvtepi32_ps(v4).m128_f32[0] / (float)downsampleScale;
    *(float *)v5.m128i_i32 = _mm_cvtepi32_ps(v5).m128_f32[0] / (float)downsampleScale;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / *(float *)v4.m128i_i32;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / *(float *)v5.m128i_i32;
    AppMain::DownsampleTexture(
      this,
      frameBufferIndex,
      &m_pRender->m_renderTextures.m_BloomMapTexture,
      m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)*(float *)v4.m128i_i32,
      (int)*(float *)v5.m128i_i32);
  }
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::PreFightSceneBlendFrameBuffers(AppMain *this, int charStackId)
{
  void (__fastcall *v2)(int, const char *); // r8
  void (__fastcall *v5)(unsigned int, unsigned int, int, const char *); // r10
  OGLRender *m_pRender; // rbp
  __int64 v7; // rax
  int blendBuffer1; // esi
  __int64 v9; // rdi
  OGLRender *v10; // r8
  int v11; // edx
  OGLRender *v12; // r8

  v2 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Blend FrameBuffers");
    v2 = _glewPushGroupMarkerEXT;
  }
  v5 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 18, "Blend FrameBuffers");
    v2 = _glewPushGroupMarkerEXT;
    v5 = _glewPushDebugGroup;
  }
  ++markerCount;
  m_pRender = this->m_pRender;
  v7 = 5i64;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  if ( charStackId != 3 )
    v7 = 3i64;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  blendBuffer1 = v7;
  v9 = v7;
  if ( v2 )
  {
    v2(0, "Combine Depths1");
    v5 = _glewPushDebugGroup;
  }
  if ( v5 )
    v5(33354u, 1u, 15, "Combine Depths1");
  v10 = this->m_pRender;
  ++markerCount;
  AppMain::CopyDepthTextureCS(
    this,
    &m_pRender->m_renderTextures.m_DepthMapTexture[v9],
    &v10->m_renderTextures.m_DepthMapTexture[1]);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  v12 = this->m_pRender;
  --markerCount;
  AppMain::BlendTwoTexturesUsingDepth(
    this,
    v11,
    v12->m_renderTextures.m_FullScreenTexture,
    &v12->m_renderTextures.m_FullScreenTexture[v9],
    &v12->m_renderTextures.m_FullScreenTexture[6],
    blendBuffer1);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::PreFightSceneBlendMasks(AppMain *this, int charStackId)
{
  void (__fastcall *v2)(int, const char *); // rax
  void (__fastcall *v5)(unsigned int, unsigned int, int, const char *); // r10
  OGLRender *m_pRender; // r8
  __int64 v7; // rax
  void (*v8)(void); // rsi
  void (*v9)(void); // rdi
  int v10; // ebx
  unsigned int *p_m_FrameBufferID; // rdx

  v2 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Blend Masks");
    v2 = _glewPushGroupMarkerEXT;
  }
  v5 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 11, "Blend Masks");
    v2 = _glewPushGroupMarkerEXT;
    v5 = _glewPushDebugGroup;
  }
  ++markerCount;
  if ( v2 )
  {
    v2(0, "Combine 2 Masks");
    v5 = _glewPushDebugGroup;
  }
  if ( v5 )
    v5(33354u, 1u, 15, "Combine 2 Masks");
  m_pRender = this->m_pRender;
  ++markerCount;
  v7 = 5i64;
  if ( charStackId != 3 )
    v7 = 3i64;
  AppMain::BlendTwoTexturesCS(
    this,
    (_DWORD)m_pRender + 781312,
    &m_pRender->m_renderTextures.m_CombinedMaskTexture[3],
    m_pRender->m_renderTextures.m_CombinedMaskTexture,
    &m_pRender->m_renderTextures.m_FullScreenMaskTexture[v7],
    &m_pRender->m_renderTextures.m_FullScreenMaskTexture[6]);
  v8 = _glewPopGroupMarkerEXT;
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v8 = _glewPopGroupMarkerEXT;
  }
  v9 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v8 = _glewPopGroupMarkerEXT;
    v9 = _glewPopDebugGroup;
  }
  v10 = markerCount - 1;
  p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_FrameBufferID;
  --markerCount;
  if ( *p_m_FrameBufferID )
  {
    glDeleteRenderbuffersAG(1, p_m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_FrameBufferID = 0;
  }
  if ( v8 )
  {
    v8();
    v10 = markerCount;
    v9 = _glewPopDebugGroup;
  }
  if ( v9 )
  {
    v9();
    --markerCount;
  }
  else
  {
    markerCount = v10 - 1;
  }
}

void __fastcall AppMain::PreFightSceneBloomEffectPass(AppMain *this, int frameBufferIndex, int stackId)
{
  float v5; // xmm6_4
  float height; // xmm7_4
  int v7; // edx

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 17, "Bloom Effect Pass");
  ++markerCount;
  AppMain::PreFightSceneDepthFilterBloom(this);
  v5 = (float)this->m_iScreenW / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  height = (float)this->m_iScreenH / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  AppMain::GaussianBlurEffect(
    this,
    &this->m_pRender->m_renderTextures.m_BloomMapTexture,
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    v5,
    height,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  if ( this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn )
    AppMain::ApplyShaderToTexture(
      this,
      7992,
      &this->m_pRender->m_renderTextures.m_CharacterHighlights[stackId == 3],
      this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)v5,
      (int)height,
      1);
  AppMain::BloomEffectBlend(this, v7);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::PreFightSceneDepthFilterBloom(AppMain *this)
{
  __m128i v2; // xmm0
  __m128i v3; // xmm1
  OGLRender *m_pRender; // r8

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Depth Filter");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 12, "Depth Filter");
  v2 = _mm_cvtsi32_si128(this->m_iScreenH);
  v3 = _mm_cvtsi32_si128(this->m_iScreenW);
  m_pRender = this->m_pRender;
  ++markerCount;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  AppMain::ApplyShaderToTexture(
    this,
    7937,
    &m_pRender->m_renderTextures.m_BloomMapTexture,
    &m_pRender->m_renderTextures.m_BloomMapTexture,
    (int)_mm_cvtepi32_ps(v3).m128_f32[0],
    (int)_mm_cvtepi32_ps(v2).m128_f32[0],
    1);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::PreFightSceneHighlightExtractionPass(AppMain *this, int frameBufferIndex)
{
  __m128i v3; // xmm0
  __int64 v4; // rbx
  float height; // xmm6_4
  float v6; // xmm7_4

  v3 = _mm_cvtsi32_si128(this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale);
  this->ModelRoomSettings.postfxUniforms.u_postfxHighlightThresholdBrightness = *(Vector2Unaligned *)&this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightThreshold;
  *(float *)v3.m128i_i32 = _mm_cvtepi32_ps(v3).m128_f32[0];
  v4 = 80 * ((frameBufferIndex == 5) + 9789i64);
  height = (float)this->m_iScreenH / *(float *)v3.m128i_i32;
  v6 = (float)this->m_iScreenW / *(float *)v3.m128i_i32;
  AppMain::CharHighlightExtractionWithoutDepth(
    this,
    &this->m_pRender->m_renderTextures.m_FullScreenTexture[frameBufferIndex],
    (OGLTexture *)((char *)this->m_pRender + v4),
    (int)v6,
    (int)height);
  AppMain::GaussianBlurEffect(
    this,
    (OGLTexture *)((char *)this->m_pRender + v4),
    (OGLTexture *)((char *)this->m_pRender + v4),
    v6,
    height,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
}

void __fastcall AppMain::PreFightSceneNewBloomEffectPass(AppMain *this, int frameBufferIndex, int stackId)
{
  __m128i v5; // xmm6
  __m128i v6; // xmm7
  OGLRender *m_pRender; // r8
  float downsampleScale; // xmm0_4
  float v9; // xmm6_4
  float v10; // xmm7_4
  int v11; // edx
  int v12; // edx
  OGLRender *v13; // r8
  float v14; // xmm6_4
  float v15; // xmm7_4
  int v16; // edx
  OGLRender *v17; // r8
  float v18; // xmm6_4
  float v19; // xmm7_4
  int v20; // edx

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "New Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 21, "New Bloom Effect Pass");
  ++markerCount;
  AppMain::PreFightSceneDepthFilterBloom(this);
  v5 = _mm_cvtsi32_si128(this->m_iScreenW);
  v6 = _mm_cvtsi32_si128(this->m_iScreenH);
  m_pRender = this->m_pRender;
  downsampleScale = (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale;
  this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
  v9 = _mm_cvtepi32_ps(v5).m128_f32[0] / downsampleScale;
  v10 = _mm_cvtepi32_ps(v6).m128_f32[0] / downsampleScale;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v9;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v10;
  AppMain::DownsampleTexture(
    this,
    v11,
    &m_pRender->m_renderTextures.m_BloomMapTexture,
    m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    (int)v9,
    (int)v10);
  if ( this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn )
    AppMain::ApplyShaderToTexture(
      this,
      7992,
      &this->m_pRender->m_renderTextures.m_CharacterHighlights[stackId == 3],
      this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)v9,
      (int)v10,
      1);
  v13 = this->m_pRender;
  v14 = v9 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
  v15 = v10 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v14;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v15;
  AppMain::DownsampleTexture(
    this,
    v12,
    v13->m_renderTextures.m_BloomMapDownSampleTexture,
    &v13->m_renderTextures.m_BloomMapDownSampleTexture[1],
    (int)v14,
    (int)v15);
  if ( this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomQuality == 1 )
  {
    v17 = this->m_pRender;
    v18 = v14 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
    v19 = v15 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v18;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v19;
    AppMain::DownsampleTexture(
      this,
      v16,
      &v17->m_renderTextures.m_BloomMapDownSampleTexture[1],
      &v17->m_renderTextures.m_BloomMapDownSampleTexture[2],
      (int)v18,
      (int)v19);
    AppMain::ApplyShaderToTexture(
      this,
      7967,
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
      (int)(float)((float)((float)this->m_iScreenW
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      (int)(float)((float)((float)this->m_iScreenH
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      1);
  }
  AppMain::ApplyShaderToTexture(
    this,
    7967,
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    (int)(float)((float)this->m_iScreenW
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    (int)(float)((float)this->m_iScreenH
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    1);
  AppMain::BloomEffectBlend(this, v20);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::RenderFullScreenToTexture(
        AppMain *this,
        int shader,
        OGLTexture *pSrcTexture,
        OGLTexture *pDestTexture,
        int frameBufferIndex)
{
  __int64 v7; // r13
  bool v9; // zf
  __m128i v10; // xmm2
  __m128i v11; // xmm1
  Framework::GLManager *v12; // r12
  unsigned int m_TexID; // edx
  Framework::GLManager *v14; // rcx
  unsigned int m_FrameBufferID; // edx
  unsigned int v16; // ecx
  unsigned int v17; // er8
  unsigned int v18; // eax
  unsigned int v19; // edx
  Framework::GLManager *v20; // rcx
  OGLShader *v21; // r15
  int v22; // edi
  AgFrameAllocator<AgAllocator<1> > *p_m_agDrawAllocator; // rcx
  unsigned __int64 v24; // r8
  _QWORD *v25; // rax
  int *v26; // r8
  char *v27; // r14
  float *v28; // rdx
  __int64 v29; // r9
  float *v30; // rcx
  float v31; // xmm0_4
  __m128 v32; // xmm1
  float v33; // eax
  unsigned __int64 v34; // xmm0_8
  __m128 v35; // xmm1
  OGLRender *m_pRender; // rax
  __m128 v37; // xmm2
  __m128 v38; // xmm3
  __m128 v39; // xmm4
  __m128 v40; // xmm5
  __m128 v41; // xmm6
  __m128 v42; // xmm7
  __m128 v43; // xmm8
  __m128 v44; // xmm9
  int v45; // ecx
  unsigned __int8 v46; // r8
  int *m_piGLUniform; // rax
  AgSingleton<KOFShaderManager> *v48; // rsi
  __int64 v49; // rcx
  signed int v50; // er10
  int renderSize; // ecx
  int v52; // eax
  int *v53; // rax
  __int64 v54; // rcx
  int v55; // eax
  signed int v56; // ecx
  unsigned int v57; // ecx
  unsigned int v58; // edx
  __int64 v59; // rax
  Framework::GLManager *v60; // rcx
  OGLRender *v61; // rdi
  __int64 v62; // rax
  GLuint v63; // edx
  Framework::GLManager *v64; // rcx
  AppMain *v65; // rcx
  int v66; // edx
  unsigned int v67; // ecx
  int v68; // [rsp+28h] [rbp-E0h]
  unsigned int v69; // [rsp+40h] [rbp-C8h]
  __int128 v70; // [rsp+58h] [rbp-B0h]
  __int128 v71; // [rsp+68h] [rbp-A0h]
  __int128 v72; // [rsp+78h] [rbp-90h]
  __int128 v73; // [rsp+88h] [rbp-80h]
  __int128 v74; // [rsp+98h] [rbp-70h]
  __int128 v75; // [rsp+A8h] [rbp-60h]
  __int128 v76; // [rsp+B8h] [rbp-50h]
  __int128 v77; // [rsp+C8h] [rbp-40h]
  float v[4]; // [rsp+E0h] [rbp-28h] BYREF
  float value[4]; // [rsp+F8h] [rbp-10h] BYREF
  __int128 v80; // [rsp+108h] [rbp+0h]
  __int128 v81; // [rsp+118h] [rbp+10h]
  __int128 v82; // [rsp+128h] [rbp+20h]
  float v83[4]; // [rsp+138h] [rbp+30h] BYREF
  __int128 v84; // [rsp+148h] [rbp+40h]
  __int128 v85; // [rsp+158h] [rbp+50h]
  __int128 v86; // [rsp+168h] [rbp+60h]
  int v87; // [rsp+178h] [rbp+70h] BYREF
  __int64 v88; // [rsp+17Ch] [rbp+74h]
  int v89; // [rsp+184h] [rbp+7Ch]
  int v90; // [rsp+188h] [rbp+80h]
  int v91; // [rsp+18Ch] [rbp+84h]
  int v92; // [rsp+190h] [rbp+88h]
  int v93; // [rsp+194h] [rbp+8Ch]
  __int64 v94; // [rsp+198h] [rbp+90h]
  __int64 v95; // [rsp+1A0h] [rbp+98h] BYREF
  unsigned int v96; // [rsp+1A8h] [rbp+A0h]
  int v97; // [rsp+1ACh] [rbp+A4h]
  unsigned int v98; // [rsp+1B0h] [rbp+A8h]
  __int64 v99; // [rsp+1B4h] [rbp+ACh]
  unsigned int v100; // [rsp+1BCh] [rbp+B4h]
  unsigned int v101; // [rsp+1C0h] [rbp+B8h]
  int v102; // [rsp+1C4h] [rbp+BCh]
  float v103[4]; // [rsp+1C8h] [rbp+C0h] BYREF

  if ( pSrcTexture )
  {
    v7 = shader;
    if ( pDestTexture )
    {
      v9 = pDestTexture->m_FrameBufferID == 0;
      v10 = _mm_cvtsi32_si128(this->m_iScreenW);
      v11 = _mm_cvtsi32_si128(this->m_iScreenH);
      v12 = Framework::GLManager::glm;
      v95 = 0i64;
      v94 = 0i64;
      v99 = 0i64;
      v102 = 0;
      v97 = 0;
      v88 = 0i64;
      v87 = 0;
      v101 = _mm_cvtepi32_ps(v11).m128_u32[0];
      v96 = v101;
      v100 = _mm_cvtepi32_ps(v10).m128_u32[0];
      v98 = v100;
      v91 = 0;
      v92 = 1065353216;
      v90 = 1065353216;
      v93 = 1065353216;
      v89 = 1065353216;
      if ( v9 )
        glGenRenderbuffersAG(1, &pDestTexture->m_FrameBufferID);
      if ( !pDestTexture->m_TexID )
        glGenTexturesAG(1, &pDestTexture->m_TexID);
      m_TexID = pDestTexture->m_TexID;
      if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
      {
        ::m_TexID[m_ActiveTexture] = m_TexID;
        v14 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = m_TexID;
        while ( v14->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, m_TexID);
      }
      glTexParameterf(0xDE1u, 0x2801u, 9729.0);
      glTexParameterf(0xDE1u, 0x2800u, 9729.0);
      glTexParameterf(0xDE1u, 0x2802u, 33071.0);
      glTexParameterf(0xDE1u, 0x2803u, 33071.0);
      m_FrameBufferID = pDestTexture->m_FrameBufferID;
      pDestTexture->m_TexParam = 1290;
      glBindRenderbufferAG(v16, m_FrameBufferID);
      v18 = m_ActiveTexture;
      if ( m_ActiveTexture )
      {
        m_ActiveTexture = 0;
        _glewActiveTexture(0x84C0u);
        v18 = m_ActiveTexture;
      }
      v19 = pSrcTexture->m_TexID;
      if ( v19 != ::m_TexID[v18] || !v19 )
      {
        ::m_TexID[v18] = v19;
        v20 = Framework::GLManager::glm;
        Framework::GLManager::glm->m_textureID = v19;
        while ( v20->m_bOpenGLBlocked )
          ;
        glBindTexture(0xDE1u, v19);
      }
      glsFramebufferTexture2D(
        AppMain::pApp,
        0x8CE0u,
        v17,
        pDestTexture->m_TexID,
        v68,
        *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
        *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
        v69);
      if ( m_DepthMask != 1 )
      {
        m_DepthMask = 1;
        glDepthMask(1u);
      }
      glClearAG(0x100u);
      GraphicsOpt::lock(this->g);
      v21 = this->m_pRender->m_ShaderFXTbl[v7];
      if ( v21 )
      {
        if ( v21->m_Program )
        {
          KOFShaderManager::useProgramSlot(
            (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance,
            v21->m_programSlot);
          v22 = 64;
          p_m_agDrawAllocator = &Framework::GLManager::glm->m_agDrawAllocator;
          v12->renderSize = 64;
          v25 = AgFrameAllocator<AgAllocator<1>>::allocate(p_m_agDrawAllocator, 0x100ui64, v24);
          v26 = &v87;
          v27 = (char *)v25;
          v28 = (float *)&v95;
          v29 = 4i64;
          v30 = (float *)(v25 + 7);
          do
          {
            v31 = *v28;
            v26 += 2;
            v32 = (__m128)*((unsigned int *)v28 - 1);
            v28 += 3;
            v[2] = v31;
            v33 = v31;
            v34 = _mm_unpacklo_ps((__m128)*((unsigned int *)v28 - 5), v32).m128_u64[0];
            v35 = (__m128)(unsigned int)*(v26 - 1);
            *((_QWORD *)v30 - 7) = v34;
            *(_QWORD *)v30 = _mm_unpacklo_ps((__m128)(unsigned int)*(v26 - 2), v35).m128_u64[0];
            *(v30 - 12) = v33;
            *((_OWORD *)v30 - 1) = _xmm;
            v30 += 16;
            --v29;
          }
          while ( v29 );
          v12->m_vertexInfoCount = 4;
          m_pRender = this->m_pRender;
          v37 = *(__m128 *)m_pRender->m_View.m;
          v38 = *(__m128 *)&m_pRender->m_View.m[4];
          v39 = *(__m128 *)&m_pRender->m_View.m[8];
          v40 = *(__m128 *)&m_pRender->m_View.m[12];
          v41 = *(__m128 *)m_pRender->m_Proj.m;
          v42 = *(__m128 *)&m_pRender->m_Proj.m[4];
          v43 = *(__m128 *)&m_pRender->m_Proj.m[8];
          v44 = *(__m128 *)&m_pRender->m_Proj.m[12];
          *(_QWORD *)&v70 = __PAIR64__(v38.m128_u32[0], v37.m128_u32[0]);
          LODWORD(v71) = _mm_shuffle_ps(v37, v37, 85).m128_u32[0];
          LODWORD(v72) = _mm_shuffle_ps(v37, v37, 170).m128_u32[0];
          DWORD1(v71) = _mm_shuffle_ps(v38, v38, 85).m128_u32[0];
          DWORD1(v72) = _mm_shuffle_ps(v38, v38, 170).m128_u32[0];
          DWORD2(v71) = _mm_shuffle_ps(v39, v39, 85).m128_u32[0];
          DWORD2(v72) = _mm_shuffle_ps(v39, v39, 170).m128_u32[0];
          HIDWORD(v71) = _mm_shuffle_ps(v40, v40, 85).m128_u32[0];
          HIDWORD(v72) = _mm_shuffle_ps(v40, v40, 170).m128_u32[0];
          v80 = v71;
          *((_QWORD *)&v70 + 1) = __PAIR64__(v40.m128_u32[0], v39.m128_u32[0]);
          *(_OWORD *)value = v70;
          v81 = v72;
          LODWORD(v75) = _mm_shuffle_ps(v41, v41, 85).m128_u32[0];
          DWORD1(v75) = _mm_shuffle_ps(v42, v42, 85).m128_u32[0];
          LODWORD(v73) = _mm_shuffle_ps(v37, v37, 255).m128_u32[0];
          DWORD1(v73) = _mm_shuffle_ps(v38, v38, 255).m128_u32[0];
          DWORD2(v73) = _mm_shuffle_ps(v39, v39, 255).m128_u32[0];
          HIDWORD(v73) = _mm_shuffle_ps(v40, v40, 255).m128_u32[0];
          v82 = v73;
          LODWORD(v76) = _mm_shuffle_ps(v41, v41, 170).m128_u32[0];
          DWORD1(v76) = _mm_shuffle_ps(v42, v42, 170).m128_u32[0];
          *(_QWORD *)&v74 = __PAIR64__(v42.m128_u32[0], v41.m128_u32[0]);
          *((_QWORD *)&v74 + 1) = __PAIR64__(v44.m128_u32[0], v43.m128_u32[0]);
          DWORD2(v77) = _mm_shuffle_ps(v43, v43, 255).m128_u32[0];
          LODWORD(v77) = _mm_shuffle_ps(v41, v41, 255).m128_u32[0];
          DWORD1(v77) = _mm_shuffle_ps(v42, v42, 255).m128_u32[0];
          DWORD2(v75) = _mm_shuffle_ps(v43, v43, 85).m128_u32[0];
          DWORD2(v76) = _mm_shuffle_ps(v43, v43, 170).m128_u32[0];
          v45 = *v21->m_piGLUniform;
          HIDWORD(v75) = _mm_shuffle_ps(v44, v44, 85).m128_u32[0];
          HIDWORD(v76) = _mm_shuffle_ps(v44, v44, 170).m128_u32[0];
          *(_OWORD *)v83 = v74;
          v84 = v75;
          HIDWORD(v77) = _mm_shuffle_ps(v44, v44, 255).m128_u32[0];
          v85 = v76;
          v86 = v77;
          glUniformMatrix4fvAG(v45, 1, (unsigned __int8)v26, value);
          glUniformMatrix4fvAG(v21->m_piGLUniform[1], 1, v46, v83);
          m_piGLUniform = v21->m_piGLUniform;
          *(_OWORD *)v = _xmm;
          glUniform4fvAG(m_piGLUniform[5], 1, v);
          v48 = AgSingleton<KOFShaderManager>::ms_instance;
          v49 = *(unsigned int *)AgSingleton<KOFShaderManager>::ms_instance[11
                                                                          * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable)
                                                                          + 7].onSingletonInit;
          if ( (unsigned int)v49 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v49;
            g_vertexAttribIndex[v49] = 0;
          }
          v50 = *(_DWORD *)v48[11 * SLODWORD(v48[360450].__vftable) + 7].onSingletonInit;
          renderSize = Framework::GLManager::glm->renderSize;
          switch ( renderSize )
          {
            case 64:
              v52 = 64;
              break;
            case 280:
              v52 = 136;
              break;
            case 208:
              v52 = 64;
              break;
            default:
              v52 = 88;
              if ( renderSize == 144 )
                v52 = 144;
              break;
          }
          if ( v50 >= 0 )
          {
            _glewVertexAttribPointer(v50, 3, 0x1406u, 0, v52, v27);
            v48 = AgSingleton<KOFShaderManager>::ms_instance;
          }
          v53 = v21->m_piGLUniform;
          *(_OWORD *)v103 = _xmm;
          glUniform4fvAG(v53[5], 1, v103);
          v54 = *((unsigned int *)v48[11 * SLODWORD(v48[360450].__vftable) + 7].onSingletonInit + 4);
          if ( (unsigned int)v54 < g_maxEnabledVertexAttribArrays )
          {
            g_pendingVertexAttribArrays |= 1 << v54;
            g_vertexAttribIndex[v54] = 4;
          }
          v55 = Framework::GLManager::glm->renderSize;
          v56 = *((_DWORD *)v48[11 * SLODWORD(v48[360450].__vftable) + 7].onSingletonInit + 4);
          if ( v55 != 64 )
          {
            if ( v55 == 280 )
            {
              v22 = 8;
LABEL_47:
              if ( v56 >= 0 )
                _glewVertexAttribPointer(v56, 2, 0x1406u, 0, v22, v27);
              if ( (_DWORD)v7 == 7935 )
              {
                v57 = m_ActiveTexture;
                if ( m_ActiveTexture != 1 )
                {
                  m_ActiveTexture = 1;
                  _glewActiveTexture(0x84C1u);
                  v57 = m_ActiveTexture;
                }
                v58 = this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_TexID;
                v59 = v57;
                if ( v58 != ::m_TexID[v57] || !v58 )
                {
                  v60 = Framework::GLManager::glm;
                  ::m_TexID[v59] = v58;
                  v60->m_textureID = v58;
                  while ( v60->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v58);
                  v57 = m_ActiveTexture;
                }
                v61 = this->m_pRender;
                v62 = v57;
                v63 = v61->m_renderTextures.m_BloomMapDownSampleTexture[0].m_TexID;
                if ( v63 != ::m_TexID[v57] || !v63 )
                {
                  v64 = Framework::GLManager::glm;
                  ::m_TexID[v62] = v63;
                  v64->m_textureID = v63;
                  while ( v64->m_bOpenGLBlocked )
                    ;
                  glBindTexture(0xDE1u, v63);
                }
                glTexParameterf(0xDE1u, 0x2801u, 9729.0);
                glTexParameterf(0xDE1u, 0x2800u, 9729.0);
                glTexParameterf(0xDE1u, 0x2802u, 33071.0);
                glTexParameterf(0xDE1u, 0x2803u, 33071.0);
                v61->m_renderTextures.m_BloomMapDownSampleTexture[0].m_TexParam = 1290;
              }
              else
              {
                if ( m_ActiveTexture != 1 )
                {
                  m_ActiveTexture = 1;
                  _glewActiveTexture(0x84C1u);
                }
                glsBindTexture(0xDE1u, this->m_pRender->m_renderTextures.m_DepthMapTexture[frameBufferIndex].m_TexID);
              }
              AppMain::SetPostFXUniforms(
                v65,
                v21,
                &this->ModelRoomSettings.postfxUniforms,
                &this->ModelRoomSettings.filterUniforms);
              glDrawArraysAG(v67, v66, 4);
              Graphics::drawStack(this->g->g);
              return;
            }
            if ( v55 != 208 )
            {
              if ( v55 == 144 )
              {
                v22 = 144;
                goto LABEL_47;
              }
              v22 = 88;
            }
          }
          v27 += 56;
          goto LABEL_47;
        }
      }
    }
  }
}

void __fastcall AppMain::RenderGameScreen(AppMain *this, int frameBufferIndex)
{
  void (__fastcall *v2)(int, const char *); // r8
  void (__fastcall *v4)(unsigned int, unsigned int, int, const char *); // r10
  float brightness; // eax
  __m128i v6; // xmm6
  __m128i v7; // xmm7
  float v8; // xmm6_4
  float v9; // xmm7_4
  OGLRender *m_pRender; // r8
  void (*v11)(void); // rdi
  void (*v12)(void); // rbx
  float blur; // xmm0_4
  OGLTexture *p_m_GameOutputTexture; // rdx
  unsigned int *p_m_FrameBufferID; // rdx

  v2 = _glewPushGroupMarkerEXT;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Render Game Screen");
    v2 = _glewPushGroupMarkerEXT;
  }
  v4 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 18, "Render Game Screen");
    v2 = _glewPushGroupMarkerEXT;
    v4 = _glewPushDebugGroup;
  }
  brightness = this->ModelRoomSettings.postprocessSettings.monitorFilter.brightness;
  v6 = _mm_cvtsi32_si128(this->m_iScreenW);
  v7 = _mm_cvtsi32_si128(this->m_iScreenH);
  ++markerCount;
  this->ModelRoomSettings.filterUniforms.u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity.x = brightness;
  this->ModelRoomSettings.filterUniforms.u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity.y = this->ModelRoomSettings.postprocessSettings.monitorFilter.saturation;
  this->ModelRoomSettings.filterUniforms.u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity.z = this->ModelRoomSettings.postprocessSettings.monitorFilter.contrast;
  v8 = _mm_cvtepi32_ps(v6).m128_f32[0] / 6.0;
  v9 = _mm_cvtepi32_ps(v7).m128_f32[0] / 6.0;
  this->ModelRoomSettings.filterUniforms.u_monitorFilterMidTonesColShift = *(Vector4Unaligned *)this->ModelRoomSettings.postprocessSettings.monitorFilter.midTonesColShift;
  if ( v2 )
  {
    v2(0, "Texture Copy");
    v4 = _glewPushDebugGroup;
  }
  if ( v4 )
    v4(33354u, 1u, 12, "Texture Copy");
  m_pRender = this->m_pRender;
  ++markerCount;
  AppMain::ApplyShaderToTexture(
    this,
    7925,
    m_pRender->m_renderTextures.m_FullScreenTexture,
    &m_pRender->m_renderTextures.m_GameOutputTexture,
    (int)v8,
    (int)v9,
    1);
  v11 = _glewPopGroupMarkerEXT;
  if ( _glewPopGroupMarkerEXT )
  {
    _glewPopGroupMarkerEXT();
    v11 = _glewPopGroupMarkerEXT;
  }
  v12 = _glewPopDebugGroup;
  if ( _glewPopDebugGroup )
  {
    _glewPopDebugGroup();
    v11 = _glewPopGroupMarkerEXT;
    v12 = _glewPopDebugGroup;
  }
  --markerCount;
  if ( this->ModelRoomSettings.postprocessSettings.monitorFilter.FilterOn )
  {
    if ( _glewPushGroupMarkerEXT )
      _glewPushGroupMarkerEXT(0, "Monitor Filter");
    if ( _glewPushDebugGroup )
      _glewPushDebugGroup(0x824Au, 1u, 14, "Monitor Filter");
    blur = this->ModelRoomSettings.postprocessSettings.monitorFilter.blur;
    p_m_GameOutputTexture = &this->m_pRender->m_renderTextures.m_GameOutputTexture;
    ++markerCount;
    AppMain::GaussianBlurEffect(this, p_m_GameOutputTexture, p_m_GameOutputTexture, v8, v9, blur);
    AppMain::ApplyShaderToTexture(
      this,
      7968,
      &this->m_pRender->m_renderTextures.m_GameOutputTexture,
      &this->m_pRender->m_renderTextures.m_GameOutputTexture,
      (int)v8,
      (int)v9,
      1);
    v11 = _glewPopGroupMarkerEXT;
    if ( _glewPopGroupMarkerEXT )
    {
      _glewPopGroupMarkerEXT();
      v11 = _glewPopGroupMarkerEXT;
    }
    v12 = _glewPopDebugGroup;
    if ( _glewPopDebugGroup )
    {
      _glewPopDebugGroup();
      v11 = _glewPopGroupMarkerEXT;
      v12 = _glewPopDebugGroup;
    }
    --markerCount;
  }
  p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID;
  if ( *p_m_FrameBufferID )
  {
    glDeleteRenderbuffersAG(1, p_m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID = 0;
  }
  if ( v11 )
  {
    v11();
    v12 = _glewPopDebugGroup;
  }
  if ( v12 )
    v12();
  --markerCount;
}

void __fastcall AppMain::RenderReflectionToTexturePass(AppMain *this, int textureIndex, int stack)
{
  unsigned int *p_m_FrameBufferID; // rdx
  unsigned int *p_m_TexID; // rdx
  unsigned int v6; // er8
  Graphics *v7; // rcx
  OGLRender *m_pRender; // rdi
  unsigned int m_TexID; // edx
  Framework::GLManager *v10; // rcx
  OGLRender *v11; // rax
  int v12; // er8
  OGLRender *v13; // rcx
  int v14; // [rsp+20h] [rbp-28h]
  unsigned int v15; // [rsp+38h] [rbp-10h]

  p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_FrameBufferID;
  if ( !*p_m_FrameBufferID )
    glGenRenderbuffersAG(1, p_m_FrameBufferID);
  p_m_TexID = &this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexID;
  if ( !*p_m_TexID )
    glGenTexturesAG(1, p_m_TexID);
  glBindRenderbufferAG((unsigned int)this, this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_FrameBufferID);
  glsFramebufferTexture2D(
    AppMain::pApp,
    0x8CE0u,
    v6,
    this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexID,
    v14,
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
    v15);
  Graphics::clearScreen(v7, 0);
  m_pRender = this->m_pRender;
  m_TexID = m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexID;
  if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
  {
    ::m_TexID[m_ActiveTexture] = m_TexID;
    v10 = Framework::GLManager::glm;
    Framework::GLManager::glm->m_textureID = m_TexID;
    while ( v10->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
  }
  glTexParameterf(0xDE1u, 0x2801u, 9729.0);
  glTexParameterf(0xDE1u, 0x2800u, 9729.0);
  glTexParameterf(0xDE1u, 0x2802u, 33071.0);
  glTexParameterf(0xDE1u, 0x2803u, 33071.0);
  m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexParam = 1290;
  GraphicsOpt::lock(this->g);
  if ( dword_140A9606C != 1 )
  {
    dword_140A9606C = 1;
    glEnable(0xB71u);
  }
  glDepthFunc(0x203u);
  if ( m_DepthMask != 1 )
  {
    m_DepthMask = 1;
    glDepthMask(1u);
  }
  if ( dword_140A96054 != 1 )
  {
    dword_140A96054 = 1;
    glEnable(0xB44u);
  }
  glCullFace(0x405u);
  this->m_pRender->m_NormalRenderPassFlg = 0;
  this->m_pRender->m_ShadowMapFlg = 0;
  v11 = this->m_pRender;
  if ( this == (AppMain *)-1551480i64 )
  {
    *(_QWORD *)v11->m_Proj.m = 1065353216i64;
    v11->m_Proj.m[4] = 0.0;
    *(_QWORD *)&v11->m_Proj.m[8] = 0i64;
    *(_QWORD *)&v11->m_Proj.m[12] = 0i64;
    *(_QWORD *)&v11->m_Proj.m[5] = 1065353216i64;
    *(_QWORD *)&v11->m_Proj.m[2] = 0i64;
    *(_QWORD *)&v11->m_Proj.m[10] = 1065353216i64;
    v11->m_Proj.m[14] = 0.0;
    v11->m_Proj.m[7] = 0.0;
    v11->m_Proj.m[15] = 1.0;
  }
  else
  {
    *(_OWORD *)v11->m_Proj.m = *(_OWORD *)this->ModelRoomSettings.mProj[0].m;
    *(_OWORD *)&v11->m_Proj.m[4] = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[4];
    *(_OWORD *)&v11->m_Proj.m[8] = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[8];
    *(_OWORD *)&v11->m_Proj.m[12] = *(_OWORD *)&this->ModelRoomSettings.mProj[0].m[12];
  }
  OGLRender::setViewTrans(this->m_pRender, &this->ModelRoomSettings.mView);
  OGLRender::setInvViewTrans(this->m_pRender, &this->ModelRoomSettings.mInvView);
  v13 = this->m_pRender;
  if ( v13->m_RenderStackNo < 8 )
    v13->m_RenderStackNo = v12;
  OGLRender::drawStack(this->m_pRender, 0, v12);
  Graphics::drawStack(this->g->g);
}

void __fastcall AppMain::RenderToTexturePass(AppMain *this, int textureIndex, int stack, int frame)
{
  OGLRender *m_pRender; // rax
  unsigned __int64 v6; // rsi
  __int64 v7; // r14
  __int64 v8; // rdx
  bool v9; // zf
  unsigned int *v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned int *p_m_TexID; // rdx
  unsigned int *v13; // rdx
  unsigned int *v14; // rdx
  OGLRender *v15; // rbp
  GLuint m_TexID; // edx
  Framework::GLManager *v17; // rcx
  unsigned int v18; // ecx
  unsigned int v19; // er8
  Graphics *v20; // rcx
  Framework::GLManager *v21; // rdx
  int v22; // ebp
  __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned int v25; // er8
  unsigned int v26; // er8
  Graphics *v27; // rcx
  unsigned int *v28; // rdx
  OGLRender *v29; // rsi
  GLuint v30; // edx
  Framework::GLManager *v31; // rcx
  __int64 v32; // rcx
  unsigned int v33; // er8
  int v34; // ecx
  Framework::GLManager *v35; // r8
  OGLRender *v36; // rsi
  GLuint v37; // edx
  __int64 v38; // rax
  OGLRender *v39; // rsi
  GLuint v40; // edx
  Framework::GLManager *v41; // rcx
  OGLMatrix *v42; // rcx
  OGLRender *v43; // rax
  OGLRender *v44; // rcx
  int v45; // [rsp+20h] [rbp-68h]
  int v46; // [rsp+20h] [rbp-68h]
  int v47; // [rsp+20h] [rbp-68h]
  int v48; // [rsp+20h] [rbp-68h]
  unsigned int v49; // [rsp+38h] [rbp-50h]
  unsigned int v50; // [rsp+38h] [rbp-50h]
  unsigned int v51; // [rsp+38h] [rbp-50h]
  unsigned int v52; // [rsp+38h] [rbp-50h]

  m_pRender = this->m_pRender;
  v6 = textureIndex;
  v7 = stack;
  v8 = textureIndex + 194388i64;
  v9 = *(&m_pRender->m_Width + v8) == 0;
  v10 = (unsigned int *)(&m_pRender->m_Width + v8);
  if ( v9 )
    glGenRenderbuffersAG(1, v10);
  v11 = v6;
  p_m_TexID = &this->m_pRender->m_renderTextures.m_FullScreenTexture[v6].m_TexID;
  if ( !*p_m_TexID )
    glGenTexturesAG(1, p_m_TexID);
  v13 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[v11].m_TexID;
  if ( !*v13 )
    glGenTexturesAG(1, v13);
  v14 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[v11].m_TexID;
  if ( !*v14 )
    glGenTexturesAG(1, v14);
  v15 = this->m_pRender;
  m_TexID = v15->m_renderTextures.m_FullScreenMaskTexture[v11].m_TexID;
  if ( m_TexID != ::m_TexID[m_ActiveTexture] || !m_TexID )
  {
    v17 = Framework::GLManager::glm;
    ::m_TexID[m_ActiveTexture] = m_TexID;
    v17->m_textureID = m_TexID;
    while ( v17->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, m_TexID);
  }
  glTexParameterf(0xDE1u, 0x2801u, 9728.0);
  glTexParameterf(0xDE1u, 0x2800u, 9728.0);
  glTexParameterf(0xDE1u, 0x2802u, 33071.0);
  glTexParameterf(0xDE1u, 0x2803u, 33071.0);
  v15->m_renderTextures.m_FullScreenMaskTexture[v11].m_TexParam = 1285;
  glBindRenderbufferAG(v18, this->m_pRender->m_renderTextures.m_RenderBufferID[v6]);
  glsFramebufferTexture2D(
    AppMain::pApp,
    0x8CE0u,
    v19,
    this->m_pRender->m_renderTextures.m_FullScreenTexture[v11].m_TexID,
    v45,
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
    v49);
  Graphics::clearScreen(
    v20,
    LOBYTE(this->ModelRoomSettings.framebufferColour[2])
  + (LOBYTE(this->ModelRoomSettings.framebufferColour[1]) << 8)
  + (LOBYTE(this->ModelRoomSettings.framebufferColour[0]) << 16));
  v21 = Framework::GLManager::glm;
  --Framework::GLManager::glm->m_renderbuffer.m_firstOccupiedIndex;
  v22 = v21->m_renderbuffer.m_freeIDs[v21->m_renderbuffer.m_firstOccupiedIndex];
  v23 = v22 - 1;
  v21->m_renderbuffer.m_items[v23].m_depthTarget = 0;
  v21->m_renderbuffer.m_items[v23].m_attachment = 36063;
  v24 = *(_QWORD *)&AppMain::pApp;
  v21->currentFramebufferID = v22;
  glsFramebufferTexture2D(
    v24,
    0x8CE1u,
    v25,
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[v11].m_TexID,
    v46,
    *(_DWORD *)(v24 + 28),
    *(_DWORD *)(v24 + 32),
    v50);
  glsFramebufferTexture2D(
    AppMain::pApp,
    0x8D00u,
    v26,
    this->m_pRender->m_renderTextures.m_DepthMapTexture[v11].m_TexID,
    v47,
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 28i64),
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
    v51);
  Graphics::clearScreen(v27, 0xFFFFFF);
  if ( !(_DWORD)v7 )
  {
    v28 = &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_TexID;
    if ( !*v28 )
      glGenTexturesAG(1, v28);
    v29 = this->m_pRender;
    v30 = v29->m_renderTextures.m_BloomMapTexture.m_TexID;
    if ( v30 != ::m_TexID[m_ActiveTexture] || !v30 )
    {
      v31 = Framework::GLManager::glm;
      ::m_TexID[m_ActiveTexture] = v30;
      v31->m_textureID = v30;
      while ( v31->m_bOpenGLBlocked )
        ;
      glBindTexture(0xDE1u, v30);
    }
    glTexParameterf(0xDE1u, 0x2801u, 9729.0);
    glTexParameterf(0xDE1u, 0x2800u, 9729.0);
    glTexParameterf(0xDE1u, 0x2802u, 33071.0);
    glTexParameterf(0xDE1u, 0x2803u, 33071.0);
    v32 = *(_QWORD *)&AppMain::pApp;
    v29->m_renderTextures.m_BloomMapTexture.m_TexParam = 1290;
    glsFramebufferTexture2D(
      v32,
      0x8CE2u,
      v33,
      this->m_pRender->m_renderTextures.m_BloomMapTexture.m_TexID,
      v48,
      *(_DWORD *)(v32 + 28),
      *(_DWORD *)(v32 + 32),
      v52);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    v34 = 0;
    if ( this->m_FuncST == 196 )
      v34 = 256;
    glClearAG(v34 | 0x4000);
  }
  v35 = Framework::GLManager::glm;
  Framework::GLManager::glm->currentFramebufferID = Framework::GLManager::glm->systemBufferID[Framework::GLManager::glm->m_backBufferIndex];
  if ( (_BYTE)v22 )
    v35->m_renderbuffer.m_freeIDs[v35->m_renderbuffer.m_firstOccupiedIndex++] = v22;
  v36 = this->m_pRender;
  v37 = v36->m_renderTextures.m_FullScreenTexture[v11].m_TexID;
  if ( v37 != ::m_TexID[m_ActiveTexture] || !v37 )
  {
    ::m_TexID[m_ActiveTexture] = v37;
    v35->m_textureID = v37;
    while ( v35->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v37);
  }
  glTexParameterf(0xDE1u, 0x2801u, 9729.0);
  glTexParameterf(0xDE1u, 0x2800u, 9729.0);
  glTexParameterf(0xDE1u, 0x2802u, 33071.0);
  glTexParameterf(0xDE1u, 0x2803u, 33071.0);
  v38 = m_ActiveTexture;
  v36->m_renderTextures.m_FullScreenTexture[v11].m_TexParam = 1290;
  v39 = this->m_pRender;
  v40 = v39->m_renderTextures.m_DepthMapTexture[v11].m_TexID;
  if ( v40 != ::m_TexID[v38] || !v40 )
  {
    v41 = Framework::GLManager::glm;
    ::m_TexID[v38] = v40;
    v41->m_textureID = v40;
    while ( v41->m_bOpenGLBlocked )
      ;
    glBindTexture(0xDE1u, v40);
  }
  glTexParameterf(0xDE1u, 0x2801u, 9729.0);
  glTexParameterf(0xDE1u, 0x2800u, 9729.0);
  glTexParameterf(0xDE1u, 0x2802u, 33071.0);
  glTexParameterf(0xDE1u, 0x2803u, 33071.0);
  v39->m_renderTextures.m_DepthMapTexture[v11].m_TexParam = 1290;
  GraphicsOpt::lock(this->g);
  if ( dword_140A9606C != 1 )
  {
    dword_140A9606C = 1;
    glEnable(0xB71u);
  }
  glDepthFunc(0x203u);
  if ( m_DepthMask != 1 )
  {
    m_DepthMask = 1;
    glDepthMask(1u);
  }
  if ( dword_140A96054 != 1 )
  {
    dword_140A96054 = 1;
    glEnable(0xB44u);
  }
  glCullFace(0x405u);
  this->m_pRender->m_NormalRenderPassFlg = 1;
  v42 = &this->ModelRoomSettings.mProj[v7];
  v43 = this->m_pRender;
  if ( v42 )
  {
    *(_OWORD *)v43->m_Proj.m = *(_OWORD *)v42->m;
    *(_OWORD *)&v43->m_Proj.m[4] = *(_OWORD *)&v42->m[4];
    *(_OWORD *)&v43->m_Proj.m[8] = *(_OWORD *)&v42->m[8];
    *(_OWORD *)&v43->m_Proj.m[12] = *(_OWORD *)&v42->m[12];
  }
  else
  {
    *(_QWORD *)v43->m_Proj.m = 1065353216i64;
    v43->m_Proj.m[4] = 0.0;
    *(_QWORD *)&v43->m_Proj.m[8] = 0i64;
    *(_QWORD *)&v43->m_Proj.m[12] = 0i64;
    *(_QWORD *)&v43->m_Proj.m[5] = 1065353216i64;
    *(_QWORD *)&v43->m_Proj.m[2] = 0i64;
    *(_QWORD *)&v43->m_Proj.m[10] = 1065353216i64;
    v43->m_Proj.m[14] = 0.0;
    v43->m_Proj.m[7] = 0.0;
    v43->m_Proj.m[15] = 1.0;
  }
  OGLRender::setViewTrans(this->m_pRender, &this->ModelRoomSettings.mView);
  OGLRender::setInvViewTrans(this->m_pRender, &this->ModelRoomSettings.mInvView);
  v44 = this->m_pRender;
  if ( v44->m_RenderStackNo < 8 )
    v44->m_RenderStackNo = v7;
  OGLRender::drawStack(this->m_pRender, 0, 0);
  if ( !(_DWORD)v7 )
  {
    OGLRender::setProjection(this->m_pRender, this->ModelRoomSettings.mProj);
    EffectTaskManager::renderStack(this->effSystem, 1);
    EffectTaskManager::renderStack(this->effSystem, 3);
  }
  this->m_pRender->m_NormalRenderPassFlg = 0;
  Graphics::drawStack(this->g->g);
}

void __fastcall AppMain::ResultScreenBlendFrameBuffers(AppMain *this, int frontBuffer, int backBuffer)
{
  void (__fastcall *v3)(int, const char *); // r10
  __int64 v5; // rbp
  __int64 v6; // r14
  void (__fastcall *v7)(unsigned int, unsigned int, int, const char *); // r11
  OGLRender *m_pRender; // rax
  OGLTexture *v9; // rdi
  OGLTexture *v10; // rsi
  OGLRender *v11; // r9
  int v12; // edx

  v3 = _glewPushGroupMarkerEXT;
  v5 = backBuffer;
  v6 = frontBuffer;
  if ( _glewPushGroupMarkerEXT )
  {
    _glewPushGroupMarkerEXT(0, "Blend Result FrameBuffers");
    v3 = _glewPushGroupMarkerEXT;
  }
  v7 = _glewPushDebugGroup;
  if ( _glewPushDebugGroup )
  {
    _glewPushDebugGroup(0x824Au, 1u, 25, "Blend Result FrameBuffers");
    v3 = _glewPushGroupMarkerEXT;
    v7 = _glewPushDebugGroup;
  }
  m_pRender = this->m_pRender;
  ++markerCount;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.x = 1.0;
  this->ModelRoomSettings.postfxUniforms.u_postfxNearFar.y = 4096.0;
  v9 = &m_pRender->m_renderTextures.m_DepthMapTexture[3];
  v10 = &m_pRender->m_renderTextures.m_DepthMapTexture[5];
  if ( v3 )
  {
    v3(0, "Combine Depths1");
    v7 = _glewPushDebugGroup;
  }
  if ( v7 )
    v7(33354u, 1u, 15, "Combine Depths1");
  v11 = this->m_pRender;
  ++markerCount;
  AppMain::CombineTwoDepthTexturesCS(this, v10, v9, &v11->m_renderTextures.m_DepthMapTexture[1]);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
  if ( this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.transparencyOn[0]
    || (v12 = 7963, this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.transparencyOn[1]) )
  {
    v12 = 7961;
  }
  AppMain::BlendThreeTexturesInOrder(
    this,
    v12,
    this->m_pRender->m_renderTextures.m_FullScreenTexture,
    &this->m_pRender->m_renderTextures.m_FullScreenTexture[v6],
    &this->m_pRender->m_renderTextures.m_FullScreenTexture[v5],
    &this->m_pRender->m_renderTextures.m_FullScreenTexture[6]);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::ResultsSceneBloomEffectPass(AppMain *this, int frameBufferIndex)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm6
  __m128i v5; // xmm7
  float v6; // xmm6_4
  float v7; // xmm7_4
  OGLRender *m_pRender; // rdx
  OGLTexture *m_BloomMapDownSampleTexture; // r8
  OGLTexture *p_m_BloomMapTexture; // rdx
  int v11; // edx

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Results Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 25, "Results Bloom Effect Pass");
  v3 = _mm_cvtsi32_si128(this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale);
  v4 = _mm_cvtsi32_si128(this->m_iScreenW);
  v5 = _mm_cvtsi32_si128(this->m_iScreenH);
  ++markerCount;
  *(float *)v3.m128i_i32 = _mm_cvtepi32_ps(v3).m128_f32[0];
  v6 = _mm_cvtepi32_ps(v4).m128_f32[0] / *(float *)v3.m128i_i32;
  v7 = _mm_cvtepi32_ps(v5).m128_f32[0] / *(float *)v3.m128i_i32;
  if ( this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn )
    AppMain::ApplyShaderToTexture(
      this,
      7990,
      this->m_pRender->m_renderTextures.m_CharacterHighlights,
      this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)v6,
      (int)v7,
      1);
  m_pRender = this->m_pRender;
  if ( this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale == 1 )
  {
    m_BloomMapDownSampleTexture = m_pRender->m_renderTextures.m_BloomMapDownSampleTexture;
    p_m_BloomMapTexture = &m_pRender->m_renderTextures.m_BloomMapTexture;
  }
  else
  {
    p_m_BloomMapTexture = m_pRender->m_renderTextures.m_BloomMapDownSampleTexture;
    m_BloomMapDownSampleTexture = p_m_BloomMapTexture;
  }
  AppMain::GaussianBlurEffect(
    this,
    p_m_BloomMapTexture,
    m_BloomMapDownSampleTexture,
    v6,
    v7,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  AppMain::BloomEffectBlend(this, v11);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::ResultsSceneHighlightExtractionPass(AppMain *this, int frameBufferIndex, bool bFront)
{
  __int64 v4; // rsi
  __m128i v5; // xmm0
  __m128i v6; // xmm7
  BOOL v7; // ecx
  __m128i v8; // xmm6
  OGLRender *m_pRender; // rdx
  _BOOL8 v10; // rdi
  float v11; // xmm7_4
  float v12; // xmm6_4
  __int64 v13; // rax
  OGLTexture *v14; // r8

  v4 = frameBufferIndex;
  v5 = _mm_cvtsi32_si128(this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale);
  v6 = _mm_cvtsi32_si128(this->m_iScreenH);
  v7 = frameBufferIndex == 5;
  v8 = _mm_cvtsi32_si128(this->m_iScreenW);
  m_pRender = this->m_pRender;
  *(float *)v5.m128i_i32 = _mm_cvtepi32_ps(v5).m128_f32[0];
  v10 = v7;
  this->ModelRoomSettings.postfxUniforms.u_postfxHighlightThresholdBrightness = *(Vector2Unaligned *)&this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightThreshold;
  v11 = _mm_cvtepi32_ps(v6).m128_f32[0] / *(float *)v5.m128i_i32;
  v12 = _mm_cvtepi32_ps(v8).m128_f32[0] / *(float *)v5.m128i_i32;
  if ( bFront )
  {
    AppMain::CharHighlightExtractionWithoutDepth(
      this,
      &m_pRender->m_renderTextures.m_FullScreenTexture[v4],
      &m_pRender->m_renderTextures.m_CharacterHighlights[v7],
      (int)v12,
      (int)v11);
  }
  else
  {
    v13 = 3i64;
    if ( (_DWORD)v4 != 5 )
      v13 = 5i64;
    AppMain::CharHighlightExtractionWithoutDepthWithMask(
      this,
      &m_pRender->m_renderTextures.m_FullScreenTexture[v4],
      &m_pRender->m_renderTextures.m_CharacterHighlights[v7],
      &m_pRender->m_renderTextures.m_FullScreenMaskTexture[v13],
      (int)v12,
      (int)v11);
  }
  v14 = &this->m_pRender->m_renderTextures.m_CharacterHighlights[v10];
  AppMain::GaussianBlurEffect(
    this,
    v14,
    v14,
    v12,
    v11,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
}

void __fastcall AppMain::ResultsSceneNewBloomEffectPass(AppMain *this, int frameBufferIndex)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm6
  __m128i v5; // xmm7
  float v6; // xmm6_4
  float v7; // xmm7_4
  OGLRender *m_pRender; // r8
  float v9; // xmm6_4
  float v10; // xmm7_4
  int v11; // edx
  OGLRender *v12; // r8
  float v13; // xmm6_4
  float v14; // xmm7_4
  int v15; // edx

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Results New Bloom Effect Pass");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 29, "Results New Bloom Effect Pass");
  v3 = _mm_cvtsi32_si128(this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale);
  v4 = _mm_cvtsi32_si128(this->m_iScreenW);
  v5 = _mm_cvtsi32_si128(this->m_iScreenH);
  ++markerCount;
  *(float *)v3.m128i_i32 = _mm_cvtepi32_ps(v3).m128_f32[0];
  v6 = _mm_cvtepi32_ps(v4).m128_f32[0] / *(float *)v3.m128i_i32;
  v7 = _mm_cvtepi32_ps(v5).m128_f32[0] / *(float *)v3.m128i_i32;
  if ( this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn )
    AppMain::ApplyShaderToTexture(
      this,
      7990,
      this->m_pRender->m_renderTextures.m_CharacterHighlights,
      this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
      (int)v6,
      (int)v7,
      1);
  m_pRender = this->m_pRender;
  v9 = v6 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
  v10 = v7 * 0.5;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v9;
  this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v10;
  AppMain::DownsampleTexture(
    this,
    frameBufferIndex,
    m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    &m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    (int)v9,
    (int)v10);
  AppMain::GaussianBlurEffect(
    this,
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    v9,
    v10,
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
  if ( this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomQuality == 1 )
  {
    v12 = this->m_pRender;
    v13 = v9 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize;
    v14 = v10 * 0.5;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = 1.0 / v13;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / v14;
    AppMain::DownsampleTexture(
      this,
      v11,
      &v12->m_renderTextures.m_BloomMapDownSampleTexture[1],
      &v12->m_renderTextures.m_BloomMapDownSampleTexture[2],
      (int)v13,
      (int)v14);
    AppMain::GaussianBlurEffect(
      this,
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      v13,
      v14,
      this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength);
    AppMain::ApplyShaderToTexture(
      this,
      7967,
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2],
      &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
      (int)(float)((float)((float)this->m_iScreenW
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      (int)(float)((float)((float)this->m_iScreenH
                         / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale)
                 * 0.5),
      1);
  }
  AppMain::ApplyShaderToTexture(
    this,
    7967,
    &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1],
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture,
    (int)(float)((float)this->m_iScreenW
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    (int)(float)((float)this->m_iScreenH
               / (float)this->ModelRoomSettings.postprocessSettings.bgBloomSettings.downsampleScale),
    1);
  AppMain::BloomEffectBlend(this, v15);
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID = 0;
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
  --markerCount;
}

void __fastcall AppMain::_MODELROOM_SETTINGS::SetBlendProjection(AppMain::_MODELROOM_SETTINGS *this, OGLModel *pModel)
{
  float y; // xmm6_4
  float z; // xmm7_4
  float x; // xmm8_4
  float v7; // xmm3_4
  float v8; // xmm1_4
  float v9; // xmm0_4
  float v10; // xmm3_4
  float v11; // xmm0_4
  float v12; // xmm8_4
  float v13; // xmm6_4
  float v14; // xmm7_4
  float v15; // xmm12_4
  float v16; // xmm13_4
  float v17; // xmm14_4
  float v18; // xmm0_4
  float v19; // xmm6_4
  float v20; // xmm0_4
  float v21; // xmm0_4
  float v22; // xmm7_4
  float v23; // xmm8_4

  if ( pModel && pModel->m_bProjectionBlend )
  {
    y = pModel->m_vCenterPosition.y;
    z = pModel->m_vCenterPosition.z;
    x = pModel->m_vCenterPosition.x;
    LODWORD(v7) = COERCE_UNSIGNED_INT(
                    (float)((float)((float)(this->vCamPosVec3.y * this->vCamLookPerpNormal.y)
                                  + (float)(this->vCamPosVec3.x * this->vCamLookPerpNormal.x))
                          + (float)(this->vCamPosVec3.z * this->vCamLookPerpNormal.z))
                  + COERCE_FLOAT(COERCE_UNSIGNED_INT(
                                   (float)((float)(y * this->vCamLookPerpNormal.y)
                                         + (float)(x * this->vCamLookPerpNormal.x))
                                 + (float)(z * this->vCamLookPerpNormal.z)) ^ _xmm)) ^ _xmm;
    v8 = v7 * this->vCamLookPerpNormal.x;
    v9 = (float)(v7 * this->vCamLookPerpNormal.y) + this->vCamPosVec3.y;
    v10 = (float)((float)(v7 * this->vCamLookPerpNormal.z) + this->vCamPosVec3.z) - z;
    v11 = sqrtf(
            (float)((float)((float)(v9 - y) * (float)(v9 - y))
                  + (float)((float)((float)(v8 + this->vCamPosVec3.x) - x)
                          * (float)((float)(v8 + this->vCamPosVec3.x) - x)))
          + (float)(v10 * v10));
    v12 = x - this->fCamPos[0];
    v13 = y - this->fCamPos[1];
    v14 = z - this->fCamPos[2];
    v15 = v11 * 0.5;
    LODWORD(v16) = COERCE_UNSIGNED_INT(v11 * 0.5) ^ _xmm;
    LODWORD(v17) = COERCE_UNSIGNED_INT((float)((float)(v11 * 0.5) * 0.0625) * 9.0) ^ _xmm;
    v18 = sqrtf((float)((float)(v13 * v13) + (float)(v12 * v12)) + (float)(v14 * v14));
    if ( v18 != 0.0 )
    {
      v12 = v12 / v18;
      v13 = v13 / v18;
      v14 = v14 / v18;
    }
    v19 = (float)((float)(v13 * this->vCamLookNormal.y) + (float)(v12 * this->vCamLookNormal.x))
        + (float)(v14 * this->vCamLookNormal.z);
    if ( v19 <= 1.0 )
      v20 = fmaxf(-1.0, v19);
    else
      v20 = *(float *)&FLOAT_1_0;
    v21 = acosf(v20);
    v22 = v14 * this->vCamLookNormal.x;
    v23 = v12 * this->vCamLookNormal.z;
    pModel->m_projNormalAngLightOffset = v21;
    if ( (float)(v22 - v23) < 0.0 )
      LODWORD(v21) ^= _xmm;
    pModel->m_projNormalAngRimLightOffset = v21;
    OGLModel::setOrthoViewTrans(pModel, &this->mView);
    OGLMatrix::ortho(&pModel->m_OrthoProj, v16, v15, v17, (float)(v15 * 0.0625) * 9.0, 1.0, 2048.0);
  }
}

void __fastcall AppMain::SetPostFXUniforms(
        AppMain *this,
        OGLShader *pShader,
        const ConstantPostFX *postFXUniforms,
        const ConstantScreenFilter *filterUniforms)
{
  KOFShaderManager *v4; // r11
  __int64 v8; // rdx
  __int64 v9; // r10
  __int64 v10; // r8
  AgSingleton<KOFShaderManager>_vtbl *v11; // rcx
  Vector2Unaligned *v12; // rax
  KOFShaderManager *v13; // rcx
  unsigned int u_postfxBlurSize; // er10
  int v15; // edx
  unsigned int *v16; // rax
  int v17; // edx
  float *v18; // rax
  float u_postfxElapsedTime; // xmm0_4
  int v20; // edx
  float *v21; // rax
  int v22; // edx
  __int64 m_currentProgramSlot; // r8
  __int64 index; // r9
  void **v25; // rcx
  float u_postfxOpacity; // xmm0_4
  int v27; // edx
  float *v28; // rax
  int v29; // edx
  __int64 v30; // r8
  __int64 v31; // r9
  void **v32; // rcx
  int v33; // er8
  Vector4Unaligned *v34; // rcx
  int v35; // er8
  Vector4Unaligned *v36; // rcx
  int v37; // er8
  Vector4Unaligned *v38; // rcx
  int v39; // edx
  __int64 v40; // r8
  __int64 v41; // r9
  void **v42; // rcx
  int v43; // er8
  Vector4Unaligned *v44; // rcx
  int v45; // er8
  Vector4Unaligned *v46; // rcx
  float u_postfxBlendFactor; // xmm0_4
  int v48; // edx
  float *v49; // rax
  float u_postfxWaterTranslation; // xmm0_4
  int v51; // edx
  float *v52; // rax
  int v53; // er8
  Vector4Unaligned *v54; // rcx
  int v55; // er8
  _DWORD *v56; // rcx
  int u_postfxWaterUseReflection; // er10
  int v58; // edx
  int *v59; // rax
  float u_postfxWaterReflectScale; // xmm0_4
  int v61; // edx
  float *v62; // rax
  int u_postfxFillColourType; // er10
  int v64; // edx
  int *v65; // rax
  int v66; // er8
  Vector4Unaligned *v67; // rcx
  int v68; // er8
  Vector4Unaligned *v69; // rcx
  int v70; // er8
  Vector4Unaligned *v71; // rcx

  v4 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
  v8 = pShader->m_piGLUniform[98];
  v9 = 11i64 * SLODWORD(AgSingleton<KOFShaderManager>::ms_instance[360450].__vftable);
  v10 = *((int *)&AgSingleton<KOFShaderManager>::ms_instance[v9 + 11].~AgSingleton<KOFShaderManager> + 4 * v8);
  v11 = AgSingleton<KOFShaderManager>::ms_instance[SHIDWORD(AgSingleton<KOFShaderManager>::ms_instance[v9 + 5].__vftable)
                                                 + 494188].__vftable;
  if ( **((_QWORD **)&v11->~AgSingleton<KOFShaderManager> + v10) != *(_QWORD *)&postFXUniforms->u_postfxPixelSize )
  {
    v12 = (Vector2Unaligned *)*((_QWORD *)&v11->~AgSingleton<KOFShaderManager> + v10);
    v13 = (KOFShaderManager *)AgSingleton<KOFShaderManager>::ms_instance;
    *v12 = postFXUniforms->u_postfxPixelSize;
    KOFShaderManager::setUniformWriteMask(v13, v8);
  }
  u_postfxBlurSize = postFXUniforms->u_postfxBlurSize;
  v15 = pShader->m_piGLUniform[95];
  v16 = (unsigned int *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v15].index];
  if ( u_postfxBlurSize != *v16 )
  {
    *v16 = u_postfxBlurSize;
    KOFShaderManager::setUniformWriteMask(v4, v15);
  }
  v17 = pShader->m_piGLUniform[94];
  v18 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v17].index];
  if ( postFXUniforms->u_postfxBlurStrength != *v18 )
  {
    *v18 = postFXUniforms->u_postfxBlurStrength;
    KOFShaderManager::setUniformWriteMask(v4, v17);
  }
  u_postfxElapsedTime = postFXUniforms->u_postfxElapsedTime;
  v20 = pShader->m_piGLUniform[103];
  v21 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v20].index];
  if ( u_postfxElapsedTime != *v21 )
  {
    *v21 = u_postfxElapsedTime;
    KOFShaderManager::setUniformWriteMask(v4, v20);
  }
  v22 = pShader->m_piGLUniform[99];
  m_currentProgramSlot = v4->m_currentProgramSlot;
  index = v4->m_program[m_currentProgramSlot].m_uniformAttrib[v22].index;
  v25 = v4->m_shaderUniformPtr[v4->m_program[m_currentProgramSlot].m_linkID];
  if ( *(_QWORD *)v25[index] != *(_QWORD *)&postFXUniforms->u_postfxNearFar )
  {
    *(Vector2Unaligned *)v25[index] = postFXUniforms->u_postfxNearFar;
    KOFShaderManager::setUniformWriteMask(v4, v22);
  }
  u_postfxOpacity = postFXUniforms->u_postfxOpacity;
  v27 = pShader->m_piGLUniform[96];
  v28 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v27].index];
  if ( u_postfxOpacity != *v28 )
  {
    *v28 = u_postfxOpacity;
    KOFShaderManager::setUniformWriteMask(v4, v27);
  }
  v29 = pShader->m_piGLUniform[110];
  v30 = v4->m_currentProgramSlot;
  v31 = v4->m_program[v30].m_uniformAttrib[v29].index;
  v32 = v4->m_shaderUniformPtr[v4->m_program[v30].m_linkID];
  if ( *(_QWORD *)v32[v31] != *(_QWORD *)&postFXUniforms->u_postfxHighlightThresholdBrightness )
  {
    *(Vector2Unaligned *)v32[v31] = postFXUniforms->u_postfxHighlightThresholdBrightness;
    KOFShaderManager::setUniformWriteMask(v4, v29);
  }
  v33 = pShader->m_piGLUniform[102];
  v34 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v33].index];
  if ( *(_QWORD *)&v34->x != *(_QWORD *)&postFXUniforms->u_postfxBloomSatIntBaseSatInt.x
    || *(_QWORD *)&v34->z != *(_QWORD *)&postFXUniforms->u_postfxBloomSatIntBaseSatInt.z )
  {
    *v34 = postFXUniforms->u_postfxBloomSatIntBaseSatInt;
    KOFShaderManager::setUniformWriteMask(v4, v33);
  }
  v35 = pShader->m_piGLUniform[113];
  v36 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v35].index];
  if ( *(_QWORD *)&v36->x != *(_QWORD *)&postFXUniforms->u_postfxFXAA.x
    || *(_QWORD *)&v36->z != *(_QWORD *)&postFXUniforms->u_postfxFXAA.z )
  {
    *v36 = postFXUniforms->u_postfxFXAA;
    KOFShaderManager::setUniformWriteMask(v4, v35);
  }
  v37 = pShader->m_piGLUniform[114];
  v38 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v37].index];
  if ( *(_QWORD *)&v38->x != *(_QWORD *)&postFXUniforms->u_postfxHazeFilter.x
    || *(_QWORD *)&v38->z != *(_QWORD *)&postFXUniforms->u_postfxHazeFilter.z )
  {
    *v38 = postFXUniforms->u_postfxHazeFilter;
    KOFShaderManager::setUniformWriteMask(v4, v37);
  }
  v39 = pShader->m_piGLUniform[109];
  v40 = v4->m_currentProgramSlot;
  v41 = v4->m_program[v40].m_uniformAttrib[v39].index;
  v42 = v4->m_shaderUniformPtr[v4->m_program[v40].m_linkID];
  if ( *(_QWORD *)v42[v41] != *(_QWORD *)&postFXUniforms->u_postfxSunPos )
  {
    *(Vector2Unaligned *)v42[v41] = postFXUniforms->u_postfxSunPos;
    KOFShaderManager::setUniformWriteMask(v4, v39);
  }
  v43 = pShader->m_piGLUniform[100];
  v44 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v43].index];
  if ( *(_QWORD *)&v44->x != *(_QWORD *)&postFXUniforms->u_postfxGodRaySettings.x
    || *(_QWORD *)&v44->z != *(_QWORD *)&postFXUniforms->u_postfxGodRaySettings.z )
  {
    *v44 = postFXUniforms->u_postfxGodRaySettings;
    KOFShaderManager::setUniformWriteMask(v4, v43);
  }
  v45 = pShader->m_piGLUniform[101];
  v46 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v45].index];
  if ( *(_QWORD *)&v46->x != *(_QWORD *)&postFXUniforms->u_postfxDOFNearFarStr.x
    || *(_QWORD *)&v46->z != *(_QWORD *)&postFXUniforms->u_postfxDOFNearFarStr.z )
  {
    *v46 = postFXUniforms->u_postfxDOFNearFarStr;
    KOFShaderManager::setUniformWriteMask(v4, v45);
  }
  u_postfxBlendFactor = postFXUniforms->u_postfxBlendFactor;
  v48 = pShader->m_piGLUniform[97];
  v49 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v48].index];
  if ( u_postfxBlendFactor != *v49 )
  {
    *v49 = u_postfxBlendFactor;
    KOFShaderManager::setUniformWriteMask(v4, v48);
  }
  u_postfxWaterTranslation = postFXUniforms->u_postfxWaterTranslation;
  v51 = pShader->m_piGLUniform[104];
  v52 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v51].index];
  if ( u_postfxWaterTranslation != *v52 )
  {
    *v52 = u_postfxWaterTranslation;
    KOFShaderManager::setUniformWriteMask(v4, v51);
  }
  v53 = pShader->m_piGLUniform[111];
  v54 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v53].index];
  if ( *(_QWORD *)&v54->x != *(_QWORD *)&postFXUniforms->u_postfxWindDir.x
    || *(_QWORD *)&v54->z != *(_QWORD *)&postFXUniforms->u_postfxWindDir.z )
  {
    *v54 = postFXUniforms->u_postfxWindDir;
    KOFShaderManager::setUniformWriteMask(v4, v53);
  }
  v55 = pShader->m_piGLUniform[107];
  v56 = v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v55].index];
  if ( *(_QWORD *)v56 != *(_QWORD *)&postFXUniforms->u_postfxWaterTint.x
    || v56[2] != LODWORD(postFXUniforms->u_postfxWaterTint.z) )
  {
    *(_QWORD *)v56 = *(_QWORD *)&postFXUniforms->u_postfxWaterTint.x;
    v56[2] = LODWORD(postFXUniforms->u_postfxWaterTint.z);
    KOFShaderManager::setUniformWriteMask(v4, v55);
  }
  u_postfxWaterUseReflection = postFXUniforms->u_postfxWaterUseReflection;
  v58 = pShader->m_piGLUniform[106];
  v59 = (int *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v58].index];
  if ( u_postfxWaterUseReflection != *v59 )
  {
    *v59 = u_postfxWaterUseReflection;
    KOFShaderManager::setUniformWriteMask(v4, v58);
  }
  u_postfxWaterReflectScale = postFXUniforms->u_postfxWaterReflectScale;
  v61 = pShader->m_piGLUniform[105];
  v62 = (float *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v61].index];
  if ( u_postfxWaterReflectScale != *v62 )
  {
    *v62 = u_postfxWaterReflectScale;
    KOFShaderManager::setUniformWriteMask(v4, v61);
  }
  u_postfxFillColourType = postFXUniforms->u_postfxFillColourType;
  v64 = pShader->m_piGLUniform[108];
  v65 = (int *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v64].index];
  if ( u_postfxFillColourType != *v65 )
  {
    *v65 = u_postfxFillColourType;
    KOFShaderManager::setUniformWriteMask(v4, v64);
  }
  v66 = pShader->m_piGLUniform[112];
  v67 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v66].index];
  if ( *(_QWORD *)&v67->x != *(_QWORD *)&postFXUniforms->u_postfxFillColour.x
    || *(_QWORD *)&v67->z != *(_QWORD *)&postFXUniforms->u_postfxFillColour.z )
  {
    *v67 = postFXUniforms->u_postfxFillColour;
    KOFShaderManager::setUniformWriteMask(v4, v66);
  }
  v68 = pShader->m_piGLUniform[125];
  v69 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v68].index];
  if ( *(_QWORD *)&v69->x != *(_QWORD *)&filterUniforms->u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity.x
    || *(_QWORD *)&v69->z != *(_QWORD *)&filterUniforms->u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity.z )
  {
    *v69 = filterUniforms->u_monitorFilterBriSatCon_ScreenFilterOverlayOpacity;
    KOFShaderManager::setUniformWriteMask(v4, v68);
  }
  v70 = pShader->m_piGLUniform[126];
  v71 = (Vector4Unaligned *)v4->m_shaderUniformPtr[v4->m_program[v4->m_currentProgramSlot].m_linkID][v4->m_program[v4->m_currentProgramSlot].m_uniformAttrib[v70].index];
  if ( *(_QWORD *)&v71->x != *(_QWORD *)&filterUniforms->u_monitorFilterMidTonesColShift.x
    || *(_QWORD *)&v71->z != *(_QWORD *)&filterUniforms->u_monitorFilterMidTonesColShift.z )
  {
    *v71 = filterUniforms->u_monitorFilterMidTonesColShift;
    KOFShaderManager::setUniformWriteMask(v4, v70);
  }
}

void __fastcall AppMain::SetUpGodRayData(AppMain *this, extension::AsyncStatus::Step a2)
{
  bool v2; // zf
  int v4; // esi
  __int64 i; // rdi
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rcx
  OGLModel *v11; // rdx
  float z; // xmm1_4
  float x; // eax

  v2 = !this->ModelRoomSettings.postprocessSettings.godRaySettings.shaderOn;
  this->ModelRoomSettings.postprocessSettings.godRaySettings.sunPosSet = 0;
  this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelIndex = -1;
  if ( !v2 )
  {
    v4 = 0;
    for ( i = 0i64; ; ++i )
    {
      v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 8i64) + 16i64);
      if ( !v6 || *(_BYTE *)(v6 + 96) )
      {
        v7 = 0i64;
      }
      else
      {
        if ( (*(_QWORD *)(v6 + 88) & 1) == 0 )
          extension::AsyncStatus::waitFor((extension::AsyncStatus *)(v6 + 88), a2);
        v7 = *(_QWORD *)(v6 + 72);
      }
      if ( v4 >= (int)((__int64)(*(_QWORD *)(v7 + 208) - *(_QWORD *)(v7 + 200)) >> 3) )
        break;
      v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 8i64) + 16i64);
      if ( !v8 || *(_BYTE *)(v8 + 96) )
      {
        v9 = 0i64;
      }
      else
      {
        if ( (*(_QWORD *)(v8 + 88) & 1) == 0 )
          extension::AsyncStatus::waitFor((extension::AsyncStatus *)(v8 + 88), a2);
        v9 = *(_QWORD *)(v8 + 72);
      }
      if ( i < 0 || v4 >= (int)((__int64)(*(_QWORD *)(v9 + 208) - *(_QWORD *)(v9 + 200)) >> 3) )
        v10 = 0i64;
      else
        v10 = *(_QWORD *)(*(_QWORD *)(v9 + 200) + 8 * i);
      if ( this->pModel && !strcmp(*(const char **)(v10 + 8824), "SUNLIGHT") )
      {
        v11 = this->pModel[v4];
        z = v11->m_vCenterPosition.z;
        x = v11->m_vCenterPosition.x;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.y = v11->m_vCenterPosition.y;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.z = z;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.x = x;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.w = 1.0;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelIndex = v4;
        this->ModelRoomSettings.postprocessSettings.godRaySettings.sunPosSet = 1;
        return;
      }
      ++v4;
    }
  }
}

void __fastcall AppMain::SetUpModelRoomCamera(AppMain *this)
{
  float v2; // xmm8_4
  float v3; // xmm9_4
  float v4; // xmm6_4
  float v5; // xmm6_4
  float v6; // xmm0_4

  *(_QWORD *)&this->ModelRoomSettings.perseAngle = 1107367035i64;
  this->ModelRoomSettings.cameraDist = 52.5;
  this->ModelRoomSettings.cameraHeight = 12.5;
  this->ModelRoomSettings.detachCameraFromLight = 0;
  this->ModelRoomSettings.fCamElevation = 1.5498525;
  v2 = sinf(0.0) * 52.5;
  this->ModelRoomSettings.fCamPos[0] = v2;
  this->ModelRoomSettings.fCamPos[1] = this->ModelRoomSettings.cameraHeight;
  v3 = cosf(this->ModelRoomSettings.cameraAngle) * this->ModelRoomSettings.cameraDist;
  this->ModelRoomSettings.fCamPos[2] = v3;
  v4 = sinf(this->ModelRoomSettings.fCamElevation) * 50.0;
  this->ModelRoomSettings.fCamLook[0] = (float)(v4 * sinf(this->ModelRoomSettings.cameraAngle)) + v2;
  this->ModelRoomSettings.fCamLook[1] = (float)(cosf(this->ModelRoomSettings.fCamElevation) * 50.0)
                                      + this->ModelRoomSettings.fCamPos[1];
  v5 = sinf(this->ModelRoomSettings.fCamElevation) * 50.0;
  v6 = cosf(this->ModelRoomSettings.cameraAngle);
  this->ModelRoomSettings.fCamUp[0] = 0.0;
  *(_QWORD *)&this->ModelRoomSettings.fCamUp[1] = 1065353216i64;
  this->ModelRoomSettings.fCamLook[2] = v3 - (float)(v5 * v6);
}

void __fastcall AppMain::SetUpModelRoomLights(AppMain *this)
{
  AppMain::SetupWorldLights(this);
  AppMain::SetUpPlayerLights(this);
  AppMain::SetUpStageLights(this);
}

void __fastcall AppMain::SetUpPlayerLights(AppMain *this)
{
  int *v2; // r13
  __int64 v3; // rax
  int v4; // er12
  __int64 v5; // rdx
  __int64 v6; // r15
  __int64 v7; // rcx
  int v8; // er14
  __int64 v9; // rsi
  OGLLightManager *v10; // rbx
  int (*playerLightId)[64][3]; // rcx
  __int64 v12; // r10
  bool (*playerLightOn)[64][3]; // rdx
  int (*numPlayerLights)[64]; // r8
  __int64 v15; // r9
  __int64 i; // rax
  int *v17; // r9
  bool *v18; // r11
  float *position; // rbx
  int *v20; // rsi
  int v21; // er10
  __int64 v22; // rax
  int v23; // edx
  __int64 v24; // r8
  __int64 v25; // rax
  __int64 v26; // rcx
  __m128i v27; // xmm6
  __int64 v28; // rdi
  int v29; // eax
  int *v30; // r10
  float v31; // xmm6_4
  float *v32; // rsi
  int v33; // er14
  float *v34; // rbx
  bool *v35; // r12
  int v36; // er13
  int *v37; // r15
  int v38; // eax
  int v39; // edx
  __int64 v40; // rcx
  __int64 v41; // rcx
  int v42; // xmm0_4
  int v43; // xmm1_4
  int v44; // eax
  int v45; // eax
  int v46; // edx
  __int64 v47; // rcx
  __int64 v48; // rcx
  int v49; // xmm0_4
  int v50; // xmm1_4
  int v51; // eax
  int *v52; // r12
  int v53; // er8
  AppMain *v54; // rdi
  OGLModel **Myval2; // rdx
  OGLModel *v56; // rcx
  float rimLightMax; // xmm0_4
  int v58; // er8
  OGLModel **v59; // rdx
  OGLModel *v60; // rcx
  float v61; // xmm0_4
  int v62; // er8
  OGLModel **v63; // rdx
  OGLModel *v64; // rcx
  float v65; // xmm0_4
  int v66; // er8
  OGLModel **v67; // rdx
  OGLModel *v68; // rcx
  float v69; // xmm0_4
  int numP1Lights; // er9
  int v71; // er8
  __int64 v72; // rsi
  int v73; // edx
  bool (*v74)[64][3]; // rax
  __int64 v75; // r15
  int *v76; // r14
  float *v77; // r12
  int (*v78)[64][3]; // r13
  int v79; // er11
  float *v80; // r8
  bool (*v81)[64][3]; // rbx
  int (*v82)[64][3]; // r10
  float *v83; // rdx
  int v84; // er9
  OGLLightManager *v85; // rcx
  OGLLightNode *v86; // rax
  int v87; // er9
  OGLLightManager *v88; // rcx
  OGLLightNode *v89; // rcx
  float v90; // xmm1_4
  float v91; // xmm0_4
  float v92; // xmm0_4
  float v93; // xmm3_4
  float v94; // xmm2_4
  float v95; // xmm0_4
  float v96; // xmm1_4
  int v97; // eax
  int v98; // er8
  __int64 v99; // rsi
  int v100; // edx
  bool (*v101)[3]; // rax
  __int64 v102; // r15
  int *v103; // r14
  float *v104; // r12
  int (*v105)[3]; // r13
  int v106; // er11
  float *v107; // r8
  bool (*v108)[3]; // rbx
  int (*v109)[3]; // r10
  float *v110; // rdx
  int v111; // er9
  OGLLightManager *v112; // rcx
  OGLLightNode *v113; // rax
  int v114; // er9
  OGLLightManager *v115; // rcx
  OGLLightNode *v116; // rcx
  float v117; // xmm1_4
  float v118; // xmm0_4
  float v119; // xmm0_4
  float v120; // xmm3_4
  float v121; // xmm2_4
  float v122; // xmm0_4
  float v123; // xmm1_4
  int v124; // eax
  int numCharLights; // er9
  int v126; // er8
  __int64 v127; // rsi
  int v128; // edx
  bool (*v129)[64][3]; // rax
  __int64 v130; // r15
  int *v131; // r14
  float *v132; // r12
  int (*v133)[64][3]; // r13
  int v134; // er11
  float *v135; // r8
  bool (*v136)[64][3]; // rbx
  int (*v137)[64][3]; // r10
  float *v138; // rdx
  int v139; // er9
  OGLLightManager *m_pLightManager; // rcx
  OGLLightNode *m_pLightNodeList; // rax
  int v142; // er9
  OGLLightManager *v143; // rcx
  OGLLightNode *v144; // rcx
  float v145; // xmm1_4
  float v146; // xmm0_4
  float v147; // xmm0_4
  float v148; // xmm3_4
  float v149; // xmm2_4
  float v150; // xmm0_4
  float v151; // xmm1_4
  int v152; // eax
  int v153; // er8
  __int64 v154; // rsi
  int v155; // edx
  bool (*v156)[3]; // rax
  __int64 v157; // r15
  int *v158; // r14
  float *v159; // r12
  int (*v160)[3]; // r13
  int v161; // er11
  float *v162; // r8
  bool (*v163)[3]; // rbx
  int (*v164)[3]; // r10
  float *v165; // rdx
  int v166; // er9
  OGLLightManager *v167; // rcx
  OGLLightNode *v168; // rax
  int v169; // er9
  OGLLightManager *v170; // rcx
  OGLLightNode *v171; // rcx
  float v172; // xmm1_4
  float v173; // xmm0_4
  float v174; // xmm0_4
  float v175; // xmm3_4
  float v176; // xmm2_4
  float v177; // xmm0_4
  float v178; // xmm1_4
  int v179; // eax
  int v180; // er15
  __int64 v181; // rbx
  int v182; // er14
  __int64 v183; // r9
  int (*v184)[64]; // r8
  __int64 v185; // rsi
  OGLLightManager *v186; // rcx
  int v187; // edx
  OGLLightNode *v188; // rax
  __int64 v189; // r11
  int v190; // er10
  OGLLightManager *v191; // rdx
  OGLLightNode *v192; // rdx
  float v193; // xmm1_4
  float v194; // xmm0_4
  __int64 v195; // rcx
  float v196; // xmm1_4
  float v197; // xmm0_4
  float v198; // xmm2_4
  __int64 v199; // rcx
  float v200; // xmm0_4
  float v201; // xmm1_4
  int type; // ecx
  OGLLightManager *v203; // rcx
  int v204; // edx
  OGLLightNode *v205; // rax
  __int64 v206; // r11
  int v207; // er10
  OGLLightManager *v208; // rdx
  OGLLightNode *v209; // rdx
  float v210; // xmm1_4
  float v211; // xmm0_4
  __int64 v212; // rcx
  float v213; // xmm1_4
  float v214; // xmm0_4
  float v215; // xmm2_4
  __int64 v216; // rcx
  float v217; // xmm0_4
  float v218; // xmm1_4
  int v219; // ecx
  OGLLightManager *v220; // rcx
  int v221; // edx
  OGLLightNode *v222; // rax
  __int64 v223; // r11
  int v224; // er10
  OGLLightManager *v225; // rdx
  OGLLightNode *v226; // rdx
  float v227; // xmm1_4
  float v228; // xmm0_4
  __int64 v229; // rcx
  float v230; // xmm1_4
  float v231; // xmm0_4
  float v232; // xmm2_4
  __int64 v233; // rcx
  float v234; // xmm0_4
  float v235; // xmm1_4
  int v236; // ecx
  int v237; // er15
  __int64 v238; // rbx
  int v239; // er14
  __int64 v240; // r9
  int *v241; // rdx
  __int64 v242; // rsi
  OGLLightManager *v243; // rcx
  int v244; // er8
  OGLLightNode *v245; // rax
  __int64 v246; // r11
  int v247; // er10
  OGLLightManager *v248; // r8
  OGLLightNode *v249; // r8
  float v250; // xmm1_4
  float v251; // xmm0_4
  __int64 v252; // rcx
  float v253; // xmm1_4
  float v254; // xmm0_4
  float v255; // xmm2_4
  __int64 v256; // rcx
  float v257; // xmm0_4
  float v258; // xmm1_4
  int v259; // ecx
  OGLLightManager *v260; // rcx
  int v261; // er8
  OGLLightNode *v262; // rax
  __int64 v263; // r11
  int v264; // er10
  OGLLightManager *v265; // r8
  OGLLightNode *v266; // r8
  float v267; // xmm1_4
  float v268; // xmm0_4
  __int64 v269; // rcx
  float v270; // xmm1_4
  float v271; // xmm0_4
  float v272; // xmm2_4
  __int64 v273; // rcx
  float v274; // xmm0_4
  float v275; // xmm1_4
  int v276; // ecx
  OGLLightManager *v277; // rcx
  int v278; // er8
  OGLLightNode *v279; // rax
  __int64 v280; // r11
  int v281; // er10
  OGLLightManager *v282; // r8
  OGLLightNode *v283; // r8
  float v284; // xmm1_4
  float v285; // xmm0_4
  __int64 v286; // rcx
  float v287; // xmm1_4
  float v288; // xmm0_4
  float v289; // xmm2_4
  __int64 v290; // rcx
  float v291; // xmm0_4
  float v292; // xmm1_4
  int v293; // ecx
  int numP2Lights; // er9
  int v295; // er8
  __int64 v296; // rsi
  int v297; // edx
  bool (*v298)[3]; // rax
  __int64 v299; // r15
  int *v300; // r14
  float *v301; // r12
  int (*v302)[3]; // r13
  int v303; // er11
  float *v304; // r8
  bool (*v305)[3]; // rbx
  int (*v306)[3]; // r10
  float *v307; // rdx
  int v308; // er9
  OGLLightManager *v309; // rcx
  OGLLightNode *v310; // rax
  int v311; // er9
  OGLLightManager *v312; // rcx
  OGLLightNode *v313; // rcx
  float v314; // xmm1_4
  float v315; // xmm0_4
  float v316; // xmm0_4
  float v317; // xmm3_4
  float v318; // xmm2_4
  float v319; // xmm0_4
  float v320; // xmm1_4
  int v321; // eax
  int v322; // er8
  __int64 v323; // rsi
  int v324; // edx
  bool (*v325)[3]; // rax
  __int64 v326; // r15
  int *v327; // r14
  float *v328; // r12
  int (*v329)[3]; // r13
  int v330; // er11
  float *v331; // r8
  bool (*v332)[3]; // rbx
  int (*v333)[3]; // r10
  float *v334; // rdx
  int v335; // er9
  OGLLightManager *v336; // rcx
  OGLLightNode *v337; // rax
  int v338; // er9
  OGLLightManager *v339; // rcx
  OGLLightNode *v340; // rcx
  float v341; // xmm1_4
  float v342; // xmm0_4
  float v343; // xmm0_4
  float v344; // xmm3_4
  float v345; // xmm2_4
  float v346; // xmm0_4
  float v347; // xmm1_4
  int v348; // eax
  int v349; // er9
  int v350; // er8
  __int64 v351; // rsi
  int v352; // edx
  bool (*v353)[3]; // rax
  __int64 v354; // r15
  int *v355; // r14
  float *v356; // r12
  int (*v357)[3]; // r13
  int v358; // er11
  float *v359; // r8
  bool (*v360)[3]; // rbx
  int (*v361)[3]; // r10
  float *v362; // rdx
  int v363; // er9
  OGLLightManager *v364; // rcx
  OGLLightNode *v365; // rax
  int v366; // er9
  OGLLightManager *v367; // rcx
  OGLLightNode *v368; // rcx
  float v369; // xmm1_4
  float v370; // xmm0_4
  float v371; // xmm0_4
  float v372; // xmm3_4
  float v373; // xmm2_4
  float v374; // xmm0_4
  float v375; // xmm1_4
  int v376; // eax
  int v377; // er8
  __int64 j; // rsi
  int v379; // edx
  bool (*v380)[3]; // rax
  __int64 v381; // r15
  int *v382; // r14
  float *v383; // r12
  int (*v384)[3]; // r13
  int v385; // er11
  float *v386; // r8
  bool (*v387)[3]; // rbx
  int (*v388)[3]; // r10
  float *v389; // rdx
  int v390; // er9
  OGLLightManager *v391; // rcx
  OGLLightNode *v392; // rax
  int v393; // er9
  OGLLightManager *v394; // rcx
  OGLLightNode *v395; // rcx
  float v396; // xmm1_4
  float v397; // xmm0_4
  float v398; // xmm0_4
  float v399; // xmm3_4
  float v400; // xmm2_4
  float v401; // xmm0_4
  float v402; // xmm1_4
  int v403; // eax
  int v404; // er15
  __int64 v405; // r11
  int v406; // er14
  __int64 v407; // r9
  int *v408; // r8
  __int64 v409; // rbx
  OGLLightManager *v410; // rcx
  int v411; // edx
  OGLLightNode *v412; // rax
  __int64 v413; // rsi
  int v414; // er10
  OGLLightManager *v415; // rdx
  OGLLightNode *v416; // rdx
  float v417; // xmm1_4
  float v418; // xmm0_4
  __int64 v419; // rcx
  float v420; // xmm1_4
  float v421; // xmm0_4
  float v422; // xmm2_4
  __int64 v423; // rcx
  float v424; // xmm0_4
  float v425; // xmm1_4
  int v426; // ecx
  int v427; // er15
  __int64 k; // r11
  int v429; // er14
  __int64 v430; // r9
  int *v431; // r8
  __int64 v432; // rbx
  OGLLightManager *v433; // rcx
  int v434; // edx
  OGLLightNode *v435; // rax
  __int64 v436; // rsi
  int v437; // er10
  OGLLightManager *v438; // rdx
  OGLLightNode *v439; // rdx
  float v440; // xmm1_4
  float v441; // xmm0_4
  __int64 v442; // rcx
  float v443; // xmm1_4
  float v444; // xmm0_4
  float v445; // xmm2_4
  __int64 v446; // rcx
  float v447; // xmm0_4
  float v448; // xmm1_4
  int v449; // ecx
  int *p_iModelCount; // [rsp+28h] [rbp-79h]
  __int128 v451; // [rsp+28h] [rbp-79h]
  __int128 v452; // [rsp+28h] [rbp-79h]
  __int128 v453; // [rsp+28h] [rbp-79h]
  __int128 v454; // [rsp+28h] [rbp-79h]
  __int128 v455; // [rsp+28h] [rbp-79h]
  __int128 v456; // [rsp+28h] [rbp-79h]
  __int128 v457; // [rsp+28h] [rbp-79h]
  __int128 v458; // [rsp+28h] [rbp-79h]
  int v459; // [rsp+38h] [rbp-69h]
  __int64 v460; // [rsp+40h] [rbp-61h]
  int *v461; // [rsp+48h] [rbp-59h]
  bool *v462; // [rsp+50h] [rbp-51h]
  int *v463; // [rsp+58h] [rbp-49h]
  float *v464; // [rsp+60h] [rbp-41h]
  int *v465; // [rsp+68h] [rbp-39h]
  float *v466; // [rsp+70h] [rbp-31h]
  bool *v467; // [rsp+78h] [rbp-29h]
  __int64 v468; // [rsp+80h] [rbp-21h]
  int v470; // [rsp+108h] [rbp+67h]
  int v471; // [rsp+108h] [rbp+67h]
  int v472; // [rsp+108h] [rbp+67h]
  int v473; // [rsp+108h] [rbp+67h]
  int v474; // [rsp+108h] [rbp+67h]
  int v475; // [rsp+108h] [rbp+67h]
  int v476; // [rsp+108h] [rbp+67h]
  int v477; // [rsp+108h] [rbp+67h]
  __int64 v478; // [rsp+110h] [rbp+6Fh]
  int v479; // [rsp+110h] [rbp+6Fh]
  int v480; // [rsp+110h] [rbp+6Fh]
  int v481; // [rsp+110h] [rbp+6Fh]
  int v482; // [rsp+110h] [rbp+6Fh]
  int v483; // [rsp+110h] [rbp+6Fh]
  int v484; // [rsp+110h] [rbp+6Fh]
  int v485; // [rsp+110h] [rbp+6Fh]
  int v486; // [rsp+110h] [rbp+6Fh]
  int v487; // [rsp+110h] [rbp+6Fh]
  int v488; // [rsp+118h] [rbp+77h]
  bool (*v489)[64][3]; // [rsp+118h] [rbp+77h]
  bool (*v490)[3]; // [rsp+118h] [rbp+77h]
  bool (*v491)[64][3]; // [rsp+118h] [rbp+77h]
  bool (*v492)[3]; // [rsp+118h] [rbp+77h]
  bool (*v493)[3]; // [rsp+118h] [rbp+77h]
  bool (*v494)[3]; // [rsp+118h] [rbp+77h]
  bool (*v495)[3]; // [rsp+118h] [rbp+77h]
  bool (*v496)[3]; // [rsp+118h] [rbp+77h]
  int v497; // [rsp+120h] [rbp+7Fh]

  p_iModelCount = &this->ModelRoomSettings.CharaInfo[0].iModelCount;
  v2 = &this->ModelRoomSettings.CharaInfo[0].iModelCount;
  v3 = 4i64;
  v468 = 4i64;
  v478 = 4i64;
  do
  {
    v4 = 0;
    if ( *v2 > 0 )
    {
      v5 = *((_QWORD *)v2 + 1);
      v6 = 0i64;
      do
      {
        if ( *(_QWORD *)(v5 + v6) )
        {
          v7 = *(_QWORD *)(v5 + v6);
          if ( *(_QWORD *)(v7 + 8456) )
          {
            v8 = 0;
            if ( *(_BYTE *)(v7 + 8464) )
            {
              v9 = 0i64;
              do
              {
                v10 = *(OGLLightManager **)(*(_QWORD *)(v7 + 8456) + v9 + 328);
                OGLLightManager::deleteAllLights(v10);
                OGLLightManager::clear(v10);
                v5 = *((_QWORD *)v2 + 1);
                v9 += 1128i64;
                ++v8;
                v7 = *(_QWORD *)(v5 + v6);
              }
              while ( v8 < *(unsigned __int8 *)(v7 + 8464) );
            }
          }
        }
        ++v4;
        v6 += 8i64;
      }
      while ( v4 < *v2 );
      v3 = v478;
    }
    v2 += 14;
    v478 = --v3;
  }
  while ( v3 );
  playerLightId = this->ModelRoomSettings.playerLightId;
  v12 = 4i64;
  playerLightOn = this->ModelRoomSettings.playerLightOn;
  numPlayerLights = this->ModelRoomSettings.numPlayerLights;
  do
  {
    v15 = 64i64;
    do
    {
      *(_DWORD *)numPlayerLights = 0;
      for ( i = 0i64; i < 3; ++i )
      {
        *(_DWORD *)playerLightId = -1;
        playerLightId = (int (*)[64][3])((char *)playerLightId + 4);
        (*playerLightOn)[0][i] = 0;
      }
      playerLightOn = (bool (*)[64][3])((char *)playerLightOn + 3);
      numPlayerLights = (int (*)[64])((char *)numPlayerLights + 4);
      --v15;
    }
    while ( v15 );
    --v12;
  }
  while ( v12 );
  v17 = p_iModelCount;
  v18 = &this->ModelRoomSettings.playerLightOn[0][0][2];
  position = this->ModelRoomPlayerLightSettings[0][0][2].position;
  v20 = &this->ModelRoomSettings.playerLightId[0][0][2];
  v467 = &this->ModelRoomSettings.playerLightOn[0][0][2];
  v21 = 0;
  v466 = this->ModelRoomPlayerLightSettings[0][0][2].position;
  v22 = 4i64;
  v465 = &this->ModelRoomSettings.playerLightId[0][0][2];
  v461 = p_iModelCount;
  v497 = 0;
  do
  {
    v23 = 0;
    v488 = 0;
    if ( *v17 <= 0 )
      goto LABEL_47;
    v24 = 0i64;
    v460 = 0i64;
    do
    {
      v25 = *((_QWORD *)v17 + 1);
      if ( *(_QWORD *)(v24 + v25) )
      {
        v26 = *(_QWORD *)(v24 + v25);
        if ( *(_QWORD *)(v26 + 8456) )
        {
          v479 = 0;
          if ( *(_BYTE *)(v26 + 8464) )
          {
            v463 = v20;
            v27 = _mm_cvtsi32_si128(v21 + 1);
            v28 = 0i64;
            v464 = position;
            v459 = 5 * (v21 + 1);
            v29 = v459;
            v462 = v18;
            v30 = v20;
            LODWORD(v31) = _mm_cvtepi32_ps(v27).m128_u32[0];
            v32 = position;
            while ( 1 )
            {
              v33 = 0;
              v34 = v32 - 33;
              v35 = v18 - 2;
              v36 = v29;
              v37 = v30 - 2;
              do
              {
                v38 = OGLLightManager::addLight(*(OGLLightManager **)(*(_QWORD *)(*(_QWORD *)(v460 + *((_QWORD *)v17 + 1))
                                                                                + 8456i64)
                                                                    + v28
                                                                    + 328));
                v17 = v461;
                *v37 = v38;
                *v35 = 0;
                *(v34 - 1) = (float)((float)v33 * 10.0) * v31;
                *v34 = (float)v36;
                v34[1] = (float)((float)v33 * 7.0) * v31;
                *((_QWORD *)v34 + 1) = 1065353216i64;
                v34[4] = 0.0;
                v34[5] = -1.0;
                *(_OWORD *)(v34 + 6) = _xmm;
                *((_WORD *)v34 + 26) = 256;
                *((_QWORD *)v34 + 5) = 1061752792i64;
                v34[12] = 1.0;
                *((_BYTE *)v34 + 54) = 1;
                *(_QWORD *)(v34 - 3) = 0i64;
                v39 = *v37;
                v40 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v460 + *((_QWORD *)v461 + 1)) + 8456i64) + v28 + 328);
                if ( !*(_QWORD *)(v40 + 712) )
                  goto LABEL_31;
                v41 = *(_QWORD *)(v40 + 712);
                if ( v39 == -1 )
                  goto LABEL_32;
                if ( v41 )
                {
                  while ( *(_DWORD *)v41 != v39 )
                  {
                    v41 = *(_QWORD *)(v41 + 288);
                    if ( !v41 )
                      goto LABEL_31;
                  }
                }
                else
                {
LABEL_31:
                  v41 = 0i64;
                }
LABEL_32:
                v42 = *((_DWORD *)v34 + 4);
                v43 = *((_DWORD *)v34 + 5);
                *(_DWORD *)(v41 + 96) = 0;
                *(_DWORD *)(v41 + 100) = v42;
                *(_DWORD *)(v41 + 104) = v43;
                *(_OWORD *)(v41 + 36) = *(_OWORD *)(v34 + 6);
                *(_BYTE *)(v41 + 152) = *((_BYTE *)v34 + 52);
                *(float *)(v41 + 124) = v34[10];
                *(float *)(v41 + 128) = v34[11];
                *(float *)(v41 + 136) = v34[12];
                *(_BYTE *)(v41 + 154) = *((_BYTE *)v34 + 53);
                *(_BYTE *)(v41 + 153) = *((_BYTE *)v34 + 54);
                *(float *)(v41 + 16) = *(v34 - 2);
                v44 = *((_DWORD *)v34 - 3);
                if ( v44 < 4 )
                  *(_DWORD *)(v41 + 12) = v44;
                v36 += v459;
                ++v33;
                ++v37;
                v34 += 17;
                ++v35;
              }
              while ( v33 < 2 );
              v45 = OGLLightManager::addLight(*(OGLLightManager **)(*(_QWORD *)(*(_QWORD *)(v460 + *((_QWORD *)v461 + 1))
                                                                              + 8456i64)
                                                                  + v28
                                                                  + 328));
              v17 = v461;
              v24 = v460;
              *v463 = v45;
              *v462 = 0;
              *(_QWORD *)v464 = 0i64;
              v464[2] = 0.0;
              *(_QWORD *)(v464 + 3) = 1065353216i64;
              v464[5] = 0.0;
              v464[6] = -1.0;
              *(_OWORD *)(v464 + 7) = _xmm;
              *((_WORD *)v464 + 28) = 256;
              *(_QWORD *)(v464 + 11) = 1061752792i64;
              v464[13] = 1.0;
              *((_BYTE *)v464 + 58) = 1;
              *((_QWORD *)v464 - 1) = 0i64;
              v46 = *v463;
              v47 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v460 + *((_QWORD *)v461 + 1)) + 8456i64) + v28 + 328);
              if ( !*(_QWORD *)(v47 + 712) )
                goto LABEL_40;
              v48 = *(_QWORD *)(v47 + 712);
              if ( v46 == -1 )
                goto LABEL_41;
              if ( v48 )
              {
                while ( *(_DWORD *)v48 != v46 )
                {
                  v48 = *(_QWORD *)(v48 + 288);
                  if ( !v48 )
                    goto LABEL_40;
                }
              }
              else
              {
LABEL_40:
                v48 = 0i64;
              }
LABEL_41:
              v49 = *((_DWORD *)v464 + 5);
              v50 = *((_DWORD *)v464 + 6);
              *(_DWORD *)(v48 + 96) = 0;
              *(_DWORD *)(v48 + 100) = v49;
              *(_DWORD *)(v48 + 104) = v50;
              *(_OWORD *)(v48 + 36) = *(_OWORD *)(v464 + 7);
              *(_BYTE *)(v48 + 152) = *((_BYTE *)v464 + 56);
              *(float *)(v48 + 124) = v464[11];
              *(float *)(v48 + 128) = v464[12];
              *(float *)(v48 + 136) = v464[13];
              *(_BYTE *)(v48 + 154) = *((_BYTE *)v464 + 57);
              *(_BYTE *)(v48 + 153) = *((_BYTE *)v464 + 58);
              *(float *)(v48 + 16) = *(v464 - 1);
              v51 = *((_DWORD *)v464 - 2);
              if ( v51 < 4 )
                *(_DWORD *)(v48 + 12) = v51;
              v18 = v462 + 3;
              v30 = v463 + 3;
              v462 += 3;
              v32 = v464 + 51;
              ++v479;
              v28 += 1128i64;
              v463 += 3;
              v464 += 51;
              v29 = v459;
              if ( v479 >= *(unsigned __int8 *)(*(_QWORD *)(v460 + *((_QWORD *)v461 + 1)) + 8464i64) )
              {
                v23 = v488;
                v21 = v497;
                v18 = v467;
                position = v466;
                v20 = v465;
                break;
              }
            }
          }
        }
      }
      ++v23;
      v24 += 8i64;
      v488 = v23;
      v460 = v24;
    }
    while ( v23 < *v17 );
    v22 = v468;
LABEL_47:
    ++v21;
    v17 += 14;
    v20 += 192;
    v497 = v21;
    position += 3264;
    v461 = v17;
    v18 += 192;
    v465 = v20;
    --v22;
    v466 = position;
    v468 = v22;
    v467 = v18;
  }
  while ( v22 );
  v52 = p_iModelCount;
  v53 = 0;
  v54 = this;
  if ( *p_iModelCount > 0 )
  {
    Myval2 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2;
    do
    {
      if ( *Myval2 )
      {
        v56 = *Myval2;
        rimLightMax = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightMax;
        v56->m_rimLightMin = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightMin;
        v56->m_rimLightMax = rimLightMax;
        v56->m_rimLightStrength = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightStrength;
        v56->m_rimLightColour[0] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[0];
        v56->m_rimLightColour[1] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[1];
        v56->m_rimLightColour[2] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[2];
        v56->m_shaderEyeDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P1EmissionData.eyeEmissionStrength;
        v56->m_shaderLightDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P1EmissionData.charEmissionStrength;
        v56->m_bodySelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.bodySelfShadowDotRangeMin;
        v56->m_bodySelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.bodySelfShadowDotRangeMax;
        v56->m_skinSelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.skinSelfShadowDotRangeMin;
        v56->m_skinSelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.skinSelfShadowDotRangeMax;
      }
      ++v53;
      ++Myval2;
    }
    while ( v53 < *p_iModelCount );
  }
  v58 = 0;
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v59 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
    do
    {
      if ( *v59 )
      {
        v60 = *v59;
        v61 = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightMax;
        v60->m_rimLightMin = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightMin;
        v60->m_rimLightMax = v61;
        v60->m_rimLightStrength = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightStrength;
        v60->m_rimLightColour[0] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[0];
        v60->m_rimLightColour[1] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[1];
        v60->m_rimLightColour[2] = this->ModelRoomSettings.worldLightData.P1RimLightAssetData.rimLightColour[2];
        v60->m_shaderEyeDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P1EmissionData.eyeEmissionStrength;
        v60->m_shaderLightDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P1EmissionData.charEmissionStrength;
        v60->m_bodySelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.bodySelfShadowDotRangeMin;
        v60->m_bodySelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.bodySelfShadowDotRangeMax;
        v60->m_skinSelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.skinSelfShadowDotRangeMin;
        v60->m_skinSelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P1ShadowRangeData.skinSelfShadowDotRangeMax;
      }
      ++v58;
      ++v59;
    }
    while ( v58 < this->ModelRoomSettings.CharaInfo[2].iModelCount );
  }
  v62 = 0;
  if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
  {
    v63 = this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2;
    do
    {
      if ( *v63 )
      {
        v64 = *v63;
        v65 = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightMax;
        v64->m_rimLightMin = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightMin;
        v64->m_rimLightMax = v65;
        v64->m_rimLightStrength = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightStrength;
        v64->m_rimLightColour[0] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[0];
        v64->m_rimLightColour[1] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[1];
        v64->m_rimLightColour[2] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[2];
        v64->m_shaderEyeDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P2EmissionData.eyeEmissionStrength;
        v64->m_shaderLightDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P2EmissionData.charEmissionStrength;
        v64->m_bodySelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.bodySelfShadowDotRangeMin;
        v64->m_bodySelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.bodySelfShadowDotRangeMax;
        v64->m_skinSelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.skinSelfShadowDotRangeMin;
        v64->m_skinSelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.skinSelfShadowDotRangeMax;
      }
      ++v62;
      ++v63;
    }
    while ( v62 < this->ModelRoomSettings.CharaInfo[1].iModelCount );
  }
  v66 = 0;
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v67 = this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
    do
    {
      if ( *v67 )
      {
        v68 = *v67;
        v69 = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightMax;
        v68->m_rimLightMin = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightMin;
        v68->m_rimLightMax = v69;
        v68->m_rimLightStrength = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightStrength;
        v68->m_rimLightColour[0] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[0];
        v68->m_rimLightColour[1] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[1];
        v68->m_rimLightColour[2] = this->ModelRoomSettings.worldLightData.P2RimLightAssetData.rimLightColour[2];
        v68->m_shaderEyeDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P2EmissionData.eyeEmissionStrength;
        v68->m_shaderLightDiffuseEmiStrength = this->ModelRoomSettings.worldLightData.P2EmissionData.charEmissionStrength;
        v68->m_bodySelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.bodySelfShadowDotRangeMin;
        v68->m_bodySelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.bodySelfShadowDotRangeMax;
        v68->m_skinSelfShadowDotRangeMinMax[0] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.skinSelfShadowDotRangeMin;
        v68->m_skinSelfShadowDotRangeMinMax[1] = this->ModelRoomSettings.worldLightData.P2ShadowRangeData.skinSelfShadowDotRangeMax;
      }
      ++v66;
      ++v67;
    }
    while ( v66 < this->ModelRoomSettings.CharaInfo[3].iModelCount );
  }
  numP1Lights = this->ModelRoomSettings.worldLightData.numP1Lights;
  if ( numP1Lights <= 0 )
  {
    numCharLights = this->ModelRoomSettings.worldLightData.numCharLights;
    if ( numCharLights > 0 )
    {
      v126 = 0;
      v482 = 0;
      if ( *p_iModelCount <= 0 )
        goto LABEL_158;
      v127 = 0i64;
      while ( 1 )
      {
        v128 = 0;
        v472 = 0;
        if ( !v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v127]->m_ucMaterialCount )
          goto LABEL_157;
        v129 = v54->ModelRoomSettings.playerLightOn;
        v130 = 0i64;
        v491 = v54->ModelRoomSettings.playerLightOn;
        v131 = v54->ModelRoomSettings.numPlayerLights[0];
        v132 = &v54->ModelRoomPlayerLightSettings[0][0][0].direction[1];
        v133 = v54->ModelRoomSettings.playerLightId;
        do
        {
          v134 = 0;
          if ( numCharLights <= 0 )
            goto LABEL_155;
          HIDWORD(v453) = 1065353216;
          v135 = &v54->ModelRoomSettings.worldLightData.charLightAssetData[0].direction[1];
          v136 = v129;
          v137 = v133;
          v138 = v132;
          do
          {
            *(v138 - 1) = *(v135 - 1);
            *v138 = *v135;
            v138[1] = v135[1];
            *(v138 - 5) = v135[2];
            *(v138 - 4) = v135[3];
            *(v138 - 3) = v135[4];
            *(float *)&v453 = v135[5];
            *(_QWORD *)((char *)&v453 + 4) = *((_QWORD *)v135 + 3);
            *(_OWORD *)(v138 + 2) = v453;
            v138[8] = v135[8];
            *(v138 - 7) = *(v135 - 2);
            *((_BYTE *)v138 + 36) = *((_BYTE *)v135 + 52);
            v138[6] = v135[9];
            v138[7] = v135[10];
            *((_BYTE *)v138 + 37) = *((_BYTE *)v135 + 44);
            *((_BYTE *)v138 + 38) = *((_BYTE *)v135 + 45);
            *(v138 - 6) = v135[12];
            v139 = *(_DWORD *)v137;
            m_pLightManager = v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v127]->m_pMaterial[v130].m_pLightManager;
            if ( m_pLightManager->m_pLightNodeList )
            {
              m_pLightNodeList = m_pLightManager->m_pLightNodeList;
              if ( v139 == -1 )
                goto LABEL_141;
              if ( m_pLightNodeList )
              {
                while ( m_pLightNodeList->m_light.m_nId != v139 )
                {
                  m_pLightNodeList = m_pLightNodeList->next;
                  if ( !m_pLightNodeList )
                    goto LABEL_143;
                }
LABEL_141:
                if ( m_pLightNodeList->m_light.m_bOn != 1 )
                {
                  ++m_pLightManager->m_activeLightCount;
                  m_pLightNodeList->m_light.m_bOn = 1;
                }
              }
            }
LABEL_143:
            *(_BYTE *)v136 = 1;
            v142 = *(_DWORD *)v137;
            v143 = v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v127]->m_pMaterial[v130].m_pLightManager;
            if ( !v143->m_pLightNodeList )
              goto LABEL_148;
            v144 = v143->m_pLightNodeList;
            if ( v142 == -1 )
              goto LABEL_149;
            if ( v144 )
            {
              while ( v144->m_light.m_nId != v142 )
              {
                v144 = v144->next;
                if ( !v144 )
                  goto LABEL_148;
              }
            }
            else
            {
LABEL_148:
              v144 = 0i64;
            }
LABEL_149:
            v145 = v138[1];
            v146 = *v138;
            v144->m_light.m_fDirection[0] = *(v138 - 1);
            v144->m_light.m_fDirection[1] = v146;
            v144->m_light.m_fDirection[2] = v145;
            v147 = *(v138 - 4);
            v148 = *(v138 - 2);
            v149 = *(v138 - 3);
            v144->m_light.m_fPosition[0] = *(v138 - 5);
            v144->m_light.m_fPosition[1] = v147;
            v144->m_light.m_fPosition[2] = v149;
            v144->m_light.m_fPosition[3] = v148;
            v150 = *(v138 - 4);
            v151 = *(v138 - 3);
            v144->m_light.m_fLocalOffset[0] = *(v138 - 5);
            v144->m_light.m_fLocalOffset[1] = v150;
            v144->m_light.m_fLocalOffset[2] = v151;
            *(_OWORD *)v144->m_light.m_fDiffuse = *(_OWORD *)(v138 + 2);
            v144->m_light.m_fIntensity = v138[8];
            v152 = *((_DWORD *)v138 - 7);
            if ( v152 < 4 )
              v144->m_light.m_LightType = v152;
            v144->m_light.m_bCastsShadows = *((_BYTE *)v138 + 36);
            v144->m_light.m_fConeAngleRad = v138[6];
            v144->m_light.m_fPenumbraRad = v138[7];
            v144->m_light.m_bEmitSpecular = *((_BYTE *)v138 + 37);
            v144->m_light.m_bEmitDiffuse = *((_BYTE *)v138 + 38);
            v144->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v138 - 6);
            if ( !v127 )
              ++*v131;
            numCharLights = v54->ModelRoomSettings.worldLightData.numCharLights;
            ++v134;
            v137 = (int (*)[64][3])((char *)v137 + 4);
            v138 += 17;
            v135 += 41;
            v136 = (bool (*)[64][3])((char *)v136 + 1);
          }
          while ( v134 < numCharLights );
          v129 = v491;
          v128 = v472;
LABEL_155:
          ++v128;
          v491 = (bool (*)[64][3])((char *)v129 + 3);
          ++v130;
          v133 = (int (*)[64][3])((char *)v133 + 12);
          v132 += 51;
          v472 = v128;
          ++v131;
          v129 = (bool (*)[64][3])((char *)v129 + 3);
        }
        while ( v128 < v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v127]->m_ucMaterialCount );
        v126 = v482;
        v52 = &v54->ModelRoomSettings.CharaInfo[0].iModelCount;
LABEL_157:
        ++v126;
        ++v127;
        v482 = v126;
        if ( v126 >= *v52 )
        {
LABEL_158:
          v153 = 0;
          v483 = 0;
          if ( v54->ModelRoomSettings.CharaInfo[2].iModelCount <= 0 )
            goto LABEL_314;
          v154 = 0i64;
          while ( 1 )
          {
            v155 = 0;
            v473 = 0;
            if ( v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v154]->m_ucMaterialCount )
              break;
LABEL_186:
            ++v153;
            ++v154;
            v483 = v153;
            if ( v153 >= v54->ModelRoomSettings.CharaInfo[2].iModelCount )
              goto LABEL_314;
          }
          v156 = v54->ModelRoomSettings.playerLightOn[2];
          v157 = 0i64;
          v492 = v54->ModelRoomSettings.playerLightOn[2];
          v158 = v54->ModelRoomSettings.numPlayerLights[2];
          v159 = &v54->ModelRoomPlayerLightSettings[2][0][0].direction[1];
          v160 = v54->ModelRoomSettings.playerLightId[2];
          while ( 2 )
          {
            v161 = 0;
            if ( v54->ModelRoomSettings.worldLightData.numCharLights <= 0 )
              goto LABEL_184;
            HIDWORD(v454) = 1065353216;
            v162 = &v54->ModelRoomSettings.worldLightData.charLightAssetData[0].direction[1];
            v163 = v156;
            v164 = v160;
            v165 = v159;
LABEL_164:
            *(v165 - 1) = *(v162 - 1);
            *v165 = *v162;
            v165[1] = v162[1];
            *(v165 - 5) = v162[2];
            *(v165 - 4) = v162[3];
            *(v165 - 3) = v162[4];
            *(float *)&v454 = v162[5];
            *(_QWORD *)((char *)&v454 + 4) = *((_QWORD *)v162 + 3);
            *(_OWORD *)(v165 + 2) = v454;
            v165[8] = v162[8];
            *(v165 - 7) = *(v162 - 2);
            *((_BYTE *)v165 + 36) = *((_BYTE *)v162 + 52);
            v165[6] = v162[9];
            v165[7] = v162[10];
            *((_BYTE *)v165 + 37) = *((_BYTE *)v162 + 44);
            *((_BYTE *)v165 + 38) = *((_BYTE *)v162 + 45);
            *(v165 - 6) = v162[12];
            v166 = *(_DWORD *)v164;
            v167 = v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v154]->m_pMaterial[v157].m_pLightManager;
            if ( v167->m_pLightNodeList )
            {
              v168 = v167->m_pLightNodeList;
              if ( v166 == -1 )
                goto LABEL_170;
              if ( v168 )
              {
                while ( v168->m_light.m_nId != v166 )
                {
                  v168 = v168->next;
                  if ( !v168 )
                    goto LABEL_172;
                }
LABEL_170:
                if ( v168->m_light.m_bOn != 1 )
                {
                  ++v167->m_activeLightCount;
                  v168->m_light.m_bOn = 1;
                }
              }
            }
LABEL_172:
            *(_BYTE *)v163 = 1;
            v169 = *(_DWORD *)v164;
            v170 = v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v154]->m_pMaterial[v157].m_pLightManager;
            if ( !v170->m_pLightNodeList )
              goto LABEL_177;
            v171 = v170->m_pLightNodeList;
            if ( v169 == -1 )
              goto LABEL_178;
            if ( v171 )
            {
              while ( v171->m_light.m_nId != v169 )
              {
                v171 = v171->next;
                if ( !v171 )
                  goto LABEL_177;
              }
            }
            else
            {
LABEL_177:
              v171 = 0i64;
            }
LABEL_178:
            v172 = v165[1];
            v173 = *v165;
            v171->m_light.m_fDirection[0] = *(v165 - 1);
            v171->m_light.m_fDirection[1] = v173;
            v171->m_light.m_fDirection[2] = v172;
            v174 = *(v165 - 4);
            v175 = *(v165 - 2);
            v176 = *(v165 - 3);
            v171->m_light.m_fPosition[0] = *(v165 - 5);
            v171->m_light.m_fPosition[1] = v174;
            v171->m_light.m_fPosition[2] = v176;
            v171->m_light.m_fPosition[3] = v175;
            v177 = *(v165 - 4);
            v178 = *(v165 - 3);
            v171->m_light.m_fLocalOffset[0] = *(v165 - 5);
            v171->m_light.m_fLocalOffset[1] = v177;
            v171->m_light.m_fLocalOffset[2] = v178;
            *(_OWORD *)v171->m_light.m_fDiffuse = *(_OWORD *)(v165 + 2);
            v171->m_light.m_fIntensity = v165[8];
            v179 = *((_DWORD *)v165 - 7);
            if ( v179 < 4 )
              v171->m_light.m_LightType = v179;
            v171->m_light.m_bCastsShadows = *((_BYTE *)v165 + 36);
            v171->m_light.m_fConeAngleRad = v165[6];
            v171->m_light.m_fPenumbraRad = v165[7];
            v171->m_light.m_bEmitSpecular = *((_BYTE *)v165 + 37);
            v171->m_light.m_bEmitDiffuse = *((_BYTE *)v165 + 38);
            v171->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v165 - 6);
            if ( !v154 )
              ++*v158;
            ++v161;
            v164 = (int (*)[3])((char *)v164 + 4);
            v165 += 17;
            v162 += 41;
            v163 = (bool (*)[3])((char *)v163 + 1);
            if ( v161 >= v54->ModelRoomSettings.worldLightData.numCharLights )
            {
              v156 = v492;
              v155 = v473;
LABEL_184:
              ++v155;
              v492 = v156 + 1;
              ++v157;
              ++v160;
              v159 += 51;
              v473 = v155;
              ++v158;
              ++v156;
              if ( v155 >= v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v154]->m_ucMaterialCount )
              {
                v153 = v483;
                goto LABEL_186;
              }
              continue;
            }
            goto LABEL_164;
          }
        }
      }
    }
    v180 = 0;
    if ( *p_iModelCount > 0 )
    {
      v181 = 0i64;
      while ( 1 )
      {
        v182 = 0;
        if ( this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_ucMaterialCount )
          break;
LABEL_250:
        ++v180;
        ++v181;
        if ( v180 >= *p_iModelCount )
          goto LABEL_251;
      }
      v183 = 0i64;
      v184 = this->ModelRoomSettings.numPlayerLights;
      v185 = 0i64;
      while ( 1 )
      {
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[0] = -3.4300001;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[1] = 11.81;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[2] = 8.6899996;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[3] = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[0] = -0.153;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[1] = -0.245;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[2] = -0.95700002;
        *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour = _xmm;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad = 1.5707999;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad = 0.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type = 1;
        v186 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
        if ( !v186 )
          goto LABEL_211;
        v187 = this->ModelRoomSettings.playerLightId[0][v183][*(_DWORD *)v184];
        if ( v186->m_pLightNodeList )
        {
          v188 = v186->m_pLightNodeList;
          if ( v187 != -1 )
          {
            if ( !v188 )
              goto LABEL_201;
            while ( v188->m_light.m_nId != v187 )
            {
              v188 = v188->next;
              if ( !v188 )
                goto LABEL_201;
            }
          }
          if ( v188->m_light.m_bOn != 1 )
          {
            ++v186->m_activeLightCount;
            v188->m_light.m_bOn = 1;
          }
        }
LABEL_201:
        this->ModelRoomSettings.playerLightOn[0][v183][*(_DWORD *)v184] = 1;
        v189 = v183 * 3 + *(_DWORD *)v184;
        v190 = this->ModelRoomSettings.playerLightId[0][0][v189];
        v191 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
        if ( !v191->m_pLightNodeList )
          goto LABEL_206;
        v192 = v191->m_pLightNodeList;
        if ( v190 != -1 )
        {
          if ( v192 )
          {
            while ( v192->m_light.m_nId != v190 )
            {
              v192 = v192->next;
              if ( !v192 )
                goto LABEL_206;
            }
            goto LABEL_207;
          }
LABEL_206:
          v192 = 0i64;
        }
LABEL_207:
        v193 = this->ModelRoomPlayerLightSettings[0][0][v189].direction[2];
        v194 = this->ModelRoomPlayerLightSettings[0][0][v189].direction[1];
        v192->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[0][0][v189].direction[0];
        v192->m_light.m_fDirection[1] = v194;
        v192->m_light.m_fDirection[2] = v193;
        v195 = v183 * 3 + *(_DWORD *)v184;
        v196 = this->ModelRoomPlayerLightSettings[0][0][v195].position[2];
        v197 = this->ModelRoomPlayerLightSettings[0][0][v195].position[1];
        v198 = this->ModelRoomPlayerLightSettings[0][0][v195].position[3];
        v192->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[0][0][v195].position[0];
        v192->m_light.m_fPosition[1] = v197;
        v192->m_light.m_fPosition[2] = v196;
        v192->m_light.m_fPosition[3] = v198;
        v199 = v183 * 3 + *(_DWORD *)v184;
        v200 = this->ModelRoomPlayerLightSettings[0][0][v199].position[1];
        v201 = this->ModelRoomPlayerLightSettings[0][0][v199].position[2];
        v192->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[0][0][v199].position[0];
        v192->m_light.m_fLocalOffset[1] = v200;
        v192->m_light.m_fLocalOffset[2] = v201;
        *(_OWORD *)v192->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour;
        v192->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows;
        v192->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad;
        v192->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad;
        v192->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity;
        v192->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular;
        v192->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse;
        v192->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate;
        type = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type;
        if ( type < 4 )
          v192->m_light.m_LightType = type;
        if ( !v181 )
          ++*(_DWORD *)v184;
LABEL_211:
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[0] = -11.62;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[1] = 4.4699998;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[2] = 7.25;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[3] = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[0] = -0.050999999;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[1] = 0.889;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[2] = -0.456;
        *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour = _xmm;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad = 1.5707999;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad = 0.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type = 1;
        v203 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
        if ( !v203 )
          goto LABEL_230;
        v204 = this->ModelRoomSettings.playerLightId[0][v183][*(_DWORD *)v184];
        if ( v203->m_pLightNodeList )
        {
          v205 = v203->m_pLightNodeList;
          if ( v204 != -1 )
          {
            if ( !v205 )
              goto LABEL_220;
            while ( v205->m_light.m_nId != v204 )
            {
              v205 = v205->next;
              if ( !v205 )
                goto LABEL_220;
            }
          }
          if ( v205->m_light.m_bOn != 1 )
          {
            ++v203->m_activeLightCount;
            v205->m_light.m_bOn = 1;
          }
        }
LABEL_220:
        this->ModelRoomSettings.playerLightOn[0][v183][*(_DWORD *)v184] = 1;
        v206 = v183 * 3 + *(_DWORD *)v184;
        v207 = this->ModelRoomSettings.playerLightId[0][0][v206];
        v208 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
        if ( !v208->m_pLightNodeList )
          goto LABEL_225;
        v209 = v208->m_pLightNodeList;
        if ( v207 != -1 )
        {
          if ( v209 )
          {
            while ( v209->m_light.m_nId != v207 )
            {
              v209 = v209->next;
              if ( !v209 )
                goto LABEL_225;
            }
            goto LABEL_226;
          }
LABEL_225:
          v209 = 0i64;
        }
LABEL_226:
        v210 = this->ModelRoomPlayerLightSettings[0][0][v206].direction[2];
        v211 = this->ModelRoomPlayerLightSettings[0][0][v206].direction[1];
        v209->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[0][0][v206].direction[0];
        v209->m_light.m_fDirection[1] = v211;
        v209->m_light.m_fDirection[2] = v210;
        v212 = v183 * 3 + *(_DWORD *)v184;
        v213 = this->ModelRoomPlayerLightSettings[0][0][v212].position[2];
        v214 = this->ModelRoomPlayerLightSettings[0][0][v212].position[1];
        v215 = this->ModelRoomPlayerLightSettings[0][0][v212].position[3];
        v209->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[0][0][v212].position[0];
        v209->m_light.m_fPosition[1] = v214;
        v209->m_light.m_fPosition[2] = v213;
        v209->m_light.m_fPosition[3] = v215;
        v216 = v183 * 3 + *(_DWORD *)v184;
        v217 = this->ModelRoomPlayerLightSettings[0][0][v216].position[1];
        v218 = this->ModelRoomPlayerLightSettings[0][0][v216].position[2];
        v209->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[0][0][v216].position[0];
        v209->m_light.m_fLocalOffset[1] = v217;
        v209->m_light.m_fLocalOffset[2] = v218;
        *(_OWORD *)v209->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour;
        v209->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows;
        v209->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad;
        v209->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad;
        v209->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity;
        v209->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular;
        v209->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse;
        v209->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate;
        v219 = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type;
        if ( v219 < 4 )
          v209->m_light.m_LightType = v219;
        if ( !v181 )
          ++*(_DWORD *)v184;
LABEL_230:
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[0] = -7.5;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[1] = 11.55;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[2] = 6.9200001;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].position[3] = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[0] = 0.0070000002;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[1] = -0.66100001;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].direction[2] = 0.75099999;
        *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour = _xmm;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad = 1.5707999;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad = 0.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity = 1.0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse = 1;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate = 0;
        this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type = 1;
        v220 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
        if ( v220 )
        {
          v221 = this->ModelRoomSettings.playerLightId[0][v183][*(_DWORD *)v184];
          if ( v220->m_pLightNodeList )
          {
            v222 = v220->m_pLightNodeList;
            if ( v221 == -1 )
              goto LABEL_237;
            if ( v222 )
            {
              while ( v222->m_light.m_nId != v221 )
              {
                v222 = v222->next;
                if ( !v222 )
                  goto LABEL_239;
              }
LABEL_237:
              if ( v222->m_light.m_bOn != 1 )
              {
                ++v220->m_activeLightCount;
                v222->m_light.m_bOn = 1;
              }
            }
          }
LABEL_239:
          this->ModelRoomSettings.playerLightOn[0][v183][*(_DWORD *)v184] = 1;
          v223 = v183 * 3 + *(_DWORD *)v184;
          v224 = this->ModelRoomSettings.playerLightId[0][0][v223];
          v225 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_pMaterial[v185].m_pLightManager;
          if ( !v225->m_pLightNodeList )
            goto LABEL_244;
          v226 = v225->m_pLightNodeList;
          if ( v224 != -1 )
          {
            if ( v226 )
            {
              while ( v226->m_light.m_nId != v224 )
              {
                v226 = v226->next;
                if ( !v226 )
                  goto LABEL_244;
              }
              goto LABEL_245;
            }
LABEL_244:
            v226 = 0i64;
          }
LABEL_245:
          v227 = this->ModelRoomPlayerLightSettings[0][0][v223].direction[2];
          v228 = this->ModelRoomPlayerLightSettings[0][0][v223].direction[1];
          v226->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[0][0][v223].direction[0];
          v226->m_light.m_fDirection[1] = v228;
          v226->m_light.m_fDirection[2] = v227;
          v229 = v183 * 3 + *(_DWORD *)v184;
          v230 = this->ModelRoomPlayerLightSettings[0][0][v229].position[2];
          v231 = this->ModelRoomPlayerLightSettings[0][0][v229].position[1];
          v232 = this->ModelRoomPlayerLightSettings[0][0][v229].position[3];
          v226->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[0][0][v229].position[0];
          v226->m_light.m_fPosition[1] = v231;
          v226->m_light.m_fPosition[2] = v230;
          v226->m_light.m_fPosition[3] = v232;
          v233 = v183 * 3 + *(_DWORD *)v184;
          v234 = this->ModelRoomPlayerLightSettings[0][0][v233].position[1];
          v235 = this->ModelRoomPlayerLightSettings[0][0][v233].position[2];
          v226->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[0][0][v233].position[0];
          v226->m_light.m_fLocalOffset[1] = v234;
          v226->m_light.m_fLocalOffset[2] = v235;
          *(_OWORD *)v226->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].colour;
          v226->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].castsShadows;
          v226->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].coneAngleRad;
          v226->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].penumbraRad;
          v226->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].intensity;
          v226->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitSpecular;
          v226->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].emitDiffuse;
          v226->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].decayRate;
          v236 = this->ModelRoomPlayerLightSettings[0][v183][*(_DWORD *)v184].type;
          if ( v236 < 4 )
            v226->m_light.m_LightType = v236;
          if ( !v181 )
            ++*(_DWORD *)v184;
        }
        ++v182;
        v184 = (int (*)[64])((char *)v184 + 4);
        ++v185;
        ++v183;
        if ( v182 >= this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v181]->m_ucMaterialCount )
          goto LABEL_250;
      }
    }
LABEL_251:
    v237 = 0;
    if ( this->ModelRoomSettings.CharaInfo[2].iModelCount <= 0 )
      goto LABEL_314;
    v238 = 0i64;
    while ( 1 )
    {
      v239 = 0;
      if ( this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_ucMaterialCount )
        break;
LABEL_313:
      ++v237;
      ++v238;
      if ( v237 >= this->ModelRoomSettings.CharaInfo[2].iModelCount )
        goto LABEL_314;
    }
    v240 = 0i64;
    v241 = this->ModelRoomSettings.numPlayerLights[2];
    v242 = 0i64;
    while ( 1 )
    {
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[0] = -3.4300001;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[1] = 11.81;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[2] = 8.6899996;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[3] = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[0] = -0.153;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[1] = -0.245;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[2] = -0.95700002;
      *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour = _xmm;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad = 1.5707999;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad = 0.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].type = 1;
      v243 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
      if ( !v243 )
        goto LABEL_274;
      v244 = this->ModelRoomSettings.playerLightId[2][v240][*v241];
      if ( v243->m_pLightNodeList )
      {
        v245 = v243->m_pLightNodeList;
        if ( v244 != -1 )
        {
          if ( !v245 )
            goto LABEL_264;
          while ( v245->m_light.m_nId != v244 )
          {
            v245 = v245->next;
            if ( !v245 )
              goto LABEL_264;
          }
        }
        if ( v245->m_light.m_bOn != 1 )
        {
          ++v243->m_activeLightCount;
          v245->m_light.m_bOn = 1;
        }
      }
LABEL_264:
      this->ModelRoomSettings.playerLightOn[2][v240][*v241] = 1;
      v246 = v240 * 3 + *v241;
      v247 = this->ModelRoomSettings.playerLightId[2][0][v246];
      v248 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
      if ( !v248->m_pLightNodeList )
        goto LABEL_269;
      v249 = v248->m_pLightNodeList;
      if ( v247 != -1 )
      {
        if ( v249 )
        {
          while ( v249->m_light.m_nId != v247 )
          {
            v249 = v249->next;
            if ( !v249 )
              goto LABEL_269;
          }
          goto LABEL_270;
        }
LABEL_269:
        v249 = 0i64;
      }
LABEL_270:
      v250 = this->ModelRoomPlayerLightSettings[2][0][v246].direction[2];
      v251 = this->ModelRoomPlayerLightSettings[2][0][v246].direction[1];
      v249->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[2][0][v246].direction[0];
      v249->m_light.m_fDirection[1] = v251;
      v249->m_light.m_fDirection[2] = v250;
      v252 = v240 * 3 + *v241;
      v253 = this->ModelRoomPlayerLightSettings[2][0][v252].position[2];
      v254 = this->ModelRoomPlayerLightSettings[2][0][v252].position[1];
      v255 = this->ModelRoomPlayerLightSettings[2][0][v252].position[3];
      v249->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[2][0][v252].position[0];
      v249->m_light.m_fPosition[1] = v254;
      v249->m_light.m_fPosition[2] = v253;
      v249->m_light.m_fPosition[3] = v255;
      v256 = v240 * 3 + *v241;
      v257 = this->ModelRoomPlayerLightSettings[2][0][v256].position[1];
      v258 = this->ModelRoomPlayerLightSettings[2][0][v256].position[2];
      v249->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[2][0][v256].position[0];
      v249->m_light.m_fLocalOffset[1] = v257;
      v249->m_light.m_fLocalOffset[2] = v258;
      *(_OWORD *)v249->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour;
      v249->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows;
      v249->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad;
      v249->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad;
      v249->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity;
      v249->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular;
      v249->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse;
      v249->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate;
      v259 = this->ModelRoomPlayerLightSettings[2][v240][*v241].type;
      if ( v259 < 4 )
        v249->m_light.m_LightType = v259;
      if ( !v238 )
        ++*v241;
LABEL_274:
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[0] = -11.62;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[1] = 4.4699998;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[2] = 7.25;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[3] = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[0] = -0.050999999;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[1] = 0.889;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[2] = -0.456;
      *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour = _xmm;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad = 0.78539801;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad = 0.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].type = 1;
      v260 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
      if ( !v260 )
        goto LABEL_293;
      v261 = this->ModelRoomSettings.playerLightId[2][v240][*v241];
      if ( v260->m_pLightNodeList )
      {
        v262 = v260->m_pLightNodeList;
        if ( v261 != -1 )
        {
          if ( !v262 )
            goto LABEL_283;
          while ( v262->m_light.m_nId != v261 )
          {
            v262 = v262->next;
            if ( !v262 )
              goto LABEL_283;
          }
        }
        if ( v262->m_light.m_bOn != 1 )
        {
          ++v260->m_activeLightCount;
          v262->m_light.m_bOn = 1;
        }
      }
LABEL_283:
      this->ModelRoomSettings.playerLightOn[2][v240][*v241] = 1;
      v263 = v240 * 3 + *v241;
      v264 = this->ModelRoomSettings.playerLightId[2][0][v263];
      v265 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
      if ( !v265->m_pLightNodeList )
        goto LABEL_288;
      v266 = v265->m_pLightNodeList;
      if ( v264 != -1 )
      {
        if ( v266 )
        {
          while ( v266->m_light.m_nId != v264 )
          {
            v266 = v266->next;
            if ( !v266 )
              goto LABEL_288;
          }
          goto LABEL_289;
        }
LABEL_288:
        v266 = 0i64;
      }
LABEL_289:
      v267 = this->ModelRoomPlayerLightSettings[2][0][v263].direction[2];
      v268 = this->ModelRoomPlayerLightSettings[2][0][v263].direction[1];
      v266->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[2][0][v263].direction[0];
      v266->m_light.m_fDirection[1] = v268;
      v266->m_light.m_fDirection[2] = v267;
      v269 = v240 * 3 + *v241;
      v270 = this->ModelRoomPlayerLightSettings[2][0][v269].position[2];
      v271 = this->ModelRoomPlayerLightSettings[2][0][v269].position[1];
      v272 = this->ModelRoomPlayerLightSettings[2][0][v269].position[3];
      v266->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[2][0][v269].position[0];
      v266->m_light.m_fPosition[1] = v271;
      v266->m_light.m_fPosition[2] = v270;
      v266->m_light.m_fPosition[3] = v272;
      v273 = v240 * 3 + *v241;
      v274 = this->ModelRoomPlayerLightSettings[2][0][v273].position[1];
      v275 = this->ModelRoomPlayerLightSettings[2][0][v273].position[2];
      v266->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[2][0][v273].position[0];
      v266->m_light.m_fLocalOffset[1] = v274;
      v266->m_light.m_fLocalOffset[2] = v275;
      *(_OWORD *)v266->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour;
      v266->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows;
      v266->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad;
      v266->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad;
      v266->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity;
      v266->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular;
      v266->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse;
      v266->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate;
      v276 = this->ModelRoomPlayerLightSettings[2][v240][*v241].type;
      if ( v276 < 4 )
        v266->m_light.m_LightType = v276;
      if ( !v238 )
        ++*v241;
LABEL_293:
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[0] = -7.5;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[1] = 11.55;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[2] = 6.9200001;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].position[3] = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[0] = 0.0070000002;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[1] = -0.66100001;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].direction[2] = 0.75099999;
      *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour = _xmm;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad = 0.78539801;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad = 0.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity = 1.0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse = 1;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate = 0;
      this->ModelRoomPlayerLightSettings[2][v240][*v241].type = 1;
      v277 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
      if ( v277 )
      {
        v278 = this->ModelRoomSettings.playerLightId[2][v240][*v241];
        if ( v277->m_pLightNodeList )
        {
          v279 = v277->m_pLightNodeList;
          if ( v278 == -1 )
            goto LABEL_300;
          if ( v279 )
          {
            while ( v279->m_light.m_nId != v278 )
            {
              v279 = v279->next;
              if ( !v279 )
                goto LABEL_302;
            }
LABEL_300:
            if ( v279->m_light.m_bOn != 1 )
            {
              ++v277->m_activeLightCount;
              v279->m_light.m_bOn = 1;
            }
          }
        }
LABEL_302:
        this->ModelRoomSettings.playerLightOn[2][v240][*v241] = 1;
        v280 = v240 * 3 + *v241;
        v281 = this->ModelRoomSettings.playerLightId[2][0][v280];
        v282 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_pMaterial[v242].m_pLightManager;
        if ( !v282->m_pLightNodeList )
          goto LABEL_307;
        v283 = v282->m_pLightNodeList;
        if ( v281 != -1 )
        {
          if ( v283 )
          {
            while ( v283->m_light.m_nId != v281 )
            {
              v283 = v283->next;
              if ( !v283 )
                goto LABEL_307;
            }
            goto LABEL_308;
          }
LABEL_307:
          v283 = 0i64;
        }
LABEL_308:
        v284 = this->ModelRoomPlayerLightSettings[2][0][v280].direction[2];
        v285 = this->ModelRoomPlayerLightSettings[2][0][v280].direction[1];
        v283->m_light.m_fDirection[0] = this->ModelRoomPlayerLightSettings[2][0][v280].direction[0];
        v283->m_light.m_fDirection[1] = v285;
        v283->m_light.m_fDirection[2] = v284;
        v286 = v240 * 3 + *v241;
        v287 = this->ModelRoomPlayerLightSettings[2][0][v286].position[2];
        v288 = this->ModelRoomPlayerLightSettings[2][0][v286].position[1];
        v289 = this->ModelRoomPlayerLightSettings[2][0][v286].position[3];
        v283->m_light.m_fPosition[0] = this->ModelRoomPlayerLightSettings[2][0][v286].position[0];
        v283->m_light.m_fPosition[1] = v288;
        v283->m_light.m_fPosition[2] = v287;
        v283->m_light.m_fPosition[3] = v289;
        v290 = v240 * 3 + *v241;
        v291 = this->ModelRoomPlayerLightSettings[2][0][v290].position[1];
        v292 = this->ModelRoomPlayerLightSettings[2][0][v290].position[2];
        v283->m_light.m_fLocalOffset[0] = this->ModelRoomPlayerLightSettings[2][0][v290].position[0];
        v283->m_light.m_fLocalOffset[1] = v291;
        v283->m_light.m_fLocalOffset[2] = v292;
        *(_OWORD *)v283->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomPlayerLightSettings[2][v240][*v241].colour;
        v283->m_light.m_bCastsShadows = this->ModelRoomPlayerLightSettings[2][v240][*v241].castsShadows;
        v283->m_light.m_fConeAngleRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].coneAngleRad;
        v283->m_light.m_fPenumbraRad = this->ModelRoomPlayerLightSettings[2][v240][*v241].penumbraRad;
        v283->m_light.m_fIntensity = this->ModelRoomPlayerLightSettings[2][v240][*v241].intensity;
        v283->m_light.m_bEmitSpecular = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitSpecular;
        v283->m_light.m_bEmitDiffuse = this->ModelRoomPlayerLightSettings[2][v240][*v241].emitDiffuse;
        v283->m_light.m_DecayRate = this->ModelRoomPlayerLightSettings[2][v240][*v241].decayRate;
        v293 = this->ModelRoomPlayerLightSettings[2][v240][*v241].type;
        if ( v293 < 4 )
          v283->m_light.m_LightType = v293;
        if ( !v238 )
          ++*v241;
      }
      ++v239;
      ++v241;
      ++v242;
      ++v240;
      if ( v239 >= this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v238]->m_ucMaterialCount )
        goto LABEL_313;
    }
  }
  v71 = 0;
  v480 = 0;
  if ( *p_iModelCount <= 0 )
    goto LABEL_98;
  v72 = 0i64;
  while ( 2 )
  {
    v73 = 0;
    v470 = 0;
    if ( !v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v72]->m_ucMaterialCount )
      goto LABEL_97;
    v74 = v54->ModelRoomSettings.playerLightOn;
    v75 = 0i64;
    v489 = v54->ModelRoomSettings.playerLightOn;
    v76 = v54->ModelRoomSettings.numPlayerLights[0];
    v77 = &v54->ModelRoomPlayerLightSettings[0][0][0].direction[1];
    v78 = v54->ModelRoomSettings.playerLightId;
    while ( 2 )
    {
      v79 = 0;
      if ( numP1Lights <= 0 )
        goto LABEL_95;
      HIDWORD(v451) = 1065353216;
      v80 = &v54->ModelRoomSettings.worldLightData.P1LightAssetData[0].direction[1];
      v81 = v74;
      v82 = v78;
      v83 = v77;
      while ( 2 )
      {
        *(v83 - 1) = *(v80 - 1);
        *v83 = *v80;
        v83[1] = v80[1];
        *(v83 - 5) = v80[2];
        *(v83 - 4) = v80[3];
        *(v83 - 3) = v80[4];
        *(float *)&v451 = v80[5];
        *(_QWORD *)((char *)&v451 + 4) = *((_QWORD *)v80 + 3);
        *(_OWORD *)(v83 + 2) = v451;
        v83[8] = v80[8];
        *(v83 - 7) = *(v80 - 2);
        *((_BYTE *)v83 + 36) = *((_BYTE *)v80 + 52);
        *((_BYTE *)v83 + 37) = *((_BYTE *)v80 + 44);
        *((_BYTE *)v83 + 38) = *((_BYTE *)v80 + 45);
        *(v83 - 6) = v80[12];
        v83[6] = v80[9];
        v83[7] = v80[10];
        v84 = *(_DWORD *)v82;
        v85 = v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v72]->m_pMaterial[v75].m_pLightManager;
        if ( v85->m_pLightNodeList )
        {
          v86 = v85->m_pLightNodeList;
          if ( v84 == -1 )
            goto LABEL_81;
          if ( v86 )
          {
            while ( v86->m_light.m_nId != v84 )
            {
              v86 = v86->next;
              if ( !v86 )
                goto LABEL_83;
            }
LABEL_81:
            if ( v86->m_light.m_bOn != 1 )
            {
              ++v85->m_activeLightCount;
              v86->m_light.m_bOn = 1;
            }
          }
        }
LABEL_83:
        *(_BYTE *)v81 = 1;
        v87 = *(_DWORD *)v82;
        v88 = v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v72]->m_pMaterial[v75].m_pLightManager;
        if ( !v88->m_pLightNodeList )
          goto LABEL_88;
        v89 = v88->m_pLightNodeList;
        if ( v87 == -1 )
          goto LABEL_89;
        if ( v89 )
        {
          while ( v89->m_light.m_nId != v87 )
          {
            v89 = v89->next;
            if ( !v89 )
              goto LABEL_88;
          }
        }
        else
        {
LABEL_88:
          v89 = 0i64;
        }
LABEL_89:
        v90 = v83[1];
        v91 = *v83;
        v89->m_light.m_fDirection[0] = *(v83 - 1);
        v89->m_light.m_fDirection[1] = v91;
        v89->m_light.m_fDirection[2] = v90;
        v92 = *(v83 - 4);
        v93 = *(v83 - 2);
        v94 = *(v83 - 3);
        v89->m_light.m_fPosition[0] = *(v83 - 5);
        v89->m_light.m_fPosition[1] = v92;
        v89->m_light.m_fPosition[2] = v94;
        v89->m_light.m_fPosition[3] = v93;
        v95 = *(v83 - 4);
        v96 = *(v83 - 3);
        v89->m_light.m_fLocalOffset[0] = *(v83 - 5);
        v89->m_light.m_fLocalOffset[1] = v95;
        v89->m_light.m_fLocalOffset[2] = v96;
        *(_OWORD *)v89->m_light.m_fDiffuse = *(_OWORD *)(v83 + 2);
        v89->m_light.m_fIntensity = v83[8];
        v97 = *((_DWORD *)v83 - 7);
        if ( v97 < 4 )
          v89->m_light.m_LightType = v97;
        v89->m_light.m_bCastsShadows = *((_BYTE *)v83 + 36);
        v89->m_light.m_fConeAngleRad = v83[6];
        v89->m_light.m_fPenumbraRad = v83[7];
        v89->m_light.m_bEmitSpecular = *((_BYTE *)v83 + 37);
        v89->m_light.m_bEmitDiffuse = *((_BYTE *)v83 + 38);
        v89->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v83 - 6);
        if ( !v72 )
          ++*v76;
        numP1Lights = v54->ModelRoomSettings.worldLightData.numP1Lights;
        ++v79;
        v82 = (int (*)[64][3])((char *)v82 + 4);
        v83 += 17;
        v80 += 41;
        v81 = (bool (*)[64][3])((char *)v81 + 1);
        if ( v79 < numP1Lights )
          continue;
        break;
      }
      v74 = v489;
      v73 = v470;
LABEL_95:
      ++v73;
      v489 = (bool (*)[64][3])((char *)v74 + 3);
      ++v75;
      v78 = (int (*)[64][3])((char *)v78 + 12);
      v77 += 51;
      v470 = v73;
      ++v76;
      v74 = (bool (*)[64][3])((char *)v74 + 3);
      if ( v73 < v54->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v72]->m_ucMaterialCount )
        continue;
      break;
    }
    v71 = v480;
    v52 = &v54->ModelRoomSettings.CharaInfo[0].iModelCount;
LABEL_97:
    ++v71;
    ++v72;
    v480 = v71;
    if ( v71 < *v52 )
      continue;
    break;
  }
LABEL_98:
  v98 = 0;
  v481 = 0;
  if ( v54->ModelRoomSettings.CharaInfo[2].iModelCount <= 0 )
    goto LABEL_314;
  v99 = 0i64;
  while ( 2 )
  {
    v100 = 0;
    v471 = 0;
    if ( !v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v99]->m_ucMaterialCount )
      goto LABEL_126;
    v101 = v54->ModelRoomSettings.playerLightOn[2];
    v102 = 0i64;
    v490 = v54->ModelRoomSettings.playerLightOn[2];
    v103 = v54->ModelRoomSettings.numPlayerLights[2];
    v104 = &v54->ModelRoomPlayerLightSettings[2][0][0].direction[1];
    v105 = v54->ModelRoomSettings.playerLightId[2];
    while ( 2 )
    {
      v106 = 0;
      if ( v54->ModelRoomSettings.worldLightData.numP1Lights <= 0 )
        goto LABEL_124;
      HIDWORD(v452) = 1065353216;
      v107 = &v54->ModelRoomSettings.worldLightData.P1LightAssetData[0].direction[1];
      v108 = v101;
      v109 = v105;
      v110 = v104;
      while ( 2 )
      {
        *(v110 - 1) = *(v107 - 1);
        *v110 = *v107;
        v110[1] = v107[1];
        *(v110 - 5) = v107[2];
        *(v110 - 4) = v107[3];
        *(v110 - 3) = v107[4];
        *(float *)&v452 = v107[5];
        *(_QWORD *)((char *)&v452 + 4) = *((_QWORD *)v107 + 3);
        *(_OWORD *)(v110 + 2) = v452;
        v110[8] = v107[8];
        *(v110 - 7) = *(v107 - 2);
        *((_BYTE *)v110 + 36) = *((_BYTE *)v107 + 52);
        v110[6] = v107[9];
        v110[7] = v107[10];
        *((_BYTE *)v110 + 37) = *((_BYTE *)v107 + 44);
        *((_BYTE *)v110 + 38) = *((_BYTE *)v107 + 45);
        *(v110 - 6) = v107[12];
        v111 = *(_DWORD *)v109;
        v112 = v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v99]->m_pMaterial[v102].m_pLightManager;
        if ( v112->m_pLightNodeList )
        {
          v113 = v112->m_pLightNodeList;
          if ( v111 == -1 )
            goto LABEL_110;
          if ( v113 )
          {
            while ( v113->m_light.m_nId != v111 )
            {
              v113 = v113->next;
              if ( !v113 )
                goto LABEL_112;
            }
LABEL_110:
            if ( v113->m_light.m_bOn != 1 )
            {
              ++v112->m_activeLightCount;
              v113->m_light.m_bOn = 1;
            }
          }
        }
LABEL_112:
        *(_BYTE *)v108 = 1;
        v114 = *(_DWORD *)v109;
        v115 = v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v99]->m_pMaterial[v102].m_pLightManager;
        if ( !v115->m_pLightNodeList )
          goto LABEL_117;
        v116 = v115->m_pLightNodeList;
        if ( v114 == -1 )
          goto LABEL_118;
        if ( v116 )
        {
          while ( v116->m_light.m_nId != v114 )
          {
            v116 = v116->next;
            if ( !v116 )
              goto LABEL_117;
          }
        }
        else
        {
LABEL_117:
          v116 = 0i64;
        }
LABEL_118:
        v117 = v110[1];
        v118 = *v110;
        v116->m_light.m_fDirection[0] = *(v110 - 1);
        v116->m_light.m_fDirection[1] = v118;
        v116->m_light.m_fDirection[2] = v117;
        v119 = *(v110 - 4);
        v120 = *(v110 - 2);
        v121 = *(v110 - 3);
        v116->m_light.m_fPosition[0] = *(v110 - 5);
        v116->m_light.m_fPosition[1] = v119;
        v116->m_light.m_fPosition[2] = v121;
        v116->m_light.m_fPosition[3] = v120;
        v122 = *(v110 - 4);
        v123 = *(v110 - 3);
        v116->m_light.m_fLocalOffset[0] = *(v110 - 5);
        v116->m_light.m_fLocalOffset[1] = v122;
        v116->m_light.m_fLocalOffset[2] = v123;
        *(_OWORD *)v116->m_light.m_fDiffuse = *(_OWORD *)(v110 + 2);
        v116->m_light.m_fIntensity = v110[8];
        v124 = *((_DWORD *)v110 - 7);
        if ( v124 < 4 )
          v116->m_light.m_LightType = v124;
        v116->m_light.m_bCastsShadows = *((_BYTE *)v110 + 36);
        v116->m_light.m_fConeAngleRad = v110[6];
        v116->m_light.m_fPenumbraRad = v110[7];
        v116->m_light.m_bEmitSpecular = *((_BYTE *)v110 + 37);
        v116->m_light.m_bEmitDiffuse = *((_BYTE *)v110 + 38);
        v116->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v110 - 6);
        if ( !v99 )
          ++*v103;
        ++v106;
        v109 = (int (*)[3])((char *)v109 + 4);
        v110 += 17;
        v107 += 41;
        v108 = (bool (*)[3])((char *)v108 + 1);
        if ( v106 < v54->ModelRoomSettings.worldLightData.numP1Lights )
          continue;
        break;
      }
      v101 = v490;
      v100 = v471;
LABEL_124:
      ++v100;
      v490 = v101 + 1;
      ++v102;
      ++v105;
      v104 += 51;
      v471 = v100;
      ++v103;
      ++v101;
      if ( v100 < v54->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v99]->m_ucMaterialCount )
        continue;
      break;
    }
    v98 = v481;
LABEL_126:
    ++v98;
    ++v99;
    v481 = v98;
    if ( v98 < v54->ModelRoomSettings.CharaInfo[2].iModelCount )
      continue;
    break;
  }
LABEL_314:
  numP2Lights = v54->ModelRoomSettings.worldLightData.numP2Lights;
  if ( numP2Lights <= 0 )
  {
    v349 = v54->ModelRoomSettings.worldLightData.numCharLights;
    if ( v349 > 0 )
    {
      v350 = 0;
      v486 = 0;
      if ( v54->ModelRoomSettings.CharaInfo[1].iModelCount <= 0 )
        goto LABEL_404;
      v351 = 0i64;
      while ( 1 )
      {
        v352 = 0;
        v476 = 0;
        if ( !v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v351]->m_ucMaterialCount )
          goto LABEL_403;
        v353 = v54->ModelRoomSettings.playerLightOn[1];
        v354 = 0i64;
        v495 = v54->ModelRoomSettings.playerLightOn[1];
        v355 = v54->ModelRoomSettings.numPlayerLights[1];
        v356 = &v54->ModelRoomPlayerLightSettings[1][0][0].direction[1];
        v357 = v54->ModelRoomSettings.playerLightId[1];
        do
        {
          v358 = 0;
          if ( v349 <= 0 )
            goto LABEL_401;
          HIDWORD(v457) = 1065353216;
          v359 = &v54->ModelRoomSettings.worldLightData.charLightAssetData[0].direction[1];
          v360 = v353;
          v361 = v357;
          v362 = v356;
          do
          {
            *(v362 - 1) = *(v359 - 1);
            *v362 = *v359;
            v362[1] = v359[1];
            *(v362 - 5) = v359[2];
            *(v362 - 4) = v359[3];
            *(v362 - 3) = v359[4];
            *(float *)&v457 = v359[5];
            *(_QWORD *)((char *)&v457 + 4) = *((_QWORD *)v359 + 3);
            *(_OWORD *)(v362 + 2) = v457;
            v362[8] = v359[8];
            *(v362 - 7) = *(v359 - 2);
            *((_BYTE *)v362 + 36) = *((_BYTE *)v359 + 52);
            v362[6] = v359[9];
            v362[7] = v359[10];
            *((_BYTE *)v362 + 37) = *((_BYTE *)v359 + 44);
            *((_BYTE *)v362 + 38) = *((_BYTE *)v359 + 45);
            *(v362 - 6) = v359[12];
            v363 = *(_DWORD *)v361;
            v364 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v351]->m_pMaterial[v354].m_pLightManager;
            if ( v364->m_pLightNodeList )
            {
              v365 = v364->m_pLightNodeList;
              if ( v363 == -1 )
                goto LABEL_387;
              if ( v365 )
              {
                while ( v365->m_light.m_nId != v363 )
                {
                  v365 = v365->next;
                  if ( !v365 )
                    goto LABEL_389;
                }
LABEL_387:
                if ( v365->m_light.m_bOn != 1 )
                {
                  ++v364->m_activeLightCount;
                  v365->m_light.m_bOn = 1;
                }
              }
            }
LABEL_389:
            *(_BYTE *)v360 = 1;
            v366 = *(_DWORD *)v361;
            v367 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v351]->m_pMaterial[v354].m_pLightManager;
            if ( !v367->m_pLightNodeList )
              goto LABEL_394;
            v368 = v367->m_pLightNodeList;
            if ( v366 == -1 )
              goto LABEL_395;
            if ( v368 )
            {
              while ( v368->m_light.m_nId != v366 )
              {
                v368 = v368->next;
                if ( !v368 )
                  goto LABEL_394;
              }
            }
            else
            {
LABEL_394:
              v368 = 0i64;
            }
LABEL_395:
            v369 = v362[1];
            v370 = *v362;
            v368->m_light.m_fDirection[0] = *(v362 - 1);
            v368->m_light.m_fDirection[1] = v370;
            v368->m_light.m_fDirection[2] = v369;
            v371 = *(v362 - 4);
            v372 = *(v362 - 2);
            v373 = *(v362 - 3);
            v368->m_light.m_fPosition[0] = *(v362 - 5);
            v368->m_light.m_fPosition[1] = v371;
            v368->m_light.m_fPosition[2] = v373;
            v368->m_light.m_fPosition[3] = v372;
            v374 = *(v362 - 4);
            v375 = *(v362 - 3);
            v368->m_light.m_fLocalOffset[0] = *(v362 - 5);
            v368->m_light.m_fLocalOffset[1] = v374;
            v368->m_light.m_fLocalOffset[2] = v375;
            *(_OWORD *)v368->m_light.m_fDiffuse = *(_OWORD *)(v362 + 2);
            v368->m_light.m_fIntensity = v362[8];
            v376 = *((_DWORD *)v362 - 7);
            if ( v376 < 4 )
              v368->m_light.m_LightType = v376;
            v368->m_light.m_bCastsShadows = *((_BYTE *)v362 + 36);
            v368->m_light.m_fConeAngleRad = v362[6];
            v368->m_light.m_fPenumbraRad = v362[7];
            v368->m_light.m_bEmitSpecular = *((_BYTE *)v362 + 37);
            v368->m_light.m_bEmitDiffuse = *((_BYTE *)v362 + 38);
            v368->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v362 - 6);
            if ( !v351 )
              ++*v355;
            v349 = v54->ModelRoomSettings.worldLightData.numCharLights;
            ++v358;
            v361 = (int (*)[3])((char *)v361 + 4);
            v362 += 17;
            v359 += 41;
            v360 = (bool (*)[3])((char *)v360 + 1);
          }
          while ( v358 < v349 );
          v353 = v495;
          v352 = v476;
LABEL_401:
          ++v352;
          v495 = v353 + 1;
          ++v354;
          ++v357;
          v356 += 51;
          v476 = v352;
          ++v355;
          ++v353;
        }
        while ( v352 < v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v351]->m_ucMaterialCount );
        v350 = v486;
LABEL_403:
        ++v350;
        ++v351;
        v486 = v350;
        if ( v350 >= v54->ModelRoomSettings.CharaInfo[1].iModelCount )
        {
LABEL_404:
          v377 = 0;
          v487 = 0;
          if ( v54->ModelRoomSettings.CharaInfo[3].iModelCount <= 0 )
            return;
          for ( j = 0i64; ; ++j )
          {
            v379 = 0;
            v477 = 0;
            if ( v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[j]->m_ucMaterialCount )
              break;
LABEL_432:
            v487 = ++v377;
            if ( v377 >= v54->ModelRoomSettings.CharaInfo[3].iModelCount )
              return;
          }
          v380 = v54->ModelRoomSettings.playerLightOn[3];
          v381 = 0i64;
          v496 = v54->ModelRoomSettings.playerLightOn[3];
          v382 = v54->ModelRoomSettings.numPlayerLights[3];
          v383 = &v54->ModelRoomPlayerLightSettings[3][0][0].direction[1];
          v384 = v54->ModelRoomSettings.playerLightId[3];
          while ( 2 )
          {
            v385 = 0;
            if ( v54->ModelRoomSettings.worldLightData.numCharLights <= 0 )
              goto LABEL_430;
            HIDWORD(v458) = 1065353216;
            v386 = &v54->ModelRoomSettings.worldLightData.charLightAssetData[0].direction[1];
            v387 = v380;
            v388 = v384;
            v389 = v383;
LABEL_410:
            *(v389 - 1) = *(v386 - 1);
            *v389 = *v386;
            v389[1] = v386[1];
            *(v389 - 5) = v386[2];
            *(v389 - 4) = v386[3];
            *(v389 - 3) = v386[4];
            *(float *)&v458 = v386[5];
            *(_QWORD *)((char *)&v458 + 4) = *((_QWORD *)v386 + 3);
            *(_OWORD *)(v389 + 2) = v458;
            v389[8] = v386[8];
            *(v389 - 7) = *(v386 - 2);
            *((_BYTE *)v389 + 36) = *((_BYTE *)v386 + 52);
            v389[6] = v386[9];
            v389[7] = v386[10];
            *((_BYTE *)v389 + 37) = *((_BYTE *)v386 + 44);
            *((_BYTE *)v389 + 38) = *((_BYTE *)v386 + 45);
            *(v389 - 6) = v386[12];
            v390 = *(_DWORD *)v388;
            v391 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[j]->m_pMaterial[v381].m_pLightManager;
            if ( v391->m_pLightNodeList )
            {
              v392 = v391->m_pLightNodeList;
              if ( v390 == -1 )
                goto LABEL_416;
              if ( v392 )
              {
                while ( v392->m_light.m_nId != v390 )
                {
                  v392 = v392->next;
                  if ( !v392 )
                    goto LABEL_418;
                }
LABEL_416:
                if ( v392->m_light.m_bOn != 1 )
                {
                  ++v391->m_activeLightCount;
                  v392->m_light.m_bOn = 1;
                }
              }
            }
LABEL_418:
            *(_BYTE *)v387 = 1;
            v393 = *(_DWORD *)v388;
            v394 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[j]->m_pMaterial[v381].m_pLightManager;
            if ( !v394->m_pLightNodeList )
              goto LABEL_423;
            v395 = v394->m_pLightNodeList;
            if ( v393 == -1 )
              goto LABEL_424;
            if ( v395 )
            {
              while ( v395->m_light.m_nId != v393 )
              {
                v395 = v395->next;
                if ( !v395 )
                  goto LABEL_423;
              }
            }
            else
            {
LABEL_423:
              v395 = 0i64;
            }
LABEL_424:
            v396 = v389[1];
            v397 = *v389;
            v395->m_light.m_fDirection[0] = *(v389 - 1);
            v395->m_light.m_fDirection[1] = v397;
            v395->m_light.m_fDirection[2] = v396;
            v398 = *(v389 - 4);
            v399 = *(v389 - 2);
            v400 = *(v389 - 3);
            v395->m_light.m_fPosition[0] = *(v389 - 5);
            v395->m_light.m_fPosition[1] = v398;
            v395->m_light.m_fPosition[2] = v400;
            v395->m_light.m_fPosition[3] = v399;
            v401 = *(v389 - 4);
            v402 = *(v389 - 3);
            v395->m_light.m_fLocalOffset[0] = *(v389 - 5);
            v395->m_light.m_fLocalOffset[1] = v401;
            v395->m_light.m_fLocalOffset[2] = v402;
            *(_OWORD *)v395->m_light.m_fDiffuse = *(_OWORD *)(v389 + 2);
            v395->m_light.m_fIntensity = v389[8];
            v403 = *((_DWORD *)v389 - 7);
            if ( v403 < 4 )
              v395->m_light.m_LightType = v403;
            v395->m_light.m_bCastsShadows = *((_BYTE *)v389 + 36);
            v395->m_light.m_fConeAngleRad = v389[6];
            v395->m_light.m_fPenumbraRad = v389[7];
            v395->m_light.m_bEmitSpecular = *((_BYTE *)v389 + 37);
            v395->m_light.m_bEmitDiffuse = *((_BYTE *)v389 + 38);
            v395->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v389 - 6);
            if ( !j )
              ++*v382;
            ++v385;
            v388 = (int (*)[3])((char *)v388 + 4);
            v389 += 17;
            v386 += 41;
            v387 = (bool (*)[3])((char *)v387 + 1);
            if ( v385 >= v54->ModelRoomSettings.worldLightData.numCharLights )
            {
              v380 = v496;
              v379 = v477;
LABEL_430:
              ++v379;
              v496 = v380 + 1;
              ++v381;
              ++v384;
              v383 += 51;
              v477 = v379;
              ++v382;
              ++v380;
              if ( v379 >= v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[j]->m_ucMaterialCount )
              {
                v377 = v487;
                goto LABEL_432;
              }
              continue;
            }
            goto LABEL_410;
          }
        }
      }
    }
    v404 = 0;
    if ( v54->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
    {
      v405 = 0i64;
      while ( 1 )
      {
        v406 = 0;
        if ( v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v405]->m_ucMaterialCount )
          break;
LABEL_458:
        ++v404;
        ++v405;
        if ( v404 >= v54->ModelRoomSettings.CharaInfo[1].iModelCount )
          goto LABEL_459;
      }
      v407 = 0i64;
      v408 = v54->ModelRoomSettings.numPlayerLights[1];
      v409 = 0i64;
      while ( 1 )
      {
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].position[0] = -13.52;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].position[1] = 15.02;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].position[2] = 0.91000003;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].position[3] = 1.0;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].direction[0] = 0.83999997;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].direction[1] = -0.44999999;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].direction[2] = -0.30000001;
        *(_OWORD *)v54->ModelRoomPlayerLightSettings[1][v407][*v408].colour = _xmm;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].castsShadows = 0;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].coneAngleRad = 0.78539801;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].penumbraRad = 0.0;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].intensity = 1.0;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].emitSpecular = 1;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].emitDiffuse = 1;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].decayRate = 0;
        v54->ModelRoomPlayerLightSettings[1][v407][*v408].type = 1;
        v410 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v405]->m_pMaterial[v409].m_pLightManager;
        if ( v410 )
          break;
LABEL_457:
        ++v406;
        ++v408;
        ++v409;
        ++v407;
        if ( v406 >= v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v405]->m_ucMaterialCount )
          goto LABEL_458;
      }
      v411 = v54->ModelRoomSettings.playerLightId[1][v407][*v408];
      if ( v410->m_pLightNodeList )
      {
        v412 = v410->m_pLightNodeList;
        if ( v411 != -1 )
        {
          if ( !v412 )
            goto LABEL_447;
          while ( v412->m_light.m_nId != v411 )
          {
            v412 = v412->next;
            if ( !v412 )
              goto LABEL_447;
          }
        }
        if ( v412->m_light.m_bOn != 1 )
        {
          ++v410->m_activeLightCount;
          v412->m_light.m_bOn = 1;
        }
      }
LABEL_447:
      v54->ModelRoomSettings.playerLightOn[1][v407][*v408] = 1;
      v413 = v407 * 3 + *v408;
      v414 = v54->ModelRoomSettings.playerLightId[1][0][v413];
      v415 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v405]->m_pMaterial[v409].m_pLightManager;
      if ( v415->m_pLightNodeList )
      {
        v416 = v415->m_pLightNodeList;
        if ( v414 == -1 )
        {
LABEL_453:
          v417 = v54->ModelRoomPlayerLightSettings[1][0][v413].direction[2];
          v418 = v54->ModelRoomPlayerLightSettings[1][0][v413].direction[1];
          v416->m_light.m_fDirection[0] = v54->ModelRoomPlayerLightSettings[1][0][v413].direction[0];
          v416->m_light.m_fDirection[1] = v418;
          v416->m_light.m_fDirection[2] = v417;
          v419 = v407 * 3 + *v408;
          v420 = v54->ModelRoomPlayerLightSettings[1][0][v419].position[2];
          v421 = v54->ModelRoomPlayerLightSettings[1][0][v419].position[1];
          v422 = v54->ModelRoomPlayerLightSettings[1][0][v419].position[3];
          v416->m_light.m_fPosition[0] = v54->ModelRoomPlayerLightSettings[1][0][v419].position[0];
          v416->m_light.m_fPosition[1] = v421;
          v416->m_light.m_fPosition[2] = v420;
          v416->m_light.m_fPosition[3] = v422;
          v423 = v407 * 3 + *v408;
          v424 = v54->ModelRoomPlayerLightSettings[1][0][v423].position[1];
          v425 = v54->ModelRoomPlayerLightSettings[1][0][v423].position[2];
          v416->m_light.m_fLocalOffset[0] = v54->ModelRoomPlayerLightSettings[1][0][v423].position[0];
          v416->m_light.m_fLocalOffset[1] = v424;
          v416->m_light.m_fLocalOffset[2] = v425;
          *(_OWORD *)v416->m_light.m_fDiffuse = *(_OWORD *)v54->ModelRoomPlayerLightSettings[1][v407][*v408].colour;
          v416->m_light.m_bCastsShadows = v54->ModelRoomPlayerLightSettings[1][v407][*v408].castsShadows;
          v416->m_light.m_fConeAngleRad = v54->ModelRoomPlayerLightSettings[1][v407][*v408].coneAngleRad;
          v416->m_light.m_fPenumbraRad = v54->ModelRoomPlayerLightSettings[1][v407][*v408].penumbraRad;
          v416->m_light.m_fIntensity = v54->ModelRoomPlayerLightSettings[1][v407][*v408].intensity;
          v416->m_light.m_bEmitSpecular = v54->ModelRoomPlayerLightSettings[1][v407][*v408].emitSpecular;
          v416->m_light.m_bEmitDiffuse = v54->ModelRoomPlayerLightSettings[1][v407][*v408].emitDiffuse;
          v416->m_light.m_DecayRate = v54->ModelRoomPlayerLightSettings[1][v407][*v408].decayRate;
          v426 = v54->ModelRoomPlayerLightSettings[1][v407][*v408].type;
          if ( v426 < 4 )
            v416->m_light.m_LightType = v426;
          if ( !v405 )
            ++*v408;
          goto LABEL_457;
        }
        if ( v416 )
        {
          while ( v416->m_light.m_nId != v414 )
          {
            v416 = v416->next;
            if ( !v416 )
              goto LABEL_452;
          }
          goto LABEL_453;
        }
      }
LABEL_452:
      v416 = 0i64;
      goto LABEL_453;
    }
LABEL_459:
    v427 = 0;
    if ( v54->ModelRoomSettings.CharaInfo[3].iModelCount <= 0 )
      return;
    for ( k = 0i64; ; ++k )
    {
      v429 = 0;
      if ( v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[k]->m_ucMaterialCount )
        break;
LABEL_483:
      if ( ++v427 >= v54->ModelRoomSettings.CharaInfo[3].iModelCount )
        return;
    }
    v430 = 0i64;
    v431 = v54->ModelRoomSettings.numPlayerLights[3];
    v432 = 0i64;
    while ( 1 )
    {
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].position[0] = -13.52;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].position[1] = 15.02;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].position[2] = 0.91000003;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].position[3] = 1.0;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].direction[0] = 0.83999997;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].direction[1] = -0.44999999;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].direction[2] = -0.30000001;
      *(_OWORD *)v54->ModelRoomPlayerLightSettings[3][v430][*v431].colour = _xmm;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].castsShadows = 0;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].coneAngleRad = 0.78539801;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].penumbraRad = 0.0;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].intensity = 1.0;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].emitSpecular = 1;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].emitDiffuse = 1;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].decayRate = 0;
      v54->ModelRoomPlayerLightSettings[3][v430][*v431].type = 1;
      v433 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[k]->m_pMaterial[v432].m_pLightManager;
      if ( v433 )
        break;
LABEL_482:
      ++v429;
      ++v431;
      ++v432;
      ++v430;
      if ( v429 >= v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[k]->m_ucMaterialCount )
        goto LABEL_483;
    }
    v434 = v54->ModelRoomSettings.playerLightId[3][v430][*v431];
    if ( v433->m_pLightNodeList )
    {
      v435 = v433->m_pLightNodeList;
      if ( v434 != -1 )
      {
        if ( !v435 )
          goto LABEL_472;
        while ( v435->m_light.m_nId != v434 )
        {
          v435 = v435->next;
          if ( !v435 )
            goto LABEL_472;
        }
      }
      if ( v435->m_light.m_bOn != 1 )
      {
        ++v433->m_activeLightCount;
        v435->m_light.m_bOn = 1;
      }
    }
LABEL_472:
    v54->ModelRoomSettings.playerLightOn[3][v430][*v431] = 1;
    v436 = v430 * 3 + *v431;
    v437 = v54->ModelRoomSettings.playerLightId[3][0][v436];
    v438 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[k]->m_pMaterial[v432].m_pLightManager;
    if ( v438->m_pLightNodeList )
    {
      v439 = v438->m_pLightNodeList;
      if ( v437 == -1 )
      {
LABEL_478:
        v440 = v54->ModelRoomPlayerLightSettings[3][0][v436].direction[2];
        v441 = v54->ModelRoomPlayerLightSettings[3][0][v436].direction[1];
        v439->m_light.m_fDirection[0] = v54->ModelRoomPlayerLightSettings[3][0][v436].direction[0];
        v439->m_light.m_fDirection[1] = v441;
        v439->m_light.m_fDirection[2] = v440;
        v442 = v430 * 3 + *v431;
        v443 = v54->ModelRoomPlayerLightSettings[3][0][v442].position[2];
        v444 = v54->ModelRoomPlayerLightSettings[3][0][v442].position[1];
        v445 = v54->ModelRoomPlayerLightSettings[3][0][v442].position[3];
        v439->m_light.m_fPosition[0] = v54->ModelRoomPlayerLightSettings[3][0][v442].position[0];
        v439->m_light.m_fPosition[1] = v444;
        v439->m_light.m_fPosition[2] = v443;
        v439->m_light.m_fPosition[3] = v445;
        v446 = v430 * 3 + *v431;
        v447 = v54->ModelRoomPlayerLightSettings[3][0][v446].position[1];
        v448 = v54->ModelRoomPlayerLightSettings[3][0][v446].position[2];
        v439->m_light.m_fLocalOffset[0] = v54->ModelRoomPlayerLightSettings[3][0][v446].position[0];
        v439->m_light.m_fLocalOffset[1] = v447;
        v439->m_light.m_fLocalOffset[2] = v448;
        *(_OWORD *)v439->m_light.m_fDiffuse = *(_OWORD *)v54->ModelRoomPlayerLightSettings[3][v430][*v431].colour;
        v439->m_light.m_bCastsShadows = v54->ModelRoomPlayerLightSettings[3][v430][*v431].castsShadows;
        v439->m_light.m_fConeAngleRad = v54->ModelRoomPlayerLightSettings[3][v430][*v431].coneAngleRad;
        v439->m_light.m_fPenumbraRad = v54->ModelRoomPlayerLightSettings[3][v430][*v431].penumbraRad;
        v439->m_light.m_fIntensity = v54->ModelRoomPlayerLightSettings[3][v430][*v431].intensity;
        v439->m_light.m_bEmitSpecular = v54->ModelRoomPlayerLightSettings[3][v430][*v431].emitSpecular;
        v439->m_light.m_bEmitDiffuse = v54->ModelRoomPlayerLightSettings[3][v430][*v431].emitDiffuse;
        v439->m_light.m_DecayRate = v54->ModelRoomPlayerLightSettings[3][v430][*v431].decayRate;
        v449 = v54->ModelRoomPlayerLightSettings[3][v430][*v431].type;
        if ( v449 < 4 )
          v439->m_light.m_LightType = v449;
        if ( !k )
          ++*v431;
        goto LABEL_482;
      }
      if ( v439 )
      {
        while ( v439->m_light.m_nId != v437 )
        {
          v439 = v439->next;
          if ( !v439 )
            goto LABEL_477;
        }
        goto LABEL_478;
      }
    }
LABEL_477:
    v439 = 0i64;
    goto LABEL_478;
  }
  v295 = 0;
  v484 = 0;
  if ( v54->ModelRoomSettings.CharaInfo[1].iModelCount <= 0 )
    goto LABEL_344;
  v296 = 0i64;
  while ( 2 )
  {
    v297 = 0;
    v474 = 0;
    if ( !v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v296]->m_ucMaterialCount )
      goto LABEL_343;
    v298 = v54->ModelRoomSettings.playerLightOn[1];
    v299 = 0i64;
    v493 = v54->ModelRoomSettings.playerLightOn[1];
    v300 = v54->ModelRoomSettings.numPlayerLights[1];
    v301 = &v54->ModelRoomPlayerLightSettings[1][0][0].direction[1];
    v302 = v54->ModelRoomSettings.playerLightId[1];
    while ( 2 )
    {
      v303 = 0;
      if ( numP2Lights <= 0 )
        goto LABEL_341;
      HIDWORD(v455) = 1065353216;
      v304 = &v54->ModelRoomSettings.worldLightData.P2LightAssetData[0].direction[1];
      v305 = v298;
      v306 = v302;
      v307 = v301;
      while ( 2 )
      {
        *(v307 - 1) = *(v304 - 1);
        *v307 = *v304;
        v307[1] = v304[1];
        *(v307 - 5) = v304[2];
        *(v307 - 4) = v304[3];
        *(v307 - 3) = v304[4];
        *(float *)&v455 = v304[5];
        *(_QWORD *)((char *)&v455 + 4) = *((_QWORD *)v304 + 3);
        *(_OWORD *)(v307 + 2) = v455;
        v307[8] = v304[8];
        *(v307 - 7) = *(v304 - 2);
        *((_BYTE *)v307 + 36) = *((_BYTE *)v304 + 52);
        v307[6] = v304[9];
        v307[7] = v304[10];
        *((_BYTE *)v307 + 37) = *((_BYTE *)v304 + 44);
        *((_BYTE *)v307 + 38) = *((_BYTE *)v304 + 45);
        *(v307 - 6) = v304[12];
        v308 = *(_DWORD *)v306;
        v309 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v296]->m_pMaterial[v299].m_pLightManager;
        if ( v309->m_pLightNodeList )
        {
          v310 = v309->m_pLightNodeList;
          if ( v308 == -1 )
            goto LABEL_327;
          if ( v310 )
          {
            while ( v310->m_light.m_nId != v308 )
            {
              v310 = v310->next;
              if ( !v310 )
                goto LABEL_329;
            }
LABEL_327:
            if ( v310->m_light.m_bOn != 1 )
            {
              ++v309->m_activeLightCount;
              v310->m_light.m_bOn = 1;
            }
          }
        }
LABEL_329:
        *(_BYTE *)v305 = 1;
        v311 = *(_DWORD *)v306;
        v312 = v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v296]->m_pMaterial[v299].m_pLightManager;
        if ( !v312->m_pLightNodeList )
          goto LABEL_334;
        v313 = v312->m_pLightNodeList;
        if ( v311 == -1 )
          goto LABEL_335;
        if ( v313 )
        {
          while ( v313->m_light.m_nId != v311 )
          {
            v313 = v313->next;
            if ( !v313 )
              goto LABEL_334;
          }
        }
        else
        {
LABEL_334:
          v313 = 0i64;
        }
LABEL_335:
        v314 = v307[1];
        v315 = *v307;
        v313->m_light.m_fDirection[0] = *(v307 - 1);
        v313->m_light.m_fDirection[1] = v315;
        v313->m_light.m_fDirection[2] = v314;
        v316 = *(v307 - 4);
        v317 = *(v307 - 2);
        v318 = *(v307 - 3);
        v313->m_light.m_fPosition[0] = *(v307 - 5);
        v313->m_light.m_fPosition[1] = v316;
        v313->m_light.m_fPosition[2] = v318;
        v313->m_light.m_fPosition[3] = v317;
        v319 = *(v307 - 4);
        v320 = *(v307 - 3);
        v313->m_light.m_fLocalOffset[0] = *(v307 - 5);
        v313->m_light.m_fLocalOffset[1] = v319;
        v313->m_light.m_fLocalOffset[2] = v320;
        *(_OWORD *)v313->m_light.m_fDiffuse = *(_OWORD *)(v307 + 2);
        v313->m_light.m_fIntensity = v307[8];
        v321 = *((_DWORD *)v307 - 7);
        if ( v321 < 4 )
          v313->m_light.m_LightType = v321;
        v313->m_light.m_bCastsShadows = *((_BYTE *)v307 + 36);
        v313->m_light.m_fConeAngleRad = v307[6];
        v313->m_light.m_fPenumbraRad = v307[7];
        v313->m_light.m_bEmitSpecular = *((_BYTE *)v307 + 37);
        v313->m_light.m_bEmitDiffuse = *((_BYTE *)v307 + 38);
        v313->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v307 - 6);
        if ( !v296 )
          ++*v300;
        numP2Lights = v54->ModelRoomSettings.worldLightData.numP2Lights;
        ++v303;
        v304 += 41;
        v306 = (int (*)[3])((char *)v306 + 4);
        v307 += 17;
        v305 = (bool (*)[3])((char *)v305 + 1);
        if ( v303 < numP2Lights )
          continue;
        break;
      }
      v298 = v493;
      v297 = v474;
LABEL_341:
      ++v297;
      v493 = v298 + 1;
      ++v299;
      ++v302;
      v301 += 51;
      v474 = v297;
      ++v300;
      ++v298;
      if ( v297 < v54->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v296]->m_ucMaterialCount )
        continue;
      break;
    }
    v295 = v484;
LABEL_343:
    ++v295;
    ++v296;
    v484 = v295;
    if ( v295 < v54->ModelRoomSettings.CharaInfo[1].iModelCount )
      continue;
    break;
  }
LABEL_344:
  v322 = 0;
  v485 = 0;
  if ( v54->ModelRoomSettings.CharaInfo[3].iModelCount <= 0 )
    return;
  v323 = 0i64;
  while ( 2 )
  {
    v324 = 0;
    v475 = 0;
    if ( !v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v323]->m_ucMaterialCount )
      goto LABEL_372;
    v325 = v54->ModelRoomSettings.playerLightOn[3];
    v326 = 0i64;
    v494 = v54->ModelRoomSettings.playerLightOn[3];
    v327 = v54->ModelRoomSettings.numPlayerLights[3];
    v328 = &v54->ModelRoomPlayerLightSettings[3][0][0].direction[1];
    v329 = v54->ModelRoomSettings.playerLightId[3];
    while ( 2 )
    {
      v330 = 0;
      if ( v54->ModelRoomSettings.worldLightData.numP2Lights <= 0 )
        goto LABEL_370;
      HIDWORD(v456) = 1065353216;
      v331 = &v54->ModelRoomSettings.worldLightData.P2LightAssetData[0].direction[1];
      v332 = v325;
      v333 = v329;
      v334 = v328;
      while ( 2 )
      {
        *(v334 - 1) = *(v331 - 1);
        *v334 = *v331;
        v334[1] = v331[1];
        *(v334 - 5) = v331[2];
        *(v334 - 4) = v331[3];
        *(v334 - 3) = v331[4];
        *(float *)&v456 = v331[5];
        *(_QWORD *)((char *)&v456 + 4) = *((_QWORD *)v331 + 3);
        *(_OWORD *)(v334 + 2) = v456;
        v334[8] = v331[8];
        *(v334 - 7) = *(v331 - 2);
        *((_BYTE *)v334 + 36) = *((_BYTE *)v331 + 52);
        v334[6] = v331[9];
        v334[7] = v331[10];
        *((_BYTE *)v334 + 37) = *((_BYTE *)v331 + 44);
        *((_BYTE *)v334 + 38) = *((_BYTE *)v331 + 45);
        *(v334 - 6) = v331[12];
        v335 = *(_DWORD *)v333;
        v336 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v323]->m_pMaterial[v326].m_pLightManager;
        if ( v336->m_pLightNodeList )
        {
          v337 = v336->m_pLightNodeList;
          if ( v335 == -1 )
            goto LABEL_356;
          if ( v337 )
          {
            while ( v337->m_light.m_nId != v335 )
            {
              v337 = v337->next;
              if ( !v337 )
                goto LABEL_358;
            }
LABEL_356:
            if ( v337->m_light.m_bOn != 1 )
            {
              ++v336->m_activeLightCount;
              v337->m_light.m_bOn = 1;
            }
          }
        }
LABEL_358:
        *(_BYTE *)v332 = 1;
        v338 = *(_DWORD *)v333;
        v339 = v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v323]->m_pMaterial[v326].m_pLightManager;
        if ( !v339->m_pLightNodeList )
          goto LABEL_363;
        v340 = v339->m_pLightNodeList;
        if ( v338 == -1 )
          goto LABEL_364;
        if ( v340 )
        {
          while ( v340->m_light.m_nId != v338 )
          {
            v340 = v340->next;
            if ( !v340 )
              goto LABEL_363;
          }
        }
        else
        {
LABEL_363:
          v340 = 0i64;
        }
LABEL_364:
        v341 = v334[1];
        v342 = *v334;
        v340->m_light.m_fDirection[0] = *(v334 - 1);
        v340->m_light.m_fDirection[1] = v342;
        v340->m_light.m_fDirection[2] = v341;
        v343 = *(v334 - 4);
        v344 = *(v334 - 2);
        v345 = *(v334 - 3);
        v340->m_light.m_fPosition[0] = *(v334 - 5);
        v340->m_light.m_fPosition[1] = v343;
        v340->m_light.m_fPosition[2] = v345;
        v340->m_light.m_fPosition[3] = v344;
        v346 = *(v334 - 4);
        v347 = *(v334 - 3);
        v340->m_light.m_fLocalOffset[0] = *(v334 - 5);
        v340->m_light.m_fLocalOffset[1] = v346;
        v340->m_light.m_fLocalOffset[2] = v347;
        *(_OWORD *)v340->m_light.m_fDiffuse = *(_OWORD *)(v334 + 2);
        v340->m_light.m_fIntensity = v334[8];
        v348 = *((_DWORD *)v334 - 7);
        if ( v348 < 4 )
          v340->m_light.m_LightType = v348;
        v340->m_light.m_bCastsShadows = *((_BYTE *)v334 + 36);
        v340->m_light.m_fConeAngleRad = v334[6];
        v340->m_light.m_fPenumbraRad = v334[7];
        v340->m_light.m_bEmitSpecular = *((_BYTE *)v334 + 37);
        v340->m_light.m_bEmitDiffuse = *((_BYTE *)v334 + 38);
        v340->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v334 - 6);
        if ( !v323 )
          ++*v327;
        ++v330;
        v331 += 41;
        v333 = (int (*)[3])((char *)v333 + 4);
        v334 += 17;
        v332 = (bool (*)[3])((char *)v332 + 1);
        if ( v330 < v54->ModelRoomSettings.worldLightData.numP2Lights )
          continue;
        break;
      }
      v325 = v494;
      v324 = v475;
LABEL_370:
      ++v324;
      v494 = v325 + 1;
      ++v326;
      ++v329;
      v328 += 51;
      v475 = v324;
      ++v327;
      ++v325;
      if ( v324 < v54->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v323]->m_ucMaterialCount )
        continue;
      break;
    }
    v322 = v485;
LABEL_372:
    ++v322;
    ++v323;
    v485 = v322;
    if ( v322 < v54->ModelRoomSettings.CharaInfo[3].iModelCount )
      continue;
    break;
  }
}

void __fastcall AppMain::SetUpStageLights(AppMain *this)
{
  bool (*stageModelLightOn)[64][3]; // r14
  OGLRender *m_pRender; // rdx
  __int64 v3; // rbx
  float v4; // xmm2_4
  AppMain *v5; // rdi
  float v6; // xmm1_4
  __int64 v7; // r12
  float v8; // xmm0_4
  int (*v9)[64][3]; // rsi
  int (*v10)[64]; // r13
  int v11; // er15
  __int64 v12; // rbp
  OGLModel *v13; // rcx
  OGLMaterial *m_pMaterial; // rax
  OGLLightManager *m_pLightManager; // rdi
  float *v16; // r11
  __int64 v17; // r8
  float *v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  int *p_numMaterials; // r9
  __int64 v22; // r10
  __int64 v23; // r13
  __int64 v24; // r8
  OGLModel *v25; // rcx
  int v26; // edx
  __int64 v27; // rax
  int *v28; // r9
  __int64 v29; // rbp
  int v30; // er12
  __int64 v31; // r10
  bool *v32; // r15
  _DWORD *v33; // r14
  int *v34; // rsi
  __int64 v35; // rbx
  OGLLightManager *v36; // rcx
  int v37; // eax
  int v38; // edx
  OGLLightManager *v39; // rcx
  OGLLightNode *m_pLightNodeList; // rax
  int v41; // er8
  OGLLightNode *v42; // rdx
  float v43; // xmm1_4
  float v44; // eax
  float v45; // eax
  float v46; // xmm3_4
  float v47; // xmm2_4
  float v48; // eax
  float v49; // xmm1_4
  int v50; // eax
  OGLLight::DecayRate v51; // eax
  int v52; // er12
  int (*v53)[64]; // rsi
  __int64 v54; // rbp
  int (*v55)[64][3]; // r15
  float *v56; // rbx
  __int64 v57; // r14
  OGLLightManager *v58; // rcx
  int v59; // edx
  OGLLightManager *v60; // rcx
  OGLLightNode *v61; // rax
  int v62; // er8
  OGLLightNode *v63; // rdx
  float v64; // xmm1_4
  float v65; // xmm0_4
  __int64 v66; // rcx
  float v67; // xmm1_4
  float v68; // xmm0_4
  float v69; // xmm2_4
  __int64 v70; // rcx
  float v71; // eax
  float v72; // xmm1_4
  int v73; // eax
  OGLLight::DecayRate v74; // eax
  bool v75; // zf
  __int64 v76; // [rsp+20h] [rbp-A8h]
  int (*numStageModelLights)[64]; // [rsp+28h] [rbp-A0h]
  int (*stageModelLightId)[64][3]; // [rsp+30h] [rbp-98h]
  float *v79; // [rsp+38h] [rbp-90h]
  int *v80; // [rsp+40h] [rbp-88h]
  __int64 v81; // [rsp+48h] [rbp-80h]
  __int64 v82; // [rsp+50h] [rbp-78h]
  __int128 v83; // [rsp+58h] [rbp-70h]
  int v85; // [rsp+D0h] [rbp+8h]
  __int64 v86; // [rsp+D8h] [rbp+10h]
  int *v87; // [rsp+E0h] [rbp+18h]
  __int64 v88; // [rsp+E8h] [rbp+20h]

  stageModelLightOn = this->ModelRoomSettings.stageModelLightOn;
  m_pRender = this->m_pRender;
  v3 = 0i64;
  v4 = this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[3];
  v5 = this;
  v6 = this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[2];
  v7 = 0i64;
  v8 = this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[1];
  m_pRender->m_LightningCol[0] = this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[0];
  stageModelLightId = this->ModelRoomSettings.stageModelLightId;
  v9 = this->ModelRoomSettings.stageModelLightId;
  m_pRender->m_LightningCol[1] = v8;
  numStageModelLights = this->ModelRoomSettings.numStageModelLights;
  v10 = this->ModelRoomSettings.numStageModelLights;
  m_pRender->m_LightningCol[2] = v6;
  m_pRender->m_LightningCol[3] = v4;
  do
  {
    v11 = 0;
    v12 = 0i64;
    while ( 1 )
    {
      *(_DWORD *)v9 = -1;
      (*stageModelLightOn)[0][v3] = 0;
      v13 = v5->pModel[v7];
      if ( v13 && v11 < v13->m_ucMaterialCount )
      {
        m_pMaterial = v13->m_pMaterial;
        m_pLightManager = m_pMaterial[v12].m_pLightManager;
        if ( m_pLightManager )
        {
          OGLLightManager::deleteAllLights(m_pMaterial[v12].m_pLightManager);
          OGLLightManager::clear(m_pLightManager);
        }
        v5 = this;
      }
      ++v3;
      v9 = (int (*)[64][3])((char *)v9 + 4);
      if ( v3 >= 3 )
      {
        v3 = 0i64;
        ++v11;
        *(_DWORD *)v10 = 0;
        stageModelLightOn = (bool (*)[64][3])((char *)stageModelLightOn + 3);
        v10 = (int (*)[64])((char *)v10 + 4);
        if ( ++v12 >= 64 )
          break;
      }
    }
    ++v7;
  }
  while ( v7 < 44 );
  v16 = &v5->ModelRoomStageModelLightSettings[0][0][0].position[1];
  v5->ModelRoomStageModelInitLightSettings.position[0] = 0.0;
  v17 = 44i64;
  v5->ModelRoomStageModelInitLightSettings.position[1] = 20.0;
  *(_OWORD *)v5->ModelRoomStageModelInitLightSettings.colour = _xmm;
  v5->ModelRoomStageModelInitLightSettings.position[2] = 40.0;
  v18 = &v5->ModelRoomStageModelLightSettings[0][0][0].position[1];
  *(_QWORD *)&v5->ModelRoomStageModelInitLightSettings.position[3] = 1065353216i64;
  v5->ModelRoomStageModelInitLightSettings.direction[1] = 0.0;
  v5->ModelRoomStageModelInitLightSettings.direction[2] = -1.0;
  *(_WORD *)&v5->ModelRoomStageModelInitLightSettings.castsShadows = 256;
  *(_QWORD *)&v5->ModelRoomStageModelInitLightSettings.coneAngleRad = 1061752792i64;
  v5->ModelRoomStageModelInitLightSettings.intensity = 1.0;
  v5->ModelRoomStageModelInitLightSettings.emitDiffuse = 1;
  *(_QWORD *)&v5->ModelRoomStageModelInitLightSettings.type = 0i64;
  v79 = &v5->ModelRoomStageModelLightSettings[0][0][0].position[1];
  v81 = 44i64;
  do
  {
    v19 = 64i64;
    do
    {
      v20 = 3i64;
      do
      {
        *(v18 - 1) = 0.0;
        *v18 = 20.0;
        v18[1] = 40.0;
        *((_QWORD *)v18 + 1) = 1065353216i64;
        v18[4] = 0.0;
        v18[5] = 1.0;
        *(_OWORD *)(v18 + 6) = _xmm;
        *((_WORD *)v18 + 26) = 256;
        *((_QWORD *)v18 + 5) = 1061752792i64;
        v18[12] = 1.0;
        *((_BYTE *)v18 + 54) = 1;
        *(_QWORD *)(v18 - 3) = 0i64;
        v18 += 17;
        --v20;
      }
      while ( v20 );
      --v19;
    }
    while ( v19 );
    --v17;
  }
  while ( v17 );
  p_numMaterials = &v5->ModelRoomSettings.modelLightData[0].numMaterials;
  v76 = 0i64;
  v87 = &v5->ModelRoomSettings.modelLightData[0].numMaterials;
  v22 = 0i64;
  v23 = 0i64;
  v88 = 0i64;
  v24 = 0i64;
  do
  {
    v25 = v5->pModel[v23];
    if ( !v25 )
      goto LABEL_66;
    if ( *((_BYTE *)p_numMaterials - 4) && *p_numMaterials > 0 )
    {
      v26 = 0;
      v85 = 0;
      v27 = 0i64;
      v86 = 0i64;
      if ( !v25->m_ucMaterialCount )
        goto LABEL_66;
      v28 = p_numMaterials + 1;
      v29 = 0i64;
      v80 = v28;
      do
      {
        v30 = 0;
        if ( *v28 > 0 )
        {
          HIDWORD(v83) = 1065353216;
          v31 = v27 + v24;
          v82 = v27 + v24;
          v32 = &v5->ModelRoomSettings.stageModelLightOn[0][0][2 * v27 + 2 * v24 + v27 + v24];
          v33 = v28 + 3;
          v34 = &v5->ModelRoomSettings.stageModelLightId[0][0][2 * v27 + 2 * v24 + v27 + v24];
          v35 = (__int64)&v5->ModelRoomStageModelLightSettings[0][v27][3 * v24].direction[1];
          do
          {
            v36 = v5->pModel[v23]->m_pMaterial[v29].m_pLightManager;
            if ( v36 )
            {
              v37 = OGLLightManager::addLight(v36);
              v28 = v80;
              v31 = v82;
              *v34 = v37;
            }
            *(_DWORD *)(v35 - 4) = *(v33 - 1);
            *(_DWORD *)v35 = *v33;
            *(_DWORD *)(v35 + 4) = v33[1];
            *(_DWORD *)(v35 - 20) = v33[2];
            *(_DWORD *)(v35 - 16) = v33[3];
            *(_DWORD *)(v35 - 12) = v33[4];
            LODWORD(v83) = v33[5];
            *(_QWORD *)((char *)&v83 + 4) = *((_QWORD *)v33 + 3);
            *(_OWORD *)(v35 + 8) = v83;
            *(_DWORD *)(v35 + 32) = v33[8];
            *(_DWORD *)(v35 - 28) = *(v33 - 2);
            *(_BYTE *)(v35 + 36) = *((_BYTE *)v33 + 52);
            *(_DWORD *)(v35 + 24) = v33[9];
            *(_DWORD *)(v35 + 28) = v33[10];
            *(_BYTE *)(v35 + 37) = *((_BYTE *)v33 + 44);
            *(_BYTE *)(v35 + 38) = *((_BYTE *)v33 + 45);
            *(_DWORD *)(v35 - 24) = v33[12];
            v38 = *v34;
            v39 = v5->pModel[v23]->m_pMaterial[v29].m_pLightManager;
            m_pLightNodeList = v39->m_pLightNodeList;
            if ( m_pLightNodeList )
            {
              if ( v38 != -1 )
              {
                while ( m_pLightNodeList->m_light.m_nId != v38 )
                {
                  m_pLightNodeList = m_pLightNodeList->next;
                  if ( !m_pLightNodeList )
                    goto LABEL_34;
                }
              }
              if ( m_pLightNodeList->m_light.m_bOn != 1 )
              {
                ++v39->m_activeLightCount;
                m_pLightNodeList->m_light.m_bOn = 1;
              }
            }
LABEL_34:
            *v32 = 1;
            v41 = *v34;
            v42 = v5->pModel[v23]->m_pMaterial[v29].m_pLightManager->m_pLightNodeList;
            if ( v42 )
            {
              if ( v41 != -1 )
              {
                while ( v42->m_light.m_nId != v41 )
                {
                  v42 = v42->next;
                  if ( !v42 )
                    goto LABEL_38;
                }
              }
            }
            else
            {
LABEL_38:
              v42 = 0i64;
            }
            v43 = *(float *)(v35 + 4);
            v44 = *(float *)(v35 - 4);
            v42->m_light.m_fDirection[1] = *(float *)v35;
            v42->m_light.m_fDirection[2] = v43;
            v42->m_light.m_fDirection[0] = v44;
            v45 = *(float *)(v35 - 20);
            v46 = *(float *)(v35 - 8);
            v47 = *(float *)(v35 - 12);
            v42->m_light.m_fPosition[1] = *(float *)(v35 - 16);
            v42->m_light.m_fPosition[2] = v47;
            v42->m_light.m_fPosition[3] = v46;
            v42->m_light.m_fPosition[0] = v45;
            v48 = *(float *)(v35 - 20);
            v49 = *(float *)(v35 - 12);
            v42->m_light.m_fLocalOffset[1] = *(float *)(v35 - 16);
            v42->m_light.m_fLocalOffset[2] = v49;
            v42->m_light.m_fLocalOffset[0] = v48;
            *(_OWORD *)v42->m_light.m_fDiffuse = *(_OWORD *)(v35 + 8);
            v42->m_light.m_fIntensity = *(float *)(v35 + 32);
            v50 = *(_DWORD *)(v35 - 28);
            if ( v50 < 4 )
              v42->m_light.m_LightType = v50;
            ++v30;
            v42->m_light.m_bCastsShadows = *(_BYTE *)(v35 + 36);
            ++v34;
            v33 += 41;
            v42->m_light.m_fConeAngleRad = *(float *)(v35 + 24);
            ++v32;
            v42->m_light.m_fPenumbraRad = *(float *)(v35 + 28);
            v42->m_light.m_bEmitSpecular = *(_BYTE *)(v35 + 37);
            v42->m_light.m_bEmitDiffuse = *(_BYTE *)(v35 + 38);
            v51 = *(_DWORD *)(v35 - 24);
            v35 += 68i64;
            v42->m_light.m_DecayRate = v51;
            ++v5->ModelRoomSettings.numStageModelLights[0][v31];
          }
          while ( v30 < *v28 );
          v27 = v86;
          v26 = v85;
          v24 = v88;
        }
        ++v26;
        v86 = v27 + 1;
        v28 += 124;
        ++v29;
        v85 = v26;
        v80 = v28;
        ++v27;
      }
      while ( v26 < v5->pModel[v23]->m_ucMaterialCount );
    }
    else
    {
      v52 = 0;
      if ( !v25->m_ucMaterialCount )
        goto LABEL_66;
      v53 = numStageModelLights;
      v54 = 0i64;
      v55 = stageModelLightId;
      v56 = v16;
      v57 = v22;
      do
      {
        v58 = v5->pModel[v23]->m_pMaterial[v54].m_pLightManager;
        if ( v58 )
          *(_DWORD *)v55 = OGLLightManager::addLight(v58);
        *(v56 - 1) = 0.0;
        *(_QWORD *)v56 = 1101004800i64;
        *((_QWORD *)v56 + 1) = 1065353216i64;
        v56[4] = -1.0;
        v56[5] = 0.0;
        *(_OWORD *)(v56 + 6) = _xmm;
        *((_WORD *)v56 + 26) = 256;
        *((_QWORD *)v56 + 5) = 1063421856i64;
        v56[12] = 1.0;
        *((_BYTE *)v56 + 54) = 1;
        *(_QWORD *)(v56 - 3) = 3i64;
        v59 = v5->ModelRoomSettings.stageModelLightId[0][0][v57 + *(_DWORD *)v53];
        v60 = v5->pModel[v23]->m_pMaterial[v54].m_pLightManager;
        v61 = v60->m_pLightNodeList;
        if ( v61 )
        {
          if ( v59 != -1 )
          {
            while ( v61->m_light.m_nId != v59 )
            {
              v61 = v61->next;
              if ( !v61 )
                goto LABEL_56;
            }
          }
          if ( v61->m_light.m_bOn != 1 )
          {
            ++v60->m_activeLightCount;
            v61->m_light.m_bOn = 1;
          }
        }
LABEL_56:
        v5->ModelRoomSettings.stageModelLightOn[0][0][v57 + *(_DWORD *)v53] = 1;
        v62 = *(_DWORD *)v55;
        v63 = v5->pModel[v23]->m_pMaterial[v54].m_pLightManager->m_pLightNodeList;
        if ( v63 )
        {
          if ( v62 != -1 )
          {
            while ( v63->m_light.m_nId != v62 )
            {
              v63 = v63->next;
              if ( !v63 )
                goto LABEL_60;
            }
          }
        }
        else
        {
LABEL_60:
          v63 = 0i64;
        }
        v64 = v56[5];
        v65 = v56[4];
        v63->m_light.m_fDirection[0] = v56[3];
        v63->m_light.m_fDirection[1] = v65;
        v63->m_light.m_fDirection[2] = v64;
        v66 = v57 + *(_DWORD *)v53;
        v67 = v5->ModelRoomStageModelLightSettings[0][0][v66].position[2];
        v68 = v5->ModelRoomStageModelLightSettings[0][0][v66].position[1];
        v69 = v5->ModelRoomStageModelLightSettings[0][0][v66].position[3];
        v63->m_light.m_fPosition[0] = v5->ModelRoomStageModelLightSettings[0][0][v66].position[0];
        v63->m_light.m_fPosition[1] = v68;
        v63->m_light.m_fPosition[2] = v67;
        v63->m_light.m_fPosition[3] = v69;
        v70 = v57 + *(_DWORD *)v53;
        v71 = v5->ModelRoomStageModelLightSettings[0][0][v70].position[0];
        v72 = v5->ModelRoomStageModelLightSettings[0][0][v70].position[2];
        v63->m_light.m_fLocalOffset[1] = v5->ModelRoomStageModelLightSettings[0][0][v70].position[1];
        v63->m_light.m_fLocalOffset[2] = v72;
        v63->m_light.m_fLocalOffset[0] = v71;
        *(_OWORD *)v63->m_light.m_fDiffuse = *(_OWORD *)(v56 + 6);
        v63->m_light.m_fIntensity = v56[12];
        v73 = *((_DWORD *)v56 - 3);
        if ( v73 < 4 )
          v63->m_light.m_LightType = v73;
        ++v52;
        v63->m_light.m_bCastsShadows = *((_BYTE *)v56 + 52);
        v55 = (int (*)[64][3])((char *)v55 + 12);
        v57 += 3i64;
        v63->m_light.m_fConeAngleRad = v56[10];
        ++v54;
        v63->m_light.m_fPenumbraRad = v56[11];
        v63->m_light.m_bEmitSpecular = *((_BYTE *)v56 + 53);
        v63->m_light.m_bEmitDiffuse = *((_BYTE *)v56 + 54);
        v74 = *((_DWORD *)v56 - 2);
        v56 += 51;
        v63->m_light.m_DecayRate = v74;
        ++*(_DWORD *)v53;
        v53 = (int (*)[64])((char *)v53 + 4);
      }
      while ( v52 < v5->pModel[v23]->m_ucMaterialCount );
      v24 = v88;
    }
    v16 = v79;
    v22 = v76;
    p_numMaterials = v87;
LABEL_66:
    ++numStageModelLights;
    p_numMaterials += 7938;
    ++stageModelLightId;
    v24 += 64i64;
    v22 += 192i64;
    v87 = p_numMaterials;
    v16 += 3264;
    v88 = v24;
    ++v23;
    v76 = v22;
    v75 = v81-- == 1;
    v79 = v16;
  }
  while ( !v75 );
}

void __fastcall AppMain::SetUpTPose(AppMain *this)
{
  float fCamElevation; // xmm6_4
  float cameraAngle; // xmm8_4
  float cameraHeight; // xmm10_4
  float v5; // xmm9_4
  float v6; // xmm0_4
  float v7; // xmm1_4
  void *v8; // rdx
  int v9; // er8
  __int64 v10; // r9
  int v11; // er8
  __int64 v12; // rdx
  OGLModel *v13; // rcx
  int v14; // er8
  __int64 v15; // rdx
  int v16; // er8
  __int64 v17; // rdx
  int v18; // er8
  __int64 v19; // rdx
  float x; // xmm0_4
  float z; // xmm2_4
  float v22; // xmm1_4
  OGLModel **Myval2; // rax
  OGLModel *v24; // rcx
  __int128 v25; // xmm0
  __int128 v26; // xmm1
  OGLModel *v27; // rbx
  OGLFigure *m_pFigure; // rax
  int m_uiBoneCount; // ecx
  int v30; // er10
  __int64 v31; // r11
  unsigned __int8 **p_m_cName; // r8
  __int64 v33; // rcx
  unsigned __int8 v34; // al
  __m128 v35; // xmm6
  __m128 x_low; // xmm0
  __m128 y_low; // xmm1
  float v38; // xmm2_4
  float v39; // xmm2_4
  __int128 v40; // xmm8
  __int128 v41; // xmm9
  __int128 v42; // xmm10
  __int128 v43; // xmm11
  float v44; // xmm0_4
  float v45; // xmm2_4
  float v46; // xmm1_4
  OGLModel **v47; // rax
  OGLModel *v48; // rcx
  OGLFigure *v49; // rax
  _OGLModelBone *m_pBoneInfo; // rax
  OGLModel *v51; // rcx
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  OGLModel *v54; // rbx
  OGLFigure *v55; // rax
  int v56; // ecx
  int v57; // er10
  __int64 v58; // r11
  unsigned __int8 **v59; // r8
  __int64 v60; // rcx
  unsigned __int8 v61; // al
  __m128 v62; // xmm0
  __m128 v63; // xmm1
  float v64; // xmm2_4
  float v65; // xmm2_4
  __int64 v66; // xmm0_8
  float v67; // xmm1_4
  float v68; // xmm2_4
  OGLModel **v69; // rax
  OGLModel *v70; // rcx
  __int128 v71; // xmm0
  __int128 v72; // xmm1
  OGLModel *v73; // rbx
  OGLFigure *v74; // rax
  int v75; // ecx
  int v76; // er10
  __int64 v77; // r11
  unsigned __int8 **v78; // r8
  __int64 v79; // rcx
  unsigned __int8 v80; // al
  float v81; // eax
  __int64 v82; // xmm0_8
  float v83; // xmm2_4
  float v84; // xmm0_4
  float v85; // xmm1_4
  OGLModel **v86; // rax
  OGLModel *v87; // rcx
  OGLFigure *v88; // rax
  _OGLModelBone *v89; // rax
  OGLModel *v90; // rcx
  __int128 v91; // xmm0
  __int128 v92; // xmm1
  OGLModel *v93; // rbx
  OGLFigure *v94; // rax
  int v95; // ecx
  int v96; // er10
  __int64 v97; // r11
  unsigned __int8 **v98; // r8
  __int64 v99; // rcx
  unsigned __int8 v100; // al
  __m128 v101; // xmm1
  float v102; // xmm0_4
  float v103; // eax
  OGLRender *m_pRender; // rax
  OGLRender *v105; // rax
  OGLRender *v106; // rax
  OGLRender *v107; // rax
  OGLVec3 trans; // [rsp+38h] [rbp-D0h] BYREF
  _BYTE v109[64]; // [rsp+48h] [rbp-C0h] BYREF
  OGLVec3 v110; // [rsp+88h] [rbp-80h] BYREF
  __int128 v111; // [rsp+98h] [rbp-70h]
  __int128 v112; // [rsp+A8h] [rbp-60h]
  __int128 v113; // [rsp+B8h] [rbp-50h]
  __int128 v114; // [rsp+C8h] [rbp-40h]

  fCamElevation = this->ModelRoomSettings.fCamElevation;
  cameraAngle = this->ModelRoomSettings.cameraAngle;
  cameraHeight = this->ModelRoomSettings.cameraHeight;
  this->ModelRoomSettings.fCamPos[1] = cameraHeight;
  v5 = sinf(fCamElevation) * this->ModelRoomSettings.cameraDist;
  this->ModelRoomSettings.fCamLook[0] = (float)(sinf(cameraAngle) * v5) + this->ModelRoomSettings.fCamPos[0];
  this->ModelRoomSettings.fCamLook[1] = (float)(cosf(fCamElevation) * this->ModelRoomSettings.cameraDist) + cameraHeight;
  v6 = cosf(cameraAngle);
  v7 = this->ModelRoomSettings.fCamPos[2];
  this->ModelRoomSettings.fCamUp[0] = 0.0;
  *(_QWORD *)&this->ModelRoomSettings.fCamUp[1] = 1065353216i64;
  this->ModelRoomSettings.fCamLook[2] = v7 - (float)(v6 * v5);
  AppMain::setRenderCamera(
    this,
    v8,
    v9,
    this->ModelRoomSettings.fCamPos,
    this->ModelRoomSettings.fCamLook,
    this->ModelRoomSettings.fCamUp);
  AppMain::updateGameLights(this, this->ModelRoomSettings.fCamPos, this->ModelRoomSettings.fCamUp, 0);
  v11 = 0;
  v111 = 0ui64;
  v112 = 0ui64;
  v113 = 0ui64;
  v114 = 0ui64;
  if ( this->ModelRoomSettings.CharaInfo[0].iModelCount > 0 )
  {
    v12 = 0i64;
    do
    {
      ++v12;
      ++v11;
      v13 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v12 - 1];
      v13->m_zOffset = this->ModelRoomSettings.ZOffsetP1;
      v13->m_shadowTextureId = 0;
      this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v12 - 1]->m_normalMapCreateFlg = 1;
      this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v12 - 1]->m_createMaskFlg = 1;
      this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v12 - 1]->m_bProjectionBlend = 1;
    }
    while ( v11 < this->ModelRoomSettings.CharaInfo[0].iModelCount );
  }
  v14 = 0;
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v15 = 0i64;
    do
    {
      ++v15;
      ++v14;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v15 - 1]->m_shadowTextureId = 0;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v15 - 1]->m_normalMapCreateFlg = 1;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v15 - 1]->m_createMaskFlg = 1;
      this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v15 - 1]->m_bProjectionBlend = 1;
    }
    while ( v14 < this->ModelRoomSettings.CharaInfo[2].iModelCount );
  }
  v16 = 0;
  if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
  {
    v17 = 0i64;
    do
    {
      ++v17;
      ++v16;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v17 - 1]->m_shadowTextureId = 1;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v17 - 1]->m_normalMapCreateFlg = 1;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v17 - 1]->m_createMaskFlg = 1;
      this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v17 - 1]->m_bProjectionBlend = 1;
    }
    while ( v16 < this->ModelRoomSettings.CharaInfo[1].iModelCount );
  }
  v18 = 0;
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v19 = 0i64;
    do
    {
      ++v19;
      ++v18;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v19 - 1]->m_shadowTextureId = 1;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v19 - 1]->m_normalMapCreateFlg = 1;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v19 - 1]->m_createMaskFlg = 1;
      this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v19 - 1]->m_bProjectionBlend = 1;
    }
    while ( v18 < this->ModelRoomSettings.CharaInfo[3].iModelCount );
  }
  x = this->ModelRoomSettings.CharaInfo[0].vPos.x;
  z = this->ModelRoomSettings.CharaInfo[0].vPos.z;
  v22 = this->ModelRoomSettings.CharaInfo[0].vPos.y + 10.0;
  *(_QWORD *)&v109[56] = 0i64;
  memset(v109, 0, 56);
  Myval2 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2;
  *(float *)&v109[48] = x;
  *(float *)&v109[52] = v22;
  *(_DWORD *)v109 = 1065353216;
  v24 = *Myval2;
  *(_DWORD *)&v109[20] = 1065353216;
  *(_DWORD *)&v109[40] = 1065353216;
  *(float *)&v109[56] = z;
  v24->m_vPosition.x = x;
  *(_OWORD *)v24->m_mWorld.m = *(_OWORD *)v109;
  v24->m_bPostureChange = 1;
  v25 = *(_OWORD *)&v109[32];
  v24->m_vPosition.y = v22;
  *(_OWORD *)&v24->m_mWorld.m[4] = *(_OWORD *)&v109[16];
  *(_DWORD *)&v109[60] = 1065353216;
  v26 = *(_OWORD *)&v109[48];
  *(_OWORD *)&v24->m_mWorld.m[8] = v25;
  *(_OWORD *)&v24->m_mWorld.m[12] = v26;
  v24->m_vPosition.z = z;
  v27 = *this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2;
  m_pFigure = v27->m_pFigure;
  if ( m_pFigure )
  {
    m_uiBoneCount = m_pFigure->m_uiBoneCount;
    if ( m_uiBoneCount )
    {
      v30 = 0;
      if ( m_uiBoneCount > 0 )
      {
        v31 = (int)m_pFigure->m_uiBoneCount;
        p_m_cName = &m_pFigure->m_pBone->m_cName;
        v10 = 0i64;
        do
        {
          if ( *p_m_cName )
          {
            v33 = 0i64;
            while ( 1 )
            {
              v34 = (*p_m_cName)[v33++];
              if ( v34 != boneName[v33 - 1] )
                break;
              if ( v33 == 7 )
                goto LABEL_24;
            }
          }
          ++v30;
          ++v10;
          p_m_cName += 29;
        }
        while ( v10 < v31 );
      }
    }
  }
  v30 = -1;
LABEL_24:
  v35 = 0i64;
  x_low = 0i64;
  trans.x = 0.0;
  y_low = 0i64;
  trans.y = 0.0;
  v38 = 0.0;
  trans.z = 0.0;
  if ( v27->m_pFigure )
  {
    OGLModel::getBoneTrans(v27, v30, &trans, 0i64);
    v38 = trans.z;
    y_low = (__m128)LODWORD(trans.y);
    x_low = (__m128)LODWORD(trans.x);
  }
  x_low.m128_f32[0] = x_low.m128_f32[0] + this->ModelRoomSettings.CharaInfo[0].vPos.x;
  y_low.m128_f32[0] = y_low.m128_f32[0] + this->ModelRoomSettings.CharaInfo[0].vPos.y;
  v39 = v38 + this->ModelRoomSettings.CharaInfo[0].vPos.z;
  v40 = v114;
  v41 = v113;
  v42 = v112;
  v43 = v111;
  *(_QWORD *)&v27->m_vCenterPosition.x = _mm_unpacklo_ps(x_low, y_low).m128_u64[0];
  trans.z = v39;
  v27->m_vCenterPosition.z = v39;
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v44 = this->ModelRoomSettings.CharaInfo[2].vPos.x + 15.0;
    v45 = this->ModelRoomSettings.CharaInfo[2].vPos.z;
    v46 = this->ModelRoomSettings.CharaInfo[2].vPos.y + 10.0;
    *(_QWORD *)&v109[56] = 0i64;
    memset(v109, 0, 56);
    v47 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
    *(float *)&v109[48] = v44;
    *(float *)&v109[52] = v46;
    *(float *)&v109[56] = v45;
    v48 = *v47;
    *(_DWORD *)v109 = 1065353216;
    *(_DWORD *)&v109[20] = 1065353216;
    *(_DWORD *)&v109[40] = 1065353216;
    v49 = v48->m_pFigure;
    *(_DWORD *)&v109[60] = 1065353216;
    if ( v49 && (int)v49->m_uiBoneCount > 1 )
    {
      m_pBoneInfo = v48->m_pBoneInfo;
      *(_OWORD *)m_pBoneInfo[1].mTrans.m = v43;
      *(_OWORD *)&m_pBoneInfo[1].mTrans.m[4] = v42;
      *(_OWORD *)&m_pBoneInfo[1].mTrans.m[8] = v41;
      *(_OWORD *)&m_pBoneInfo[1].mTrans.m[12] = v40;
      v48->m_pBoneInfo[1].bChangeFlg = 1;
      v48->m_pBoneInfo[1].bTransFlg = 1;
    }
    v51 = *this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
    v51->m_vPosition.x = v44;
    *(_OWORD *)v51->m_mWorld.m = *(_OWORD *)v109;
    v51->m_bPostureChange = 1;
    v52 = *(_OWORD *)&v109[32];
    v51->m_vPosition.y = v46;
    *(_OWORD *)&v51->m_mWorld.m[4] = *(_OWORD *)&v109[16];
    v53 = *(_OWORD *)&v109[48];
    *(_OWORD *)&v51->m_mWorld.m[8] = v52;
    *(_OWORD *)&v51->m_mWorld.m[12] = v53;
    v51->m_vPosition.z = v45;
    v54 = *this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
    v55 = v54->m_pFigure;
    if ( v55 )
    {
      v56 = v55->m_uiBoneCount;
      if ( v56 )
      {
        v57 = 0;
        if ( v56 > 0 )
        {
          v58 = (int)v55->m_uiBoneCount;
          v59 = &v55->m_pBone->m_cName;
          v10 = 0i64;
          do
          {
            if ( *v59 )
            {
              v60 = 0i64;
              while ( 1 )
              {
                v61 = (*v59)[v60++];
                if ( v61 != boneName[v60 - 1] )
                  break;
                if ( v60 == 7 )
                  goto LABEL_41;
              }
            }
            ++v57;
            ++v10;
            v59 += 29;
          }
          while ( v10 < v58 );
        }
      }
    }
    v57 = -1;
LABEL_41:
    v62 = 0i64;
    trans.x = 0.0;
    v63 = 0i64;
    trans.y = 0.0;
    v64 = 0.0;
    trans.z = 0.0;
    if ( v54->m_pFigure )
    {
      OGLModel::getBoneTrans(v54, v57, &trans, 0i64);
      v64 = trans.z;
      v63 = (__m128)LODWORD(trans.y);
      v62 = (__m128)LODWORD(trans.x);
    }
    v62.m128_f32[0] = v62.m128_f32[0] + this->ModelRoomSettings.CharaInfo[2].vPos.x;
    v63.m128_f32[0] = v63.m128_f32[0] + this->ModelRoomSettings.CharaInfo[2].vPos.y;
    v65 = v64 + this->ModelRoomSettings.CharaInfo[2].vPos.z;
    trans.z = v65;
    *(_QWORD *)&v54->m_vCenterPosition.x = _mm_unpacklo_ps(v62, v63).m128_u64[0];
    v54->m_vCenterPosition.z = v65;
  }
  v66 = *(_QWORD *)&this->ModelRoomSettings.CharaInfo[1].vPos.x;
  trans.z = this->ModelRoomSettings.CharaInfo[1].vPos.z;
  *(_QWORD *)&v109[56] = 0i64;
  memset(v109, 0, 56);
  *(_QWORD *)&trans.x = v66;
  v67 = *(float *)&v66;
  v68 = *((float *)&v66 + 1) + 10.0;
  v69 = this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2;
  *(float *)&v109[56] = trans.z;
  *(_DWORD *)&v109[48] = v66;
  *(_DWORD *)v109 = 1065353216;
  v70 = *v69;
  *(_DWORD *)&v109[20] = 1065353216;
  *(_DWORD *)&v109[40] = 1065353216;
  *(float *)&v109[52] = *((float *)&v66 + 1) + 10.0;
  v70->m_vPosition.z = trans.z;
  *(_OWORD *)v70->m_mWorld.m = *(_OWORD *)v109;
  v70->m_bPostureChange = 1;
  v71 = *(_OWORD *)&v109[32];
  v70->m_vPosition.x = v67;
  *(_OWORD *)&v70->m_mWorld.m[4] = *(_OWORD *)&v109[16];
  *(_DWORD *)&v109[60] = 1065353216;
  v72 = *(_OWORD *)&v109[48];
  *(_OWORD *)&v70->m_mWorld.m[8] = v71;
  *(_OWORD *)&v70->m_mWorld.m[12] = v72;
  v70->m_vPosition.y = v68;
  v73 = *this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2;
  v74 = v73->m_pFigure;
  if ( v74 )
  {
    v75 = v74->m_uiBoneCount;
    if ( v75 )
    {
      v76 = 0;
      if ( v75 > 0 )
      {
        v77 = (int)v74->m_uiBoneCount;
        v78 = &v74->m_pBone->m_cName;
        v10 = 0i64;
        do
        {
          if ( *v78 )
          {
            v79 = 0i64;
            while ( 1 )
            {
              v80 = (*v78)[v79++];
              if ( v80 != boneName[v79 - 1] )
                break;
              if ( v79 == 7 )
                goto LABEL_55;
            }
          }
          ++v76;
          ++v10;
          v78 += 29;
        }
        while ( v10 < v77 );
      }
    }
  }
  v76 = -1;
LABEL_55:
  *(_QWORD *)&v110.x = 0i64;
  v110.z = 0.0;
  if ( v73->m_pFigure )
    OGLModel::getBoneTrans(v73, v76, &v110, 0i64);
  v81 = v110.z;
  *(_QWORD *)&v73->m_vCenterPosition.x = *(_QWORD *)&v110.x;
  v73->m_vCenterPosition.z = v81;
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v82 = *(_QWORD *)&this->ModelRoomSettings.CharaInfo[3].vPos.x;
    trans.z = this->ModelRoomSettings.CharaInfo[3].vPos.z;
    v83 = trans.z;
    *(_QWORD *)&v109[56] = 0i64;
    memset(v109, 0, 56);
    *(_QWORD *)&trans.x = v82;
    v84 = *(float *)&v82 + 15.0;
    v85 = trans.y + 10.0;
    v86 = this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
    *(float *)&v109[48] = v84;
    *(float *)&v109[52] = trans.y + 10.0;
    *(float *)&v109[56] = trans.z;
    v87 = *v86;
    *(_DWORD *)v109 = 1065353216;
    *(_DWORD *)&v109[20] = 1065353216;
    *(_DWORD *)&v109[40] = 1065353216;
    v88 = v87->m_pFigure;
    *(_DWORD *)&v109[60] = 1065353216;
    if ( v88 && (int)v88->m_uiBoneCount > 1 )
    {
      v89 = v87->m_pBoneInfo;
      *(_OWORD *)v89[1].mTrans.m = v43;
      *(_OWORD *)&v89[1].mTrans.m[4] = v42;
      *(_OWORD *)&v89[1].mTrans.m[8] = v41;
      *(_OWORD *)&v89[1].mTrans.m[12] = v40;
      v87->m_pBoneInfo[1].bChangeFlg = 1;
      v87->m_pBoneInfo[1].bTransFlg = 1;
    }
    v90 = *this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
    v90->m_vPosition.x = v84;
    *(_OWORD *)v90->m_mWorld.m = *(_OWORD *)v109;
    v90->m_bPostureChange = 1;
    v91 = *(_OWORD *)&v109[32];
    v90->m_vPosition.y = v85;
    *(_OWORD *)&v90->m_mWorld.m[4] = *(_OWORD *)&v109[16];
    v92 = *(_OWORD *)&v109[48];
    *(_OWORD *)&v90->m_mWorld.m[8] = v91;
    *(_OWORD *)&v90->m_mWorld.m[12] = v92;
    v90->m_vPosition.z = v83;
    v93 = *this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
    v94 = v93->m_pFigure;
    if ( v94 )
    {
      v95 = v94->m_uiBoneCount;
      if ( v95 )
      {
        v96 = 0;
        if ( v95 > 0 )
        {
          v97 = (int)v94->m_uiBoneCount;
          v98 = &v94->m_pBone->m_cName;
          v10 = 0i64;
          do
          {
            if ( *v98 )
            {
              v99 = 0i64;
              while ( 1 )
              {
                v100 = (*v98)[v99++];
                if ( v100 != boneName[v99 - 1] )
                  break;
                if ( v99 == 7 )
                  goto LABEL_72;
              }
            }
            ++v96;
            ++v10;
            v98 += 29;
          }
          while ( v10 < v97 );
        }
      }
    }
    v96 = -1;
LABEL_72:
    v101 = 0i64;
    trans.x = 0.0;
    v102 = 0.0;
    trans.y = 0.0;
    trans.z = 0.0;
    if ( v93->m_pFigure )
    {
      OGLModel::getBoneTrans(v93, v96, &trans, 0i64);
      v102 = trans.z;
      v101 = (__m128)LODWORD(trans.y);
      v35 = (__m128)LODWORD(trans.x);
    }
    v35.m128_f32[0] = v35.m128_f32[0] + this->ModelRoomSettings.CharaInfo[3].vPos.x;
    v101.m128_f32[0] = v101.m128_f32[0] + this->ModelRoomSettings.CharaInfo[3].vPos.y;
    trans.z = v102 + this->ModelRoomSettings.CharaInfo[3].vPos.z;
    v103 = trans.z;
    *(_QWORD *)&v93->m_vCenterPosition.x = _mm_unpacklo_ps(v35, v101).m128_u64[0];
    v93->m_vCenterPosition.z = v103;
  }
  if ( this->ModelRoomSettings.CharaInfo[0].iModelCount > 0 )
  {
    m_pRender = this->m_pRender;
    if ( m_pRender->m_RenderStackNo < 8 )
      m_pRender->m_RenderStackNo = 2;
    OGLRender::addStack(this->m_pRender, *this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2, 1.0, v10);
  }
  if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
  {
    v105 = this->m_pRender;
    if ( v105->m_RenderStackNo < 8 )
      v105->m_RenderStackNo = 2;
    OGLRender::addStack(this->m_pRender, *this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2, 1.0, v10);
  }
  if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
  {
    v106 = this->m_pRender;
    if ( v106->m_RenderStackNo < 8 )
      v106->m_RenderStackNo = 3;
    OGLRender::addStack(this->m_pRender, *this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2, 1.0, v10);
  }
  if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
  {
    v107 = this->m_pRender;
    if ( v107->m_RenderStackNo < 8 )
      v107->m_RenderStackNo = 3;
    OGLRender::addStack(this->m_pRender, *this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2, 1.0, v10);
  }
  AppMain::setupLightUniforms(this, -1);
}

void __fastcall AppMain::SetupWorldLights(AppMain *this)
{
  OGLRender *m_pRender; // rbx
  int *worldLightId; // r14
  bool *worldLightOn; // r12
  float *v5; // rbx
  int v6; // er15
  float *v7; // rsi
  int v8; // eax
  OGLRender *v9; // rdx
  OGLLightNode *v10; // rcx
  int v11; // edx
  OGLLightNode *v12; // rcx
  float v13; // eax
  float v14; // xmm1_4
  int v15; // eax
  OGLRender *v16; // rcx
  OGLRender *v17; // rcx
  OGLRender *v18; // rcx
  OGLRender *v19; // rdx
  int v20; // ecx
  OGLLightNode *m_pLightNodeList; // rax
  OGLRender *v22; // rax
  OGLRender *v23; // rax
  OGLRender *v24; // rax
  OGLRender *v25; // rax
  __int64 numWorldLights; // r8
  OGLLightNode *v27; // rdx
  int v28; // ecx
  float v29; // xmm0_4
  float v30; // xmm1_4
  int type; // eax
  OGLRender *v32; // rcx

  m_pRender = this->m_pRender;
  OGLLightManager::deleteAllLights(&m_pRender->m_WorldLightManager);
  OGLLightManager::clear(&m_pRender->m_WorldLightManager);
  worldLightId = this->ModelRoomSettings.worldLightId;
  this->ModelRoomSettings.worldLightId[0] = -1;
  worldLightOn = this->ModelRoomSettings.worldLightOn;
  this->ModelRoomSettings.worldLightOn[0] = 0;
  if ( this->ModelRoomSettings.worldLightData.numWorldLights <= 0 )
  {
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[0] = 5.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[1] = 60.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[2] = 105.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[3] = 1.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[0] = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[1] = -0.71700001;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[2] = -0.69700003;
    *(_OWORD *)this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].colour = _xmm;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].castsShadows = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].type = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].coneAngleRad = 0.78539801;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].penumbraRad = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].intensity = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitSpecular = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitDiffuse = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].decayRate = 0;
    this->ModelRoomSettings.worldLightId[this->ModelRoomSettings.numWorldLights] = OGLLightManager::addLight(&this->m_pRender->m_WorldLightManager);
    v19 = this->m_pRender;
    v20 = this->ModelRoomSettings.worldLightId[this->ModelRoomSettings.numWorldLights];
    m_pLightNodeList = v19->m_WorldLightManager.m_pLightNodeList;
    if ( m_pLightNodeList )
    {
      if ( v20 != -1 )
      {
        while ( m_pLightNodeList->m_light.m_nId != v20 )
        {
          m_pLightNodeList = m_pLightNodeList->next;
          if ( !m_pLightNodeList )
            goto LABEL_34;
        }
      }
      if ( m_pLightNodeList->m_light.m_bOn != 1 )
      {
        ++v19->m_WorldLightManager.m_activeLightCount;
        m_pLightNodeList->m_light.m_bOn = 1;
      }
    }
LABEL_34:
    this->ModelRoomSettings.worldLightOn[this->ModelRoomSettings.numWorldLights] = 1;
    v22 = this->m_pRender;
    v22->m_WorldLightManager.m_GroundShadowColour[0] = 0.0;
    v22->m_WorldLightManager.m_GroundShadowColour[1] = 0.029999999;
    v22->m_WorldLightManager.m_GroundShadowColour[2] = 0.059999999;
    this->m_pRender->m_WorldLightManager.m_GroundShadowColIntensity = 0.44;
    this->m_pRender->m_WorldLightManager.m_GroundShadowBias = 0.0;
    this->m_pRender->m_WorldLightManager.m_GroundShadowMaxStrength = 0.80000001;
    this->m_pRender->m_WorldLightManager.m_GroundShadowVisibility = 0.25;
    v23 = this->m_pRender;
    v23->m_WorldLightManager.m_BodySelfShadowColour[0] = 0.0;
    v23->m_WorldLightManager.m_BodySelfShadowColour[1] = 0.029999999;
    v23->m_WorldLightManager.m_BodySelfShadowColour[2] = 0.059999999;
    this->m_pRender->m_WorldLightManager.m_BodySelfShadowColIntensity = 0.44;
    this->m_pRender->m_WorldLightManager.m_BodySelfShadowVisibility = 0.25;
    this->m_pRender->m_WorldLightManager.m_BodySelfShadowMaxStrength = 0.94;
    this->m_pRender->m_WorldLightManager.m_BodySelfShadowBias = 0.012;
    this->m_pRender->m_WorldLightManager.m_BodySelfShadowHardEdge = 0.0;
    v24 = this->m_pRender;
    v24->m_WorldLightManager.m_SkinSelfShadowColour[0] = 0.0;
    v24->m_WorldLightManager.m_SkinSelfShadowColour[1] = 0.029999999;
    v24->m_WorldLightManager.m_SkinSelfShadowColour[2] = 0.059999999;
    this->m_pRender->m_WorldLightManager.m_SkinSelfShadowColIntensity = 0.44;
    this->m_pRender->m_WorldLightManager.m_SkinSelfShadowVisibility = 0.0;
    this->m_pRender->m_WorldLightManager.m_SkinSelfShadowMaxStrength = 1.0;
    this->m_pRender->m_WorldLightManager.m_SkinSelfShadowBias = 0.0064099999;
    this->m_pRender->m_WorldLightManager.m_SkinSelfShadowHardEdge = -0.40000001;
    this->m_pRender->m_WorldLightManager.m_ShadowBlur = 2;
    this->m_pRender->m_WorldLightManager.m_ShadowFXAA = 0;
    this->m_pRender->m_WorldLightManager.m_RimMultiplier = 0.050000001;
    this->m_pRender->m_WorldLightManager.m_RimStart = 0.56999999;
    this->m_pRender->m_WorldLightManager.m_RimEnd = 1.0;
    v25 = this->m_pRender;
    v25->m_WorldLightManager.m_RimColour[0] = 0.80000001;
    v25->m_WorldLightManager.m_RimColour[1] = 0.80000001;
    v25->m_WorldLightManager.m_RimColour[2] = 1.0;
    numWorldLights = this->ModelRoomSettings.numWorldLights;
    v27 = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
    v28 = this->ModelRoomSettings.worldLightId[numWorldLights];
    if ( v27 )
    {
      if ( v28 != -1 )
      {
        while ( v27->m_light.m_nId != v28 )
        {
          v27 = v27->next;
          if ( !v27 )
            goto LABEL_38;
        }
      }
    }
    else
    {
LABEL_38:
      v27 = 0i64;
    }
    v29 = this->ModelRoomWorldLightSettings[numWorldLights].direction[1];
    v30 = this->ModelRoomWorldLightSettings[numWorldLights].direction[2];
    v27->m_light.m_fDirection[0] = this->ModelRoomWorldLightSettings[numWorldLights].direction[0];
    v27->m_light.m_fDirection[1] = v29;
    v27->m_light.m_fDirection[2] = v30;
    *(_OWORD *)v27->m_light.m_fDiffuse = *(_OWORD *)this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].colour;
    v27->m_light.m_bCastsShadows = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].castsShadows;
    v27->m_light.m_fConeAngleRad = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].coneAngleRad;
    v27->m_light.m_fPenumbraRad = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].penumbraRad;
    v27->m_light.m_fIntensity = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].intensity;
    v27->m_light.m_bEmitSpecular = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitSpecular;
    v27->m_light.m_bEmitDiffuse = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitDiffuse;
    v27->m_light.m_DecayRate = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].decayRate;
    type = this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].type;
    if ( type < 4 )
      v27->m_light.m_LightType = type;
    v32 = this->m_pRender;
    ++this->ModelRoomSettings.numWorldLights;
    this->ModelRoomSettings.worldLightId[this->ModelRoomSettings.numWorldLights] = OGLLightManager::addLight(&v32->m_WorldLightManager);
    this->ModelRoomSettings.worldLightOn[this->ModelRoomSettings.numWorldLights] = 0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[0] = 100.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[1] = 60.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[2] = 50.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].position[3] = 1.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[0] = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[1] = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].direction[2] = 0.5;
    *(_OWORD *)this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].colour = _xmm;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].castsShadows = 0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].coneAngleRad = 1.5707999;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].penumbraRad = 0.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].intensity = 1.0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitSpecular = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].emitDiffuse = 1;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].decayRate = 0;
    this->ModelRoomWorldLightSettings[this->ModelRoomSettings.numWorldLights].type = 0;
  }
  else
  {
    v5 = &this->ModelRoomSettings.worldLightData.worldLightAssetData[0].groundShadowColour[2];
    v6 = 0;
    v7 = &this->ModelRoomWorldLightSettings[0].position[1];
    do
    {
      *(v7 - 1) = *(v5 - 14);
      *v7 = *(v5 - 13);
      v7[1] = *(v5 - 12);
      v7[2] = 1.0;
      v7[3] = *(v5 - 17);
      v7[4] = *(v5 - 16);
      v7[5] = *(v5 - 15);
      *(_OWORD *)(v7 + 6) = *(_OWORD *)(v5 - 11);
      *((_BYTE *)v7 + 52) = *((_BYTE *)v5 - 12);
      *(v7 - 3) = *(v5 - 18);
      v7[10] = *(v5 - 7);
      v7[11] = *(v5 - 6);
      v7[12] = *(v5 - 8);
      *((_BYTE *)v7 + 53) = *((_BYTE *)v5 - 20);
      *((_BYTE *)v7 + 54) = *((_BYTE *)v5 - 19);
      *(v7 - 2) = *(v5 - 4);
      v8 = OGLLightManager::addLight(&this->m_pRender->m_WorldLightManager);
      *worldLightId = v8;
      v9 = this->m_pRender;
      v10 = v9->m_WorldLightManager.m_pLightNodeList;
      if ( v10 )
      {
        if ( v8 != -1 )
        {
          while ( v10->m_light.m_nId != v8 )
          {
            v10 = v10->next;
            if ( !v10 )
              goto LABEL_10;
          }
        }
        if ( v10->m_light.m_bOn != 1 )
        {
          ++v9->m_WorldLightManager.m_activeLightCount;
          v10->m_light.m_bOn = 1;
        }
      }
LABEL_10:
      *worldLightOn = 1;
      v11 = *worldLightId;
      v12 = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
      if ( v12 )
      {
        if ( v11 != -1 )
        {
          while ( v12->m_light.m_nId != v11 )
          {
            v12 = v12->next;
            if ( !v12 )
              goto LABEL_14;
          }
        }
      }
      else
      {
LABEL_14:
        v12 = 0i64;
      }
      v13 = v7[3];
      v14 = v7[5];
      v12->m_light.m_fDirection[1] = v7[4];
      v12->m_light.m_fDirection[2] = v14;
      v12->m_light.m_fDirection[0] = v13;
      *(_OWORD *)v12->m_light.m_fDiffuse = *(_OWORD *)(v7 + 6);
      v12->m_light.m_bCastsShadows = *((_BYTE *)v7 + 52);
      v12->m_light.m_fConeAngleRad = v7[10];
      v12->m_light.m_fPenumbraRad = v7[11];
      v12->m_light.m_fIntensity = v7[12];
      v12->m_light.m_bEmitSpecular = *((_BYTE *)v7 + 53);
      v12->m_light.m_bEmitDiffuse = *((_BYTE *)v7 + 54);
      v12->m_light.m_DecayRate = *(OGLLight::DecayRate *)(v7 - 2);
      v15 = *((_DWORD *)v7 - 3);
      if ( v15 < 4 )
        v12->m_light.m_LightType = v15;
      if ( *((_BYTE *)v7 + 52) )
      {
        v16 = this->m_pRender;
        if ( v5 != (float *)8 )
        {
          v16->m_WorldLightManager.m_GroundShadowColour[0] = *(v5 - 2);
          v16->m_WorldLightManager.m_GroundShadowColour[1] = *(v5 - 1);
          v16->m_WorldLightManager.m_GroundShadowColour[2] = *v5;
        }
        this->m_pRender->m_WorldLightManager.m_GroundShadowColIntensity = v5[1];
        this->m_pRender->m_WorldLightManager.m_GroundShadowMaxStrength = v5[2];
        this->m_pRender->m_WorldLightManager.m_GroundShadowVisibility = v5[20];
        this->m_pRender->m_WorldLightManager.m_GroundShadowBias = 0.0;
        v17 = this->m_pRender;
        if ( v5 != (float *)-16i64 )
        {
          v17->m_WorldLightManager.m_BodySelfShadowColour[0] = v5[4];
          v17->m_WorldLightManager.m_BodySelfShadowColour[1] = v5[5];
          v17->m_WorldLightManager.m_BodySelfShadowColour[2] = v5[6];
        }
        this->m_pRender->m_WorldLightManager.m_BodySelfShadowColIntensity = v5[7];
        this->m_pRender->m_WorldLightManager.m_BodySelfShadowVisibility = v5[18];
        this->m_pRender->m_WorldLightManager.m_BodySelfShadowBias = v5[8];
        this->m_pRender->m_WorldLightManager.m_BodySelfShadowMaxStrength = v5[9];
        this->m_pRender->m_WorldLightManager.m_BodySelfShadowHardEdge = v5[21];
        v18 = this->m_pRender;
        if ( v5 != (float *)-40i64 )
        {
          v18->m_WorldLightManager.m_SkinSelfShadowColour[0] = v5[10];
          v18->m_WorldLightManager.m_SkinSelfShadowColour[1] = v5[11];
          v18->m_WorldLightManager.m_SkinSelfShadowColour[2] = v5[12];
        }
        this->m_pRender->m_WorldLightManager.m_SkinSelfShadowColIntensity = v5[13];
        this->m_pRender->m_WorldLightManager.m_SkinSelfShadowVisibility = v5[19];
        this->m_pRender->m_WorldLightManager.m_SkinSelfShadowBias = v5[14];
        this->m_pRender->m_WorldLightManager.m_SkinSelfShadowMaxStrength = v5[15];
        this->m_pRender->m_WorldLightManager.m_SkinSelfShadowHardEdge = v5[22];
        this->m_pRender->m_WorldLightManager.m_ShadowBlur = (int)v5[16];
        this->m_pRender->m_WorldLightManager.m_ShadowFXAA = *((_BYTE *)v5 + 68);
      }
      ++this->ModelRoomSettings.numWorldLights;
      ++v6;
      ++worldLightId;
      ++worldLightOn;
      v7 += 17;
      v5 += 41;
    }
    while ( v6 < this->ModelRoomSettings.worldLightData.numWorldLights );
  }
}

void __fastcall AppMain::SimpleBoxBlurEffect(AppMain *this, OGLTexture *pDestTexture, float blurStrength)
{
  float v5; // xmm0_4
  float m_iScreenH; // xmm1_4

  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Box Blur");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 8, "Box Blur");
  ++markerCount;
  if ( pDestTexture )
  {
    v5 = 1.0 / (float)this->m_iScreenW;
    this->ModelRoomSettings.postfxUniforms.u_postfxBlurSize = (int)blurStrength;
    m_iScreenH = (float)this->m_iScreenH;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.x = v5;
    this->ModelRoomSettings.postfxUniforms.u_postfxPixelSize.y = 1.0 / m_iScreenH;
    AppMain::RenderFullScreenToTexture(this, 7946, pDestTexture, pDestTexture, 1);
    if ( _glewPopGroupMarkerEXT )
      _glewPopGroupMarkerEXT();
    if ( _glewPopDebugGroup )
      _glewPopDebugGroup();
    --markerCount;
  }
}

std::string *__fastcall extension::FutureObjectJobManager<extension::exsound_detail::SoundBankImpl,void>::Stringize(
        std::string *result,
        const void *__formal)
{
  std::string *v2; // rax

  result->_Mypair._Myval2._Myres = 15i64;
  v2 = result;
  result->_Mypair._Myval2._Mysize = 0i64;
  result->_Mypair._Myval2._Bx._Buf[0] = 0;
  return v2;
}

bool __fastcall AppMain::SwitchBackToGameLights(AppMain *this, int charId)
{
  __int64 v2; // rbp
  AppMain *v3; // rbx
  bool result; // al
  bool v5; // r11
  int numP2Lights; // eax
  __int64 v7; // r13
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // r8
  _DWORD *v11; // rsi
  int v12; // er10
  float *v13; // rdx
  float *v14; // rdi
  __int64 v15; // r9
  int v16; // edx
  __int64 v17; // r8
  __int64 v18; // r14
  __int64 v19; // rcx
  __int64 v20; // rbp
  int v21; // er15
  __int64 v22; // r12
  __int64 v23; // rsi
  int j; // ecx
  __int64 v25; // rdx
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // r11
  __int64 v30; // rcx
  float *v31; // r10
  float *v32; // r8
  char *v33; // rdi
  int *v34; // rbx
  int v35; // ecx
  __int64 v36; // rdx
  __int64 v37; // rax
  int v38; // er9
  __int64 v39; // rdx
  int v40; // xmm1_4
  int v41; // eax
  int v42; // eax
  int v43; // xmm3_4
  int v44; // xmm2_4
  int v45; // eax
  int v46; // xmm1_4
  int v47; // eax
  int v48; // eax
  __int64 v49; // rax
  int v50; // er13
  __int64 v51; // r12
  __int64 v52; // rcx
  __int64 v53; // rbp
  int v54; // er14
  __int64 v55; // r15
  __int64 v56; // rsi
  int i; // ecx
  __int64 v58; // rdx
  __int64 v59; // rdx
  __int64 v60; // rax
  __int64 v61; // rax
  int v62; // edi
  __int64 v63; // rcx
  float *v64; // r10
  float *v65; // r8
  bool *v66; // r11
  int *v67; // rbx
  int v68; // ecx
  __int64 v69; // rdx
  __int64 v70; // rax
  int v71; // er9
  __int64 v72; // rdx
  int v73; // xmm1_4
  int v74; // eax
  int v75; // eax
  int v76; // xmm3_4
  int v77; // xmm2_4
  int v78; // eax
  int v79; // xmm1_4
  int v80; // eax
  int v81; // eax
  __int64 v82; // r9
  OGLModel **Myval2; // r8
  float v84; // eax
  OGLModel *v85; // rcx
  OGLModel *v86; // rcx
  OGLModel *v87; // rdx
  float *v88; // [rsp+0h] [rbp-98h]
  __int64 v89; // [rsp+8h] [rbp-90h]
  __int64 v90; // [rsp+10h] [rbp-88h]
  __int64 v91; // [rsp+10h] [rbp-88h]
  float *v92; // [rsp+18h] [rbp-80h]
  _DWORD *v93; // [rsp+20h] [rbp-78h]
  __int64 v94; // [rsp+28h] [rbp-70h]
  __int64 v95; // [rsp+28h] [rbp-70h]
  __int64 v96; // [rsp+30h] [rbp-68h]
  __int64 v97; // [rsp+30h] [rbp-68h]
  __int128 v98; // [rsp+38h] [rbp-60h]
  __int128 v99; // [rsp+38h] [rbp-60h]
  char v102; // [rsp+B0h] [rbp+18h]
  int v103; // [rsp+B8h] [rbp+20h]
  int v104; // [rsp+B8h] [rbp+20h]

  v2 = charId;
  v3 = this;
  if ( charId > 4 )
    return 0;
  v5 = 0;
  v102 = 0;
  if ( (charId & 0xFFFFFFFD) != 0 )
  {
    numP2Lights = this->ModelRoomSettings.worldLightData.numP2Lights;
    v7 = 1540124i64;
    v8 = 1540616i64;
    v9 = 1540640i64;
    v10 = 1540648i64;
  }
  else
  {
    numP2Lights = this->ModelRoomSettings.worldLightData.numP1Lights;
    v7 = 1539580i64;
    v8 = 1540072i64;
    v9 = 1540096i64;
    v10 = 1540104i64;
  }
  v11 = (_DWORD *)((char *)v3 + v9);
  v12 = 0;
  v89 = v7;
  v13 = (float *)((char *)v3 + v8);
  v88 = (float *)((char *)v3 + v8);
  v14 = (float *)((char *)v3 + v10);
  v92 = (float *)((char *)v3 + v10);
  v93 = v11;
  if ( numP2Lights <= 0 )
  {
    if ( v3->ModelRoomSettings.worldLightData.numCharLights <= 0 )
      goto LABEL_93;
    v49 = 56 * v2;
    v50 = 0;
    v104 = 0;
    v51 = v2;
    v97 = v2;
    v95 = v2;
    if ( v3->ModelRoomSettings.CharaInfo[v2].iModelCount <= 0 )
      goto LABEL_93;
    v52 = 0i64;
    v91 = 0i64;
    do
    {
      v53 = *(__int64 *)(*(char **)((char *)&v3->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2 + v49) + v52);
      if ( v53 )
      {
        v54 = 0;
        v55 = 0i64;
        if ( *(_BYTE *)(v53 + 8464) )
        {
          v56 = 0i64;
          do
          {
            for ( i = 0; i < 2; ++i )
            {
              v58 = *(_QWORD *)(v53 + 8456);
              if ( v58 )
              {
                v59 = *(_QWORD *)(v58 + v56 + 328);
                if ( v59 )
                {
                  v60 = *(_QWORD *)(v59 + 712);
                  if ( v60 )
                  {
                    if ( i != -1 )
                    {
                      while ( *(_DWORD *)v60 != i )
                      {
                        v60 = *(_QWORD *)(v60 + 288);
                        if ( !v60 )
                          goto LABEL_69;
                      }
                    }
                    v61 = *(_QWORD *)(v59 + 712);
                    if ( v61 )
                    {
                      if ( i != -1 )
                      {
                        while ( *(_DWORD *)v61 != i )
                        {
                          v61 = *(_QWORD *)(v61 + 288);
                          if ( !v61 )
                            goto LABEL_69;
                        }
                      }
                      if ( *(_BYTE *)(v61 + 4) )
                      {
                        --*(_DWORD *)(v59 + 4);
                        *(_BYTE *)(v61 + 4) = 0;
                      }
                    }
                  }
                }
              }
LABEL_69:
              ;
            }
            v62 = 0;
            if ( v3->ModelRoomSettings.worldLightData.numCharLights > 0 )
            {
              v63 = v55 + (v51 << 6);
              v102 = 1;
              HIDWORD(v99) = 1065353216;
              v64 = &this->ModelRoomSettings.worldLightData.charLightAssetData[0].direction[1];
              v65 = &v3->ModelRoomPlayerLightSettings[0][v63][0].direction[1];
              v66 = &v3->ModelRoomSettings.playerLightOn[0][0][2 * v63 + v63];
              v67 = v3->ModelRoomSettings.playerLightId[0][v63];
              do
              {
                *(v65 - 1) = *(v64 - 1);
                *v65 = *v64;
                v65[1] = v64[1];
                *(v65 - 5) = v64[2];
                *(v65 - 4) = v64[3];
                *(v65 - 3) = v64[4];
                *(float *)&v99 = v64[5];
                *(_QWORD *)((char *)&v99 + 4) = *((_QWORD *)v64 + 3);
                *(_OWORD *)(v65 + 2) = v99;
                v65[8] = v64[8];
                *(v65 - 7) = *(v64 - 2);
                *((_BYTE *)v65 + 36) = *((_BYTE *)v64 + 52);
                v65[6] = v64[9];
                v65[7] = v64[10];
                *((_BYTE *)v65 + 37) = *((_BYTE *)v64 + 44);
                *((_BYTE *)v65 + 38) = *((_BYTE *)v64 + 45);
                *(v65 - 6) = v64[12];
                v68 = *v67;
                v69 = *(_QWORD *)(v56 + *(_QWORD *)(v53 + 8456) + 328);
                v70 = *(_QWORD *)(v69 + 712);
                if ( v70 )
                {
                  if ( v68 != -1 )
                  {
                    while ( *(_DWORD *)v70 != v68 )
                    {
                      v70 = *(_QWORD *)(v70 + 288);
                      if ( !v70 )
                        goto LABEL_79;
                    }
                  }
                  if ( *(_BYTE *)(v70 + 4) != 1 )
                  {
                    ++*(_DWORD *)(v69 + 4);
                    *(_BYTE *)(v70 + 4) = 1;
                  }
                }
LABEL_79:
                *v66 = 1;
                v71 = *v67;
                v72 = *(_QWORD *)(*(_QWORD *)(v56 + *(_QWORD *)(v53 + 8456) + 328) + 712i64);
                if ( v72 )
                {
                  if ( v71 != -1 )
                  {
                    while ( *(_DWORD *)v72 != v71 )
                    {
                      v72 = *(_QWORD *)(v72 + 288);
                      if ( !v72 )
                        goto LABEL_83;
                    }
                  }
                }
                else
                {
LABEL_83:
                  v72 = 0i64;
                }
                v73 = *((_DWORD *)v65 + 1);
                v74 = *((_DWORD *)v65 - 1);
                *(float *)(v72 + 100) = *v65;
                *(_DWORD *)(v72 + 104) = v73;
                *(_DWORD *)(v72 + 96) = v74;
                v75 = *((_DWORD *)v65 - 5);
                v76 = *((_DWORD *)v65 - 2);
                v77 = *((_DWORD *)v65 - 3);
                *(float *)(v72 + 72) = *(v65 - 4);
                *(_DWORD *)(v72 + 76) = v77;
                *(_DWORD *)(v72 + 80) = v76;
                *(_DWORD *)(v72 + 68) = v75;
                v78 = *((_DWORD *)v65 - 5);
                v79 = *((_DWORD *)v65 - 3);
                *(float *)(v72 + 88) = *(v65 - 4);
                *(_DWORD *)(v72 + 92) = v79;
                *(_DWORD *)(v72 + 84) = v78;
                *(_OWORD *)(v72 + 36) = *(_OWORD *)(v65 + 2);
                *(float *)(v72 + 136) = v65[8];
                v80 = *((_DWORD *)v65 - 7);
                if ( v80 < 4 )
                  *(_DWORD *)(v72 + 12) = v80;
                ++v62;
                *(_BYTE *)(v72 + 152) = *((_BYTE *)v65 + 36);
                ++v67;
                v64 += 41;
                *(float *)(v72 + 124) = v65[6];
                ++v66;
                *(float *)(v72 + 128) = v65[7];
                *(_BYTE *)(v72 + 154) = *((_BYTE *)v65 + 37);
                *(_BYTE *)(v72 + 153) = *((_BYTE *)v65 + 38);
                v81 = *((_DWORD *)v65 - 6);
                v65 += 17;
                *(_DWORD *)(v72 + 16) = v81;
              }
              while ( v62 < this->ModelRoomSettings.worldLightData.numCharLights );
              v51 = v97;
              v12 = 0;
              v3 = this;
            }
            ++v54;
            ++v55;
            v56 += 1128i64;
          }
          while ( v54 < *(unsigned __int8 *)(v53 + 8464) );
          v50 = v104;
          v52 = v91;
        }
      }
      v49 = v95 * 56;
      ++v50;
      v52 += 8i64;
      v104 = v50;
      v91 = v52;
    }
    while ( v50 < v3->ModelRoomSettings.CharaInfo[v95].iModelCount );
    goto LABEL_91;
  }
  v15 = 56 * v2;
  v16 = 0;
  v94 = v2;
  v103 = 0;
  v17 = v2;
  v96 = 56 * v2;
  v18 = numP2Lights;
  if ( v3->ModelRoomSettings.CharaInfo[v2].iModelCount > 0 )
  {
    v19 = 0i64;
    v90 = 0i64;
    do
    {
      v20 = *(__int64 *)(*(char **)((char *)&v3->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2 + v15) + v19);
      if ( v20 )
      {
        v21 = 0;
        v22 = 0i64;
        if ( *(_BYTE *)(v20 + 8464) )
        {
          v23 = 0i64;
          do
          {
            for ( j = 0; j < 2; ++j )
            {
              v25 = *(_QWORD *)(v20 + 8456);
              if ( v25 )
              {
                v26 = *(_QWORD *)(v23 + v25 + 328);
                if ( v26 )
                {
                  v27 = *(_QWORD *)(v26 + 712);
                  if ( v27 )
                  {
                    if ( j != -1 )
                    {
                      while ( *(_DWORD *)v27 != j )
                      {
                        v27 = *(_QWORD *)(v27 + 288);
                        if ( !v27 )
                          goto LABEL_27;
                      }
                    }
                    v28 = *(_QWORD *)(v26 + 712);
                    if ( v28 )
                    {
                      if ( j != -1 )
                      {
                        while ( *(_DWORD *)v28 != j )
                        {
                          v28 = *(_QWORD *)(v28 + 288);
                          if ( !v28 )
                            goto LABEL_27;
                        }
                      }
                      if ( *(_BYTE *)(v28 + 4) )
                      {
                        --*(_DWORD *)(v26 + 4);
                        *(_BYTE *)(v28 + 4) = 0;
                      }
                    }
                  }
                }
              }
LABEL_27:
              ;
            }
            v29 = 0i64;
            v102 = 1;
            v30 = v22 + (v17 << 6);
            HIDWORD(v98) = 1065353216;
            v31 = (float *)((char *)&v3->e + v7);
            v32 = &v3->ModelRoomPlayerLightSettings[0][v30][0].direction[1];
            v33 = (char *)this->ModelRoomSettings.modelLightData[27].matLightAssetData[56].lightAssetData[1].colour
                + 2 * v30
                + v30
                + 2;
            v34 = v3->ModelRoomSettings.playerLightId[0][v30];
            do
            {
              *(v32 - 1) = *(v31 - 1);
              *v32 = *v31;
              v32[1] = v31[1];
              *(v32 - 5) = v31[2];
              *(v32 - 4) = v31[3];
              *(v32 - 3) = v31[4];
              *(float *)&v98 = v31[5];
              *(_QWORD *)((char *)&v98 + 4) = *((_QWORD *)v31 + 3);
              *(_OWORD *)(v32 + 2) = v98;
              v32[8] = v31[8];
              *(v32 - 7) = *(v31 - 2);
              *((_BYTE *)v32 + 36) = *((_BYTE *)v31 + 52);
              *((_BYTE *)v32 + 37) = *((_BYTE *)v31 + 44);
              *((_BYTE *)v32 + 38) = *((_BYTE *)v31 + 45);
              *(v32 - 6) = v31[12];
              v32[6] = v31[9];
              v32[7] = v31[10];
              v35 = *v34;
              v36 = *(_QWORD *)(v23 + *(_QWORD *)(v20 + 8456) + 328);
              v37 = *(_QWORD *)(v36 + 712);
              if ( v37 )
              {
                if ( v35 != -1 )
                {
                  while ( *(_DWORD *)v37 != v35 )
                  {
                    v37 = *(_QWORD *)(v37 + 288);
                    if ( !v37 )
                      goto LABEL_36;
                  }
                }
                if ( *(_BYTE *)(v37 + 4) != 1 )
                {
                  ++*(_DWORD *)(v36 + 4);
                  *(_BYTE *)(v37 + 4) = 1;
                }
              }
LABEL_36:
              v33[v29 + 513555] = 1;
              v38 = *v34;
              v39 = *(_QWORD *)(*(_QWORD *)(v23 + *(_QWORD *)(v20 + 8456) + 328) + 712i64);
              if ( v39 )
              {
                if ( v38 != -1 )
                {
                  while ( *(_DWORD *)v39 != v38 )
                  {
                    v39 = *(_QWORD *)(v39 + 288);
                    if ( !v39 )
                      goto LABEL_40;
                  }
                }
              }
              else
              {
LABEL_40:
                v39 = 0i64;
              }
              v40 = *((_DWORD *)v32 + 1);
              v41 = *((_DWORD *)v32 - 1);
              *(float *)(v39 + 100) = *v32;
              *(_DWORD *)(v39 + 104) = v40;
              *(_DWORD *)(v39 + 96) = v41;
              v42 = *((_DWORD *)v32 - 5);
              v43 = *((_DWORD *)v32 - 2);
              v44 = *((_DWORD *)v32 - 3);
              *(float *)(v39 + 72) = *(v32 - 4);
              *(_DWORD *)(v39 + 76) = v44;
              *(_DWORD *)(v39 + 80) = v43;
              *(_DWORD *)(v39 + 68) = v42;
              v45 = *((_DWORD *)v32 - 5);
              v46 = *((_DWORD *)v32 - 3);
              *(float *)(v39 + 88) = *(v32 - 4);
              *(_DWORD *)(v39 + 92) = v46;
              *(_DWORD *)(v39 + 84) = v45;
              *(_OWORD *)(v39 + 36) = *(_OWORD *)(v32 + 2);
              *(float *)(v39 + 136) = v32[8];
              v47 = *((_DWORD *)v32 - 7);
              if ( v47 < 4 )
                *(_DWORD *)(v39 + 12) = v47;
              ++v29;
              *(_BYTE *)(v39 + 152) = *((_BYTE *)v32 + 36);
              ++v34;
              v31 += 41;
              *(float *)(v39 + 124) = v32[6];
              *(float *)(v39 + 128) = v32[7];
              *(_BYTE *)(v39 + 154) = *((_BYTE *)v32 + 37);
              *(_BYTE *)(v39 + 153) = *((_BYTE *)v32 + 38);
              v48 = *((_DWORD *)v32 - 6);
              v32 += 17;
              *(_DWORD *)(v39 + 16) = v48;
            }
            while ( v29 < v18 );
            v7 = v89;
            v12 = 0;
            v17 = v94;
            v3 = this;
            ++v21;
            ++v22;
            v23 += 1128i64;
          }
          while ( v21 < *(unsigned __int8 *)(v20 + 8464) );
          v19 = v90;
          v16 = v103;
          v15 = v96;
        }
      }
      ++v16;
      v19 += 8i64;
      v103 = v16;
      v90 = v19;
    }
    while ( v16 < *(int *)((char *)&v3->ModelRoomSettings.CharaInfo[0].iModelCount + v15) );
LABEL_91:
    LODWORD(v2) = charId;
    v11 = v93;
    v14 = v92;
    v5 = v102;
  }
  v13 = v88;
LABEL_93:
  v82 = (int)v2;
  if ( v3->ModelRoomSettings.CharaInfo[v82].iModelCount > 0 )
  {
    Myval2 = v3->ModelRoomSettings.CharaInfo[v82].ppModel._Mypair._Myval2;
    do
    {
      if ( *Myval2 )
      {
        if ( v13 )
        {
          v84 = *v13;
          v85 = *Myval2;
          v85->m_rimLightMax = v13[1];
          v85->m_rimLightMin = v84;
          v85->m_rimLightStrength = v13[2];
          v85->m_rimLightColour[0] = v13[3];
          v85->m_rimLightColour[1] = v13[4];
          v85->m_rimLightColour[2] = v13[5];
        }
        if ( v11 )
        {
          v86 = *Myval2;
          v86->m_shaderEyeDiffuseEmiStrength = *(float *)v11;
          v86->m_shaderLightDiffuseEmiStrength = (float)v11[1];
        }
        if ( v14 )
        {
          v87 = *Myval2;
          v87->m_bodySelfShadowDotRangeMinMax[0] = *v14;
          v87->m_bodySelfShadowDotRangeMinMax[1] = v14[1];
          v87->m_skinSelfShadowDotRangeMinMax[0] = v14[2];
          v87->m_skinSelfShadowDotRangeMinMax[1] = v14[3];
        }
      }
      v13 = v88;
      ++v12;
      ++Myval2;
    }
    while ( v12 < v3->ModelRoomSettings.CharaInfo[v82].iModelCount );
  }
  result = v5;
  v3->ModelRoomSettings.detachCameraFromLight = 0;
  return result;
}

char __fastcall AppMain::SwitchToCameraLights(AppMain *this, int charId, int settingId, bool bMirror)
{
  char v6; // cl
  int v7; // eax
  __int64 v8; // r11
  int v9; // ebp
  _DWORD *v10; // rsi
  __int64 v11; // r12
  __int64 v12; // rdi
  _DWORD *v13; // rbx
  _DWORD *v14; // r9
  __int64 v15; // r15
  int v16; // edx
  __int64 v17; // rcx
  __int64 v18; // rbp
  __int64 v19; // r14
  __int64 v20; // rsi
  int v21; // edx
  __int64 i; // r11
  __int64 v23; // rcx
  __int64 v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r9
  __int64 v28; // rdi
  __int64 v29; // rbx
  __int64 v30; // r8
  __int64 v31; // rcx
  __int64 v32; // rbx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rcx
  float v36; // eax
  float v37; // xmm1_4
  int type; // eax
  __int64 v39; // rcx
  __int64 v40; // rax
  int v41; // er8
  _QWORD *v42; // rdx
  int v43; // eax
  _DWORD *v44; // rcx
  _DWORD *v45; // rcx
  _DWORD *v46; // rcx
  int v47; // [rsp+0h] [rbp-88h]
  int v48; // [rsp+4h] [rbp-84h]
  int v49; // [rsp+8h] [rbp-80h]
  __int64 v50; // [rsp+10h] [rbp-78h]
  __int64 v51; // [rsp+18h] [rbp-70h]
  _DWORD *v52; // [rsp+20h] [rbp-68h]
  _DWORD *v53; // [rsp+28h] [rbp-60h]
  _DWORD *v54; // [rsp+30h] [rbp-58h]
  __int64 v55; // [rsp+38h] [rbp-50h]
  __int64 v56; // [rsp+40h] [rbp-48h]
  char v57; // [rsp+98h] [rbp+10h]
  int v58; // [rsp+A0h] [rbp+18h]

  v58 = settingId;
  if ( charId > 4 || settingId > 4 )
    return 0;
  v6 = 0;
  v57 = 0;
  if ( charId == 2 )
  {
    v7 = 0;
  }
  else
  {
    v7 = charId;
    if ( charId == 3 )
      v7 = 1;
  }
  v8 = 788i64 * v7;
  v51 = v8;
  if ( *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].numSettings + v8) <= 0 )
  {
LABEL_71:
    this->ModelRoomSettings.detachCameraFromLight = 1;
    return v6;
  }
  v9 = 0;
  v49 = 0;
  v10 = (_DWORD *)((char *)this->ModelRoomPlayerSpecialLightSettings[0].specialEmissionData + v8);
  v11 = charId;
  v12 = 56i64 * charId;
  v53 = v10;
  v13 = (_DWORD *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialShadowRangeData[0].skinSelfShadowDotRangeMin
                 + v8);
  v56 = v12;
  v54 = v13;
  v14 = (_DWORD *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialRimLightAssetData[0].rimLightColour[2]
                 + v8);
  v52 = v14;
  v15 = 788i64 * v7;
  v55 = -788i64 * v7;
  while ( *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].settingId + v15) != settingId
       || !*(&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].isValid + v15) )
  {
LABEL_69:
    ++v9;
    v14 += 6;
    v10 += 2;
    v49 = v9;
    v13 += 4;
    v52 = v14;
    v15 += 148i64;
    v53 = v10;
    v54 = v13;
    if ( v9 >= *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].numSettings + v8) )
    {
      v6 = v57;
      goto LABEL_71;
    }
  }
  v16 = 0;
  v48 = 0;
  if ( *(int *)((char *)&this->ModelRoomSettings.CharaInfo[0].iModelCount + v12) <= 0 )
  {
LABEL_58:
    v41 = 0;
    if ( *(int *)((char *)&this->ModelRoomSettings.CharaInfo[0].iModelCount + v12) > 0 )
    {
      v42 = *(OGLModel ***)((char *)&this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2 + v12);
      do
      {
        if ( *v42 )
        {
          if ( v14 != (_DWORD *)20 )
          {
            v43 = *(v14 - 5);
            v44 = (_DWORD *)*v42;
            v44[2239] = *(v14 - 4);
            v44[2238] = v43;
            v44[2240] = *(v14 - 3);
            v44[2241] = *(v14 - 2);
            v44[2242] = *(v14 - 1);
            v44[2243] = *v14;
          }
          if ( v10 )
          {
            v45 = (_DWORD *)*v42;
            v45[2245] = *v10;
            v45[2246] = v10[1];
          }
          if ( v13 != (_DWORD *)8 )
          {
            v46 = (_DWORD *)*v42;
            v46[2247] = *(v13 - 2);
            v46[2248] = *(v13 - 1);
            v46[2249] = *v13;
            v46[2250] = v13[1];
          }
        }
        ++v41;
        ++v42;
      }
      while ( v41 < *(int *)((char *)&this->ModelRoomSettings.CharaInfo[0].iModelCount + v12) );
    }
    settingId = v58;
    goto LABEL_69;
  }
  v17 = 0i64;
  v50 = 0i64;
  while ( 1 )
  {
    v18 = *(__int64 *)(*(char **)((char *)&this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2 + v12) + v17);
    if ( !v18 )
      return 0;
    v19 = 0i64;
    v47 = 0;
    if ( *(_BYTE *)(v18 + 8464) )
    {
      v20 = 0i64;
      do
      {
        v21 = 0;
        for ( i = 0i64; i < 2; ++i )
        {
          v23 = *(_QWORD *)(v18 + 8456);
          if ( v23 )
          {
            v24 = *(_QWORD *)(v23 + v20 + 328);
            if ( v24 )
            {
              v25 = *(_QWORD *)(v24 + 712);
              if ( v25 )
              {
                if ( i != -1 )
                {
                  while ( *(_DWORD *)v25 != v21 )
                  {
                    v25 = *(_QWORD *)(v25 + 288);
                    if ( !v25 )
                      goto LABEL_33;
                  }
                }
                v26 = *(_QWORD *)(v24 + 712);
                if ( v26 )
                {
                  if ( i != -1 )
                  {
                    while ( *(_DWORD *)v26 != v21 )
                    {
                      v26 = *(_QWORD *)(v26 + 288);
                      if ( !v26 )
                        goto LABEL_32;
                    }
                  }
                  if ( *(_BYTE *)(v26 + 4) )
                  {
                    --*(_DWORD *)(v24 + 4);
                    *(_BYTE *)(v26 + 4) = 0;
                  }
                }
LABEL_32:
                this->ModelRoomSettings.playerLightOn[0][0][128 * v11 + 64 * v11 + 2 * v19 + i + v19] = 0;
              }
            }
          }
LABEL_33:
          if ( *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].numLights + v15) > v21 )
          {
            v57 = 1;
            v27 = v15 + 68 * i;
            v28 = v19 + (v11 << 6);
            v29 = v28 + i + 2 * v28;
            v30 = v29;
            *(_QWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].direction = *(_QWORD *)((char *)this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].direction
                                                                                           + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].direction[2] = *(float *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].direction[2]
                                                                                  + v27);
            if ( bMirror )
              LODWORD(this->ModelRoomPlayerLightSettings[0][0][v30].direction[0]) ^= _xmm;
            this->ModelRoomPlayerLightSettings[0][0][v30].castsShadows = *(&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].castsShadows
                                                                         + v27);
            v31 = v55 + v51 + v15 + 68 * (i + 32039);
            *(_QWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].colour = *(ViewController **)((char *)&this->bv
                                                                                                 + v31);
            this->ModelRoomPlayerLightSettings[0][0][v30].colour[2] = *(float *)((char *)&this->e + v31);
            v32 = 68 * (v29 + 22822);
            *(float *)((char *)&this->bv + v32) = *(float *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].colour[4]
                                                           + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].decayRate = *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].decayRate
                                                                             + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].emitDiffuse = *(&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].emitDiffuse
                                                                        + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].emitSpecular = *(&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].emitSpecular
                                                                         + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].intensity = *(float *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].intensity
                                                                               + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].penumbraRad = *(float *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].penumbraRad
                                                                                 + v27);
            *(_QWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].position = *(_QWORD *)((char *)this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].position
                                                                                          + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].position[2] = *(float *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].position[2]
                                                                                 + v27);
            this->ModelRoomPlayerLightSettings[0][0][v30].type = *(int *)((char *)&this->ModelRoomPlayerSpecialLightSettings[0].specialLightData[0].lightData[0].type
                                                                        + v27);
            v33 = *(_QWORD *)(v18 + 8456);
            if ( v33 )
            {
              v34 = *(_QWORD *)(v33 + v20 + 328);
              if ( v34 )
              {
                v35 = *(_QWORD *)(v34 + 712);
                if ( v35 )
                {
                  if ( i != -1 )
                  {
                    while ( *(_DWORD *)v35 != v21 )
                    {
                      v35 = *(_QWORD *)(v35 + 288);
                      if ( !v35 )
                        goto LABEL_42;
                    }
                  }
                }
                else
                {
LABEL_42:
                  v35 = 0i64;
                }
                *(_BYTE *)(v35 + 152) = this->ModelRoomPlayerLightSettings[0][0][v30].castsShadows;
                *(_OWORD *)(v35 + 36) = *(_OWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].colour;
                *(_DWORD *)(v35 + 124) = *(_DWORD *)((char *)&this->bv + v32);
                *(_DWORD *)(v35 + 16) = this->ModelRoomPlayerLightSettings[0][0][v30].decayRate;
                v36 = this->ModelRoomPlayerLightSettings[0][0][v30].direction[0];
                v37 = this->ModelRoomPlayerLightSettings[0][0][v30].direction[2];
                *(float *)(v35 + 100) = this->ModelRoomPlayerLightSettings[0][0][v30].direction[1];
                *(float *)(v35 + 104) = v37;
                *(float *)(v35 + 96) = v36;
                *(_BYTE *)(v35 + 153) = this->ModelRoomPlayerLightSettings[0][0][v30].emitDiffuse;
                *(_BYTE *)(v35 + 154) = this->ModelRoomPlayerLightSettings[0][0][v30].emitSpecular;
                *(float *)(v35 + 136) = this->ModelRoomPlayerLightSettings[0][0][v30].intensity;
                *(float *)(v35 + 128) = this->ModelRoomPlayerLightSettings[0][0][v30].penumbraRad;
                *(_OWORD *)(v35 + 68) = *(_OWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].position;
                *(_QWORD *)(v35 + 84) = *(_QWORD *)this->ModelRoomPlayerLightSettings[0][0][v30].position;
                *(float *)(v35 + 92) = this->ModelRoomPlayerLightSettings[0][0][v30].position[2];
                type = this->ModelRoomPlayerLightSettings[0][0][v30].type;
                if ( type < 4 )
                  *(_DWORD *)(v35 + 12) = type;
                v39 = *(_QWORD *)(v20 + *(_QWORD *)(v18 + 8456) + 328);
                v40 = *(_QWORD *)(v39 + 712);
                if ( v40 )
                {
                  if ( i != -1 )
                  {
                    while ( *(_DWORD *)v40 != v21 )
                    {
                      v40 = *(_QWORD *)(v40 + 288);
                      if ( !v40 )
                        goto LABEL_52;
                    }
                  }
                  if ( *(_BYTE *)(v40 + 4) != 1 )
                  {
                    ++*(_DWORD *)(v39 + 4);
                    *(_BYTE *)(v40 + 4) = 1;
                  }
                }
LABEL_52:
                this->ModelRoomSettings.playerLightOn[0][0][2 * v28 + i + v28] = 1;
              }
            }
          }
          ++v21;
        }
        ++v19;
        v20 += 1128i64;
        ++v47;
      }
      while ( v47 < *(unsigned __int8 *)(v18 + 8464) );
      v12 = v56;
      v17 = v50;
      v16 = v48;
    }
    ++v16;
    v17 += 8i64;
    v48 = v16;
    v50 = v17;
    if ( v16 >= *(int *)((char *)&this->ModelRoomSettings.CharaInfo[0].iModelCount + v12) )
    {
      v14 = v52;
      v8 = v51;
      v13 = v54;
      v10 = v53;
      v9 = v49;
      goto LABEL_58;
    }
  }
}

void __fastcall AppMain::TextureCopyCS(AppMain *this, OGLTexture *pSrcTexture, OGLTexture *pDestTexture)
{
  if ( _glewPushGroupMarkerEXT )
    _glewPushGroupMarkerEXT(0, "Texture Copy");
  if ( _glewPushDebugGroup )
    _glewPushDebugGroup(0x824Au, 1u, 12, "Texture Copy");
  AppMain::ApplyShaderToTexture(
    this,
    7923,
    pSrcTexture,
    pDestTexture,
    (int)(float)*(int *)(*(_QWORD *)&AppMain::pApp + 28i64),
    *(_DWORD *)(*(_QWORD *)&AppMain::pApp + 32i64),
    1);
  if ( _glewPopGroupMarkerEXT )
    _glewPopGroupMarkerEXT();
  if ( _glewPopDebugGroup )
    _glewPopDebugGroup();
}

std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *__fastcall std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>::_Buynode0(
        std::_List_alloc<std::_List_base_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> > *this,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *_Next,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *_Prev)
{
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *result; // rax

  result = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)operator new(0x40ui64);
  if ( !_Next )
  {
    _Next = result;
    _Prev = result;
  }
  if ( result )
    result->_Next = _Next;
  if ( result != (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)-8i64 )
    result->_Prev = _Prev;
  return result;
}

std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *__fastcall std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>::_Buynode0(
        std::_List_alloc<std::_List_base_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >> > *this,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *_Next,
        std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *_Prev)
{
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *result; // rax

  result = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *)operator new(0x40ui64);
  if ( result )
    result->_Next = result;
  if ( result != (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *)-8i64 )
    result->_Prev = result;
  return result;
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<Image,extension::FutureImageOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<Image,extension::FutureImageOption>::Body>>>,0>>::_Check_size(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this)
{
  signed __int64 Mysize; // rax
  __int64 Maxidx; // rdx
  float v4; // xmm0_4
  float v5; // xmm1_4
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Prev; // rdi
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rbx
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >,bool> result; // [rsp+20h] [rbp-18h] BYREF

  Mysize = this->_List._Mypair._Myval2._Mysize;
  Maxidx = this->_Maxidx;
  v4 = (float)(int)Mysize;
  if ( Mysize < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)Maxidx;
  if ( Maxidx < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > this->_Traitsobj._Mypair._Myval2._Myval2 )
  {
    if ( (unsigned __int64)Maxidx >= 0x200 )
    {
      if ( (unsigned __int64)Maxidx < 0xFFFFFFFFFFFFFFFi64 )
        Maxidx *= 2i64;
    }
    else
    {
      Maxidx *= 8i64;
    }
    std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
      (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
      Maxidx);
    Myhead = this->_List._Mypair._Myval2._Myhead;
    if ( Myhead->_Next != Myhead )
    {
      Prev = Myhead->_Prev;
      do
      {
        Next = this->_List._Mypair._Myval2._Myhead->_Next;
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>,0>>::_Insert<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>(
          this,
          &result,
          &Next->_Myval,
          (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > >)Next);
      }
      while ( Next != Prev );
    }
  }
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>,0>>::_Destroy_if_not_nil(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > _Plist)
{
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // rcx

  _Plist._Ptr->_Prev->_Next = _Plist._Ptr->_Next;
  _Plist._Ptr->_Next->_Prev = _Plist._Ptr->_Prev;
  --this->_List._Mypair._Myval2._Mysize;
  m_ptr = _Plist._Ptr->_Myval.second.m_proxy.m_ptr;
  if ( m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    operator delete(m_ptr, 0x18ui64);
  std::string::~string((std::string *)&_Plist._Ptr->_Myval.first);
  operator delete(_Plist._Ptr);
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
        std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *this,
        unsigned __int64 _Buckets)
{
  unsigned __int64 v2; // rdi
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > _Val; // [rsp+50h] [rbp+8h] BYREF
  std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > result; // [rsp+58h] [rbp+10h] BYREF

  v2 = 2 * _Buckets;
  if ( this->_Vec._Mypair._Myval2._Myend - this->_Vec._Mypair._Myval2._Myfirst < 2 * _Buckets )
  {
    if ( v2 > 0x1FFFFFFFFFFFFFFFi64 )
      std::_Xlength_error("vector<T> too long");
    std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>::_Reallocate(
      &this->_Vec,
      v2);
  }
  _Val._Ptr = this->_List._Mypair._Myval2._Myhead;
  this->_Vec._Mypair._Myval2._Mylast = this->_Vec._Mypair._Myval2._Myfirst;
  std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>>>::_Insert_n(
    &this->_Vec,
    &result,
    (std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > >)this->_Vec._Mypair._Myval2._Myfirst,
    v2,
    &_Val);
  this->_Mask = _Buckets - 1;
  this->_Maxidx = _Buckets;
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>,0>>::_Init(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > >,0> > *this,
        unsigned __int64 _Buckets,
        __int64 a3,
        unsigned __int64 a4)
{
  std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > result; // [rsp+40h] [rbp+8h] BYREF
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > _Val; // [rsp+48h] [rbp+10h] BYREF

  _Val._Ptr = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *)_Buckets;
  if ( (unsigned __int64)(this->_Vec._Mypair._Myval2._Myend - this->_Vec._Mypair._Myval2._Myfirst) < 0x10 )
    std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>>>>::_Reallocate(
      &this->_Vec,
      _Buckets);
  _Val._Ptr = this->_List._Mypair._Myval2._Myhead;
  this->_Vec._Mypair._Myval2._Mylast = this->_Vec._Mypair._Myval2._Myfirst;
  std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>>>>::_Insert_n(
    &this->_Vec,
    &result,
    (std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > >)this->_Vec._Mypair._Myval2._Myfirst,
    a4,
    &_Val);
  this->_Mask = 7i64;
  this->_Maxidx = 8i64;
}

std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *__fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>>>::_Insert_n(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *result,
        std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > _Where,
        unsigned __int64 _Count,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Val)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *Myfirst; // r8
  signed __int64 v10; // r12
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *Mylast; // r14
  __int64 v12; // r14
  unsigned __int64 v13; // r15
  unsigned __int64 v14; // rdx
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v15; // rcx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v16; // rbx
  signed __int64 v17; // r14
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v18; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v19; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v20; // r9
  std::allocator<AgLogger *> *v21; // rcx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rbx
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v24; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v25; // rdx
  __int64 v26; // rcx
  unsigned __int64 v27; // r8
  std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *v28; // rax
  std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *Ptr; // rbx
  unsigned __int64 v30; // r15
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *i; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > _Pval; // [rsp+80h] [rbp+8h] BYREF
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *_Last; // [rsp+90h] [rbp+18h]
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v35; // [rsp+98h] [rbp+20h]

  _Last = _Where._Ptr;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v10 = _Where._Ptr - this->_Mypair._Myval2._Myfirst;
  if ( _Count )
  {
    Mylast = this->_Mypair._Myval2._Mylast;
    if ( this->_Mypair._Myval2._Myend - Mylast >= _Count )
    {
      if ( Mylast - _Where._Ptr >= _Count )
      {
        Ptr = _Val->_Ptr;
        v30 = _Count;
        this->_Mypair._Myval2._Mylast = std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
                                          &Mylast[-_Count],
                                          Mylast,
                                          Mylast,
                                          (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)_Count);
        memmove(&_Last[_Count], _Last, (size_t)Mylast - 8 * _Count - (_QWORD)_Last);
        for ( i = _Last; i != &_Last[v30]; ++i )
          i->_Ptr = Ptr;
      }
      else
      {
        _Pval._Ptr = _Val->_Ptr;
        v23 = 8 * _Count;
        std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
          _Where._Ptr,
          Mylast,
          &_Where._Ptr[_Count],
          (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)_Count);
        std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
          this->_Mypair._Myval2._Mylast,
          _Count - (this->_Mypair._Myval2._Mylast - _Last),
          &_Pval,
          v24);
        this->_Mypair._Myval2._Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)((char *)this->_Mypair._Myval2._Mylast + v23);
        v25 = _Last;
        v26 = 0i64;
        v27 = (unsigned __int64)((char *)&this->_Mypair._Myval2._Mylast[v23 / 0xFFFFFFFFFFFFFFF8ui64] - (char *)_Last + 7) >> 3;
        if ( _Last > &this->_Mypair._Myval2._Mylast[v23 / 0xFFFFFFFFFFFFFFF8ui64] )
          v27 = 0i64;
        if ( v27 )
        {
          v28 = _Pval._Ptr;
          do
          {
            v25->_Ptr = v28;
            ++v25;
            ++v26;
          }
          while ( v26 != v27 );
        }
      }
    }
    else
    {
      v12 = Mylast - Myfirst;
      if ( 0x1FFFFFFFFFFFFFFFi64 - v12 < _Count )
        std::_Xlength_error("vector<T> too long");
      v13 = v12 + _Count;
      v14 = this->_Mypair._Myval2._Myend - Myfirst;
      v15 = 0i64;
      if ( 0x1FFFFFFFFFFFFFFFi64 - (v14 >> 1) >= v14 )
        v15 = (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)(v14 + (v14 >> 1));
      if ( (unsigned __int64)v15 >= v13 )
        v13 = (unsigned __int64)v15;
      _Pval._Ptr = (std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *)v13;
      v16 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
              v15,
              v13);
      v35 = v16;
      v17 = _Last - this->_Mypair._Myval2._Myfirst;
      std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
        &v16[v17],
        _Count,
        _Val,
        v18);
      std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        this->_Mypair._Myval2._Myfirst,
        _Last,
        v16,
        v19);
      std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        _Last,
        this->_Mypair._Myval2._Mylast,
        &v16[v17 + _Count],
        v20);
      v22 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst + _Count;
      if ( this->_Mypair._Myval2._Myfirst )
        std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
          v21,
          (AgLogger **)this->_Mypair._Myval2._Myfirst,
          this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
      this->_Mypair._Myval2._Myend = &v16[v13];
      this->_Mypair._Myval2._Mylast = &v16[v22];
      this->_Mypair._Myval2._Myfirst = v16;
    }
  }
  result->_Ptr = &this->_Mypair._Myval2._Myfirst[v10];
  return result;
}

std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > *__fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>>>>::_Insert_n(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > *this,
        std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > *result,
        std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > _Where,
        unsigned __int64 _Count,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *_Val)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *Myfirst; // rcx
  __int64 v8; // r14
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *Mylast; // rsi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *Myend; // r9
  __int64 v11; // rsi
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v14; // rcx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v15; // rbx
  signed __int64 v16; // rsi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v17; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v18; // r9
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v19; // r9
  std::allocator<AgLogger *> *v20; // rcx
  signed __int64 v21; // rsi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v22; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *v23; // rdx
  __int64 v24; // rcx
  unsigned __int64 v25; // r8
  std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *v26; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *Ptr; // rbx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *i; // rcx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > _Pval; // [rsp+88h] [rbp+20h] BYREF

  _Pval._Ptr = (std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *)_Count;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v8 = _Where._Ptr - Myfirst;
  Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast;
  Myend = (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)this->_Mypair._Myval2._Myend;
  if ( (unsigned __int64)((Myend
                         - (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)Mylast) >> 3) >= 0x10 )
  {
    if ( (unsigned __int64)(((char *)Mylast - (char *)_Where._Ptr) >> 3) >= 0x10 )
    {
      Ptr = _Val->_Ptr;
      this->_Mypair._Myval2._Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(Mylast - 16, (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast, (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast, Myend);
      memmove(&_Where._Ptr[16], _Where._Ptr, (char *)Mylast - (char *)_Where._Ptr - 128);
      for ( i = _Where._Ptr; i != _Where._Ptr + 16; ++i )
        i->_Ptr = Ptr;
    }
    else
    {
      _Pval._Ptr = (std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *)_Val->_Ptr;
      std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
        (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)_Where._Ptr,
        Mylast,
        (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)&_Where._Ptr[16],
        Myend);
      std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
        (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast,
        16 - (this->_Mypair._Myval2._Mylast - _Where._Ptr),
        &_Pval,
        v22);
      this->_Mypair._Myval2._Mylast += 16;
      v23 = _Where._Ptr;
      v24 = 0i64;
      v25 = (unsigned __int64)((char *)&this->_Mypair._Myval2._Mylast[-16] - (char *)_Where._Ptr + 7) >> 3;
      if ( _Where._Ptr > &this->_Mypair._Myval2._Mylast[-16] )
        v25 = 0i64;
      if ( v25 )
      {
        v26 = _Pval._Ptr;
        do
        {
          v23->_Ptr = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> >,void *> *)v26;
          ++v23;
          ++v24;
        }
        while ( v24 != v25 );
      }
    }
  }
  else
  {
    v11 = ((char *)Mylast - (char *)Myfirst) >> 3;
    if ( (unsigned __int64)(0x1FFFFFFFFFFFFFFFi64 - v11) < 0x10 )
      std::_Xlength_error("vector<T> too long");
    v12 = v11 + 16;
    v13 = (Myend
         - (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)Myfirst) >> 3;
    v14 = 0i64;
    if ( 0x1FFFFFFFFFFFFFFFi64 - (v13 >> 1) >= v13 )
      v14 = (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)(v13 + (v13 >> 1));
    if ( (unsigned __int64)v14 >= v12 )
      v12 = (unsigned __int64)v14;
    _Pval._Ptr = (std::_List_node<std::pair<extension::SoundHashKey const ,int>,void *> *)v12;
    v15 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
            v14,
            v12);
    v16 = _Where._Ptr - this->_Mypair._Myval2._Myfirst;
    std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>> *,unsigned __int64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>(
      &v15[v16],
      0x10ui64,
      (const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)_Val,
      v17);
    std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Myfirst,
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)_Where._Ptr,
      v15,
      v18);
    std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)_Where._Ptr,
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast,
      &v15[v16 + 16],
      v19);
    v21 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst;
    if ( this->_Mypair._Myval2._Myfirst )
      std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
        v20,
        (AgLogger **)this->_Mypair._Myval2._Myfirst,
        this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myend = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)&v15[v12];
    this->_Mypair._Myval2._Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)&v15[v21 + 16];
    this->_Mypair._Myval2._Myfirst = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)v15;
  }
  result->_Ptr = &this->_Mypair._Myval2._Myfirst[v8];
  return result;
}

void __fastcall std::vector<extension::FutureAssetOptionFileSetting>::_Reallocate(
        std::vector<extension::FutureAssetOptionFileSetting> *this,
        unsigned __int64 _Count)
{
  extension::FutureAssetOptionFileSetting *v4; // rdi
  std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *v5; // r9
  extension::FutureAssetOptionFileSetting *Mylast; // r9
  signed __int64 v7; // rsi

  v4 = std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting>>::allocate(
         (std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *)this,
         _Count);
  std::_Uninitialized_move_al_unchecked1<extension::FutureAssetOptionFileSetting *,extension::FutureAssetOptionFileSetting *,std::allocator<extension::FutureAssetOptionFileSetting>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    v5);
  Mylast = this->_Mypair._Myval2._Mylast;
  v7 = Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Destroy_range1<std::allocator<extension::FutureAssetOptionFileSetting>,extension::FutureAssetOptionFileSetting *>(
      this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Mylast,
      (std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *)((unsigned __int64)((unsigned __int128)(((char *)this->_Mypair._Myval2._Mylast - (char *)this->_Mypair._Myval2._Myfirst) * (__int128)0x6666666666666667i64) >> 64) >> 63),
      (std::integral_constant<bool,0>)Mylast);
    std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting>>::deallocate(
      (std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *)((char *)this->_Mypair._Myval2._Myend
                                                                                   - (char *)this->_Mypair._Myval2._Myfirst),
      this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v7];
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>>>>>>>::_Reallocate(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        unsigned __int64 _Count)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v4; // rdi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v5; // r9
  std::allocator<AgLogger *> *v6; // rcx
  signed __int64 v7; // rsi

  v4 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
         (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)this,
         _Count);
  std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    v5);
  v7 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      v6,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v7];
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body>>>>>>>>::_Reallocate(
        std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > > > > *this,
        unsigned __int64 _Count)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *v3; // rdi
  std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *v4; // r9
  std::allocator<AgLogger *> *v5; // rcx
  signed __int64 v6; // rsi

  v3 = std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
         (std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *)this,
         0x10ui64);
  std::_Uninitialized_move_al_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCurve,void>::Body>>>>>>>>(
    (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Myfirst,
    (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)this->_Mypair._Myval2._Mylast,
    v3,
    v4);
  v6 = this->_Mypair._Myval2._Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      v5,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  this->_Mypair._Myval2._Myend = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)&v3[16];
  this->_Mypair._Myval2._Mylast = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)&v3[v6];
  this->_Mypair._Myval2._Myfirst = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMotion,void>::Body> > > > > *)v3;
}

void __fastcall std::vector<extension::FutureAssetOptionFileSetting>::_Reserve(
        std::vector<extension::FutureAssetOptionFileSetting> *this,
        unsigned __int64 _Count)
{
  extension::FutureAssetOptionFileSetting *Myend; // rcx
  extension::FutureAssetOptionFileSetting *Mylast; // r8
  signed __int64 v5; // rdx
  unsigned __int64 v6; // r8
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( !(Myend - Mylast) )
  {
    v5 = Mylast - this->_Mypair._Myval2._Myfirst;
    if ( v5 == 0x666666666666666i64 )
      std::_Xlength_error("vector<T> too long");
    v6 = v5 + 1;
    v7 = (unsigned __int128)(((char *)Myend - (char *)this->_Mypair._Myval2._Myfirst) * (__int128)0x6666666666666667i64) >> 64;
    v8 = 0i64;
    v9 = ((unsigned __int64)v7 >> 63) + (v7 >> 4);
    if ( 0x666666666666666i64 - (v9 >> 1) >= v9 )
      v8 = v9 + (v9 >> 1);
    if ( v8 >= v6 )
      v6 = v8;
    std::vector<extension::FutureAssetOptionFileSetting>::_Reallocate(this, v6);
  }
}

std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *__fastcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>>>>>>>>::allocate(
        std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > > > > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 v3; // rcx
  void *v4; // rax

  if ( !_Count )
    return 0i64;
  if ( _Count > 0x1FFFFFFFFFFFFFFFi64 )
    std::_Xbad_alloc();
  v3 = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
    return (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)operator new(v3);
  if ( v3 + 39 <= v3 )
    std::_Xbad_alloc();
  v4 = operator new(v3 + 39);
  *(_QWORD *)((((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64) - 8) = v4;
  return (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<extension::SoundHashKey const ,int> > > > *)(((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
}

extension::FutureAssetOptionFileSetting *__fastcall std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting>>::allocate(
        std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 v3; // rcx
  void *v4; // rax

  if ( !_Count )
    return 0i64;
  if ( _Count > 0x666666666666666i64 )
    std::_Xbad_alloc();
  v3 = 40 * _Count;
  if ( 40 * _Count < 0x1000 )
    return (extension::FutureAssetOptionFileSetting *)operator new(v3);
  if ( v3 + 39 <= v3 )
    std::_Xbad_alloc();
  v4 = operator new(v3 + 39);
  *(_QWORD *)((((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64) - 8) = v4;
  return (extension::FutureAssetOptionFileSetting *)(((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
}

void __fastcall std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body>>>::clear(
        std::list<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *this)
{
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rdi
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // rcx
  void **p_Myval; // rbx
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v5; // rsi
  unsigned __int64 Myres; // rax
  char *v7; // rcx
  char *v8; // rax
  unsigned __int64 v9; // rcx
  bool v10; // cf

  Next = this->_Mypair._Myval2._Myhead->_Next;
  this->_Mypair._Myval2._Myhead->_Next = this->_Mypair._Myval2._Myhead;
  this->_Mypair._Myval2._Myhead->_Prev = this->_Mypair._Myval2._Myhead;
  this->_Mypair._Myval2._Mysize = 0i64;
  if ( Next != this->_Mypair._Myval2._Myhead )
  {
    do
    {
      m_ptr = Next->_Myval.second.m_proxy.m_ptr;
      p_Myval = (void **)&Next->_Myval;
      v5 = Next->_Next;
      if ( m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
        operator delete(m_ptr, 0x18ui64);
      Myres = Next->_Myval.first._Mypair._Myval2._Myres;
      if ( Myres >= 0x10 )
      {
        v7 = (char *)*p_Myval;
        if ( Myres + 1 >= 0x1000 )
        {
          if ( ((unsigned __int8)v7 & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v8 = (char *)*((_QWORD *)v7 - 1);
          if ( v8 >= v7 )
            invalid_parameter_noinfo_noreturn();
          v9 = v7 - v8;
          if ( v9 < 8 )
            invalid_parameter_noinfo_noreturn();
          if ( v9 > 0x27 )
            invalid_parameter_noinfo_noreturn();
          v7 = v8;
        }
        operator delete(v7);
      }
      Next->_Myval.first._Mypair._Myval2._Myres = 15i64;
      v10 = Next->_Myval.first._Mypair._Myval2._Myres < 0x10;
      Next->_Myval.first._Mypair._Myval2._Mysize = 0i64;
      if ( !v10 )
        p_Myval = (void **)*p_Myval;
      *(_BYTE *)p_Myval = 0;
      operator delete(Next);
      Next = v5;
    }
    while ( v5 != this->_Mypair._Myval2._Myhead );
  }
}

void __fastcall std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
        std::allocator<AgLogger *> *this,
        AgLogger **_Ptr,
        unsigned __int64 _Count)
{
  AgLogger **v3; // rax
  char *v4; // rdx

  if ( _Count > 0x1FFFFFFFFFFFFFFFi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 8 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    v3 = (AgLogger **)*(_Ptr - 1);
    if ( v3 >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)v3);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = v3;
  }
  operator delete(_Ptr);
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *__fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>>,0>>::erase(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *result,
        std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > _Plist)
{
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *p_Myval; // r9
  unsigned __int64 Mysize; // r11
  unsigned __int64 v7; // rcx
  __int64 i; // rdx
  __int64 v9; // rax
  unsigned __int64 v10; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *v11; // rcx

  p_Myval = &_Plist._Ptr->_Myval;
  Mysize = _Plist._Ptr->_Myval.first._Mypair._Myval2._Mysize;
  if ( _Plist._Ptr->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
    p_Myval = (std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *)p_Myval->first._Mypair._Myval2._Bx._Ptr;
  v7 = 0i64;
  for ( i = 0xCBF29CE484222325ui64; v7 < Mysize; i = 0x100000001B3i64 * (v9 ^ i) )
    v9 = (unsigned __int8)p_Myval->first._Mypair._Myval2._Bx._Buf[v7++];
  v10 = 2 * (i & this->_Mask);
  v11 = &this->_Vec._Mypair._Myval2._Myfirst[v10];
  if ( v11[1]._Ptr == _Plist._Ptr )
  {
    if ( v11->_Ptr == _Plist._Ptr )
    {
      v11->_Ptr = this->_List._Mypair._Myval2._Myhead;
      this->_Vec._Mypair._Myval2._Myfirst[v10 + 1]._Ptr = this->_List._Mypair._Myval2._Myhead;
    }
    else
    {
      v11[1]._Ptr = _Plist._Ptr->_Prev;
    }
  }
  else if ( v11->_Ptr == _Plist._Ptr )
  {
    v11->_Ptr = _Plist._Ptr->_Next;
  }
  std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>::erase(
    &this->_List,
    result,
    _Plist);
  return result;
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *__fastcall std::list<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>::erase(
        std::list<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *result,
        std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > _Where)
{
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // rcx
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // [rsp+40h] [rbp+18h]

  Next = _Where._Ptr->_Next;
  _Where._Ptr->_Prev->_Next = _Where._Ptr->_Next;
  _Where._Ptr->_Next->_Prev = _Where._Ptr->_Prev;
  --this->_Mypair._Myval2._Mysize;
  m_ptr = _Where._Ptr->_Myval.second.m_proxy.m_ptr;
  if ( m_ptr && _InterlockedExchangeAdd64((volatile signed __int64 *)m_ptr, 0xFFFFFFFFFFFFFFFFui64) == 1 )
    operator delete(m_ptr, 0x18ui64);
  std::string::~string((std::string *)&_Where._Ptr->_Myval.first);
  operator delete(_Where._Ptr);
  result->_Ptr = Next;
  return result;
}

extension::RefCountablePtr<extension::BasicFutureObject<OGLMirror,void>::Body> *__fastcall extension::BasicFutureObject<OGLMirror,void>::AssetCache::getCachedOrLoadStart(
        extension::BasicFutureObject<OGLMirror,void>::AssetCache *this,
        extension::RefCountablePtr<extension::BasicFutureObject<OGLMirror,void>::Body> *result,
        std::string *name,
        const void *opt)
{
  volatile signed __int64 *v6; // rsi
  std::string *v7; // rax
  char *Ptr; // rcx
  char *v9; // rax
  unsigned __int64 v10; // rax
  bool v11; // r12
  std::string *v12; // rax
  std::string *v13; // rax
  char *v14; // rcx
  char *v15; // rax
  char *v16; // rcx
  char *v17; // rax
  const void *v18; // rdx
  unsigned __int64 Mysize; // rcx
  unsigned __int64 v20; // rbx
  unsigned __int64 Myres; // rdx
  std::string *p_Keyval; // rax
  std::string *v23; // rax
  std::string *v24; // rax
  extension::RCWeakPtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *v25; // rax
  extension::AsyncStatus::Step v26; // edx
  extension::BasicFutureObject<OGLMirror,void>::Body *m_ptr; // rcx
  extension::AsyncContent<OGLMirror> *v28; // rax
  extension::AsyncContent<OGLMirror> *v29; // rbx
  std::string *v30; // rcx
  std::string *v31; // rax
  std::string *v32; // rax
  std::string *v33; // rcx
  std::string *v34; // rax
  std::string *v35; // rax
  extension::BasicFutureObject<OGLMirror,void>::Body *v36; // rbx
  const void *v37; // r9
  extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > *v38; // rax
  extension::BasicFutureObject<OGLMirror,void>::Body *v39; // rcx
  extension::BasicFutureObject<OGLMirror,void>::Body *v40; // rax
  extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> *v41; // rax
  extension::BasicFutureObject<OGLMirror,void>::Body *v42; // rcx
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body> >,void *> *Next; // rbx
  std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > v44; // r8
  extension::RefCountableWeakSupportBase::WeakProxy *v45; // rax
  extension::BasicFutureObject<OGLMirror,void>::Body *v47; // [rsp+28h] [rbp-D8h]
  extension::RefCountableWeakSupportBase::WeakProxy *block; // [rsp+30h] [rbp-D0h]
  extension::RefCountablePtr<extension::AsyncContent<OGLMirror> > v49; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v50; // [rsp+40h] [rbp-C0h]
  extension::RefCountablePtr<extension::BasicFutureObject<OGLMirror,void>::Body> *v51; // [rsp+48h] [rbp-B8h]
  extension::BasicFutureObject<OGLMirror,void>::Body *v52; // [rsp+50h] [rbp-B0h]
  std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > v53; // [rsp+60h] [rbp-A0h] BYREF
  extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache> *v54; // [rsp+68h] [rbp-98h]
  int v55; // [rsp+70h] [rbp-90h]
  std::string *v56; // [rsp+78h] [rbp-88h]
  std::string _Keyval; // [rsp+80h] [rbp-80h] BYREF
  std::string v58; // [rsp+A0h] [rbp-60h] BYREF
  std::string _Right; // [rsp+C0h] [rbp-40h] BYREF
  std::string resulta; // [rsp+E0h] [rbp-20h] BYREF
  std::string v61; // [rsp+100h] [rbp+0h] BYREF
  std::string v62; // [rsp+120h] [rbp+20h] BYREF
  std::string v63; // [rsp+140h] [rbp+40h] BYREF
  std::string v64; // [rsp+160h] [rbp+60h] BYREF
  std::string v65; // [rsp+180h] [rbp+80h] BYREF

  v50 = -2i64;
  v51 = result;
  v56 = name;
  v6 = 0i64;
  v7 = extension::AsyncWorker::NormalizeAssetPath(&resulta, name);
  std::string::assign(name, v7);
  if ( resulta._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = resulta._Mypair._Myval2._Bx._Ptr;
    if ( resulta._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (resulta._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v9 = (char *)*((_QWORD *)resulta._Mypair._Myval2._Bx._Ptr - 1);
      if ( v9 >= resulta._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(resulta._Mypair._Myval2._Bx._Ptr - v9) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(resulta._Mypair._Myval2._Bx._Ptr - v9) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)resulta._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  v10 = std::string::find(name, "obm", 0i64, 3ui64);
  v11 = v10 != -1i64;
  if ( v10 != -1i64 )
  {
    v12 = std::string::substr(name, &v61, 0i64, name->_Mypair._Myval2._Mysize - 3);
    v13 = std::operator+<char>(&v58, v12, "dds");
    std::string::assign(name, v13);
    if ( v58._Mypair._Myval2._Myres >= 0x10 )
    {
      v14 = v58._Mypair._Myval2._Bx._Ptr;
      if ( v58._Mypair._Myval2._Myres + 1 >= 0x1000 )
      {
        if ( (v58._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
          invalid_parameter_noinfo_noreturn();
        v15 = (char *)*((_QWORD *)v58._Mypair._Myval2._Bx._Ptr - 1);
        if ( v15 >= v58._Mypair._Myval2._Bx._Ptr )
          invalid_parameter_noinfo_noreturn();
        if ( (char *)(v58._Mypair._Myval2._Bx._Ptr - v15) < (char *)8 )
          invalid_parameter_noinfo_noreturn();
        if ( (char *)(v58._Mypair._Myval2._Bx._Ptr - v15) > (char *)0x27 )
          invalid_parameter_noinfo_noreturn();
        v14 = (char *)*((_QWORD *)v58._Mypair._Myval2._Bx._Ptr - 1);
      }
      operator delete(v14);
    }
    v58._Mypair._Myval2._Myres = 15i64;
    v58._Mypair._Myval2._Mysize = 0i64;
    v58._Mypair._Myval2._Bx._Buf[0] = 0;
    if ( v61._Mypair._Myval2._Myres >= 0x10 )
    {
      v16 = v61._Mypair._Myval2._Bx._Ptr;
      if ( v61._Mypair._Myval2._Myres + 1 >= 0x1000 )
      {
        if ( (v61._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
          invalid_parameter_noinfo_noreturn();
        v17 = (char *)*((_QWORD *)v61._Mypair._Myval2._Bx._Ptr - 1);
        if ( v17 >= v61._Mypair._Myval2._Bx._Ptr )
          invalid_parameter_noinfo_noreturn();
        if ( (char *)(v61._Mypair._Myval2._Bx._Ptr - v17) < (char *)8 )
          invalid_parameter_noinfo_noreturn();
        if ( (char *)(v61._Mypair._Myval2._Bx._Ptr - v17) > (char *)0x27 )
          invalid_parameter_noinfo_noreturn();
        v16 = (char *)*((_QWORD *)v61._Mypair._Myval2._Bx._Ptr - 1);
      }
      operator delete(v16);
    }
  }
  extension::AsyncWorker::ToLowerCasePath(&_Keyval, name);
  extension::FutureObjectJobManager<extension::exsound_detail::SoundBankImpl,void>::Stringize(&_Right, v18);
  if ( _Right._Mypair._Myval2._Mysize )
  {
    Mysize = _Keyval._Mypair._Myval2._Mysize;
    if ( _Keyval._Mypair._Myval2._Mysize == -1i64 || ~_Keyval._Mypair._Myval2._Mysize == 1 )
      std::_Xlength_error("string too long");
    v20 = _Keyval._Mypair._Myval2._Mysize + 1;
    if ( _Keyval._Mypair._Myval2._Mysize == -2i64 )
      std::_Xlength_error("string too long");
    Myres = _Keyval._Mypair._Myval2._Myres;
    if ( _Keyval._Mypair._Myval2._Myres >= v20 )
    {
      if ( _Keyval._Mypair._Myval2._Mysize != -1i64 )
        goto LABEL_50;
      _Keyval._Mypair._Myval2._Mysize = 0i64;
      p_Keyval = &_Keyval;
      if ( _Keyval._Mypair._Myval2._Myres >= 0x10 )
        p_Keyval = (std::string *)_Keyval._Mypair._Myval2._Bx._Ptr;
      p_Keyval->_Mypair._Myval2._Bx._Buf[0] = 0;
    }
    else
    {
      std::string::_Copy(&_Keyval, _Keyval._Mypair._Myval2._Mysize + 1, _Keyval._Mypair._Myval2._Mysize);
    }
    Mysize = _Keyval._Mypair._Myval2._Mysize;
    Myres = _Keyval._Mypair._Myval2._Myres;
    if ( !v20 )
    {
LABEL_55:
      std::string::append(&_Keyval, &_Right, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      goto LABEL_56;
    }
LABEL_50:
    v23 = &_Keyval;
    if ( Myres >= 0x10 )
      v23 = (std::string *)_Keyval._Mypair._Myval2._Bx._Ptr;
    v23->_Mypair._Myval2._Bx._Buf[Mysize] = 63;
    _Keyval._Mypair._Myval2._Mysize = v20;
    v24 = &_Keyval;
    if ( _Keyval._Mypair._Myval2._Myres >= 0x10 )
      v24 = (std::string *)_Keyval._Mypair._Myval2._Bx._Ptr;
    v24->_Mypair._Myval2._Bx._Buf[v20] = 0;
    goto LABEL_55;
  }
LABEL_56:
  v54 = &extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache>;
  v55 = 1;
  EnterCriticalSection((LPCRITICAL_SECTION)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache>);
  v25 = (extension::RCWeakPtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *)std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>::operator[](
                                                                                            (std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>> *)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap,
                                                                                            &_Keyval);
  extension::RCWeakPtr<extension::BasicFutureObject<extension::GFXIMovieData,void>::Body>::lock(
    v25,
    (extension::RefCountablePtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *)result);
  m_ptr = result->m_ptr;
  if ( !result->m_ptr )
    goto LABEL_69;
  v28 = m_ptr->m_content.m_ptr;
  if ( !v28 || v28->m_isDataReleased )
    goto LABEL_66;
  if ( (v28->m_status.m_stateFlags.m_value._My_val & 1) != 0 )
  {
    v29 = result->m_ptr->m_content.m_ptr;
    if ( v29 )
    {
      if ( !v29->m_isDataReleased )
      {
        if ( (v29->m_status.m_stateFlags.m_value._My_val & 1) == 0 )
          extension::AsyncStatus::waitFor(&v29->m_status, v26);
        if ( v29->m_errorCode )
        {
          m_ptr = result->m_ptr;
LABEL_66:
          result->m_ptr = 0i64;
          if ( m_ptr
            && _InterlockedExchangeAdd64(
                 (volatile signed __int64 *)&m_ptr->m_refCount.m_ptr->m_sharedCount,
                 0xFFFFFFFFFFFFFFFFui64) == 1 )
          {
            ((void (__fastcall *)(extension::BasicFutureObject<OGLMirror,void>::Body *, __int64))m_ptr->~RefCountableWeakSupportBase)(
              m_ptr,
              1i64);
          }
        }
      }
    }
  }
LABEL_69:
  if ( !result->m_ptr )
  {
    if ( v11 )
    {
      v30 = name->_Mypair._Myval2._Myres < 0x10 ? name : (std::string *)name->_Mypair._Myval2._Bx._Ptr;
      if ( !(unsigned __int8)CFile::exists(v30->_Mypair._Myval2._Bx._Buf) )
      {
        v31 = std::string::substr(name, &v63, 0i64, name->_Mypair._Myval2._Mysize - 3);
        v32 = std::operator+<char>(&v62, v31, "dds");
        std::string::assign(name, v32);
        std::string::~string(&v62);
        std::string::~string(&v63);
        v33 = name->_Mypair._Myval2._Myres < 0x10 ? name : (std::string *)name->_Mypair._Myval2._Bx._Ptr;
        if ( !(unsigned __int8)CFile::exists(v33->_Mypair._Myval2._Bx._Buf) )
        {
          v34 = std::string::substr(name, &v65, 0i64, name->_Mypair._Myval2._Mysize - 3);
          v35 = std::operator+<char>(&v64, v34, "png");
          std::string::assign(name, v35);
          std::string::~string(&v64);
          std::string::~string(&v65);
        }
      }
    }
    v36 = (extension::BasicFutureObject<OGLMirror,void>::Body *)operator new(0x18ui64);
    v52 = v36;
    v38 = extension::FutureObjectJobManager<OGLMirror,void>::LoadStart(&v49, name, &_Right, v37);
    extension::BasicFutureObject<OGLMirror,void>::Body::Body(
      v36,
      (extension::RefCountablePtr<extension::AsyncContent<OGLMirror> >)v38);
    v39 = result->m_ptr;
    result->m_ptr = v40;
    if ( v39
      && _InterlockedExchangeAdd64(
           (volatile signed __int64 *)&v39->m_refCount.m_ptr->m_sharedCount,
           0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      ((void (__fastcall *)(extension::BasicFutureObject<OGLMirror,void>::Body *, __int64))v39->~RefCountableWeakSupportBase)(
        v39,
        1i64);
    }
    v41 = std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<CMediaSound,extension::exsound_detail::FutureSoundOption>::Body>>::operator[](
            (std::unordered_map<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>> *)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap,
            &_Keyval);
    v42 = result->m_ptr;
    v47 = result->m_ptr;
    if ( result->m_ptr )
    {
      v6 = (volatile signed __int64 *)v42->m_refCount.m_ptr;
      if ( v6 )
      {
        _InterlockedExchangeAdd64(v6, 1ui64);
        v42 = v47;
      }
    }
    v41->m_ptr = (extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body *)v42;
    block = v41->m_proxy.m_ptr;
    v41->m_proxy.m_ptr = (extension::RefCountableWeakSupportBase::WeakProxy *)v6;
    if ( block && _InterlockedExchangeAdd64((volatile signed __int64 *)block, 0xFFFFFFFFFFFFFFFFui64) == 1 )
      operator delete(block, 0x18ui64);
  }
  Next = extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap._List._Mypair._Myval2._Myhead->_Next;
  while ( Next != extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap._List._Mypair._Myval2._Myhead )
  {
    v44._Ptr = (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)Next;
    v45 = Next->_Myval.second.m_proxy.m_ptr;
    Next = Next->_Next;
    if ( !v45 || !v45->m_sharedCount.m_value._My_val )
      std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLFigure,extension::FutureFigureOption>::Body>>>,0>>::erase(
        (std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *)&extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.m_cachedObjectMap,
        &v53,
        v44);
  }
  extension::lockable_detail::LockUnlock(
    &extension::BasicFutureObject<OGLMirror,void>::s_cacheManager.extension::ExSimpleLockable<extension::BasicFutureObject<OGLMirror,void>::AssetCache>,
    -1);
  std::string::~string(&_Right);
  std::string::~string(&_Keyval);
  std::string::~string(name);
  return result;
}

__int64 __fastcall AppMain::loadBasicLightData(
        AppMain *this,
        const char *lightFileName,
        AppMain::_WORLD_LIGHT_DATA *lightData,
        int a4)
{
  unsigned __int64 v4; // r13
  int v5; // edi
  int v6; // eax
  int v8; // er8
  char *Ptr; // rcx
  char *v10; // rax
  const std::locale *v11; // rax
  __int64 v12; // rdx
  std::locale::facet *v13; // rbx
  void (__fastcall ***v14)(_QWORD, __int64); // rax
  char v15; // al
  std::istream *v16; // rax
  std::locale *v17; // rbx
  const std::locale *v18; // rax
  __int64 v19; // rdx
  std::locale::facet *v20; // rbx
  void (__fastcall ***v21)(_QWORD, __int64); // rax
  int v22; // er9
  std::string *p_Str; // rdx
  std::istream *v24; // rax
  std::string *v25; // rdi
  unsigned __int64 Mysize; // r15
  std::string *p_Right; // r12
  char *v28; // rcx
  unsigned __int64 Myres; // rdx
  std::string *v30; // rax
  std::string *v31; // rax
  std::string *v32; // r14
  signed __int64 v33; // rsi
  __int64 i; // rbx
  std::string *v35; // r8
  std::string *v36; // rbx
  unsigned __int64 v37; // rbx
  std::string *v38; // rsi
  char *v39; // r14
  unsigned __int64 v40; // r12
  __int64 j; // rbx
  std::string *v42; // rax
  signed __int64 v43; // r8
  unsigned __int64 v44; // r10
  std::string *v45; // rax
  std::string *v46; // r9
  char *v47; // r9
  unsigned __int64 v48; // r15
  std::string *v49; // rax
  char *v50; // rcx
  signed __int64 v51; // rbx
  __int64 v52; // rdi
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // rdx
  std::string *v55; // rbx
  std::string *v56; // rax
  std::string *v57; // rdx
  __int64 v58; // rdi
  unsigned __int64 v59; // r9
  unsigned __int64 v60; // rdx
  std::istream *v61; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v62; // r8
  std::integral_constant<bool,0> v63; // r9
  char *v64; // rbx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v65; // rcx
  int v66; // er14
  std::vector<std::string> *Myfirst; // r15
  std::string *v68; // rcx
  int v69; // eax
  std::vector<std::string> *Mylast; // r12
  int v71; // esi
  __int64 v72; // rbx
  std::string *v73; // rdi
  const char *Buf; // rcx
  std::string *v75; // rdx
  unsigned __int64 v76; // r8
  unsigned __int64 *v77; // rdx
  int v78; // edi
  int v79; // edi
  __int64 v80; // rsi
  const std::vector<std::string> *v81; // rbx
  std::string *v82; // rcx
  int v83; // er14
  int v84; // esi
  __int64 v85; // r14
  __int64 v86; // rbx
  std::string *v87; // rdi
  const char *v88; // rcx
  std::string *v89; // rdx
  unsigned __int64 v90; // r8
  unsigned __int64 *v91; // rdx
  int v92; // edi
  __int64 v93; // rsi
  const std::vector<std::string> *v94; // rbx
  signed __int64 v95; // r12
  unsigned __int64 v96; // rdx
  unsigned __int64 v97; // rsi
  std::string *v98; // rcx
  std::_Wrap_alloc<std::allocator<std::string > > *v99; // r8
  std::integral_constant<bool,0> v100; // r9
  int v101; // edi
  std::string *v102; // rax
  std::string *v103; // r14
  unsigned __int64 v104; // r12
  int v105; // esi
  char *v106; // rbx
  int v107; // er15
  const char *v108; // rcx
  std::string *v109; // rdx
  unsigned __int64 v110; // r8
  unsigned __int64 *v111; // rdx
  float v112; // xmm0_4
  const char *v113; // rcx
  std::string *v114; // rdx
  unsigned __int64 v115; // r8
  unsigned __int64 *v116; // rdx
  float v117; // xmm0_4
  const char *v118; // rcx
  std::string *v119; // rdx
  unsigned __int64 v120; // r8
  unsigned __int64 *v121; // rdx
  float v122; // xmm0_4
  const char *v123; // rcx
  std::string *v124; // rdx
  unsigned __int64 v125; // r8
  unsigned __int64 *v126; // rdx
  float v127; // xmm0_4
  std::string *v128; // rdx
  unsigned __int64 v129; // r8
  unsigned __int64 *v130; // rdx
  float v131; // xmm0_4
  std::string *v132; // rdx
  unsigned __int64 v133; // r8
  unsigned __int64 *v134; // rdx
  float v135; // xmm0_4
  int v136; // eax
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v137; // rcx
  int v138; // er14
  std::string *v139; // rcx
  int v140; // er14
  std::string *v141; // rcx
  const char *v142; // rbx
  unsigned __int64 v143; // r8
  unsigned __int64 *v144; // rdx
  float v145; // xmm0_4
  AppMain::_WORLD_LIGHT_DATA *v146; // r12
  const char *v147; // rcx
  const char *v148; // rbx
  unsigned __int64 v149; // r8
  unsigned __int64 *v150; // rdx
  float v151; // xmm0_4
  std::string *v152; // rcx
  __int64 v153; // rax
  __int64 v154; // rdi
  std::string *v155; // rcx
  std::string *v156; // rcx
  const char *v157; // rbx
  unsigned __int64 v158; // r8
  unsigned __int64 *v159; // rdx
  float v160; // xmm0_4
  AppMain::_WORLD_LIGHT_DATA *v161; // rsi
  const char *v162; // rcx
  const char *v163; // rcx
  const char *v164; // rbx
  unsigned __int64 v165; // r8
  unsigned __int64 *v166; // rdx
  float v167; // xmm0_4
  const char *v168; // rcx
  const char *v169; // rbx
  unsigned __int64 v170; // r8
  unsigned __int64 *v171; // rdx
  float v172; // xmm0_4
  const char *v173; // rcx
  const char *v174; // rbx
  unsigned __int64 *v175; // rdx
  float v176; // xmm0_4
  __int64 v177; // rdx
  std::_Wrap_alloc<std::allocator<std::vector<std::string> > > *v178; // r8
  std::integral_constant<bool,0> v179; // r9
  int v180; // [rsp+30h] [rbp-D0h]
  int v181; // [rsp+34h] [rbp-CCh]
  int v182; // [rsp+34h] [rbp-CCh]
  int v183; // [rsp+34h] [rbp-CCh]
  int v184; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v186; // [rsp+48h] [rbp-B8h]
  char *v187; // [rsp+50h] [rbp-B0h]
  __int64 v188; // [rsp+50h] [rbp-B0h]
  char *_Ptr; // [rsp+58h] [rbp-A8h] BYREF
  std::vector<std::vector<std::string>> v190; // [rsp+60h] [rbp-A0h] BYREF
  int v191; // [rsp+7Ch] [rbp-84h]
  std::istream _Istr; // [rsp+80h] [rbp-80h] BYREF
  __int64 v193; // [rsp+F8h] [rbp-8h]
  int v194; // [rsp+100h] [rbp+0h]
  int v195; // [rsp+10Ch] [rbp+Ch]
  std::ios_base _This; // [rsp+110h] [rbp+10h] BYREF
  _BYTE *v197; // [rsp+158h] [rbp+58h]
  __int64 v198; // [rsp+160h] [rbp+60h]
  char v199; // [rsp+168h] [rbp+68h]
  __int64 v200; // [rsp+170h] [rbp+70h]
  std::istringstream v201; // [rsp+180h] [rbp+80h] BYREF
  std::string _Val; // [rsp+270h] [rbp+170h] BYREF
  std::string _Right; // [rsp+290h] [rbp+190h] BYREF
  std::string result; // [rsp+2B0h] [rbp+1B0h] BYREF
  std::string _Str; // [rsp+2D0h] [rbp+1D0h] BYREF
  std::string v206; // [rsp+2F0h] [rbp+1F0h] BYREF

  v200 = -2i64;
  v4 = 0i64;
  v5 = 0;
  _Ptr = 0i64;
  v184 = 0;
  v6 = CFile::ResourceDataLoaderNew(lightFileName, (int)lightFileName, (int)lightData, a4, (unsigned __int8 **)&_Ptr);
  if ( !_Ptr )
    return 0xFFFFFFFFi64;
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&_Str, _Ptr, v6);
  std::istringstream::istringstream(&v201, &_Str, v8);
  if ( _Str._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = _Str._Mypair._Myval2._Bx._Ptr;
    if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v10 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
      if ( v10 >= _Str._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  memset(&v190, 0, sizeof(v190));
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  v180 = 2;
  while ( 1 )
  {
    v11 = std::ios_base::getloc(
            (std::ios_base *)&v201.gap0[*(int *)(*(_QWORD *)v201.gap0 + 4i64)],
            (std::locale *)&result);
    v13 = std::use_facet<std::ctype<char>>(v11);
    if ( *(_QWORD *)&result._Mypair._Myval2._Bx._Alias[8] )
    {
      v14 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)&result._Mypair._Myval2._Bx._Alias[8]
                                                                                      + 16i64))(*(_QWORD *)&result._Mypair._Myval2._Bx._Alias[8]);
      if ( v14 )
        (**v14)(v14, 1i64);
    }
    LOBYTE(v12) = 10;
    v15 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v13->__vftable[2]._Decref)(v13, v12);
    v16 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&v201, &_Str, v15);
    if ( (v16->gap10[*(int *)(*(_QWORD *)v16->gap0 + 4i64)] & 6) != 0 )
      break;
    *(_QWORD *)_Istr.gap0 = &std::istringstream::`vbtable';
    v5 |= 1u;
    v181 = v5;
    _This.__vftable = (std::ios_base_vtbl *)&std::istream::`vftable';
    v195 = 120;
    _Istr._Chcount = 0i64;
    _This._Stdstr = 0i64;
    _This._Except = 0;
    _This._Fmtfl = 513;
    *(__m128i *)&_This._Prec = _mm_load_si128((const __m128i *)&_xmm);
    memset(&_This._Arr, 0, 24);
    std::ios_base::clear(&_This, 0, 0);
    v17 = (std::locale *)operator new(0x10ui64);
    v17->_Ptr = std::locale::_Init(1);
    _This._Ploc = v17;
    v197 = _Istr.gap10;
    v198 = 0i64;
    v18 = std::ios_base::getloc(&_This, (std::locale *)&v206);
    v20 = std::use_facet<std::ctype<char>>(v18);
    if ( *(_QWORD *)&v206._Mypair._Myval2._Bx._Alias[8] )
    {
      v21 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)&v206._Mypair._Myval2._Bx._Alias[8]
                                                                                      + 16i64))(*(_QWORD *)&v206._Mypair._Myval2._Bx._Alias[8]);
      if ( v21 )
        (**v21)(v21, 1i64);
    }
    LOBYTE(v19) = 32;
    v199 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v20->__vftable[2]._Decref)(v20, v19);
    if ( !v197 )
      std::ios_base::clear(&_This, _This._Mystate | 4, 0);
    *(_QWORD *)&_Istr.gap0[*(int *)(*(_QWORD *)_Istr.gap0 + 4i64)] = &std::istringstream::`vftable';
    *(int *)((char *)&v191 + *(int *)(*(_QWORD *)_Istr.gap0 + 4i64)) = *(_DWORD *)(*(_QWORD *)_Istr.gap0 + 4i64) - 144;
    std::streambuf::streambuf((std::streambuf *)_Istr.gap10);
    *(_QWORD *)_Istr.gap10 = &std::stringbuf::`vftable';
    p_Str = &_Str;
    if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
    v193 = 0i64;
    v194 = 2;
    if ( _Str._Mypair._Myval2._Mysize )
      std::stringbuf::_Init(
        (std::stringbuf *)_Istr.gap10,
        p_Str->_Mypair._Myval2._Bx._Buf,
        _Str._Mypair._Myval2._Mysize,
        v22);
    _Right._Mypair._Myval2._Myres = 15i64;
    _Right._Mypair._Myval2._Mysize = 0i64;
    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
    memset(&_Val, 0, 24);
    v186 = 0i64;
    v24 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
    if ( (v24->gap10[*(int *)(*(_QWORD *)v24->gap0 + 4i64)] & 6) == 0 )
    {
      v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      while ( 1 )
      {
        Mysize = _Right._Mypair._Myval2._Mysize;
        if ( !_Right._Mypair._Myval2._Mysize )
        {
LABEL_107:
          v5 = v181;
          break;
        }
        p_Right = &_Right;
        v28 = _Right._Mypair._Myval2._Bx._Ptr;
        Myres = _Right._Mypair._Myval2._Myres;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          p_Right = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v30 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v30 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v31 = (std::string *)((char *)v30 + _Right._Mypair._Myval2._Mysize);
        v32 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v32 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v33 = (char *)v31 - (char *)v32;
        if ( v32 > v31 )
          v33 = 0i64;
        if ( v33 )
        {
          for ( i = 0i64; i != v33; ++i )
            p_Right->_Mypair._Myval2._Bx._Buf[i] = toupper(v32->_Mypair._Myval2._Bx._Buf[i]);
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v28 = _Right._Mypair._Myval2._Bx._Ptr;
        }
        v35 = &_Right;
        if ( Myres >= 0x10 )
          v35 = (std::string *)v28;
        v187 = &v35->_Mypair._Myval2._Bx._Buf[Mysize];
        v36 = &_Right;
        if ( Myres >= 0x10 )
          v36 = (std::string *)v28;
        v37 = (unsigned __int64)v36 + Mysize;
        v38 = &_Right;
        if ( Myres >= 0x10 )
          v38 = (std::string *)v28;
        if ( v38 != (std::string *)v37 )
        {
          do
          {
            if ( isspace(v38->_Mypair._Myval2._Bx._Buf[0]) )
              break;
            v38 = (std::string *)((char *)v38 + 1);
          }
          while ( v38 != (std::string *)v37 );
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v28 = _Right._Mypair._Myval2._Bx._Ptr;
          if ( v38 != (std::string *)v37 )
          {
            v39 = &v38->_Mypair._Myval2._Bx._Buf[1];
            v40 = v37 - (_QWORD)&v38->_Mypair._Myval2._Bx._Buf[1];
            if ( (unsigned __int64)&v38->_Mypair._Myval2._Bx._Buf[1] > v37 )
              v40 = 0i64;
            if ( v40 )
            {
              for ( j = 0i64; j != v40; ++j )
              {
                if ( !isspace(*v39) )
                {
                  v38->_Mypair._Myval2._Bx._Buf[0] = *v39;
                  v38 = (std::string *)((char *)v38 + 1);
                }
                ++v39;
              }
              Myres = _Right._Mypair._Myval2._Myres;
              Mysize = _Right._Mypair._Myval2._Mysize;
              v28 = _Right._Mypair._Myval2._Bx._Ptr;
            }
          }
        }
        v42 = &_Right;
        if ( Myres >= 0x10 )
          v42 = (std::string *)v28;
        v43 = (char *)v38 - (char *)v42;
        v44 = v187 - (char *)v38;
        if ( Mysize < (char *)v38 - (char *)v42 )
          std::_Xout_of_range("invalid string position");
        if ( Mysize - v43 > v44 )
        {
          if ( v44 )
          {
            v46 = &_Right;
            if ( Myres >= 0x10 )
              v46 = (std::string *)v28;
            v47 = &v46->_Mypair._Myval2._Bx._Buf[v43];
            v48 = Mysize - v44;
            if ( v48 != v43 )
            {
              memmove(v47, &v47[v44], v48 - v43);
              Myres = _Right._Mypair._Myval2._Myres;
              v28 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            _Right._Mypair._Myval2._Mysize = v48;
            v49 = &_Right;
            if ( Myres >= 0x10 )
              v49 = (std::string *)v28;
            v49->_Mypair._Myval2._Bx._Buf[v48] = 0;
          }
        }
        else
        {
          _Right._Mypair._Myval2._Mysize = (char *)v38 - (char *)v42;
          v45 = &_Right;
          if ( Myres >= 0x10 )
            v45 = (std::string *)v28;
          v45->_Mypair._Myval2._Bx._Buf[v43] = 0;
        }
        v50 = _Val._Mypair._Myval2._Bx._Ptr;
        if ( &_Right >= v25 || _Val._Mypair._Myval2._Bx._Ptr > (char *)&_Right )
        {
          if ( v25 == (std::string *)v186 && !((__int64)(v186 - (_QWORD)v25) >> 5) )
          {
            v58 = ((char *)v25 - _Val._Mypair._Myval2._Bx._Ptr) >> 5;
            if ( v58 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v59 = (__int64)(v186 - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
            v60 = (v59 >> 1) + v59;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v59 >> 1) < v59 )
              v60 = 0i64;
            if ( v60 < v58 + 1 )
              v60 = v58 + 1;
            std::vector<std::string>::_Reallocate((std::vector<std::string> *)&_Val, v60);
            v186 = _Val._Mypair._Myval2._Mysize;
            v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
          }
          if ( !v25 )
            goto LABEL_106;
          v25->_Mypair._Myval2._Myres = 15i64;
          v25->_Mypair._Myval2._Mysize = 0i64;
          if ( v25->_Mypair._Myval2._Myres < 0x10 )
            v56 = v25;
          else
            v56 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
          v57 = &_Right;
        }
        else
        {
          v51 = (char *)&_Right - _Val._Mypair._Myval2._Bx._Ptr;
          if ( v25 == (std::string *)v186 && !((__int64)(v186 - (_QWORD)v25) >> 5) )
          {
            v52 = ((char *)v25 - _Val._Mypair._Myval2._Bx._Ptr) >> 5;
            if ( v52 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v53 = (__int64)(v186 - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
            v54 = (v53 >> 1) + v53;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v53 >> 1) < v53 )
              v54 = 0i64;
            if ( v54 < v52 + 1 )
              v54 = v52 + 1;
            std::vector<std::string>::_Reallocate((std::vector<std::string> *)&_Val, v54);
            v186 = _Val._Mypair._Myval2._Mysize;
            v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
            v50 = _Val._Mypair._Myval2._Bx._Ptr;
          }
          v55 = (std::string *)&v50[v51 & 0xFFFFFFFFFFFFFFE0ui64];
          if ( !v25 )
            goto LABEL_106;
          v25->_Mypair._Myval2._Myres = 15i64;
          v25->_Mypair._Myval2._Mysize = 0i64;
          if ( v25->_Mypair._Myval2._Myres < 0x10 )
            v56 = v25;
          else
            v56 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
          v57 = v55;
        }
        v56->_Mypair._Myval2._Bx._Buf[0] = 0;
        std::string::_Assign_rv(v25, v57);
LABEL_106:
        *(_QWORD *)&_Val._Mypair._Myval2._Bx._Alias[8] = ++v25;
        v61 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
        if ( (v61->gap10[*(int *)(*(_QWORD *)v61->gap0 + 4i64)] & 6) != 0 )
          goto LABEL_107;
      }
    }
    std::vector<std::vector<std::string>>::push_back(&v190, (std::vector<std::string> *)&_Val);
    v64 = _Val._Mypair._Myval2._Bx._Ptr;
    if ( _Val._Mypair._Myval2._Bx._Ptr )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        (std::string *)_Val._Mypair._Myval2._Bx._Ptr,
        *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8],
        v62,
        v63);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v65,
        (AgDirectory::DirectoryEntry *)v64,
        (__int64)(_Val._Mypair._Myval2._Mysize - (_QWORD)v64) >> 5);
    }
    std::string::~string(&_Right);
    std::istringstream::~istringstream((std::istringstream *)&_This);
    _This.__vftable = (std::ios_base_vtbl *)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&_This);
  }
  v66 = 0;
  Myfirst = v190._Mypair._Myval2._Myfirst;
  v68 = v190._Mypair._Myval2._Myfirst->_Mypair._Myval2._Myfirst;
  if ( v190._Mypair._Myval2._Myfirst->_Mypair._Myval2._Myfirst->_Mypair._Myval2._Myres >= 0x10 )
    v68 = (std::string *)v68->_Mypair._Myval2._Bx._Ptr;
  v69 = strcmp(v68->_Mypair._Myval2._Bx._Buf, "WORLDLIGHT");
  Mylast = v190._Mypair._Myval2._Mylast;
  if ( !v69 )
  {
    v71 = 0;
    if ( Myfirst[1]._Mypair._Myval2._Mylast - Myfirst[1]._Mypair._Myval2._Myfirst )
    {
      v72 = 0i64;
      do
      {
        v73 = Myfirst[1]._Mypair._Myval2._Myfirst;
        Buf = v73[v72]._Mypair._Myval2._Bx._Buf;
        if ( v73[v72]._Mypair._Myval2._Myres >= 0x10 )
          Buf = *(const char **)Buf;
        if ( !strcmp(Buf, "NUMLIGHTS") )
        {
          v75 = &v73[v72 + 1];
          if ( v75->_Mypair._Myval2._Myres >= 0x10 )
            v75 = (std::string *)v75->_Mypair._Myval2._Bx._Ptr;
          _Right._Mypair._Myval2._Myres = 15i64;
          _Right._Mypair._Myval2._Mysize = 0i64;
          _Right._Mypair._Myval2._Bx._Buf[0] = 0;
          if ( v75->_Mypair._Myval2._Bx._Buf[0] )
          {
            v76 = -1i64;
            do
              ++v76;
            while ( v75->_Mypair._Myval2._Bx._Buf[v76] );
          }
          else
          {
            v76 = 0i64;
          }
          std::string::assign(&_Right, v75->_Mypair._Myval2._Bx._Buf, v76);
          v78 = (int)std::stof(&_Right, v77);
          v184 = v78;
          std::string::~string(&_Right);
          ++v71;
          ++v72;
        }
        else
        {
          v78 = v184;
        }
        ++v71;
        ++v72;
      }
      while ( v71 < (unsigned __int64)(Myfirst[1]._Mypair._Myval2._Mylast - Myfirst[1]._Mypair._Myval2._Myfirst) );
    }
    else
    {
      v78 = 0;
    }
    lightData->numWorldLights = v78;
    v66 = 2;
    if ( v78 > 0 && (unsigned __int64)(Mylast - Myfirst) > 1 )
    {
      v79 = 0;
      v80 = v184;
      if ( v184 > 0 )
      {
        v81 = Myfirst + 2;
        do
        {
          if ( v81->_Mypair._Myval2._Mylast - v81->_Mypair._Myval2._Myfirst )
            AppMain::processLightData((AppMain *)(164i64 * v79), v81, &lightData->worldLightAssetData[v79]);
          ++v79;
          ++v81;
          --v80;
        }
        while ( v80 );
        Myfirst = v190._Mypair._Myval2._Myfirst;
      }
      v66 = v184 + 2;
    }
  }
  v82 = Myfirst[v66]._Mypair._Myval2._Myfirst;
  if ( v82->_Mypair._Myval2._Myres >= 0x10 )
    v82 = (std::string *)v82->_Mypair._Myval2._Bx._Ptr;
  if ( !strcmp(v82->_Mypair._Myval2._Bx._Buf, "CHARACTERLIGHT") )
  {
    v83 = v66 + 1;
    v182 = v83;
    v84 = 0;
    if ( Myfirst[v83]._Mypair._Myval2._Mylast - Myfirst[v83]._Mypair._Myval2._Myfirst )
    {
      v85 = v83;
      v86 = 0i64;
      do
      {
        v87 = Myfirst[v85]._Mypair._Myval2._Myfirst;
        v88 = v87[v86]._Mypair._Myval2._Bx._Buf;
        if ( v87[v86]._Mypair._Myval2._Myres >= 0x10 )
          v88 = *(const char **)v88;
        if ( !strcmp(v88, "NUMLIGHTS") )
        {
          v89 = &v87[v86 + 1];
          if ( v89->_Mypair._Myval2._Myres >= 0x10 )
            v89 = (std::string *)v89->_Mypair._Myval2._Bx._Ptr;
          v206._Mypair._Myval2._Myres = 15i64;
          v206._Mypair._Myval2._Mysize = 0i64;
          v206._Mypair._Myval2._Bx._Buf[0] = 0;
          if ( v89->_Mypair._Myval2._Bx._Buf[0] )
          {
            v90 = -1i64;
            do
              ++v90;
            while ( v89->_Mypair._Myval2._Bx._Buf[v90] );
          }
          else
          {
            v90 = 0i64;
          }
          std::string::assign(&v206, v89->_Mypair._Myval2._Bx._Buf, v90);
          v184 = (int)std::stof(&v206, v91);
          std::string::~string(&v206);
          ++v84;
          ++v86;
        }
        ++v84;
        ++v86;
      }
      while ( v84 < (unsigned __int64)(Myfirst[v85]._Mypair._Myval2._Mylast - Myfirst[v85]._Mypair._Myval2._Myfirst) );
      v83 = v182;
    }
    lightData->numCharLights = v184;
    v66 = v83 + 1;
    if ( v184 > 0 && (unsigned __int64)(Mylast - Myfirst) > 1 )
    {
      v92 = 0;
      v93 = v184;
      v94 = &Myfirst[v66];
      do
      {
        if ( v94->_Mypair._Myval2._Mylast - v94->_Mypair._Myval2._Myfirst )
          AppMain::processLightData((AppMain *)(164i64 * v92), v94, &lightData->charLightAssetData[v92]);
        ++v92;
        ++v94;
        --v93;
      }
      while ( v93 );
      Myfirst = v190._Mypair._Myval2._Myfirst;
      v66 += v184;
    }
  }
  v95 = (char *)Mylast - (char *)Myfirst;
  v96 = (unsigned __int128)(v95 * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v97 = v95 / 24;
  v188 = v95 / 24;
  if ( v66 < (unsigned __int64)(v95 / 24)
    && Myfirst[v66]._Mypair._Myval2._Mylast - Myfirst[v66]._Mypair._Myval2._Myfirst )
  {
    v98 = Myfirst[v66]._Mypair._Myval2._Myfirst;
    if ( v98->_Mypair._Myval2._Myres >= 0x10 )
      v98 = (std::string *)v98->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v98->_Mypair._Myval2._Bx._Buf, "RIMLIGHT") )
    {
      v183 = v66 + 1;
      std::vector<std::string>::vector<std::string>((std::vector<std::string> *)&_Val, &Myfirst[v66 + 1]);
      v101 = 0;
      v102 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      v103 = (std::string *)_Val._Mypair._Myval2._Bx._Ptr;
      v104 = (__int64)(*(_QWORD *)&_Val._Mypair._Myval2._Bx._Alias[8] - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
      if ( v104 )
      {
        v105 = 3;
        v106 = _Val._Mypair._Myval2._Bx._Ptr;
        v107 = 1;
        do
        {
          if ( *((_QWORD *)v106 + 3) < 0x10ui64 )
            v108 = v106;
          else
            v108 = *(const char **)v106;
          if ( !strcmp(v108, "RIMLIGHTMIN") )
          {
            v109 = &v103[v107];
            if ( v109->_Mypair._Myval2._Myres >= 0x10 )
              v109 = (std::string *)v109->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v109->_Mypair._Myval2._Bx._Buf[0] )
            {
              v110 = -1i64;
              do
                ++v110;
              while ( v109->_Mypair._Myval2._Bx._Buf[v110] );
            }
            else
            {
              v110 = 0i64;
            }
            std::string::assign(&result, v109->_Mypair._Myval2._Bx._Buf, v110);
            v112 = std::stof(&result, v111);
            lightData->P2RimLightAssetData.rimLightMin = v112;
            lightData->P1RimLightAssetData.rimLightMin = v112;
            std::string::~string(&result);
            v101 += 2;
            v107 += 2;
            v180 += 2;
            v105 += 2;
            v106 += 64;
          }
          if ( *((_QWORD *)v106 + 3) < 0x10ui64 )
            v113 = v106;
          else
            v113 = *(const char **)v106;
          if ( !strcmp(v113, "RIMLIGHTMAX") )
          {
            v114 = &v103[v107];
            if ( v114->_Mypair._Myval2._Myres >= 0x10 )
              v114 = (std::string *)v114->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v114->_Mypair._Myval2._Bx._Buf[0] )
            {
              v115 = -1i64;
              do
                ++v115;
              while ( v114->_Mypair._Myval2._Bx._Buf[v115] );
            }
            else
            {
              v115 = 0i64;
            }
            std::string::assign(&result, v114->_Mypair._Myval2._Bx._Buf, v115);
            v117 = std::stof(&result, v116);
            lightData->P2RimLightAssetData.rimLightMax = v117;
            lightData->P1RimLightAssetData.rimLightMax = v117;
            std::string::~string(&result);
            v101 += 2;
            v107 += 2;
            v180 += 2;
            v105 += 2;
            v106 += 64;
          }
          if ( *((_QWORD *)v106 + 3) < 0x10ui64 )
            v118 = v106;
          else
            v118 = *(const char **)v106;
          if ( !strcmp(v118, "RIMLIGHTSTRENGTH") )
          {
            v119 = &v103[v107];
            if ( v119->_Mypair._Myval2._Myres >= 0x10 )
              v119 = (std::string *)v119->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v119->_Mypair._Myval2._Bx._Buf[0] )
            {
              v120 = -1i64;
              do
                ++v120;
              while ( v119->_Mypair._Myval2._Bx._Buf[v120] );
            }
            else
            {
              v120 = 0i64;
            }
            std::string::assign(&result, v119->_Mypair._Myval2._Bx._Buf, v120);
            v122 = std::stof(&result, v121);
            lightData->P2RimLightAssetData.rimLightStrength = v122;
            lightData->P1RimLightAssetData.rimLightStrength = v122;
            std::string::~string(&result);
            v101 += 2;
            v107 += 2;
            v180 += 2;
            v105 += 2;
            v106 += 64;
          }
          if ( *((_QWORD *)v106 + 3) < 0x10ui64 )
            v123 = v106;
          else
            v123 = *(const char **)v106;
          if ( !strcmp(v123, "RIMLIGHTCOLOR") )
          {
            v124 = &v103[v107];
            if ( v124->_Mypair._Myval2._Myres >= 0x10 )
              v124 = (std::string *)v124->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v124->_Mypair._Myval2._Bx._Buf[0] )
            {
              v125 = -1i64;
              do
                ++v125;
              while ( v124->_Mypair._Myval2._Bx._Buf[v125] );
            }
            else
            {
              v125 = 0i64;
            }
            std::string::assign(&result, v124->_Mypair._Myval2._Bx._Buf, v125);
            v127 = std::stof(&result, v126);
            lightData->P2RimLightAssetData.rimLightColour[0] = v127;
            lightData->P1RimLightAssetData.rimLightColour[0] = v127;
            std::string::~string(&result);
            v128 = &v103[v180];
            if ( v128->_Mypair._Myval2._Myres >= 0x10 )
              v128 = (std::string *)v128->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v128->_Mypair._Myval2._Bx._Buf[0] )
            {
              v129 = -1i64;
              do
                ++v129;
              while ( v128->_Mypair._Myval2._Bx._Buf[v129] );
            }
            else
            {
              v129 = 0i64;
            }
            std::string::assign(&result, v128->_Mypair._Myval2._Bx._Buf, v129);
            v131 = std::stof(&result, v130);
            lightData->P2RimLightAssetData.rimLightColour[1] = v131;
            lightData->P1RimLightAssetData.rimLightColour[1] = v131;
            std::string::~string(&result);
            v132 = &v103[v105];
            if ( v132->_Mypair._Myval2._Myres >= 0x10 )
              v132 = (std::string *)v132->_Mypair._Myval2._Bx._Ptr;
            result._Mypair._Myval2._Myres = 15i64;
            result._Mypair._Myval2._Mysize = 0i64;
            result._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v132->_Mypair._Myval2._Bx._Buf[0] )
            {
              v133 = -1i64;
              do
                ++v133;
              while ( v132->_Mypair._Myval2._Bx._Buf[v133] );
            }
            else
            {
              v133 = 0i64;
            }
            std::string::assign(&result, v132->_Mypair._Myval2._Bx._Buf, v133);
            v135 = std::stof(&result, v134);
            lightData->P2RimLightAssetData.rimLightColour[2] = v135;
            lightData->P1RimLightAssetData.rimLightColour[2] = v135;
            std::string::~string(&result);
            v101 += 4;
            v107 += 4;
            v136 = v180 + 4;
            v105 += 4;
            v106 += 128;
          }
          else
          {
            v136 = v180;
          }
          ++v101;
          ++v107;
          v180 = v136 + 1;
          ++v105;
          v106 += 32;
        }
        while ( v101 < v104 );
        Myfirst = v190._Mypair._Myval2._Myfirst;
        v97 = v188;
        v102 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      }
      if ( v103 )
      {
        std::_Destroy_range1<std::allocator<std::string>,std::string *>(v103, v102, v99, v100);
        std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
          v137,
          (AgDirectory::DirectoryEntry *)v103,
          (__int64)(_Val._Mypair._Myval2._Mysize - (_QWORD)v103) >> 5);
      }
      v66 = v183;
    }
  }
  v138 = v66 + 1;
  if ( v138 < v97 && Myfirst[v138]._Mypair._Myval2._Mylast - Myfirst[v138]._Mypair._Myval2._Myfirst )
  {
    v139 = Myfirst[v138]._Mypair._Myval2._Myfirst;
    if ( v139->_Mypair._Myval2._Myres >= 0x10 )
      v139 = (std::string *)v139->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v139->_Mypair._Myval2._Bx._Buf, "EMISSION") )
    {
      v140 = v138 + 1;
      v141 = Myfirst[v140]._Mypair._Myval2._Myfirst;
      if ( v141->_Mypair._Myval2._Myres >= 0x10 )
        v141 = (std::string *)v141->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v141->_Mypair._Myval2._Bx._Buf, "EYEEMISSIONSTRENGTH") )
      {
        v142 = Myfirst[v140]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v140]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Myres >= 0x10 )
          v142 = *(const char **)v142;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v142 )
        {
          v143 = -1i64;
          do
            ++v143;
          while ( v142[v143] );
        }
        else
        {
          v143 = 0i64;
        }
        std::string::assign(&_Val, v142, v143);
        v145 = std::stof(&_Val, v144);
        v146 = lightData;
        lightData->P2EmissionData.eyeEmissionStrength = v145;
        lightData->P1EmissionData.eyeEmissionStrength = v145;
        std::string::~string(&_Val);
      }
      else
      {
        v146 = lightData;
      }
      v147 = Myfirst[v140]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v140]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v147 = *(const char **)v147;
      if ( !strcmp(v147, "CHAREMISSIONSTRENGTH") )
      {
        v148 = Myfirst[v140]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v140]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Myres >= 0x10 )
          v148 = *(const char **)v148;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v148 )
        {
          v149 = -1i64;
          do
            ++v149;
          while ( v148[v149] );
        }
        else
        {
          v149 = 0i64;
        }
        std::string::assign(&_Val, v148, v149);
        v151 = std::stof(&_Val, v150);
        v146->P2EmissionData.charEmissionStrength = v151;
        v146->P1EmissionData.charEmissionStrength = v151;
        std::string::~string(&_Val);
      }
      v138 = v140 + 1;
    }
  }
  if ( v138 < v97 && Myfirst[v138]._Mypair._Myval2._Mylast - Myfirst[v138]._Mypair._Myval2._Myfirst )
  {
    v152 = Myfirst[v138]._Mypair._Myval2._Myfirst;
    if ( v152->_Mypair._Myval2._Myres >= 0x10 )
      v152 = (std::string *)v152->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v152->_Mypair._Myval2._Bx._Buf, "SHADOWSTRENGTHRANGE") )
    {
      v153 = v138 + 1;
      v154 = v153;
      v155 = Myfirst[v153]._Mypair._Myval2._Myfirst;
      if ( v155->_Mypair._Myval2._Myres >= 0x10 )
        v155 = (std::string *)v155->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v155->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADSTRRGEMIN") )
        goto LABEL_275;
      v156 = Myfirst[v154]._Mypair._Myval2._Myfirst;
      if ( v156->_Mypair._Myval2._Myres >= 0x10 )
        v156 = (std::string *)v156->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v156->_Mypair._Myval2._Bx._Buf, "SHADOWSTRENGTHRANGEMIN") )
      {
LABEL_275:
        v157 = Myfirst[v154]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v154]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Myres >= 0x10 )
          v157 = *(const char **)v157;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v157 )
        {
          v158 = -1i64;
          do
            ++v158;
          while ( v157[v158] );
        }
        else
        {
          v158 = 0i64;
        }
        std::string::assign(&_Val, v157, v158);
        v160 = std::stof(&_Val, v159);
        v161 = lightData;
        lightData->P2ShadowRangeData.bodySelfShadowDotRangeMin = v160;
        lightData->P1ShadowRangeData.bodySelfShadowDotRangeMin = v160;
        std::string::~string(&_Val);
      }
      else
      {
        v161 = lightData;
      }
      v162 = Myfirst[v154]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v154]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v162 = *(const char **)v162;
      if ( !strcmp(v162, "BODYSELFSHADSTRRGEMAX") )
        goto LABEL_289;
      v163 = Myfirst[v154]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v154]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v163 = *(const char **)v163;
      if ( !strcmp(v163, "SHADOWSTRENGTHRANGEMAX") )
      {
LABEL_289:
        v164 = Myfirst[v154]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v154]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Myres >= 0x10 )
          v164 = *(const char **)v164;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v164 )
        {
          v165 = -1i64;
          do
            ++v165;
          while ( v164[v165] );
        }
        else
        {
          v165 = 0i64;
        }
        std::string::assign(&_Val, v164, v165);
        v167 = std::stof(&_Val, v166);
        v161->P2ShadowRangeData.bodySelfShadowDotRangeMax = v167;
        v161->P1ShadowRangeData.bodySelfShadowDotRangeMax = v167;
        std::string::~string(&_Val);
      }
      v168 = Myfirst[v154]._Mypair._Myval2._Myfirst[4]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v154]._Mypair._Myval2._Myfirst[4]._Mypair._Myval2._Myres >= 0x10 )
        v168 = *(const char **)v168;
      if ( !strcmp(v168, "SKINSELFSHADSTRRGEMIN") )
      {
        v169 = Myfirst[v154]._Mypair._Myval2._Myfirst[5]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v154]._Mypair._Myval2._Myfirst[5]._Mypair._Myval2._Myres >= 0x10 )
          v169 = *(const char **)v169;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v169 )
        {
          v170 = -1i64;
          do
            ++v170;
          while ( v169[v170] );
        }
        else
        {
          v170 = 0i64;
        }
        std::string::assign(&_Val, v169, v170);
        v172 = std::stof(&_Val, v171);
        v161->P2ShadowRangeData.skinSelfShadowDotRangeMin = v172;
        v161->P1ShadowRangeData.skinSelfShadowDotRangeMin = v172;
        std::string::~string(&_Val);
      }
      v173 = Myfirst[v154]._Mypair._Myval2._Myfirst[6]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v154]._Mypair._Myval2._Myfirst[6]._Mypair._Myval2._Myres >= 0x10 )
        v173 = *(const char **)v173;
      if ( !strcmp(v173, "SKINSELFSHADSTRRGEMAX") )
      {
        v174 = Myfirst[v154]._Mypair._Myval2._Myfirst[7]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v154]._Mypair._Myval2._Myfirst[7]._Mypair._Myval2._Myres >= 0x10 )
          v174 = *(const char **)v174;
        _Right._Mypair._Myval2._Mysize = 0i64;
        _Right._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Right, 0, 0i64);
        if ( *v174 )
        {
          v4 = -1i64;
          do
            ++v4;
          while ( v174[v4] );
        }
        std::string::assign(&_Right, v174, v4);
        v176 = std::stof(&_Right, v175);
        v161->P2ShadowRangeData.skinSelfShadowDotRangeMax = v176;
        v161->P1ShadowRangeData.skinSelfShadowDotRangeMax = v176;
        std::string::~string(&_Right);
      }
    }
  }
  operator delete(_Ptr, v96);
  std::string::~string(&_Str);
  std::vector<std::vector<std::string>>::~vector<std::vector<std::string>>(&v190, v177, v178, v179);
  std::istringstream::~istringstream((std::istringstream *)&v201.gap88[8]);
  *(_QWORD *)&v201.gap88[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v201.gap88[8]);
  return 0i64;
}

__int64 __fastcall AppMain::loadCharacterLightData(
        AppMain *this,
        const char *lightFileName,
        AppMain::_WORLD_LIGHT_DATA *lightData,
        int charNo)
{
  unsigned __int64 v4; // r13
  int v5; // edi
  int v6; // eax
  int v8; // er8
  char *Ptr; // rcx
  char *v10; // rax
  const std::locale *v11; // rax
  __int64 v12; // rdx
  std::locale::facet *v13; // rbx
  std::_Facet_base *v14; // rax
  char v15; // al
  std::istream *v16; // rax
  std::locale *v17; // rbx
  const std::locale *v18; // rax
  __int64 v19; // rdx
  std::locale::facet *v20; // rbx
  void (__fastcall ***v21)(_QWORD, __int64); // rax
  int v22; // er9
  std::string *p_Str; // rdx
  std::istream *v24; // rax
  std::string *v25; // rdi
  unsigned __int64 Mysize; // r15
  std::string *p_Right; // r12
  char *v28; // rcx
  unsigned __int64 Myres; // rdx
  std::string *v30; // rax
  std::string *v31; // rax
  std::string *v32; // r14
  signed __int64 v33; // rsi
  __int64 i; // rbx
  std::string *v35; // r8
  std::string *v36; // rbx
  unsigned __int64 v37; // rbx
  std::string *v38; // rsi
  char *v39; // r14
  unsigned __int64 v40; // r12
  __int64 j; // rbx
  std::string *v42; // rax
  signed __int64 v43; // r8
  unsigned __int64 v44; // r10
  std::string *v45; // rax
  std::string *v46; // r9
  char *v47; // r9
  unsigned __int64 v48; // r15
  std::string *v49; // rax
  char *v50; // rcx
  signed __int64 v51; // rbx
  __int64 v52; // rdi
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // rdx
  std::string *v55; // rbx
  std::string *v56; // rax
  std::string *v57; // rdx
  __int64 v58; // rdi
  unsigned __int64 v59; // r9
  unsigned __int64 v60; // rdx
  std::istream *v61; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v62; // r8
  std::integral_constant<bool,0> v63; // r9
  char *v64; // rbx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v65; // rcx
  int v66; // edi
  std::vector<std::string> *Myfirst; // r12
  __int64 v68; // rbx
  std::string *v69; // rsi
  std::string *v70; // rcx
  __int64 v71; // rdx
  unsigned __int64 v72; // r8
  unsigned __int64 *v73; // rdx
  __int64 v74; // rsi
  int v75; // edi
  int v76; // ebx
  std::vector<std::string> *Mylast; // r15
  AppMain *v78; // rcx
  ShaderFxHelper::ShaderFxLightSetting *P1LightAssetData; // r14
  int v80; // edi
  const std::vector<std::string> *v81; // rbx
  signed __int64 v82; // r15
  unsigned __int64 v83; // rdx
  unsigned __int64 v84; // rsi
  std::string *v85; // rcx
  AppMain::_MODEL_RIM_LIGHT_DATA *p_P2RimLightAssetData; // r15
  std::_Wrap_alloc<std::allocator<std::string > > *v87; // r8
  std::integral_constant<bool,0> v88; // r9
  int v89; // edi
  std::string *v90; // rcx
  std::string *v91; // r14
  int v92; // esi
  char *v93; // rbx
  int v94; // er12
  const char *v95; // rcx
  std::string *v96; // rdx
  unsigned __int64 v97; // r8
  unsigned __int64 *v98; // rdx
  const char *v99; // rcx
  std::string *v100; // rdx
  unsigned __int64 v101; // r8
  unsigned __int64 *v102; // rdx
  const char *v103; // rcx
  std::string *v104; // rdx
  unsigned __int64 v105; // r8
  unsigned __int64 *v106; // rdx
  const char *v107; // rcx
  std::string *v108; // rdx
  unsigned __int64 v109; // r8
  unsigned __int64 *v110; // rdx
  std::string *v111; // rdx
  unsigned __int64 v112; // r8
  unsigned __int64 *v113; // rdx
  std::string *v114; // rdx
  unsigned __int64 v115; // r8
  unsigned __int64 *v116; // rdx
  int v117; // eax
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v118; // rcx
  int v119; // ebx
  std::string *v120; // rcx
  int v121; // er14
  int v122; // ebx
  AppMain::_MODEL_EMISSION_DATA *p_P2EmissionData; // rsi
  __int64 v124; // rdi
  std::string *v125; // rcx
  const char *Buf; // rbx
  unsigned __int64 v127; // r8
  unsigned __int64 *v128; // rdx
  const char *v129; // rcx
  const char *v130; // rbx
  unsigned __int64 v131; // r8
  unsigned __int64 *v132; // rdx
  std::string *v133; // rcx
  int v134; // ebx
  AppMain::_MODEL_SHADOW_DOT_RANGE_DATA *p_P2ShadowRangeData; // rsi
  __int64 v136; // rdi
  std::string *v137; // rcx
  std::string *v138; // rcx
  const char *v139; // rbx
  unsigned __int64 v140; // r8
  unsigned __int64 *v141; // rdx
  const char *v142; // rcx
  const char *v143; // rcx
  const char *v144; // rbx
  unsigned __int64 v145; // r8
  unsigned __int64 *v146; // rdx
  const char *v147; // rcx
  const char *v148; // rbx
  unsigned __int64 v149; // r8
  unsigned __int64 *v150; // rdx
  const char *v151; // rcx
  const char *v152; // rbx
  unsigned __int64 *v153; // rdx
  __int64 v154; // rdx
  std::_Wrap_alloc<std::allocator<std::vector<std::string> > > *v155; // r8
  std::integral_constant<bool,0> v156; // r9
  int v157; // [rsp+30h] [rbp-D0h]
  int v158; // [rsp+34h] [rbp-CCh]
  int v159; // [rsp+34h] [rbp-CCh]
  int v160; // [rsp+34h] [rbp-CCh]
  int v163; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v164; // [rsp+50h] [rbp-B0h]
  __int64 v165; // [rsp+50h] [rbp-B0h]
  char *v166; // [rsp+58h] [rbp-A8h]
  unsigned __int64 v167; // [rsp+58h] [rbp-A8h]
  char *_Ptr; // [rsp+60h] [rbp-A0h] BYREF
  std::vector<std::vector<std::string>> v169; // [rsp+68h] [rbp-98h] BYREF
  std::istream _Istr; // [rsp+80h] [rbp-80h] BYREF
  __int64 v171; // [rsp+F8h] [rbp-8h]
  int v172; // [rsp+100h] [rbp+0h]
  int v173; // [rsp+10Ch] [rbp+Ch]
  std::ios_base _This; // [rsp+110h] [rbp+10h] BYREF
  _BYTE *v175; // [rsp+158h] [rbp+58h]
  __int64 v176; // [rsp+160h] [rbp+60h]
  char v177; // [rsp+168h] [rbp+68h]
  __int64 v178; // [rsp+170h] [rbp+70h]
  std::locale result; // [rsp+178h] [rbp+78h] BYREF
  std::istringstream v180; // [rsp+190h] [rbp+90h] BYREF
  std::string _Val; // [rsp+280h] [rbp+180h] BYREF
  std::string _Right; // [rsp+2A0h] [rbp+1A0h] BYREF
  std::string v183; // [rsp+2C0h] [rbp+1C0h] BYREF
  std::string _Str; // [rsp+2E0h] [rbp+1E0h] BYREF

  v178 = -2i64;
  v4 = 0i64;
  v5 = 0;
  _Ptr = 0i64;
  v158 = 0;
  v6 = CFile::ResourceDataLoaderNew(
         lightFileName,
         (int)lightFileName,
         (int)lightData,
         charNo,
         (unsigned __int8 **)&_Ptr);
  if ( !_Ptr )
    return 0xFFFFFFFFi64;
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&_Str, _Ptr, v6);
  std::istringstream::istringstream(&v180, &_Str, v8);
  if ( _Str._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = _Str._Mypair._Myval2._Bx._Ptr;
    if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v10 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
      if ( v10 >= _Str._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  memset(&v169, 0, sizeof(v169));
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  v157 = 2;
  while ( 1 )
  {
    v11 = std::ios_base::getloc((std::ios_base *)&v180.gap0[*(int *)(*(_QWORD *)v180.gap0 + 4i64)], &result);
    v13 = std::use_facet<std::ctype<char>>(v11);
    if ( result._Ptr )
    {
      v14 = result._Ptr->_Decref(result._Ptr);
      if ( v14 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v14->~_Facet_base)(v14, 1i64);
    }
    LOBYTE(v12) = 10;
    v15 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v13->__vftable[2]._Decref)(v13, v12);
    v16 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&v180, &_Str, v15);
    if ( (v16->gap10[*(int *)(*(_QWORD *)v16->gap0 + 4i64)] & 6) != 0 )
      break;
    *(_QWORD *)_Istr.gap0 = &std::istringstream::`vbtable';
    v5 |= 1u;
    v163 = v5;
    _This.__vftable = (std::ios_base_vtbl *)&std::istream::`vftable';
    v173 = 120;
    _Istr._Chcount = 0i64;
    _This._Stdstr = 0i64;
    _This._Except = 0;
    _This._Fmtfl = 513;
    *(__m128i *)&_This._Prec = _mm_load_si128((const __m128i *)&_xmm);
    memset(&_This._Arr, 0, 24);
    std::ios_base::clear(&_This, 0, 0);
    v17 = (std::locale *)operator new(0x10ui64);
    v17->_Ptr = std::locale::_Init(1);
    _This._Ploc = v17;
    v175 = _Istr.gap10;
    v176 = 0i64;
    v18 = std::ios_base::getloc(&_This, (std::locale *)&v183);
    v20 = std::use_facet<std::ctype<char>>(v18);
    if ( *(_QWORD *)&v183._Mypair._Myval2._Bx._Alias[8] )
    {
      v21 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)&v183._Mypair._Myval2._Bx._Alias[8]
                                                                                      + 16i64))(*(_QWORD *)&v183._Mypair._Myval2._Bx._Alias[8]);
      if ( v21 )
        (**v21)(v21, 1i64);
    }
    LOBYTE(v19) = 32;
    v177 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v20->__vftable[2]._Decref)(v20, v19);
    if ( !v175 )
      std::ios_base::clear(&_This, _This._Mystate | 4, 0);
    *(_QWORD *)&_Istr.gap0[*(int *)(*(_QWORD *)_Istr.gap0 + 4i64)] = &std::istringstream::`vftable';
    *(_DWORD *)((char *)&v169._Mypair._Myval2._Myend + *(int *)(*(_QWORD *)_Istr.gap0 + 4i64) + 4) = *(_DWORD *)(*(_QWORD *)_Istr.gap0 + 4i64) - 144;
    std::streambuf::streambuf((std::streambuf *)_Istr.gap10);
    *(_QWORD *)_Istr.gap10 = &std::stringbuf::`vftable';
    p_Str = &_Str;
    if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
    v171 = 0i64;
    v172 = 2;
    if ( _Str._Mypair._Myval2._Mysize )
      std::stringbuf::_Init(
        (std::stringbuf *)_Istr.gap10,
        p_Str->_Mypair._Myval2._Bx._Buf,
        _Str._Mypair._Myval2._Mysize,
        v22);
    _Right._Mypair._Myval2._Myres = 15i64;
    _Right._Mypair._Myval2._Mysize = 0i64;
    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
    memset(&_Val, 0, 24);
    v164 = 0i64;
    v24 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
    if ( (v24->gap10[*(int *)(*(_QWORD *)v24->gap0 + 4i64)] & 6) == 0 )
    {
      v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      while ( 1 )
      {
        Mysize = _Right._Mypair._Myval2._Mysize;
        if ( !_Right._Mypair._Myval2._Mysize )
        {
LABEL_107:
          v5 = v163;
          break;
        }
        p_Right = &_Right;
        v28 = _Right._Mypair._Myval2._Bx._Ptr;
        Myres = _Right._Mypair._Myval2._Myres;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          p_Right = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v30 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v30 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v31 = (std::string *)((char *)v30 + _Right._Mypair._Myval2._Mysize);
        v32 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v32 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v33 = (char *)v31 - (char *)v32;
        if ( v32 > v31 )
          v33 = 0i64;
        if ( v33 )
        {
          for ( i = 0i64; i != v33; ++i )
            p_Right->_Mypair._Myval2._Bx._Buf[i] = toupper(v32->_Mypair._Myval2._Bx._Buf[i]);
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v28 = _Right._Mypair._Myval2._Bx._Ptr;
        }
        v35 = &_Right;
        if ( Myres >= 0x10 )
          v35 = (std::string *)v28;
        v166 = &v35->_Mypair._Myval2._Bx._Buf[Mysize];
        v36 = &_Right;
        if ( Myres >= 0x10 )
          v36 = (std::string *)v28;
        v37 = (unsigned __int64)v36 + Mysize;
        v38 = &_Right;
        if ( Myres >= 0x10 )
          v38 = (std::string *)v28;
        if ( v38 != (std::string *)v37 )
        {
          do
          {
            if ( isspace(v38->_Mypair._Myval2._Bx._Buf[0]) )
              break;
            v38 = (std::string *)((char *)v38 + 1);
          }
          while ( v38 != (std::string *)v37 );
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v28 = _Right._Mypair._Myval2._Bx._Ptr;
          if ( v38 != (std::string *)v37 )
          {
            v39 = &v38->_Mypair._Myval2._Bx._Buf[1];
            v40 = v37 - (_QWORD)&v38->_Mypair._Myval2._Bx._Buf[1];
            if ( (unsigned __int64)&v38->_Mypair._Myval2._Bx._Buf[1] > v37 )
              v40 = 0i64;
            if ( v40 )
            {
              for ( j = 0i64; j != v40; ++j )
              {
                if ( !isspace(*v39) )
                {
                  v38->_Mypair._Myval2._Bx._Buf[0] = *v39;
                  v38 = (std::string *)((char *)v38 + 1);
                }
                ++v39;
              }
              Myres = _Right._Mypair._Myval2._Myres;
              Mysize = _Right._Mypair._Myval2._Mysize;
              v28 = _Right._Mypair._Myval2._Bx._Ptr;
            }
          }
        }
        v42 = &_Right;
        if ( Myres >= 0x10 )
          v42 = (std::string *)v28;
        v43 = (char *)v38 - (char *)v42;
        v44 = v166 - (char *)v38;
        if ( Mysize < (char *)v38 - (char *)v42 )
          std::_Xout_of_range("invalid string position");
        if ( Mysize - v43 > v44 )
        {
          if ( v44 )
          {
            v46 = &_Right;
            if ( Myres >= 0x10 )
              v46 = (std::string *)v28;
            v47 = &v46->_Mypair._Myval2._Bx._Buf[v43];
            v48 = Mysize - v44;
            if ( v48 != v43 )
            {
              memmove(v47, &v47[v44], v48 - v43);
              Myres = _Right._Mypair._Myval2._Myres;
              v28 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            _Right._Mypair._Myval2._Mysize = v48;
            v49 = &_Right;
            if ( Myres >= 0x10 )
              v49 = (std::string *)v28;
            v49->_Mypair._Myval2._Bx._Buf[v48] = 0;
          }
        }
        else
        {
          _Right._Mypair._Myval2._Mysize = (char *)v38 - (char *)v42;
          v45 = &_Right;
          if ( Myres >= 0x10 )
            v45 = (std::string *)v28;
          v45->_Mypair._Myval2._Bx._Buf[v43] = 0;
        }
        v50 = _Val._Mypair._Myval2._Bx._Ptr;
        if ( &_Right >= v25 || _Val._Mypair._Myval2._Bx._Ptr > (char *)&_Right )
        {
          if ( v25 == (std::string *)v164 && !((__int64)(v164 - (_QWORD)v25) >> 5) )
          {
            v58 = ((char *)v25 - _Val._Mypair._Myval2._Bx._Ptr) >> 5;
            if ( v58 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v59 = (__int64)(v164 - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
            v60 = (v59 >> 1) + v59;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v59 >> 1) < v59 )
              v60 = 0i64;
            if ( v60 < v58 + 1 )
              v60 = v58 + 1;
            std::vector<std::string>::_Reallocate((std::vector<std::string> *)&_Val, v60);
            v164 = _Val._Mypair._Myval2._Mysize;
            v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
          }
          if ( !v25 )
            goto LABEL_106;
          v25->_Mypair._Myval2._Myres = 15i64;
          v25->_Mypair._Myval2._Mysize = 0i64;
          if ( v25->_Mypair._Myval2._Myres < 0x10 )
            v56 = v25;
          else
            v56 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
          v57 = &_Right;
        }
        else
        {
          v51 = (char *)&_Right - _Val._Mypair._Myval2._Bx._Ptr;
          if ( v25 == (std::string *)v164 && !((__int64)(v164 - (_QWORD)v25) >> 5) )
          {
            v52 = ((char *)v25 - _Val._Mypair._Myval2._Bx._Ptr) >> 5;
            if ( v52 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v53 = (__int64)(v164 - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
            v54 = (v53 >> 1) + v53;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v53 >> 1) < v53 )
              v54 = 0i64;
            if ( v54 < v52 + 1 )
              v54 = v52 + 1;
            std::vector<std::string>::_Reallocate((std::vector<std::string> *)&_Val, v54);
            v164 = _Val._Mypair._Myval2._Mysize;
            v25 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
            v50 = _Val._Mypair._Myval2._Bx._Ptr;
          }
          v55 = (std::string *)&v50[v51 & 0xFFFFFFFFFFFFFFE0ui64];
          if ( !v25 )
            goto LABEL_106;
          v25->_Mypair._Myval2._Myres = 15i64;
          v25->_Mypair._Myval2._Mysize = 0i64;
          if ( v25->_Mypair._Myval2._Myres < 0x10 )
            v56 = v25;
          else
            v56 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
          v57 = v55;
        }
        v56->_Mypair._Myval2._Bx._Buf[0] = 0;
        std::string::_Assign_rv(v25, v57);
LABEL_106:
        *(_QWORD *)&_Val._Mypair._Myval2._Bx._Alias[8] = ++v25;
        v61 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
        if ( (v61->gap10[*(int *)(*(_QWORD *)v61->gap0 + 4i64)] & 6) != 0 )
          goto LABEL_107;
      }
    }
    std::vector<std::vector<std::string>>::push_back(&v169, (std::vector<std::string> *)&_Val);
    v64 = _Val._Mypair._Myval2._Bx._Ptr;
    if ( _Val._Mypair._Myval2._Bx._Ptr )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        (std::string *)_Val._Mypair._Myval2._Bx._Ptr,
        *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8],
        v62,
        v63);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v65,
        (AgDirectory::DirectoryEntry *)v64,
        (__int64)(_Val._Mypair._Myval2._Mysize - (_QWORD)v64) >> 5);
    }
    std::string::~string(&_Right);
    std::istringstream::~istringstream((std::istringstream *)&_This);
    _This.__vftable = (std::ios_base_vtbl *)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&_This);
  }
  v66 = 0;
  Myfirst = v169._Mypair._Myval2._Myfirst;
  if ( v169._Mypair._Myval2._Myfirst->_Mypair._Myval2._Mylast - v169._Mypair._Myval2._Myfirst->_Mypair._Myval2._Myfirst )
  {
    v68 = 0i64;
    do
    {
      v69 = Myfirst->_Mypair._Myval2._Myfirst;
      v70 = &Myfirst->_Mypair._Myval2._Myfirst[v68];
      if ( v70->_Mypair._Myval2._Myres >= 0x10 )
        v70 = (std::string *)v70->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v70->_Mypair._Myval2._Bx._Buf, "NUMLIGHTS") )
      {
        v71 = (__int64)&v69[v68 + 1];
        if ( *(_QWORD *)(v71 + 24) >= 0x10ui64 )
          v71 = *(_QWORD *)v71;
        _Right._Mypair._Myval2._Myres = 15i64;
        _Right._Mypair._Myval2._Mysize = 0i64;
        _Right._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( *(_BYTE *)v71 )
        {
          v72 = -1i64;
          do
            ++v72;
          while ( *(_BYTE *)(v71 + v72) );
        }
        else
        {
          v72 = 0i64;
        }
        std::string::assign(&_Right, (const char *)v71, v72);
        LODWORD(v74) = (int)std::stof(&_Right, v73);
        v158 = v74;
        std::string::~string(&_Right);
        ++v66;
        ++v68;
      }
      else
      {
        LODWORD(v74) = v158;
      }
      ++v66;
      ++v68;
    }
    while ( v66 < (unsigned __int64)(Myfirst->_Mypair._Myval2._Mylast - Myfirst->_Mypair._Myval2._Myfirst) );
  }
  else
  {
    LODWORD(v74) = 0;
  }
  v75 = charNo;
  if ( charNo )
    lightData->numP2Lights = v74;
  else
    lightData->numP1Lights = v74;
  v76 = 1;
  Mylast = v169._Mypair._Myval2._Mylast;
  if ( (int)v74 > 0 )
  {
    v78 = (AppMain *)((char *)v169._Mypair._Myval2._Mylast - (char *)Myfirst);
    if ( (unsigned __int64)(v169._Mypair._Myval2._Mylast - Myfirst) > 1 )
    {
      P1LightAssetData = lightData->P1LightAssetData;
      if ( charNo )
        P1LightAssetData = lightData->P2LightAssetData;
      v80 = 0;
      v74 = (int)v74;
      v81 = Myfirst + 1;
      do
      {
        if ( v81->_Mypair._Myval2._Mylast - v81->_Mypair._Myval2._Myfirst )
          AppMain::processLightData(v78, v81, &P1LightAssetData[v80]);
        ++v80;
        ++v81;
        --v74;
      }
      while ( v74 );
      v76 = v158 + 1;
      v75 = charNo;
    }
  }
  v82 = (char *)Mylast - (char *)Myfirst;
  v83 = (unsigned __int128)(v82 * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v84 = v82 / 24;
  v165 = v82 / 24;
  if ( v76 < (unsigned __int64)(v82 / 24)
    && Myfirst[v76]._Mypair._Myval2._Mylast - Myfirst[v76]._Mypair._Myval2._Myfirst )
  {
    v85 = Myfirst[v76]._Mypair._Myval2._Myfirst;
    if ( v85->_Mypair._Myval2._Myres >= 0x10 )
      v85 = (std::string *)v85->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v85->_Mypair._Myval2._Bx._Buf, "RIMLIGHT") )
    {
      if ( v75 )
        p_P2RimLightAssetData = &lightData->P2RimLightAssetData;
      else
        p_P2RimLightAssetData = &lightData->P1RimLightAssetData;
      v159 = ++v76;
      std::vector<std::string>::vector<std::string>((std::vector<std::string> *)&_Val, &Myfirst[v76]);
      v89 = 0;
      v90 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      v91 = (std::string *)_Val._Mypair._Myval2._Bx._Ptr;
      v167 = (__int64)(*(_QWORD *)&_Val._Mypair._Myval2._Bx._Alias[8] - (unsigned __int64)_Val._Mypair._Myval2._Bx._Ptr) >> 5;
      if ( v167 )
      {
        v92 = 3;
        v93 = _Val._Mypair._Myval2._Bx._Ptr;
        v94 = 1;
        do
        {
          if ( *((_QWORD *)v93 + 3) < 0x10ui64 )
            v95 = v93;
          else
            v95 = *(const char **)v93;
          if ( !strcmp(v95, "RIMLIGHTMIN") )
          {
            v96 = &v91[v94];
            if ( v96->_Mypair._Myval2._Myres >= 0x10 )
              v96 = (std::string *)v96->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v96->_Mypair._Myval2._Bx._Buf[0] )
            {
              v97 = -1i64;
              do
                ++v97;
              while ( v96->_Mypair._Myval2._Bx._Buf[v97] );
            }
            else
            {
              v97 = 0i64;
            }
            std::string::assign(&v183, v96->_Mypair._Myval2._Bx._Buf, v97);
            p_P2RimLightAssetData->rimLightMin = std::stof(&v183, v98);
            std::string::~string(&v183);
            v89 += 2;
            v94 += 2;
            v157 += 2;
            v92 += 2;
            v93 += 64;
          }
          if ( *((_QWORD *)v93 + 3) < 0x10ui64 )
            v99 = v93;
          else
            v99 = *(const char **)v93;
          if ( !strcmp(v99, "RIMLIGHTMAX") )
          {
            v100 = &v91[v94];
            if ( v100->_Mypair._Myval2._Myres >= 0x10 )
              v100 = (std::string *)v100->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v100->_Mypair._Myval2._Bx._Buf[0] )
            {
              v101 = -1i64;
              do
                ++v101;
              while ( v100->_Mypair._Myval2._Bx._Buf[v101] );
            }
            else
            {
              v101 = 0i64;
            }
            std::string::assign(&v183, v100->_Mypair._Myval2._Bx._Buf, v101);
            p_P2RimLightAssetData->rimLightMax = std::stof(&v183, v102);
            std::string::~string(&v183);
            v89 += 2;
            v94 += 2;
            v157 += 2;
            v92 += 2;
            v93 += 64;
          }
          if ( *((_QWORD *)v93 + 3) < 0x10ui64 )
            v103 = v93;
          else
            v103 = *(const char **)v93;
          if ( !strcmp(v103, "RIMLIGHTSTRENGTH") )
          {
            v104 = &v91[v94];
            if ( v104->_Mypair._Myval2._Myres >= 0x10 )
              v104 = (std::string *)v104->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v104->_Mypair._Myval2._Bx._Buf[0] )
            {
              v105 = -1i64;
              do
                ++v105;
              while ( v104->_Mypair._Myval2._Bx._Buf[v105] );
            }
            else
            {
              v105 = 0i64;
            }
            std::string::assign(&v183, v104->_Mypair._Myval2._Bx._Buf, v105);
            p_P2RimLightAssetData->rimLightStrength = std::stof(&v183, v106);
            std::string::~string(&v183);
            v89 += 2;
            v94 += 2;
            v157 += 2;
            v92 += 2;
            v93 += 64;
          }
          if ( *((_QWORD *)v93 + 3) < 0x10ui64 )
            v107 = v93;
          else
            v107 = *(const char **)v93;
          if ( !strcmp(v107, "RIMLIGHTCOLOR") )
          {
            v108 = &v91[v94];
            if ( v108->_Mypair._Myval2._Myres >= 0x10 )
              v108 = (std::string *)v108->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v108->_Mypair._Myval2._Bx._Buf[0] )
            {
              v109 = -1i64;
              do
                ++v109;
              while ( v108->_Mypair._Myval2._Bx._Buf[v109] );
            }
            else
            {
              v109 = 0i64;
            }
            std::string::assign(&v183, v108->_Mypair._Myval2._Bx._Buf, v109);
            p_P2RimLightAssetData->rimLightColour[0] = std::stof(&v183, v110);
            std::string::~string(&v183);
            v111 = &v91[v157];
            if ( v111->_Mypair._Myval2._Myres >= 0x10 )
              v111 = (std::string *)v111->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v111->_Mypair._Myval2._Bx._Buf[0] )
            {
              v112 = -1i64;
              do
                ++v112;
              while ( v111->_Mypair._Myval2._Bx._Buf[v112] );
            }
            else
            {
              v112 = 0i64;
            }
            std::string::assign(&v183, v111->_Mypair._Myval2._Bx._Buf, v112);
            p_P2RimLightAssetData->rimLightColour[1] = std::stof(&v183, v113);
            std::string::~string(&v183);
            v114 = &v91[v92];
            if ( v114->_Mypair._Myval2._Myres >= 0x10 )
              v114 = (std::string *)v114->_Mypair._Myval2._Bx._Ptr;
            v183._Mypair._Myval2._Myres = 15i64;
            v183._Mypair._Myval2._Mysize = 0i64;
            v183._Mypair._Myval2._Bx._Buf[0] = 0;
            if ( v114->_Mypair._Myval2._Bx._Buf[0] )
            {
              v115 = -1i64;
              do
                ++v115;
              while ( v114->_Mypair._Myval2._Bx._Buf[v115] );
            }
            else
            {
              v115 = 0i64;
            }
            std::string::assign(&v183, v114->_Mypair._Myval2._Bx._Buf, v115);
            p_P2RimLightAssetData->rimLightColour[2] = std::stof(&v183, v116);
            std::string::~string(&v183);
            v89 += 4;
            v94 += 4;
            v117 = v157 + 4;
            v92 += 4;
            v93 += 128;
          }
          else
          {
            v117 = v157;
          }
          ++v89;
          ++v94;
          v157 = v117 + 1;
          ++v92;
          v93 += 32;
        }
        while ( v89 < v167 );
        Myfirst = v169._Mypair._Myval2._Myfirst;
        v76 = v159;
        v84 = v165;
        v90 = *(std::string **)&_Val._Mypair._Myval2._Bx._Alias[8];
      }
      if ( v91 )
      {
        std::_Destroy_range1<std::allocator<std::string>,std::string *>(v91, v90, v87, v88);
        std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
          v118,
          (AgDirectory::DirectoryEntry *)v91,
          (__int64)(_Val._Mypair._Myval2._Mysize - (_QWORD)v91) >> 5);
      }
    }
  }
  v119 = v76 + 1;
  if ( v119 < v84 && Myfirst[v119]._Mypair._Myval2._Mylast - Myfirst[v119]._Mypair._Myval2._Myfirst )
  {
    v120 = Myfirst[v119]._Mypair._Myval2._Myfirst;
    if ( v120->_Mypair._Myval2._Myres >= 0x10 )
      v120 = (std::string *)v120->_Mypair._Myval2._Bx._Ptr;
    v121 = charNo;
    if ( !strcmp(v120->_Mypair._Myval2._Bx._Buf, "EMISSION") )
    {
      v122 = v119 + 1;
      v160 = v122;
      if ( charNo )
        p_P2EmissionData = &lightData->P2EmissionData;
      else
        p_P2EmissionData = &lightData->P1EmissionData;
      v124 = v122;
      v125 = Myfirst[v122]._Mypair._Myval2._Myfirst;
      if ( v125->_Mypair._Myval2._Myres >= 0x10 )
        v125 = (std::string *)v125->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v125->_Mypair._Myval2._Bx._Buf, "EYEEMISSIONSTRENGTH") )
      {
        Buf = Myfirst[v122]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v124]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Myres >= 0x10 )
          Buf = *(const char **)Buf;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *Buf )
        {
          v127 = -1i64;
          do
            ++v127;
          while ( Buf[v127] );
        }
        else
        {
          v127 = 0i64;
        }
        std::string::assign(&_Val, Buf, v127);
        p_P2EmissionData->eyeEmissionStrength = std::stof(&_Val, v128);
        std::string::~string(&_Val);
        v122 = v160;
      }
      v129 = Myfirst[v124]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v124]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v129 = *(const char **)v129;
      if ( !strcmp(v129, "CHAREMISSIONSTRENGTH") )
      {
        v130 = Myfirst[v124]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v124]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Myres >= 0x10 )
          v130 = *(const char **)v130;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v130 )
        {
          v131 = -1i64;
          do
            ++v131;
          while ( v130[v131] );
        }
        else
        {
          v131 = 0i64;
        }
        std::string::assign(&_Val, v130, v131);
        p_P2EmissionData->charEmissionStrength = std::stof(&_Val, v132);
        std::string::~string(&_Val);
        v122 = v160;
      }
      v119 = v122 + 1;
      v84 = v165;
    }
  }
  else
  {
    v121 = charNo;
  }
  if ( v119 < v84 && Myfirst[v119]._Mypair._Myval2._Mylast - Myfirst[v119]._Mypair._Myval2._Myfirst )
  {
    v133 = Myfirst[v119]._Mypair._Myval2._Myfirst;
    if ( v133->_Mypair._Myval2._Myres >= 0x10 )
      v133 = (std::string *)v133->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v133->_Mypair._Myval2._Bx._Buf, "SHADOWSTRENGTHRANGE") )
    {
      v134 = v119 + 1;
      if ( v121 )
        p_P2ShadowRangeData = &lightData->P2ShadowRangeData;
      else
        p_P2ShadowRangeData = &lightData->P1ShadowRangeData;
      v136 = v134;
      v137 = Myfirst[v134]._Mypair._Myval2._Myfirst;
      if ( v137->_Mypair._Myval2._Myres >= 0x10 )
        v137 = (std::string *)v137->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v137->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADSTRRGEMIN") )
        goto LABEL_257;
      v138 = Myfirst[v134]._Mypair._Myval2._Myfirst;
      if ( v138->_Mypair._Myval2._Myres >= 0x10 )
        v138 = (std::string *)v138->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v138->_Mypair._Myval2._Bx._Buf, "SHADOWSTRENGTHRANGEMIN") )
      {
LABEL_257:
        v139 = Myfirst[v134]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v136]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Myres >= 0x10 )
          v139 = *(const char **)v139;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v139 )
        {
          v140 = -1i64;
          do
            ++v140;
          while ( v139[v140] );
        }
        else
        {
          v140 = 0i64;
        }
        std::string::assign(&_Val, v139, v140);
        p_P2ShadowRangeData->bodySelfShadowDotRangeMin = std::stof(&_Val, v141);
        std::string::~string(&_Val);
      }
      v142 = Myfirst[v136]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v136]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v142 = *(const char **)v142;
      if ( !strcmp(v142, "BODYSELFSHADSTRRGEMAX") )
        goto LABEL_270;
      v143 = Myfirst[v136]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v136]._Mypair._Myval2._Myfirst[2]._Mypair._Myval2._Myres >= 0x10 )
        v143 = *(const char **)v143;
      if ( !strcmp(v143, "SHADOWSTRENGTHRANGEMAX") )
      {
LABEL_270:
        v144 = Myfirst[v136]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v136]._Mypair._Myval2._Myfirst[3]._Mypair._Myval2._Myres >= 0x10 )
          v144 = *(const char **)v144;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v144 )
        {
          v145 = -1i64;
          do
            ++v145;
          while ( v144[v145] );
        }
        else
        {
          v145 = 0i64;
        }
        std::string::assign(&_Val, v144, v145);
        p_P2ShadowRangeData->bodySelfShadowDotRangeMax = std::stof(&_Val, v146);
        std::string::~string(&_Val);
      }
      v147 = Myfirst[v136]._Mypair._Myval2._Myfirst[4]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v136]._Mypair._Myval2._Myfirst[4]._Mypair._Myval2._Myres >= 0x10 )
        v147 = *(const char **)v147;
      if ( !strcmp(v147, "SKINSELFSHADSTRRGEMIN") )
      {
        v148 = Myfirst[v136]._Mypair._Myval2._Myfirst[5]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v136]._Mypair._Myval2._Myfirst[5]._Mypair._Myval2._Myres >= 0x10 )
          v148 = *(const char **)v148;
        _Val._Mypair._Myval2._Mysize = 0i64;
        _Val._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Val, 0, 0i64);
        if ( *v148 )
        {
          v149 = -1i64;
          do
            ++v149;
          while ( v148[v149] );
        }
        else
        {
          v149 = 0i64;
        }
        std::string::assign(&_Val, v148, v149);
        p_P2ShadowRangeData->skinSelfShadowDotRangeMin = std::stof(&_Val, v150);
        std::string::~string(&_Val);
      }
      v151 = Myfirst[v136]._Mypair._Myval2._Myfirst[6]._Mypair._Myval2._Bx._Buf;
      if ( Myfirst[v136]._Mypair._Myval2._Myfirst[6]._Mypair._Myval2._Myres >= 0x10 )
        v151 = *(const char **)v151;
      if ( !strcmp(v151, "SKINSELFSHADSTRRGEMAX") )
      {
        v152 = Myfirst[v136]._Mypair._Myval2._Myfirst[7]._Mypair._Myval2._Bx._Buf;
        if ( Myfirst[v136]._Mypair._Myval2._Myfirst[7]._Mypair._Myval2._Myres >= 0x10 )
          v152 = *(const char **)v152;
        _Right._Mypair._Myval2._Mysize = 0i64;
        _Right._Mypair._Myval2._Myres = 0i64;
        std::string::_Tidy(&_Right, 0, 0i64);
        if ( *v152 )
        {
          v4 = -1i64;
          do
            ++v4;
          while ( v152[v4] );
        }
        std::string::assign(&_Right, v152, v4);
        p_P2ShadowRangeData->skinSelfShadowDotRangeMax = std::stof(&_Right, v153);
        std::string::~string(&_Right);
      }
    }
  }
  operator delete(_Ptr, v83);
  std::string::~string(&_Str);
  std::vector<std::vector<std::string>>::~vector<std::vector<std::string>>(&v169, v154, v155, v156);
  std::istringstream::~istringstream((std::istringstream *)&v180.gap88[8]);
  *(_QWORD *)&v180.gap88[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v180.gap88[8]);
  return 0i64;
}

__int64 __fastcall AppMain::loadCharacterSpecialLightSettings(
        AppMain *this,
        const char *lightFileName,
        AppMain::_SPECIAL_LIGHT_SETTINGS *specialSettings,
        int a4)
{
  __int64 v4; // r13
  int v5; // edi
  int v6; // eax
  int v8; // er8
  char *Ptr; // rcx
  char *v10; // rax
  const std::locale *v11; // rax
  __int64 v12; // rdx
  std::locale::facet *v13; // rbx
  std::_Facet_base *v14; // rax
  char v15; // al
  std::istream *v16; // rax
  unsigned __int64 v17; // rdx
  std::locale *v18; // rbx
  const std::locale *v19; // rax
  __int64 v20; // rdx
  std::locale::facet *v21; // rbx
  void (__fastcall ***v22)(_QWORD, __int64); // rax
  int v23; // er9
  std::string *p_Str; // rdx
  std::string *Myend; // r12
  std::istream *v26; // rax
  std::string *Mylast; // rdi
  unsigned __int64 Mysize; // r15
  std::string *p_Right; // r13
  char *v30; // rcx
  unsigned __int64 Myres; // rdx
  std::string *v32; // rax
  std::string *v33; // rax
  std::string *v34; // r14
  signed __int64 v35; // rsi
  __int64 i; // rbx
  std::string *v37; // r8
  std::string *v38; // rbx
  unsigned __int64 v39; // rbx
  std::string *v40; // rsi
  char *v41; // r14
  unsigned __int64 v42; // r13
  __int64 j; // rbx
  std::string *v44; // rax
  signed __int64 v45; // r8
  unsigned __int64 v46; // r9
  std::string *v47; // rax
  std::string *v48; // r10
  char *v49; // r10
  unsigned __int64 v50; // r15
  std::string *v51; // rax
  std::string *Myfirst; // rcx
  signed __int64 v53; // rbx
  __int64 v54; // rdi
  unsigned __int64 v55; // r12
  unsigned __int64 v56; // rdx
  std::string *v57; // rbx
  std::string *v58; // rax
  std::string *v59; // rdx
  __int64 v60; // rdi
  unsigned __int64 v61; // r12
  unsigned __int64 v62; // rdx
  std::istream *v63; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v64; // r8
  std::integral_constant<bool,0> v65; // r9
  AgDirectory::DirectoryEntry *v66; // rbx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v67; // rcx
  int v68; // edi
  std::vector<std::string> *v69; // r12
  int v70; // er14
  __int64 v71; // rbx
  std::string *v72; // rsi
  std::string *v73; // rcx
  __int64 v74; // rdx
  unsigned __int64 v75; // r8
  unsigned __int64 *v76; // rdx
  int v77; // er15
  __int64 v78; // rsi
  std::string *v79; // rbx
  const char *Buf; // rcx
  const char *v81; // rdx
  unsigned __int64 v82; // r8
  unsigned __int64 *v83; // rdx
  int v84; // er8
  int v85; // eax
  __int64 v86; // rcx
  AppMain::_SPECIAL_LIGHT_SETTINGS *v87; // r13
  int v88; // er15
  std::string *v89; // rcx
  const char *v90; // rdx
  unsigned __int64 v91; // r8
  unsigned __int64 *v92; // rdx
  __int64 v93; // rbx
  __int64 v94; // r14
  AppMain *v95; // rcx
  const std::vector<std::string> *v96; // rdi
  float *colour; // rbx
  __int64 v98; // rbx
  unsigned __int64 v99; // rdi
  int v100; // er15
  std::string *v101; // rcx
  std::_Wrap_alloc<std::allocator<std::string > > *v102; // r8
  std::integral_constant<bool,0> v103; // r9
  int v104; // er14
  std::string *v105; // rcx
  std::string *v106; // r13
  int v107; // esi
  int v108; // er15
  int v109; // er12
  std::string *v110; // rdi
  const char *v111; // rcx
  std::string *v112; // rdx
  unsigned __int64 v113; // r8
  unsigned __int64 *v114; // rdx
  const char *v115; // rcx
  std::string *v116; // rdx
  unsigned __int64 v117; // r8
  unsigned __int64 *v118; // rdx
  const char *v119; // rcx
  std::string *v120; // rdx
  unsigned __int64 v121; // r8
  unsigned __int64 *v122; // rdx
  const char *v123; // rcx
  std::string *v124; // rdx
  unsigned __int64 v125; // r8
  __int64 v126; // rbx
  unsigned __int64 *v127; // rdx
  std::string *v128; // rdx
  unsigned __int64 v129; // r8
  unsigned __int64 *v130; // rdx
  std::string *v131; // rdx
  unsigned __int64 v132; // r8
  unsigned __int64 *v133; // rdx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v134; // rcx
  std::string *v135; // rcx
  int v136; // er15
  std::string *v137; // rbx
  const char *v138; // rcx
  std::string *v139; // rbx
  unsigned __int64 v140; // r8
  unsigned __int64 *v141; // rdx
  __int64 v142; // r13
  AppMain::_SPECIAL_LIGHT_SETTINGS *v143; // rsi
  std::string *v144; // rbx
  const char *v145; // rcx
  std::string *v146; // rbx
  unsigned __int64 v147; // r8
  unsigned __int64 *v148; // rdx
  std::string *v149; // rcx
  int v150; // er15
  std::string *v151; // rbx
  const char *v152; // rcx
  const char *v153; // rcx
  std::string *v154; // rbx
  unsigned __int64 v155; // r8
  unsigned __int64 *v156; // rdx
  AppMain::_SPECIAL_LIGHT_SETTINGS *v157; // r14
  std::string *v158; // rdi
  const char *v159; // rbx
  const char *v160; // rcx
  const char *v161; // rbx
  unsigned __int64 v162; // r8
  unsigned __int64 *v163; // rdx
  std::string *v164; // rbx
  const char *v165; // rcx
  std::string *v166; // rbx
  unsigned __int64 v167; // r8
  unsigned __int64 *v168; // rdx
  std::string *v169; // rbx
  const char *v170; // rcx
  std::string *v171; // rbx
  unsigned __int64 v172; // r8
  unsigned __int64 *v173; // rdx
  char **v174; // rcx
  char v175; // al
  __int64 v176; // rdx
  std::_Wrap_alloc<std::allocator<std::vector<std::string> > > *v177; // r8
  std::integral_constant<bool,0> v178; // r9
  int v179; // [rsp+30h] [rbp-D0h]
  __int64 v180; // [rsp+30h] [rbp-D0h]
  int v181; // [rsp+38h] [rbp-C8h]
  int v183; // [rsp+48h] [rbp-B8h]
  std::vector<std::string> _Val; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v185; // [rsp+68h] [rbp-98h]
  char *_Ptr; // [rsp+70h] [rbp-90h] BYREF
  __int64 v187; // [rsp+78h] [rbp-88h]
  std::vector<std::vector<std::string>> v188; // [rsp+80h] [rbp-80h] BYREF
  std::locale result; // [rsp+98h] [rbp-68h] BYREF
  int v190; // [rsp+ACh] [rbp-54h]
  std::istream _Istr; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v192; // [rsp+128h] [rbp+28h]
  int v193; // [rsp+130h] [rbp+30h]
  int v194; // [rsp+13Ch] [rbp+3Ch]
  std::ios_base _This; // [rsp+140h] [rbp+40h] BYREF
  _BYTE *v196; // [rsp+188h] [rbp+88h]
  __int64 v197; // [rsp+190h] [rbp+90h]
  char v198; // [rsp+198h] [rbp+98h]
  __int64 v199; // [rsp+1A0h] [rbp+A0h]
  std::istringstream v200; // [rsp+1B0h] [rbp+B0h] BYREF
  std::string _Right; // [rsp+2A0h] [rbp+1A0h] BYREF
  std::string _Str; // [rsp+2C0h] [rbp+1C0h] BYREF
  std::string v203; // [rsp+2E0h] [rbp+1E0h] BYREF

  v199 = -2i64;
  v4 = 0i64;
  v5 = 0;
  _Ptr = 0i64;
  v181 = 0;
  v6 = CFile::ResourceDataLoaderNew(
         lightFileName,
         (int)lightFileName,
         (int)specialSettings,
         a4,
         (unsigned __int8 **)&_Ptr);
  if ( !_Ptr )
    return 0xFFFFFFFFi64;
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&_Str, _Ptr, v6);
  std::istringstream::istringstream(&v200, &_Str, v8);
  if ( _Str._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = _Str._Mypair._Myval2._Bx._Ptr;
    if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v10 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
      if ( v10 >= _Str._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  memset(&v188, 0, sizeof(v188));
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  while ( 1 )
  {
    v11 = std::ios_base::getloc((std::ios_base *)&v200.gap0[*(int *)(*(_QWORD *)v200.gap0 + 4i64)], &result);
    v13 = std::use_facet<std::ctype<char>>(v11);
    if ( result._Ptr )
    {
      v14 = result._Ptr->_Decref(result._Ptr);
      if ( v14 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v14->~_Facet_base)(v14, 1i64);
    }
    LOBYTE(v12) = 10;
    v15 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v13->__vftable[2]._Decref)(v13, v12);
    v16 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&v200, &_Str, v15);
    v17 = *(int *)(*(_QWORD *)v16->gap0 + 4i64);
    if ( (v16->gap10[v17] & 6) != 0 )
      break;
    *(_QWORD *)_Istr.gap0 = &std::istringstream::`vbtable';
    v5 |= 1u;
    v179 = v5;
    _This.__vftable = (std::ios_base_vtbl *)&std::istream::`vftable';
    v194 = 120;
    _Istr._Chcount = 0i64;
    _This._Stdstr = 0i64;
    _This._Except = 0;
    _This._Fmtfl = 513;
    *(__m128i *)&_This._Prec = _mm_load_si128((const __m128i *)&_xmm);
    memset(&_This._Arr, 0, 24);
    std::ios_base::clear(&_This, 0, 0);
    v18 = (std::locale *)operator new(0x10ui64);
    v18->_Ptr = std::locale::_Init(1);
    _This._Ploc = v18;
    v196 = _Istr.gap10;
    v197 = 0i64;
    v19 = std::ios_base::getloc(&_This, (std::locale *)&v203);
    v21 = std::use_facet<std::ctype<char>>(v19);
    if ( *(_QWORD *)&v203._Mypair._Myval2._Bx._Alias[8] )
    {
      v22 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)&v203._Mypair._Myval2._Bx._Alias[8]
                                                                                      + 16i64))(*(_QWORD *)&v203._Mypair._Myval2._Bx._Alias[8]);
      if ( v22 )
        (**v22)(v22, 1i64);
    }
    LOBYTE(v20) = 32;
    v198 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v21->__vftable[2]._Decref)(v21, v20);
    if ( !v196 )
      std::ios_base::clear(&_This, _This._Mystate | 4, 0);
    *(_QWORD *)&_Istr.gap0[*(int *)(*(_QWORD *)_Istr.gap0 + 4i64)] = &std::istringstream::`vftable';
    *(int *)((char *)&v190 + *(int *)(*(_QWORD *)_Istr.gap0 + 4i64)) = *(_DWORD *)(*(_QWORD *)_Istr.gap0 + 4i64) - 144;
    v187 = (__int64)_Istr.gap10;
    std::streambuf::streambuf((std::streambuf *)_Istr.gap10);
    *(_QWORD *)_Istr.gap10 = &std::stringbuf::`vftable';
    p_Str = &_Str;
    if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
    v192 = 0i64;
    v193 = 2;
    if ( _Str._Mypair._Myval2._Mysize )
      std::stringbuf::_Init(
        (std::stringbuf *)_Istr.gap10,
        p_Str->_Mypair._Myval2._Bx._Buf,
        _Str._Mypair._Myval2._Mysize,
        v23);
    _Right._Mypair._Myval2._Myres = 15i64;
    _Right._Mypair._Myval2._Mysize = 0i64;
    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
    memset(&_Val, 0, sizeof(_Val));
    Myend = 0i64;
    v26 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
    if ( (v26->gap10[*(int *)(*(_QWORD *)v26->gap0 + 4i64)] & 6) == 0 )
    {
      Mylast = _Val._Mypair._Myval2._Mylast;
      while ( 1 )
      {
        Mysize = _Right._Mypair._Myval2._Mysize;
        if ( !_Right._Mypair._Myval2._Mysize )
        {
LABEL_107:
          v4 = 0i64;
          v5 = v179;
          break;
        }
        p_Right = &_Right;
        v30 = _Right._Mypair._Myval2._Bx._Ptr;
        Myres = _Right._Mypair._Myval2._Myres;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          p_Right = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v32 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v32 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v33 = (std::string *)((char *)v32 + _Right._Mypair._Myval2._Mysize);
        v34 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v34 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v35 = (char *)v33 - (char *)v34;
        if ( v34 > v33 )
          v35 = 0i64;
        if ( v35 )
        {
          for ( i = 0i64; i != v35; ++i )
            p_Right->_Mypair._Myval2._Bx._Buf[i] = toupper(v34->_Mypair._Myval2._Bx._Buf[i]);
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v30 = _Right._Mypair._Myval2._Bx._Ptr;
        }
        v37 = &_Right;
        if ( Myres >= 0x10 )
          v37 = (std::string *)v30;
        v185 = (unsigned __int64)v37 + Mysize;
        v38 = &_Right;
        if ( Myres >= 0x10 )
          v38 = (std::string *)v30;
        v39 = (unsigned __int64)v38 + Mysize;
        v40 = &_Right;
        if ( Myres >= 0x10 )
          v40 = (std::string *)v30;
        if ( v40 != (std::string *)v39 )
        {
          do
          {
            if ( isspace(v40->_Mypair._Myval2._Bx._Buf[0]) )
              break;
            v40 = (std::string *)((char *)v40 + 1);
          }
          while ( v40 != (std::string *)v39 );
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v30 = _Right._Mypair._Myval2._Bx._Ptr;
          if ( v40 != (std::string *)v39 )
          {
            v41 = &v40->_Mypair._Myval2._Bx._Buf[1];
            v42 = v39 - (_QWORD)&v40->_Mypair._Myval2._Bx._Buf[1];
            if ( (unsigned __int64)&v40->_Mypair._Myval2._Bx._Buf[1] > v39 )
              v42 = 0i64;
            if ( v42 )
            {
              for ( j = 0i64; j != v42; ++j )
              {
                if ( !isspace(*v41) )
                {
                  v40->_Mypair._Myval2._Bx._Buf[0] = *v41;
                  v40 = (std::string *)((char *)v40 + 1);
                }
                ++v41;
              }
              Myres = _Right._Mypair._Myval2._Myres;
              Mysize = _Right._Mypair._Myval2._Mysize;
              v30 = _Right._Mypair._Myval2._Bx._Ptr;
            }
          }
        }
        v44 = &_Right;
        if ( Myres >= 0x10 )
          v44 = (std::string *)v30;
        v45 = (char *)v40 - (char *)v44;
        v46 = v185 - (_QWORD)v40;
        if ( Mysize < (char *)v40 - (char *)v44 )
          std::_Xout_of_range("invalid string position");
        if ( Mysize - v45 > v46 )
        {
          if ( v46 )
          {
            v48 = &_Right;
            if ( Myres >= 0x10 )
              v48 = (std::string *)v30;
            v49 = &v48->_Mypair._Myval2._Bx._Buf[v45];
            v50 = Mysize - v46;
            if ( v50 != v45 )
            {
              memmove(v49, &v49[v46], v50 - v45);
              Myres = _Right._Mypair._Myval2._Myres;
              v30 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            _Right._Mypair._Myval2._Mysize = v50;
            v51 = &_Right;
            if ( Myres >= 0x10 )
              v51 = (std::string *)v30;
            v51->_Mypair._Myval2._Bx._Buf[v50] = 0;
          }
        }
        else
        {
          _Right._Mypair._Myval2._Mysize = (char *)v40 - (char *)v44;
          v47 = &_Right;
          if ( Myres >= 0x10 )
            v47 = (std::string *)v30;
          v47->_Mypair._Myval2._Bx._Buf[v45] = 0;
        }
        Myfirst = _Val._Mypair._Myval2._Myfirst;
        if ( &_Right >= Mylast || _Val._Mypair._Myval2._Myfirst > &_Right )
        {
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v60 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v60 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v61 = Myend - _Val._Mypair._Myval2._Myfirst;
            v62 = (v61 >> 1) + v61;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v61 >> 1) < v61 )
              v62 = 0i64;
            if ( v62 < v60 + 1 )
              v62 = v60 + 1;
            std::vector<std::string>::_Reallocate(&_Val, v62);
            Myend = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
          }
          if ( !Mylast )
            goto LABEL_106;
          Mylast->_Mypair._Myval2._Myres = 15i64;
          Mylast->_Mypair._Myval2._Mysize = 0i64;
          if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
            v58 = Mylast;
          else
            v58 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
          v59 = &_Right;
        }
        else
        {
          v53 = (char *)&_Right - (char *)_Val._Mypair._Myval2._Myfirst;
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v54 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v54 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v55 = Myend - _Val._Mypair._Myval2._Myfirst;
            v56 = (v55 >> 1) + v55;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v55 >> 1) < v55 )
              v56 = 0i64;
            if ( v56 < v54 + 1 )
              v56 = v54 + 1;
            std::vector<std::string>::_Reallocate(&_Val, v56);
            Myend = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
            Myfirst = _Val._Mypair._Myval2._Myfirst;
          }
          v57 = (std::string *)((char *)Myfirst + (v53 & 0xFFFFFFFFFFFFFFE0ui64));
          if ( !Mylast )
            goto LABEL_106;
          Mylast->_Mypair._Myval2._Myres = 15i64;
          Mylast->_Mypair._Myval2._Mysize = 0i64;
          if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
            v58 = Mylast;
          else
            v58 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
          v59 = v57;
        }
        v58->_Mypair._Myval2._Bx._Buf[0] = 0;
        std::string::_Assign_rv(Mylast, v59);
LABEL_106:
        _Val._Mypair._Myval2._Mylast = ++Mylast;
        v63 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
        if ( (v63->gap10[*(int *)(*(_QWORD *)v63->gap0 + 4i64)] & 6) != 0 )
          goto LABEL_107;
      }
    }
    std::vector<std::vector<std::string>>::push_back(&v188, &_Val);
    v66 = (AgDirectory::DirectoryEntry *)_Val._Mypair._Myval2._Myfirst;
    if ( _Val._Mypair._Myval2._Myfirst )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        _Val._Mypair._Myval2._Myfirst,
        _Val._Mypair._Myval2._Mylast,
        v64,
        v65);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v67,
        v66,
        ((char *)_Val._Mypair._Myval2._Myend - (char *)v66) >> 5);
    }
    std::string::~string(&_Right);
    std::istringstream::~istringstream((std::istringstream *)&_This);
    _This.__vftable = (std::ios_base_vtbl *)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&_This);
  }
  v68 = 0;
  v69 = v188._Mypair._Myval2._Myfirst;
  v70 = 0;
  if ( v188._Mypair._Myval2._Myfirst->_Mypair._Myval2._Mylast - v188._Mypair._Myval2._Myfirst->_Mypair._Myval2._Myfirst )
  {
    v71 = 0i64;
    do
    {
      v72 = v69->_Mypair._Myval2._Myfirst;
      v73 = &v69->_Mypair._Myval2._Myfirst[v71];
      if ( v73->_Mypair._Myval2._Myres >= 0x10 )
        v73 = (std::string *)v73->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v73->_Mypair._Myval2._Bx._Buf, "NUMSETTINGS") )
      {
        v74 = (__int64)&v72[v71 + 1];
        if ( *(_QWORD *)(v74 + 24) >= 0x10ui64 )
          v74 = *(_QWORD *)v74;
        _Right._Mypair._Myval2._Myres = 15i64;
        _Right._Mypair._Myval2._Mysize = 0i64;
        _Right._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( *(_BYTE *)v74 )
        {
          v75 = -1i64;
          do
            ++v75;
          while ( *(_BYTE *)(v74 + v75) );
        }
        else
        {
          v75 = 0i64;
        }
        std::string::assign(&_Right, (const char *)v74, v75);
        v70 = (int)std::stof(&_Right, v76);
        std::string::~string(&_Right);
        ++v68;
        ++v71;
      }
      ++v68;
      ++v71;
    }
    while ( v68 < (unsigned __int64)(v69->_Mypair._Myval2._Mylast - v69->_Mypair._Myval2._Myfirst) );
  }
  v77 = 1;
  specialSettings->numSettings = v70;
  v180 = 0i64;
  v187 = v70;
  if ( v70 > 0 )
  {
    LODWORD(v78) = 0;
    do
    {
      v79 = v69[v77]._Mypair._Myval2._Myfirst;
      if ( v79->_Mypair._Myval2._Myres < 0x10 )
        Buf = v69[v77]._Mypair._Myval2._Myfirst->_Mypair._Myval2._Bx._Buf;
      else
        Buf = v79->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(Buf, "SETTINGID") )
      {
        v81 = v79[1]._Mypair._Myval2._Bx._Buf;
        if ( v79[1]._Mypair._Myval2._Myres >= 0x10 )
          v81 = *(const char **)v81;
        _Right._Mypair._Myval2._Myres = 15i64;
        _Right._Mypair._Myval2._Mysize = 0i64;
        _Right._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( *v81 )
        {
          v82 = -1i64;
          do
            ++v82;
          while ( v81[v82] );
        }
        else
        {
          v82 = 0i64;
        }
        std::string::assign(&_Right, v81, v82);
        v85 = std::stoi(&_Right, v83, v84);
        v86 = v4;
        v87 = specialSettings;
        specialSettings->specialLightData[v86].settingId = v85;
        std::string::~string(&_Right);
      }
      else
      {
        v87 = specialSettings;
      }
      v88 = v77 + 1;
      v89 = v69[v88]._Mypair._Myval2._Myfirst;
      if ( v89->_Mypair._Myval2._Myres >= 0x10 )
        v89 = (std::string *)v89->_Mypair._Myval2._Bx._Ptr;
      if ( !strcmp(v89->_Mypair._Myval2._Bx._Buf, "NUMLIGHTS") )
      {
        v90 = v69[v88]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Bx._Buf;
        if ( v69[v88]._Mypair._Myval2._Myfirst[1]._Mypair._Myval2._Myres >= 0x10 )
          v90 = *(const char **)v90;
        v203._Mypair._Myval2._Myres = 15i64;
        v203._Mypair._Myval2._Mysize = 0i64;
        v203._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( *v90 )
        {
          v91 = -1i64;
          do
            ++v91;
          while ( v90[v91] );
        }
        else
        {
          v91 = 0i64;
        }
        std::string::assign(&v203, v90, v91);
        LODWORD(v78) = (int)std::stof(&v203, v92);
        v181 = v78;
        std::string::~string(&v203);
      }
      v93 = v180;
      v94 = v180;
      v87->specialLightData[v180].numLights = v78;
      v77 = v88 + 1;
      if ( (int)v78 > 0 )
      {
        v95 = (AppMain *)((char *)v188._Mypair._Myval2._Mylast - (char *)v69);
        v17 = (unsigned __int128)(((char *)v188._Mypair._Myval2._Mylast - (char *)v69) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
        v185 = v188._Mypair._Myval2._Mylast - v69;
        if ( v185 > 1 )
        {
          v78 = (int)v78;
          v96 = &v69[v77];
          colour = v87->specialLightData[v94].lightData[0].colour;
          do
          {
            if ( v96->_Mypair._Myval2._Mylast - v96->_Mypair._Myval2._Myfirst )
              AppMain::processLightData(v95, v96, (ShaderFxHelper::ShaderFxLightSetting *)&_Istr);
            *((_BYTE *)colour + 28) = 0;
            *(_QWORD *)colour = *(_QWORD *)&_Istr.gap10[12];
            colour[2] = *(float *)&_Istr.gap10[20];
            colour[4] = *(float *)&_Istr.gap10[28];
            *(colour - 8) = *(float *)&_Istr.gap10[40];
            *(_QWORD *)(colour - 3) = *(_QWORD *)&_Istr.gap0[4];
            *(colour - 1) = *((float *)&_Istr._Chcount + 1);
            *((_BYTE *)colour + 30) = _Istr.gap10[37];
            *((_BYTE *)colour + 29) = _Istr.gap10[36];
            colour[6] = *(float *)&_Istr.gap10[24];
            colour[5] = *(float *)&_Istr.gap10[32];
            *(_QWORD *)(colour - 7) = *(_QWORD *)_Istr.gap10;
            *(colour - 5) = *(float *)&_Istr.gap10[8];
            *(colour - 9) = *(float *)_Istr.gap0;
            ++v96;
            colour += 17;
            --v78;
          }
          while ( v78 );
          v98 = v180;
          v99 = v185;
          v87->specialLightData[v94].isValid = 1;
          v100 = v181 + v77;
          if ( v100 < v99 && v69[v100]._Mypair._Myval2._Mylast - v69[v100]._Mypair._Myval2._Myfirst )
          {
            v101 = v69[v100]._Mypair._Myval2._Myfirst;
            if ( v101->_Mypair._Myval2._Myres >= 0x10 )
              v101 = (std::string *)v101->_Mypair._Myval2._Bx._Ptr;
            if ( !strcmp(v101->_Mypair._Myval2._Bx._Buf, "RIMLIGHT") )
            {
              v183 = ++v100;
              std::vector<std::string>::vector<std::string>(&_Val, &v69[v100]);
              v104 = 0;
              v105 = _Val._Mypair._Myval2._Mylast;
              v106 = _Val._Mypair._Myval2._Myfirst;
              *(_QWORD *)&result.gap0 = _Val._Mypair._Myval2._Mylast - _Val._Mypair._Myval2._Myfirst;
              if ( *(_QWORD *)&result.gap0 )
              {
                v107 = 1;
                v108 = 3;
                v109 = 2;
                v110 = _Val._Mypair._Myval2._Myfirst;
                do
                {
                  if ( v110->_Mypair._Myval2._Myres < 0x10 )
                    v111 = (const char *)v110;
                  else
                    v111 = v110->_Mypair._Myval2._Bx._Ptr;
                  if ( !strcmp(v111, "RIMLIGHTMIN") )
                  {
                    v112 = &v106[v107];
                    if ( v112->_Mypair._Myval2._Myres >= 0x10 )
                      v112 = (std::string *)v112->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v112->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v113 = -1i64;
                      do
                        ++v113;
                      while ( v112->_Mypair._Myval2._Bx._Buf[v113] );
                    }
                    else
                    {
                      v113 = 0i64;
                    }
                    std::string::assign(&_Right, v112->_Mypair._Myval2._Bx._Buf, v113);
                    specialSettings->specialRimLightAssetData[v98].rimLightMin = std::stof(&_Right, v114);
                    std::string::~string(&_Right);
                    v104 += 2;
                    v107 += 2;
                    v109 += 2;
                    v108 += 2;
                    v110 += 2;
                  }
                  if ( v110->_Mypair._Myval2._Myres < 0x10 )
                    v115 = (const char *)v110;
                  else
                    v115 = v110->_Mypair._Myval2._Bx._Ptr;
                  if ( !strcmp(v115, "RIMLIGHTMAX") )
                  {
                    v116 = &v106[v107];
                    if ( v116->_Mypair._Myval2._Myres >= 0x10 )
                      v116 = (std::string *)v116->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v116->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v117 = -1i64;
                      do
                        ++v117;
                      while ( v116->_Mypair._Myval2._Bx._Buf[v117] );
                    }
                    else
                    {
                      v117 = 0i64;
                    }
                    std::string::assign(&_Right, v116->_Mypair._Myval2._Bx._Buf, v117);
                    specialSettings->specialRimLightAssetData[v98].rimLightMax = std::stof(&_Right, v118);
                    std::string::~string(&_Right);
                    v104 += 2;
                    v107 += 2;
                    v109 += 2;
                    v108 += 2;
                    v110 += 2;
                  }
                  if ( v110->_Mypair._Myval2._Myres < 0x10 )
                    v119 = (const char *)v110;
                  else
                    v119 = v110->_Mypair._Myval2._Bx._Ptr;
                  if ( !strcmp(v119, "RIMLIGHTSTRENGTH") )
                  {
                    v120 = &v106[v107];
                    if ( v120->_Mypair._Myval2._Myres >= 0x10 )
                      v120 = (std::string *)v120->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v120->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v121 = -1i64;
                      do
                        ++v121;
                      while ( v120->_Mypair._Myval2._Bx._Buf[v121] );
                    }
                    else
                    {
                      v121 = 0i64;
                    }
                    std::string::assign(&_Right, v120->_Mypair._Myval2._Bx._Buf, v121);
                    specialSettings->specialRimLightAssetData[v98].rimLightStrength = std::stof(&_Right, v122);
                    std::string::~string(&_Right);
                    v104 += 2;
                    v107 += 2;
                    v109 += 2;
                    v108 += 2;
                    v110 += 2;
                  }
                  if ( v110->_Mypair._Myval2._Myres < 0x10 )
                    v123 = (const char *)v110;
                  else
                    v123 = v110->_Mypair._Myval2._Bx._Ptr;
                  if ( !strcmp(v123, "RIMLIGHTCOLOR") )
                  {
                    v124 = &v106[v107];
                    if ( v124->_Mypair._Myval2._Myres >= 0x10 )
                      v124 = (std::string *)v124->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v124->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v125 = -1i64;
                      do
                        ++v125;
                      while ( v124->_Mypair._Myval2._Bx._Buf[v125] );
                    }
                    else
                    {
                      v125 = 0i64;
                    }
                    std::string::assign(&_Right, v124->_Mypair._Myval2._Bx._Buf, v125);
                    v126 = v98;
                    specialSettings->specialRimLightAssetData[v126].rimLightColour[0] = std::stof(&_Right, v127);
                    std::string::~string(&_Right);
                    v128 = &v106[v109];
                    if ( v128->_Mypair._Myval2._Myres >= 0x10 )
                      v128 = (std::string *)v128->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v128->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v129 = -1i64;
                      do
                        ++v129;
                      while ( v128->_Mypair._Myval2._Bx._Buf[v129] );
                    }
                    else
                    {
                      v129 = 0i64;
                    }
                    std::string::assign(&_Right, v128->_Mypair._Myval2._Bx._Buf, v129);
                    specialSettings->specialRimLightAssetData[v126].rimLightColour[1] = std::stof(&_Right, v130);
                    std::string::~string(&_Right);
                    v131 = &v106[v108];
                    if ( v131->_Mypair._Myval2._Myres >= 0x10 )
                      v131 = (std::string *)v131->_Mypair._Myval2._Bx._Ptr;
                    _Right._Mypair._Myval2._Myres = 15i64;
                    _Right._Mypair._Myval2._Mysize = 0i64;
                    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
                    if ( v131->_Mypair._Myval2._Bx._Buf[0] )
                    {
                      v132 = -1i64;
                      do
                        ++v132;
                      while ( v131->_Mypair._Myval2._Bx._Buf[v132] );
                    }
                    else
                    {
                      v132 = 0i64;
                    }
                    std::string::assign(&_Right, v131->_Mypair._Myval2._Bx._Buf, v132);
                    specialSettings->specialRimLightAssetData[v126].rimLightColour[2] = std::stof(&_Right, v133);
                    std::string::~string(&_Right);
                    v104 += 4;
                    v107 += 4;
                    v109 += 4;
                    v108 += 4;
                    v110 += 4;
                  }
                  ++v104;
                  ++v107;
                  ++v109;
                  ++v108;
                  ++v110;
                  v98 = v180;
                }
                while ( (unsigned __int64)v104 < *(_QWORD *)&result.gap0 );
                v105 = _Val._Mypair._Myval2._Mylast;
                v100 = v183;
                v69 = v188._Mypair._Myval2._Myfirst;
                v99 = v185;
              }
              if ( v106 )
              {
                std::_Destroy_range1<std::allocator<std::string>,std::string *>(v106, v105, v102, v103);
                std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
                  v134,
                  (AgDirectory::DirectoryEntry *)v106,
                  _Val._Mypair._Myval2._Myend - v106);
              }
            }
          }
          v77 = v100 + 1;
          if ( v77 >= v99 || !(v69[v77]._Mypair._Myval2._Mylast - v69[v77]._Mypair._Myval2._Myfirst) )
            goto LABEL_254;
          v135 = v69[v77]._Mypair._Myval2._Myfirst;
          if ( v135->_Mypair._Myval2._Myres >= 0x10 )
            v135 = (std::string *)v135->_Mypair._Myval2._Bx._Ptr;
          if ( !strcmp(v135->_Mypair._Myval2._Bx._Buf, "EMISSION") )
          {
            v136 = v77 + 1;
            v137 = v69[v136]._Mypair._Myval2._Myfirst;
            if ( v137->_Mypair._Myval2._Myres < 0x10 )
              v138 = v69[v136]._Mypair._Myval2._Myfirst->_Mypair._Myval2._Bx._Buf;
            else
              v138 = v137->_Mypair._Myval2._Bx._Ptr;
            if ( !strcmp(v138, "EYEEMISSIONSTRENGTH") )
            {
              v139 = v137 + 1;
              if ( v139->_Mypair._Myval2._Myres >= 0x10 )
                v139 = (std::string *)v139->_Mypair._Myval2._Bx._Ptr;
              _Right._Mypair._Myval2._Mysize = 0i64;
              _Right._Mypair._Myval2._Myres = 0i64;
              std::string::_Tidy(&_Right, 0, 0i64);
              if ( v139->_Mypair._Myval2._Bx._Buf[0] )
              {
                v140 = -1i64;
                do
                  ++v140;
                while ( v139->_Mypair._Myval2._Bx._Buf[v140] );
              }
              else
              {
                v140 = 0i64;
              }
              std::string::assign(&_Right, v139->_Mypair._Myval2._Bx._Buf, v140);
              v142 = v180;
              v143 = specialSettings;
              specialSettings->specialEmissionData[v180].eyeEmissionStrength = std::stof(&_Right, v141);
              std::string::~string(&_Right);
            }
            else
            {
              v142 = v180;
              v143 = specialSettings;
            }
            v144 = v69[v136]._Mypair._Myval2._Myfirst;
            v145 = v144[2]._Mypair._Myval2._Bx._Buf;
            if ( v144[2]._Mypair._Myval2._Myres >= 0x10 )
              v145 = *(const char **)v145;
            if ( !strcmp(v145, "CHAREMISSIONSTRENGTH") )
            {
              v146 = v144 + 3;
              if ( v146->_Mypair._Myval2._Myres >= 0x10 )
                v146 = (std::string *)v146->_Mypair._Myval2._Bx._Ptr;
              _Right._Mypair._Myval2._Mysize = 0i64;
              _Right._Mypair._Myval2._Myres = 0i64;
              std::string::_Tidy(&_Right, 0, 0i64);
              if ( v146->_Mypair._Myval2._Bx._Buf[0] )
              {
                v147 = -1i64;
                do
                  ++v147;
                while ( v146->_Mypair._Myval2._Bx._Buf[v147] );
              }
              else
              {
                v147 = 0i64;
              }
              std::string::assign(&_Right, v146->_Mypair._Myval2._Bx._Buf, v147);
              v143->specialEmissionData[v142].charEmissionStrength = std::stof(&_Right, v148);
              std::string::~string(&_Right);
            }
            v77 = v136 + 1;
            v99 = v185;
          }
          else
          {
LABEL_254:
            v142 = v180;
          }
          if ( v77 < v99 && v69[v77]._Mypair._Myval2._Mylast - v69[v77]._Mypair._Myval2._Myfirst )
          {
            v149 = v69[v77]._Mypair._Myval2._Myfirst;
            if ( v149->_Mypair._Myval2._Myres >= 0x10 )
              v149 = (std::string *)v149->_Mypair._Myval2._Bx._Ptr;
            if ( !strcmp(v149->_Mypair._Myval2._Bx._Buf, "SHADOWSTRENGTHRANGE") )
            {
              v150 = v77 + 1;
              v151 = v69[v150]._Mypair._Myval2._Myfirst;
              if ( v151->_Mypair._Myval2._Myres < 0x10 )
                v152 = v69[v150]._Mypair._Myval2._Myfirst->_Mypair._Myval2._Bx._Buf;
              else
                v152 = v151->_Mypair._Myval2._Bx._Ptr;
              if ( !strcmp(v152, "BODYSELFSHADSTRRGEMIN")
                || (v151->_Mypair._Myval2._Myres < 0x10 ? (v153 = (const char *)v151) : (v153 = v151->_Mypair._Myval2._Bx._Ptr),
                    !strcmp(v153, "SHADOWSTRENGTHRANGEMIN")) )
              {
                v154 = v151 + 1;
                if ( v154->_Mypair._Myval2._Myres >= 0x10 )
                  v154 = (std::string *)v154->_Mypair._Myval2._Bx._Ptr;
                _Right._Mypair._Myval2._Mysize = 0i64;
                _Right._Mypair._Myval2._Myres = 0i64;
                std::string::_Tidy(&_Right, 0, 0i64);
                if ( v154->_Mypair._Myval2._Bx._Buf[0] )
                {
                  v155 = -1i64;
                  do
                    ++v155;
                  while ( v154->_Mypair._Myval2._Bx._Buf[v155] );
                }
                else
                {
                  v155 = 0i64;
                }
                std::string::assign(&_Right, v154->_Mypair._Myval2._Bx._Buf, v155);
                v157 = specialSettings;
                specialSettings->specialShadowRangeData[v142].bodySelfShadowDotRangeMin = std::stof(&_Right, v156);
                std::string::~string(&_Right);
              }
              else
              {
                v157 = specialSettings;
              }
              v158 = v69[v150]._Mypair._Myval2._Myfirst;
              v159 = v158[2]._Mypair._Myval2._Bx._Buf;
              if ( v158[2]._Mypair._Myval2._Myres < 0x10 )
                v160 = v158[2]._Mypair._Myval2._Bx._Buf;
              else
                v160 = *(const char **)v159;
              if ( !strcmp(v160, "BODYSELFSHADSTRRGEMAX") )
                goto LABEL_283;
              if ( v158[2]._Mypair._Myval2._Myres >= 0x10 )
                v159 = *(const char **)v159;
              if ( !strcmp(v159, "SHADOWSTRENGTHRANGEMAX") )
              {
LABEL_283:
                v161 = v158[3]._Mypair._Myval2._Bx._Buf;
                if ( v158[3]._Mypair._Myval2._Myres >= 0x10 )
                  v161 = *(const char **)v161;
                _Right._Mypair._Myval2._Mysize = 0i64;
                _Right._Mypair._Myval2._Myres = 0i64;
                std::string::_Tidy(&_Right, 0, 0i64);
                if ( *v161 )
                {
                  v162 = -1i64;
                  do
                    ++v162;
                  while ( v161[v162] );
                }
                else
                {
                  v162 = 0i64;
                }
                std::string::assign(&_Right, v161, v162);
                v157->specialShadowRangeData[v142].bodySelfShadowDotRangeMax = std::stof(&_Right, v163);
                std::string::~string(&_Right);
              }
              v164 = v69[v150]._Mypair._Myval2._Myfirst;
              v165 = v164[4]._Mypair._Myval2._Bx._Buf;
              if ( v164[4]._Mypair._Myval2._Myres >= 0x10 )
                v165 = *(const char **)v165;
              if ( !strcmp(v165, "SKINSELFSHADSTRRGEMIN") )
              {
                v166 = v164 + 5;
                if ( v166->_Mypair._Myval2._Myres >= 0x10 )
                  v166 = (std::string *)v166->_Mypair._Myval2._Bx._Ptr;
                _Right._Mypair._Myval2._Mysize = 0i64;
                _Right._Mypair._Myval2._Myres = 0i64;
                std::string::_Tidy(&_Right, 0, 0i64);
                if ( v166->_Mypair._Myval2._Bx._Buf[0] )
                {
                  v167 = -1i64;
                  do
                    ++v167;
                  while ( v166->_Mypair._Myval2._Bx._Buf[v167] );
                }
                else
                {
                  v167 = 0i64;
                }
                std::string::assign(&_Right, v166->_Mypair._Myval2._Bx._Buf, v167);
                v157->specialShadowRangeData[v142].skinSelfShadowDotRangeMin = std::stof(&_Right, v168);
                std::string::~string(&_Right);
              }
              v169 = v69[v150]._Mypair._Myval2._Myfirst;
              v170 = v169[6]._Mypair._Myval2._Bx._Buf;
              if ( v169[6]._Mypair._Myval2._Myres >= 0x10 )
                v170 = *(const char **)v170;
              if ( !strcmp(v170, "SKINSELFSHADSTRRGEMAX") )
              {
                v171 = v169 + 7;
                if ( v171->_Mypair._Myval2._Myres >= 0x10 )
                  v171 = (std::string *)v171->_Mypair._Myval2._Bx._Ptr;
                _Right._Mypair._Myval2._Mysize = 0i64;
                _Right._Mypair._Myval2._Myres = 0i64;
                std::string::_Tidy(&_Right, 0, 0i64);
                if ( v171->_Mypair._Myval2._Bx._Buf[0] )
                {
                  v172 = -1i64;
                  do
                    ++v172;
                  while ( v171->_Mypair._Myval2._Bx._Buf[v172] );
                }
                else
                {
                  v172 = 0i64;
                }
                std::string::assign(&_Right, v171->_Mypair._Myval2._Bx._Buf, v172);
                v157->specialShadowRangeData[v142].skinSelfShadowDotRangeMax = std::stof(&_Right, v173);
                std::string::~string(&_Right);
              }
              v77 = v150 + 1;
              v99 = v185;
            }
          }
          if ( v77 < v99 && v69[v77]._Mypair._Myval2._Mylast - v69[v77]._Mypair._Myval2._Myfirst )
          {
            v174 = (char **)v69[v77]._Mypair._Myval2._Myfirst;
            if ( (unsigned __int64)v174[3] >= 0x10 )
              v174 = (char **)*v174;
            v17 = 0i64;
            while ( 1 )
            {
              v175 = *((_BYTE *)v174 + v17++);
              if ( v175 != aShade[v17 - 1] )
                break;
              if ( v17 == 6 )
              {
                v77 += 2;
                break;
              }
            }
          }
          LODWORD(v78) = v181;
          v93 = v180;
        }
      }
      v180 = v93 + 1;
      v4 = v93 + 1;
    }
    while ( v93 + 1 < v187 );
  }
  operator delete(_Ptr, v17);
  std::string::~string(&_Str);
  std::vector<std::vector<std::string>>::~vector<std::vector<std::string>>(&v188, v176, v177, v178);
  std::istringstream::~istringstream((std::istringstream *)&v200.gap88[8]);
  *(_QWORD *)&v200.gap88[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v200.gap88[8]);
  return 0i64;
}

__int64 __fastcall AppMain::loadGlobalShaderData(
        AppMain *this,
        const char *filename,
        AppMain::_GLOBAL_SHADER_SETTINGS *globalShaderSettings,
        int a4)
{
  int v4; // er13
  int v5; // edi
  int v6; // eax
  int v8; // er8
  char *Ptr; // rcx
  char *v10; // rax
  const std::locale *v11; // rax
  __int64 v12; // rdx
  std::locale::facet *v13; // rbx
  std::_Facet_base *v14; // rax
  char v15; // al
  std::istream *v16; // rax
  std::locale *v17; // rbx
  const std::locale *v18; // rax
  __int64 v19; // rdx
  std::locale::facet *v20; // rbx
  std::_Facet_base *v21; // rax
  int v22; // er9
  std::string *p_Str; // rdx
  std::string *Myend; // r14
  std::istream *v25; // rax
  std::string *Mylast; // rdi
  unsigned __int64 Mysize; // r15
  std::string *p_Right; // r8
  char *v29; // rcx
  unsigned __int64 Myres; // rdx
  std::string *v31; // rbx
  unsigned __int64 v32; // rbx
  std::string *v33; // rsi
  char *v34; // r14
  unsigned __int64 v35; // r12
  __int64 i; // rbx
  std::string *v37; // rax
  signed __int64 v38; // r8
  unsigned __int64 v39; // r10
  std::string *v40; // rax
  std::string *v41; // r9
  char *v42; // r9
  unsigned __int64 v43; // r15
  std::string *v44; // rax
  std::string *Myfirst; // rcx
  signed __int64 v46; // rbx
  __int64 v47; // rdi
  unsigned __int64 v48; // rdi
  unsigned __int64 v49; // r14
  unsigned __int64 v50; // rdx
  char *v51; // rbx
  std::string *v52; // rax
  __int64 v53; // rdi
  unsigned __int64 v54; // rdi
  unsigned __int64 v55; // r14
  unsigned __int64 v56; // rdx
  std::string *v57; // rax
  std::istream *v58; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v59; // r8
  std::integral_constant<bool,0> v60; // r9
  AgDirectory::DirectoryEntry *v61; // rbx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v62; // rcx
  std::vector<std::string> *v63; // r14
  std::vector<std::string> *v64; // rsi
  AppMain *v65; // rcx
  unsigned __int64 v66; // rdx
  unsigned __int64 v67; // rdi
  std::vector<std::string> *v68; // rbx
  AppMain::_GLOBAL_SHADER_SETTINGS *v69; // r15
  std::_Wrap_alloc<std::allocator<std::vector<std::string> > > *v70; // r8
  std::integral_constant<bool,0> v71; // r9
  int v72; // [rsp+30h] [rbp-D0h]
  std::vector<std::string> _Val; // [rsp+38h] [rbp-C8h] BYREF
  std::string *v74; // [rsp+50h] [rbp-B0h]
  char *_Ptr; // [rsp+58h] [rbp-A8h] BYREF
  char *v76; // [rsp+60h] [rbp-A0h]
  AppMain::_GLOBAL_SHADER_SETTINGS *globalShaderSettingsa; // [rsp+68h] [rbp-98h]
  std::vector<std::vector<std::string>> v78; // [rsp+70h] [rbp-90h] BYREF
  int v79; // [rsp+8Ch] [rbp-74h]
  std::istream _Istr; // [rsp+90h] [rbp-70h] BYREF
  __int64 v81; // [rsp+108h] [rbp+8h]
  int v82; // [rsp+110h] [rbp+10h]
  int v83; // [rsp+11Ch] [rbp+1Ch]
  std::ios_base _This; // [rsp+120h] [rbp+20h] BYREF
  _BYTE *v85; // [rsp+168h] [rbp+68h]
  __int64 v86; // [rsp+170h] [rbp+70h]
  char v87; // [rsp+178h] [rbp+78h]
  __int64 v88; // [rsp+180h] [rbp+80h]
  std::locale result; // [rsp+188h] [rbp+88h] BYREF
  std::locale v90; // [rsp+198h] [rbp+98h] BYREF
  std::istringstream v91; // [rsp+1B0h] [rbp+B0h] BYREF
  std::string _Right; // [rsp+2A0h] [rbp+1A0h] BYREF
  std::string _Str; // [rsp+2C0h] [rbp+1C0h] BYREF

  v88 = -2i64;
  globalShaderSettingsa = globalShaderSettings;
  v4 = 0;
  v5 = 0;
  _Ptr = 0i64;
  v6 = CFile::ResourceDataLoaderNew(filename, (int)filename, (int)globalShaderSettings, a4, (unsigned __int8 **)&_Ptr);
  if ( !_Ptr )
    return 0xFFFFFFFFi64;
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&_Str, _Ptr, v6);
  std::istringstream::istringstream(&v91, &_Str, v8);
  if ( _Str._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = _Str._Mypair._Myval2._Bx._Ptr;
    if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v10 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
      if ( v10 >= _Str._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  memset(&v78, 0, sizeof(v78));
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  while ( 1 )
  {
    v11 = std::ios_base::getloc((std::ios_base *)&v91.gap0[*(int *)(*(_QWORD *)v91.gap0 + 4i64)], &result);
    v13 = std::use_facet<std::ctype<char>>(v11);
    if ( result._Ptr )
    {
      v14 = result._Ptr->_Decref(result._Ptr);
      if ( v14 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v14->~_Facet_base)(v14, 1i64);
    }
    LOBYTE(v12) = 10;
    v15 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v13->__vftable[2]._Decref)(v13, v12);
    v16 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&v91, &_Str, v15);
    if ( (v16->gap10[*(int *)(*(_QWORD *)v16->gap0 + 4i64)] & 6) != 0 )
      break;
    *(_QWORD *)_Istr.gap0 = &std::istringstream::`vbtable';
    v5 |= 1u;
    v72 = v5;
    _This.__vftable = (std::ios_base_vtbl *)&std::istream::`vftable';
    v83 = 120;
    _Istr._Chcount = 0i64;
    _This._Stdstr = 0i64;
    _This._Except = 0;
    _This._Fmtfl = 513;
    *(__m128i *)&_This._Prec = _mm_load_si128((const __m128i *)&_xmm);
    memset(&_This._Arr, 0, 24);
    std::ios_base::clear(&_This, 0, 0);
    v17 = (std::locale *)operator new(0x10ui64);
    v17->_Ptr = std::locale::_Init(1);
    _This._Ploc = v17;
    v85 = _Istr.gap10;
    v86 = 0i64;
    v18 = std::ios_base::getloc(&_This, &v90);
    v20 = std::use_facet<std::ctype<char>>(v18);
    if ( v90._Ptr )
    {
      v21 = v90._Ptr->_Decref(v90._Ptr);
      if ( v21 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v21->~_Facet_base)(v21, 1i64);
    }
    LOBYTE(v19) = 32;
    v87 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v20->__vftable[2]._Decref)(v20, v19);
    if ( !v85 )
      std::ios_base::clear(&_This, _This._Mystate | 4, 0);
    *(_QWORD *)&_Istr.gap0[*(int *)(*(_QWORD *)_Istr.gap0 + 4i64)] = &std::istringstream::`vftable';
    *(int *)((char *)&v79 + *(int *)(*(_QWORD *)_Istr.gap0 + 4i64)) = *(_DWORD *)(*(_QWORD *)_Istr.gap0 + 4i64) - 144;
    v76 = _Istr.gap10;
    std::streambuf::streambuf((std::streambuf *)_Istr.gap10);
    *(_QWORD *)_Istr.gap10 = &std::stringbuf::`vftable';
    p_Str = &_Str;
    if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
    v81 = 0i64;
    v82 = 2;
    if ( _Str._Mypair._Myval2._Mysize )
      std::stringbuf::_Init(
        (std::stringbuf *)_Istr.gap10,
        p_Str->_Mypair._Myval2._Bx._Buf,
        _Str._Mypair._Myval2._Mysize,
        v22);
    _Right._Mypair._Myval2._Myres = 15i64;
    _Right._Mypair._Myval2._Mysize = 0i64;
    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
    memset(&_Val, 0, sizeof(_Val));
    Myend = 0i64;
    v74 = 0i64;
    v25 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
    if ( (v25->gap10[*(int *)(*(_QWORD *)v25->gap0 + 4i64)] & 6) == 0 )
    {
      Mylast = _Val._Mypair._Myval2._Mylast;
      do
      {
        Mysize = _Right._Mypair._Myval2._Mysize;
        if ( !_Right._Mypair._Myval2._Mysize )
          break;
        p_Right = &_Right;
        v29 = _Right._Mypair._Myval2._Bx._Ptr;
        Myres = _Right._Mypair._Myval2._Myres;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          p_Right = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v76 = &p_Right->_Mypair._Myval2._Bx._Buf[_Right._Mypair._Myval2._Mysize];
        v31 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v31 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v32 = (unsigned __int64)v31 + _Right._Mypair._Myval2._Mysize;
        v33 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v33 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        if ( v33 != (std::string *)v32 )
        {
          do
          {
            if ( isspace(v33->_Mypair._Myval2._Bx._Buf[0]) )
              break;
            v33 = (std::string *)((char *)v33 + 1);
          }
          while ( v33 != (std::string *)v32 );
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v29 = _Right._Mypair._Myval2._Bx._Ptr;
          if ( v33 != (std::string *)v32 )
          {
            v34 = &v33->_Mypair._Myval2._Bx._Buf[1];
            v35 = v32 - (_QWORD)&v33->_Mypair._Myval2._Bx._Buf[1];
            if ( (unsigned __int64)&v33->_Mypair._Myval2._Bx._Buf[1] > v32 )
              v35 = 0i64;
            if ( v35 )
            {
              for ( i = 0i64; i != v35; ++i )
              {
                if ( !isspace(*v34) )
                {
                  v33->_Mypair._Myval2._Bx._Buf[0] = *v34;
                  v33 = (std::string *)((char *)v33 + 1);
                }
                ++v34;
              }
              Myres = _Right._Mypair._Myval2._Myres;
              Mysize = _Right._Mypair._Myval2._Mysize;
              v29 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            Myend = v74;
          }
        }
        v37 = &_Right;
        if ( Myres >= 0x10 )
          v37 = (std::string *)v29;
        v38 = (char *)v33 - (char *)v37;
        v39 = v76 - (char *)v33;
        if ( Mysize < (char *)v33 - (char *)v37 )
          std::_Xout_of_range("invalid string position");
        if ( Mysize - v38 > v39 )
        {
          if ( v39 )
          {
            v41 = &_Right;
            if ( Myres >= 0x10 )
              v41 = (std::string *)v29;
            v42 = &v41->_Mypair._Myval2._Bx._Buf[v38];
            v43 = Mysize - v39;
            if ( v43 != v38 )
            {
              memmove(v42, &v42[v39], v43 - v38);
              Myres = _Right._Mypair._Myval2._Myres;
              v29 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            _Right._Mypair._Myval2._Mysize = v43;
            v44 = &_Right;
            if ( Myres >= 0x10 )
              v44 = (std::string *)v29;
            v44->_Mypair._Myval2._Bx._Buf[v43] = 0;
          }
        }
        else
        {
          _Right._Mypair._Myval2._Mysize = (char *)v33 - (char *)v37;
          v40 = &_Right;
          if ( Myres >= 0x10 )
            v40 = (std::string *)v29;
          v40->_Mypair._Myval2._Bx._Buf[v38] = 0;
        }
        Myfirst = _Val._Mypair._Myval2._Myfirst;
        if ( &_Right >= Mylast || _Val._Mypair._Myval2._Myfirst > &_Right )
        {
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v53 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v53 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v54 = v53 + 1;
            v55 = Myend - _Val._Mypair._Myval2._Myfirst;
            v56 = (v55 >> 1) + v55;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v55 >> 1) < v55 )
              v56 = 0i64;
            if ( v56 < v54 )
              v56 = v54;
            std::vector<std::string>::_Reallocate(&_Val, v56);
            Myend = _Val._Mypair._Myval2._Myend;
            v74 = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
          }
          if ( Mylast )
          {
            Mylast->_Mypair._Myval2._Myres = 15i64;
            Mylast->_Mypair._Myval2._Mysize = 0i64;
            if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
              v57 = Mylast;
            else
              v57 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
            v57->_Mypair._Myval2._Bx._Buf[0] = 0;
            std::string::_Assign_rv(Mylast, &_Right);
          }
        }
        else
        {
          v46 = (char *)&_Right - (char *)_Val._Mypair._Myval2._Myfirst;
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v47 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v47 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v48 = v47 + 1;
            v49 = Myend - _Val._Mypair._Myval2._Myfirst;
            v50 = (v49 >> 1) + v49;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v49 >> 1) < v49 )
              v50 = 0i64;
            if ( v50 < v48 )
              v50 = v48;
            std::vector<std::string>::_Reallocate(&_Val, v50);
            Myend = _Val._Mypair._Myval2._Myend;
            v74 = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
            Myfirst = _Val._Mypair._Myval2._Myfirst;
          }
          v51 = &Myfirst->_Mypair._Myval2._Bx._Buf[v46 & 0xFFFFFFFFFFFFFFE0ui64];
          if ( Mylast )
          {
            Mylast->_Mypair._Myval2._Myres = 15i64;
            Mylast->_Mypair._Myval2._Mysize = 0i64;
            if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
              v52 = Mylast;
            else
              v52 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
            v52->_Mypair._Myval2._Bx._Buf[0] = 0;
            if ( *((_QWORD *)v51 + 3) >= 0x10ui64 )
            {
              Mylast->_Mypair._Myval2._Bx._Ptr = *(char **)v51;
              *(_QWORD *)v51 = 0i64;
            }
            else if ( *((_QWORD *)v51 + 2) != -1i64 )
            {
              memmove(Mylast, v51, *((_QWORD *)v51 + 2) + 1i64);
            }
            Mylast->_Mypair._Myval2._Mysize = *((_QWORD *)v51 + 2);
            Mylast->_Mypair._Myval2._Myres = *((_QWORD *)v51 + 3);
            *((_QWORD *)v51 + 3) = 15i64;
            *((_QWORD *)v51 + 2) = 0i64;
            if ( *((_QWORD *)v51 + 3) >= 0x10ui64 )
              v51 = *(char **)v51;
            *v51 = 0;
          }
        }
        _Val._Mypair._Myval2._Mylast = ++Mylast;
        v58 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
      }
      while ( (v58->gap10[*(int *)(*(_QWORD *)v58->gap0 + 4i64)] & 6) == 0 );
      v5 = v72;
    }
    std::vector<std::vector<std::string>>::push_back(&v78, &_Val);
    v61 = (AgDirectory::DirectoryEntry *)_Val._Mypair._Myval2._Myfirst;
    if ( _Val._Mypair._Myval2._Myfirst )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        _Val._Mypair._Myval2._Myfirst,
        _Val._Mypair._Myval2._Mylast,
        v59,
        v60);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v62,
        v61,
        ((char *)_Val._Mypair._Myval2._Myend - (char *)v61) >> 5);
    }
    std::string::~string(&_Right);
    std::istringstream::~istringstream((std::istringstream *)&_This);
    _This.__vftable = (std::ios_base_vtbl *)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&_This);
  }
  v63 = v78._Mypair._Myval2._Mylast;
  v64 = v78._Mypair._Myval2._Myfirst;
  v65 = (AppMain *)((char *)v78._Mypair._Myval2._Mylast - (char *)v78._Mypair._Myval2._Myfirst);
  v66 = (unsigned __int128)(((char *)v78._Mypair._Myval2._Mylast - (char *)v78._Mypair._Myval2._Myfirst)
                          * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v67 = v78._Mypair._Myval2._Mylast - v78._Mypair._Myval2._Myfirst;
  if ( v67 > 1 )
  {
    v68 = v78._Mypair._Myval2._Myfirst;
    v69 = globalShaderSettingsa;
    do
    {
      if ( v68->_Mypair._Myval2._Mylast - v68->_Mypair._Myval2._Myfirst )
        AppMain::processGlobalShaderData(v65, v68, v69);
      ++v4;
      ++v68;
    }
    while ( v4 < v67 );
  }
  operator delete(_Ptr, v66);
  std::string::~string(&_Str);
  if ( v64 )
  {
    std::_Destroy_range1<std::allocator<std::vector<std::string>>,std::vector<std::string> *>(v64, v63, v70, v71);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)((char *)v78._Mypair._Myval2._Myend - (char *)v64),
      (AgJsonNode *)v64,
      v78._Mypair._Myval2._Myend - v64);
  }
  std::istringstream::~istringstream((std::istringstream *)&v91.gap88[8]);
  *(_QWORD *)&v91.gap88[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v91.gap88[8]);
  return 0i64;
}

__int64 __fastcall AppMain::loadPostProcessShaderData(
        AppMain *this,
        const char *filename,
        AppMain::_POSTPROCESS_SHADER_SETTINGS *postProcessSettings,
        int a4)
{
  int v4; // er13
  int v5; // edi
  int v6; // eax
  int v8; // er8
  char *Ptr; // rcx
  char *v10; // rax
  const std::locale *v11; // rax
  __int64 v12; // rdx
  std::locale::facet *v13; // rbx
  std::_Facet_base *v14; // rax
  char v15; // al
  std::istream *v16; // rax
  std::locale *v17; // rbx
  const std::locale *v18; // rax
  __int64 v19; // rdx
  std::locale::facet *v20; // rbx
  std::_Facet_base *v21; // rax
  int v22; // er9
  std::string *p_Str; // rdx
  std::string *Myend; // r14
  std::istream *v25; // rax
  std::string *Mylast; // rdi
  unsigned __int64 Mysize; // r15
  std::string *p_Right; // r8
  char *v29; // rcx
  unsigned __int64 Myres; // rdx
  std::string *v31; // rbx
  unsigned __int64 v32; // rbx
  std::string *v33; // rsi
  char *v34; // r14
  unsigned __int64 v35; // r12
  __int64 i; // rbx
  std::string *v37; // rax
  signed __int64 v38; // r8
  unsigned __int64 v39; // r10
  std::string *v40; // rax
  std::string *v41; // r9
  char *v42; // r9
  unsigned __int64 v43; // r15
  std::string *v44; // rax
  std::string *Myfirst; // rcx
  signed __int64 v46; // rbx
  __int64 v47; // rdi
  unsigned __int64 v48; // rdi
  unsigned __int64 v49; // r14
  unsigned __int64 v50; // rdx
  char *v51; // rbx
  std::string *v52; // rax
  __int64 v53; // rdi
  unsigned __int64 v54; // rdi
  unsigned __int64 v55; // r14
  unsigned __int64 v56; // rdx
  std::string *v57; // rax
  std::istream *v58; // rax
  std::_Wrap_alloc<std::allocator<std::string > > *v59; // r8
  std::integral_constant<bool,0> v60; // r9
  AgDirectory::DirectoryEntry *v61; // rbx
  std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry> > *v62; // rcx
  std::vector<std::string> *v63; // r14
  std::vector<std::string> *v64; // rsi
  AppMain *v65; // rcx
  unsigned __int64 v66; // rdx
  unsigned __int64 v67; // rdi
  std::vector<std::string> *v68; // rbx
  AppMain::_POSTPROCESS_SHADER_SETTINGS *v69; // r15
  std::_Wrap_alloc<std::allocator<std::vector<std::string> > > *v70; // r8
  std::integral_constant<bool,0> v71; // r9
  int v72; // [rsp+30h] [rbp-D0h]
  std::vector<std::string> _Val; // [rsp+38h] [rbp-C8h] BYREF
  std::string *v74; // [rsp+50h] [rbp-B0h]
  char *_Ptr; // [rsp+58h] [rbp-A8h] BYREF
  char *v76; // [rsp+60h] [rbp-A0h]
  AppMain::_POSTPROCESS_SHADER_SETTINGS *postProcessSettingsa; // [rsp+68h] [rbp-98h]
  std::vector<std::vector<std::string>> v78; // [rsp+70h] [rbp-90h] BYREF
  int v79; // [rsp+8Ch] [rbp-74h]
  std::istream _Istr; // [rsp+90h] [rbp-70h] BYREF
  __int64 v81; // [rsp+108h] [rbp+8h]
  int v82; // [rsp+110h] [rbp+10h]
  int v83; // [rsp+11Ch] [rbp+1Ch]
  std::ios_base _This; // [rsp+120h] [rbp+20h] BYREF
  _BYTE *v85; // [rsp+168h] [rbp+68h]
  __int64 v86; // [rsp+170h] [rbp+70h]
  char v87; // [rsp+178h] [rbp+78h]
  __int64 v88; // [rsp+180h] [rbp+80h]
  std::locale result; // [rsp+188h] [rbp+88h] BYREF
  std::locale v90; // [rsp+198h] [rbp+98h] BYREF
  std::istringstream v91; // [rsp+1B0h] [rbp+B0h] BYREF
  std::string _Right; // [rsp+2A0h] [rbp+1A0h] BYREF
  std::string _Str; // [rsp+2C0h] [rbp+1C0h] BYREF

  v88 = -2i64;
  postProcessSettingsa = postProcessSettings;
  v4 = 0;
  v5 = 0;
  _Ptr = 0i64;
  v6 = CFile::ResourceDataLoaderNew(filename, (int)filename, (int)postProcessSettings, a4, (unsigned __int8 **)&_Ptr);
  if ( !_Ptr )
    return 0xFFFFFFFFi64;
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  std::string::assign(&_Str, _Ptr, v6);
  std::istringstream::istringstream(&v91, &_Str, v8);
  if ( _Str._Mypair._Myval2._Myres >= 0x10 )
  {
    Ptr = _Str._Mypair._Myval2._Bx._Ptr;
    if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
    {
      if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
        invalid_parameter_noinfo_noreturn();
      v10 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
      if ( v10 >= _Str._Mypair._Myval2._Bx._Ptr )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) < (char *)8 )
        invalid_parameter_noinfo_noreturn();
      if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v10) > (char *)0x27 )
        invalid_parameter_noinfo_noreturn();
      Ptr = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
    }
    operator delete(Ptr);
  }
  memset(&v78, 0, sizeof(v78));
  _Str._Mypair._Myval2._Myres = 15i64;
  _Str._Mypair._Myval2._Mysize = 0i64;
  _Str._Mypair._Myval2._Bx._Buf[0] = 0;
  while ( 1 )
  {
    v11 = std::ios_base::getloc((std::ios_base *)&v91.gap0[*(int *)(*(_QWORD *)v91.gap0 + 4i64)], &result);
    v13 = std::use_facet<std::ctype<char>>(v11);
    if ( result._Ptr )
    {
      v14 = result._Ptr->_Decref(result._Ptr);
      if ( v14 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v14->~_Facet_base)(v14, 1i64);
    }
    LOBYTE(v12) = 10;
    v15 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v13->__vftable[2]._Decref)(v13, v12);
    v16 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&v91, &_Str, v15);
    if ( (v16->gap10[*(int *)(*(_QWORD *)v16->gap0 + 4i64)] & 6) != 0 )
      break;
    *(_QWORD *)_Istr.gap0 = &std::istringstream::`vbtable';
    v5 |= 1u;
    v72 = v5;
    _This.__vftable = (std::ios_base_vtbl *)&std::istream::`vftable';
    v83 = 120;
    _Istr._Chcount = 0i64;
    _This._Stdstr = 0i64;
    _This._Except = 0;
    _This._Fmtfl = 513;
    *(__m128i *)&_This._Prec = _mm_load_si128((const __m128i *)&_xmm);
    memset(&_This._Arr, 0, 24);
    std::ios_base::clear(&_This, 0, 0);
    v17 = (std::locale *)operator new(0x10ui64);
    v17->_Ptr = std::locale::_Init(1);
    _This._Ploc = v17;
    v85 = _Istr.gap10;
    v86 = 0i64;
    v18 = std::ios_base::getloc(&_This, &v90);
    v20 = std::use_facet<std::ctype<char>>(v18);
    if ( v90._Ptr )
    {
      v21 = v90._Ptr->_Decref(v90._Ptr);
      if ( v21 )
        ((void (__fastcall *)(std::_Facet_base *, __int64))v21->~_Facet_base)(v21, 1i64);
    }
    LOBYTE(v19) = 32;
    v87 = ((__int64 (__fastcall *)(std::locale::facet *, __int64))v20->__vftable[2]._Decref)(v20, v19);
    if ( !v85 )
      std::ios_base::clear(&_This, _This._Mystate | 4, 0);
    *(_QWORD *)&_Istr.gap0[*(int *)(*(_QWORD *)_Istr.gap0 + 4i64)] = &std::istringstream::`vftable';
    *(int *)((char *)&v79 + *(int *)(*(_QWORD *)_Istr.gap0 + 4i64)) = *(_DWORD *)(*(_QWORD *)_Istr.gap0 + 4i64) - 144;
    v76 = _Istr.gap10;
    std::streambuf::streambuf((std::streambuf *)_Istr.gap10);
    *(_QWORD *)_Istr.gap10 = &std::stringbuf::`vftable';
    p_Str = &_Str;
    if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
    v81 = 0i64;
    v82 = 2;
    if ( _Str._Mypair._Myval2._Mysize )
      std::stringbuf::_Init(
        (std::stringbuf *)_Istr.gap10,
        p_Str->_Mypair._Myval2._Bx._Buf,
        _Str._Mypair._Myval2._Mysize,
        v22);
    _Right._Mypair._Myval2._Myres = 15i64;
    _Right._Mypair._Myval2._Mysize = 0i64;
    _Right._Mypair._Myval2._Bx._Buf[0] = 0;
    memset(&_Val, 0, sizeof(_Val));
    Myend = 0i64;
    v74 = 0i64;
    v25 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
    if ( (v25->gap10[*(int *)(*(_QWORD *)v25->gap0 + 4i64)] & 6) == 0 )
    {
      Mylast = _Val._Mypair._Myval2._Mylast;
      do
      {
        Mysize = _Right._Mypair._Myval2._Mysize;
        if ( !_Right._Mypair._Myval2._Mysize )
          break;
        p_Right = &_Right;
        v29 = _Right._Mypair._Myval2._Bx._Ptr;
        Myres = _Right._Mypair._Myval2._Myres;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          p_Right = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v76 = &p_Right->_Mypair._Myval2._Bx._Buf[_Right._Mypair._Myval2._Mysize];
        v31 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v31 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        v32 = (unsigned __int64)v31 + _Right._Mypair._Myval2._Mysize;
        v33 = &_Right;
        if ( _Right._Mypair._Myval2._Myres >= 0x10 )
          v33 = (std::string *)_Right._Mypair._Myval2._Bx._Ptr;
        if ( v33 != (std::string *)v32 )
        {
          do
          {
            if ( isspace(v33->_Mypair._Myval2._Bx._Buf[0]) )
              break;
            v33 = (std::string *)((char *)v33 + 1);
          }
          while ( v33 != (std::string *)v32 );
          Myres = _Right._Mypair._Myval2._Myres;
          Mysize = _Right._Mypair._Myval2._Mysize;
          v29 = _Right._Mypair._Myval2._Bx._Ptr;
          if ( v33 != (std::string *)v32 )
          {
            v34 = &v33->_Mypair._Myval2._Bx._Buf[1];
            v35 = v32 - (_QWORD)&v33->_Mypair._Myval2._Bx._Buf[1];
            if ( (unsigned __int64)&v33->_Mypair._Myval2._Bx._Buf[1] > v32 )
              v35 = 0i64;
            if ( v35 )
            {
              for ( i = 0i64; i != v35; ++i )
              {
                if ( !isspace(*v34) )
                {
                  v33->_Mypair._Myval2._Bx._Buf[0] = *v34;
                  v33 = (std::string *)((char *)v33 + 1);
                }
                ++v34;
              }
              Myres = _Right._Mypair._Myval2._Myres;
              Mysize = _Right._Mypair._Myval2._Mysize;
              v29 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            Myend = v74;
          }
        }
        v37 = &_Right;
        if ( Myres >= 0x10 )
          v37 = (std::string *)v29;
        v38 = (char *)v33 - (char *)v37;
        v39 = v76 - (char *)v33;
        if ( Mysize < (char *)v33 - (char *)v37 )
          std::_Xout_of_range("invalid string position");
        if ( Mysize - v38 > v39 )
        {
          if ( v39 )
          {
            v41 = &_Right;
            if ( Myres >= 0x10 )
              v41 = (std::string *)v29;
            v42 = &v41->_Mypair._Myval2._Bx._Buf[v38];
            v43 = Mysize - v39;
            if ( v43 != v38 )
            {
              memmove(v42, &v42[v39], v43 - v38);
              Myres = _Right._Mypair._Myval2._Myres;
              v29 = _Right._Mypair._Myval2._Bx._Ptr;
            }
            _Right._Mypair._Myval2._Mysize = v43;
            v44 = &_Right;
            if ( Myres >= 0x10 )
              v44 = (std::string *)v29;
            v44->_Mypair._Myval2._Bx._Buf[v43] = 0;
          }
        }
        else
        {
          _Right._Mypair._Myval2._Mysize = (char *)v33 - (char *)v37;
          v40 = &_Right;
          if ( Myres >= 0x10 )
            v40 = (std::string *)v29;
          v40->_Mypair._Myval2._Bx._Buf[v38] = 0;
        }
        Myfirst = _Val._Mypair._Myval2._Myfirst;
        if ( &_Right >= Mylast || _Val._Mypair._Myval2._Myfirst > &_Right )
        {
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v53 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v53 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v54 = v53 + 1;
            v55 = Myend - _Val._Mypair._Myval2._Myfirst;
            v56 = (v55 >> 1) + v55;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v55 >> 1) < v55 )
              v56 = 0i64;
            if ( v56 < v54 )
              v56 = v54;
            std::vector<std::string>::_Reallocate(&_Val, v56);
            Myend = _Val._Mypair._Myval2._Myend;
            v74 = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
          }
          if ( Mylast )
          {
            Mylast->_Mypair._Myval2._Myres = 15i64;
            Mylast->_Mypair._Myval2._Mysize = 0i64;
            if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
              v57 = Mylast;
            else
              v57 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
            v57->_Mypair._Myval2._Bx._Buf[0] = 0;
            std::string::_Assign_rv(Mylast, &_Right);
          }
        }
        else
        {
          v46 = (char *)&_Right - (char *)_Val._Mypair._Myval2._Myfirst;
          if ( Mylast == Myend && !(Myend - Mylast) )
          {
            v47 = Mylast - _Val._Mypair._Myval2._Myfirst;
            if ( v47 == 0x7FFFFFFFFFFFFFFi64 )
              std::_Xlength_error("vector<T> too long");
            v48 = v47 + 1;
            v49 = Myend - _Val._Mypair._Myval2._Myfirst;
            v50 = (v49 >> 1) + v49;
            if ( 0x7FFFFFFFFFFFFFFi64 - (v49 >> 1) < v49 )
              v50 = 0i64;
            if ( v50 < v48 )
              v50 = v48;
            std::vector<std::string>::_Reallocate(&_Val, v50);
            Myend = _Val._Mypair._Myval2._Myend;
            v74 = _Val._Mypair._Myval2._Myend;
            Mylast = _Val._Mypair._Myval2._Mylast;
            Myfirst = _Val._Mypair._Myval2._Myfirst;
          }
          v51 = &Myfirst->_Mypair._Myval2._Bx._Buf[v46 & 0xFFFFFFFFFFFFFFE0ui64];
          if ( Mylast )
          {
            Mylast->_Mypair._Myval2._Myres = 15i64;
            Mylast->_Mypair._Myval2._Mysize = 0i64;
            if ( Mylast->_Mypair._Myval2._Myres < 0x10 )
              v52 = Mylast;
            else
              v52 = (std::string *)Mylast->_Mypair._Myval2._Bx._Ptr;
            v52->_Mypair._Myval2._Bx._Buf[0] = 0;
            if ( *((_QWORD *)v51 + 3) >= 0x10ui64 )
            {
              Mylast->_Mypair._Myval2._Bx._Ptr = *(char **)v51;
              *(_QWORD *)v51 = 0i64;
            }
            else if ( *((_QWORD *)v51 + 2) != -1i64 )
            {
              memmove(Mylast, v51, *((_QWORD *)v51 + 2) + 1i64);
            }
            Mylast->_Mypair._Myval2._Mysize = *((_QWORD *)v51 + 2);
            Mylast->_Mypair._Myval2._Myres = *((_QWORD *)v51 + 3);
            *((_QWORD *)v51 + 3) = 15i64;
            *((_QWORD *)v51 + 2) = 0i64;
            if ( *((_QWORD *)v51 + 3) >= 0x10ui64 )
              v51 = *(char **)v51;
            *v51 = 0;
          }
        }
        _Val._Mypair._Myval2._Mylast = ++Mylast;
        v58 = std::getline<char,std::char_traits<char>,std::allocator<char>>(&_Istr, &_Right, 44);
      }
      while ( (v58->gap10[*(int *)(*(_QWORD *)v58->gap0 + 4i64)] & 6) == 0 );
      v5 = v72;
    }
    std::vector<std::vector<std::string>>::push_back(&v78, &_Val);
    v61 = (AgDirectory::DirectoryEntry *)_Val._Mypair._Myval2._Myfirst;
    if ( _Val._Mypair._Myval2._Myfirst )
    {
      std::_Destroy_range1<std::allocator<std::string>,std::string *>(
        _Val._Mypair._Myval2._Myfirst,
        _Val._Mypair._Myval2._Mylast,
        v59,
        v60);
      std::_Wrap_alloc<std::allocator<AgDirectory::DirectoryEntry>>::deallocate(
        v62,
        v61,
        ((char *)_Val._Mypair._Myval2._Myend - (char *)v61) >> 5);
    }
    std::string::~string(&_Right);
    std::istringstream::~istringstream((std::istringstream *)&_This);
    _This.__vftable = (std::ios_base_vtbl *)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&_This);
  }
  v63 = v78._Mypair._Myval2._Mylast;
  v64 = v78._Mypair._Myval2._Myfirst;
  v65 = (AppMain *)((char *)v78._Mypair._Myval2._Mylast - (char *)v78._Mypair._Myval2._Myfirst);
  v66 = (unsigned __int128)(((char *)v78._Mypair._Myval2._Mylast - (char *)v78._Mypair._Myval2._Myfirst)
                          * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v67 = v78._Mypair._Myval2._Mylast - v78._Mypair._Myval2._Myfirst;
  if ( v67 )
  {
    v68 = v78._Mypair._Myval2._Myfirst;
    v69 = postProcessSettingsa;
    do
    {
      if ( v68->_Mypair._Myval2._Mylast - v68->_Mypair._Myval2._Myfirst )
        AppMain::processPostProcessData(v65, v68, v69);
      ++v4;
      ++v68;
    }
    while ( v4 < v67 );
  }
  operator delete(_Ptr, v66);
  std::string::~string(&_Str);
  if ( v64 )
  {
    std::_Destroy_range1<std::allocator<std::vector<std::string>>,std::vector<std::string> *>(v64, v63, v70, v71);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)((char *)v78._Mypair._Myval2._Myend - (char *)v64),
      (AgJsonNode *)v64,
      v78._Mypair._Myval2._Myend - v64);
  }
  std::istringstream::~istringstream((std::istringstream *)&v91.gap88[8]);
  *(_QWORD *)&v91.gap88[8] = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((std::ios_base *)&v91.gap88[8]);
  return 0i64;
}

void __fastcall AppMain::loadShaderFXDataToAsyncAsset(
        AppMain *this,
        extension::AsyncAsset *asset,
        AppMain::_MODEL_LIGHT_DATA *modelLightAssetData)
{
  extension::AsyncAsset *v4; // r8
  signed __int64 v5; // rax
  __int64 v6; // rdx
  int v7; // er15
  __int64 v8; // r9
  int *p_numMaterials; // rcx
  OGLModel *Myval2; // r13
  unsigned int m_ucMaterialCount; // er12
  int *v12; // rsi
  __int64 v13; // r14
  __int64 v14; // rdi
  OGLMaterial *m_pMaterial; // rbx
  int m_lightCount; // er9
  int v17; // er8
  __int64 v18; // r10
  OGLLightManager *m_pLightManager; // rax
  OGLLightNode *m_pLightNodeList; // rcx
  __int64 v21; // rax
  int v22; // er8
  OGLLightManager *v23; // rbx
  __int64 v24; // [rsp+20h] [rbp-58h]
  int *v25; // [rsp+28h] [rbp-50h]
  __int64 v26; // [rsp+30h] [rbp-48h]
  int v27; // [rsp+80h] [rbp+8h]
  __int64 v29; // [rsp+98h] [rbp+20h]

  if ( asset )
  {
    v4 = asset;
    if ( modelLightAssetData )
    {
      v5 = asset->m_models._Mypair._Myval2._Mylast - asset->m_models._Mypair._Myval2._Myfirst;
      if ( (_DWORD)v5 )
      {
        v6 = 0i64;
        v7 = 0;
        v8 = (int)v5;
        v26 = (int)v5;
        v24 = 0i64;
        if ( (int)v5 > 0 )
        {
          p_numMaterials = &modelLightAssetData->numMaterials;
          v25 = &modelLightAssetData->numMaterials;
          while ( 1 )
          {
            if ( v7 < 0 || v7 >= (int)(v4->m_models._Mypair._Myval2._Mylast - v4->m_models._Mypair._Myval2._Myfirst) )
              Myval2 = 0i64;
            else
              Myval2 = v4->m_models._Mypair._Myval2._Myfirst[v6]._Mypair._Myval2;
            if ( !Myval2->m_useShaderFX )
              goto LABEL_30;
            m_ucMaterialCount = Myval2->m_ucMaterialCount;
            v27 = m_ucMaterialCount;
            if ( m_ucMaterialCount > 0x40 )
              break;
            if ( Myval2->m_ucMaterialCount )
              goto LABEL_14;
LABEL_29:
            *p_numMaterials = m_ucMaterialCount;
            *((_BYTE *)p_numMaterials - 4) = 1;
LABEL_30:
            ++v6;
            p_numMaterials += 7938;
            ++v7;
            v24 = v6;
            v25 = p_numMaterials;
            if ( v6 >= v8 )
              return;
          }
          m_ucMaterialCount = 64;
          v27 = 64;
LABEL_14:
          v12 = p_numMaterials + 1;
          v13 = 0i64;
          v29 = m_ucMaterialCount;
          v14 = 0i64;
          do
          {
            m_pMaterial = Myval2->m_pMaterial;
            m_lightCount = m_pMaterial[v13].m_pLightManager->m_lightCount;
            if ( m_lightCount > 3 )
              m_lightCount = 3;
            v17 = 0;
            if ( m_lightCount > 0 )
            {
              v18 = v14 + 31752i64 * v7;
              do
              {
                m_pLightManager = m_pMaterial[v13].m_pLightManager;
                m_pLightNodeList = m_pLightManager->m_pLightNodeList;
                if ( m_pLightNodeList && v17 < m_pLightManager->m_lightCount )
                {
                  if ( v17 > 0 )
                  {
                    v21 = (unsigned int)v17;
                    do
                    {
                      m_pLightNodeList = m_pLightNodeList->next;
                      --v21;
                    }
                    while ( v21 );
                  }
                }
                else
                {
                  m_pLightNodeList = 0i64;
                }
                ShaderFxHelper::ShaderFxExtractLightSetting(
                  &m_pLightNodeList->m_light,
                  (ShaderFxHelper::ShaderFxLightSetting *)((char *)&modelLightAssetData->matLightAssetData[0].lightAssetData[v17]
                                                         + v18));
                v17 = v22 + 1;
              }
              while ( v17 < m_lightCount );
            }
            *v12 = m_lightCount;
            v23 = m_pMaterial[v13].m_pLightManager;
            OGLLightManager::deleteAllLights(v23);
            OGLLightManager::clear(v23);
            v14 += 496i64;
            ++v13;
            v12 += 124;
            --v29;
          }
          while ( v29 );
          m_ucMaterialCount = v27;
          p_numMaterials = v25;
          v6 = v24;
          v4 = asset;
          v8 = v26;
          goto LABEL_29;
        }
      }
    }
  }
}

extension::RefCountablePtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *__fastcall extension::RCWeakPtr<extension::BasicFutureObject<extension::GFXIMovieData,void>::Body>::lock(
        extension::RCWeakPtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *this,
        extension::RefCountablePtr<extension::exsound_detail::SoundNameRegistry::NameBuffer> *result)
{
  extension::exsound_detail::SoundNameRegistry::NameBuffer *m_principal; // rdx
  extension::RefCountableWeakSupportBase::WeakProxy *m_ptr; // r8
  signed __int64 My_val; // rax
  unsigned __int64 v6; // rtt
  extension::exsound_detail::SoundNameRegistry::NameBuffer *v7; // rcx

  m_principal = 0i64;
  result->m_ptr = 0i64;
  m_ptr = this->m_proxy.m_ptr;
  if ( m_ptr )
  {
    while ( 1 )
    {
      My_val = m_ptr->m_sharedCount.m_value._My_val;
      if ( !My_val )
        break;
      v6 = m_ptr->m_sharedCount.m_value._My_val;
      if ( v6 == _InterlockedCompareExchange64((volatile signed __int64 *)&m_ptr->m_sharedCount, My_val + 1, My_val) )
      {
        m_principal = (extension::exsound_detail::SoundNameRegistry::NameBuffer *)m_ptr->m_principal;
        break;
      }
    }
    v7 = result->m_ptr;
    result->m_ptr = m_principal;
    if ( v7
      && _InterlockedExchangeAdd64(
           (volatile signed __int64 *)&v7->m_refCount.m_ptr->m_sharedCount,
           0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      ((void (__fastcall *)(extension::exsound_detail::SoundNameRegistry::NameBuffer *, __int64))v7->~RefCountableWeakSupportBase)(
        v7,
        1i64);
    }
  }
  return result;
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *__fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>>>,0>>::lower_bound(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *result,
        const std::string *_Keyval)
{
  unsigned __int64 Myres; // r15
  const std::string *v4; // r14
  unsigned __int64 Mysize; // rdi
  unsigned __int64 v8; // rcx
  __int64 i; // rdx
  __int64 v10; // rax
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *Myfirst; // rcx
  unsigned __int64 Mask; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rbp
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Ptr; // r13
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v17; // rbx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *v18; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rax
  char **p_Myval; // rcx
  const std::string *v21; // rdx
  unsigned __int64 v22; // rsi
  size_t v23; // r8
  char **v24; // rdx
  size_t v25; // rsi
  size_t v26; // r8
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *j; // [rsp+50h] [rbp+8h]

  Myres = _Keyval->_Mypair._Myval2._Myres;
  v4 = _Keyval;
  Mysize = _Keyval->_Mypair._Myval2._Mysize;
  if ( Myres >= 0x10 )
    _Keyval = (const std::string *)_Keyval->_Mypair._Myval2._Bx._Ptr;
  v8 = 0i64;
  for ( i = 0xCBF29CE484222325ui64; v8 < Mysize; i = 0x100000001B3i64 * (v10 ^ i) )
    v10 = (unsigned __int8)_Keyval->_Mypair._Myval2._Bx._Buf[v8++];
  Myfirst = this->_Vec._Mypair._Myval2._Myfirst;
  Mask = this->_Mask;
  Myhead = this->_List._Mypair._Myval2._Myhead;
  v14 = i & Mask;
  v15 = 2 * (i & Mask);
  Ptr = Myfirst[v15]._Ptr;
  v17 = Myfirst[2 * v14]._Ptr;
  v18 = &Myfirst[v15 + 1];
  for ( j = v18; ; v18 = j )
  {
    if ( Ptr == Myhead )
      Next = Myhead;
    else
      Next = v18->_Ptr->_Next;
    if ( v17 == Next )
    {
      result->_Ptr = Myhead;
      return result;
    }
    p_Myval = (char **)&v17->_Myval;
    if ( Myres < 0x10 )
      v21 = v4;
    else
      v21 = (const std::string *)v4->_Mypair._Myval2._Bx._Ptr;
    if ( v17->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
      p_Myval = (char **)*p_Myval;
    v22 = v17->_Myval.first._Mypair._Myval2._Mysize;
    v23 = Mysize;
    if ( v22 < Mysize )
      v23 = v17->_Myval.first._Mypair._Myval2._Mysize;
    if ( (!v23 || !memcmp(p_Myval, v21, v23)) && v22 >= Mysize && v22 <= Mysize )
      break;
    v17 = v17->_Next;
  }
  v24 = (char **)&v17->_Myval;
  if ( v17->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
    v24 = (char **)*v24;
  if ( Myres >= 0x10 )
    v4 = (const std::string *)v4->_Mypair._Myval2._Bx._Ptr;
  v25 = v17->_Myval.first._Mypair._Myval2._Mysize;
  v26 = v25;
  if ( Mysize < v25 )
    v26 = Mysize;
  if ( v26 && memcmp(v4, v24, v26) || Mysize < v25 || Mysize > v25 )
    v17 = Myhead;
  result->_Ptr = v17;
  return result;
}

void __fastcall AppMain::processGlobalShaderData(
        AppMain *this,
        std::vector<std::string> *line,
        AppMain::_GLOBAL_SHADER_SETTINGS *globalShaderSettings)
{
  int v5; // edi
  std::string *i; // rbx
  std::string *Ptr; // rcx
  std::string *v8; // rdx
  unsigned __int64 v9; // r8
  std::string *p_Str; // rbx
  float v11; // xmm6_4
  char *v12; // rcx
  char *v13; // rax
  std::string *v14; // rdx
  unsigned __int64 v15; // r8
  std::string *v16; // rbx
  float v17; // xmm6_4
  char *v18; // rcx
  char *v19; // rax
  std::string *Myfirst; // rbx
  std::string *v21; // rcx
  std::string *v22; // rdx
  unsigned __int64 v23; // r8
  std::string *v24; // rbx
  float v25; // xmm6_4
  char *v26; // rcx
  char *v27; // rax
  std::string *v28; // rbx
  std::string *v29; // rcx
  std::string *v30; // rdx
  unsigned __int64 v31; // r8
  std::string *v32; // rbx
  float v33; // xmm6_4
  char *v34; // rcx
  char *v35; // rax
  std::string *v36; // rdx
  unsigned __int64 v37; // r8
  std::string *v38; // rbx
  float v39; // xmm6_4
  std::string *v40; // rbx
  std::string *v41; // rcx
  std::string *v42; // rdx
  unsigned __int64 v43; // r8
  std::string *v44; // rbx
  float v45; // xmm6_4
  std::string *v46; // rbx
  std::string *v47; // rcx
  std::string *v48; // rdx
  unsigned __int64 v49; // r8
  std::string *v50; // rbx
  float v51; // xmm6_4
  std::string *v52; // rdx
  unsigned __int64 v53; // r8
  unsigned __int64 *v54; // rdx
  std::string *v55; // rbx
  std::string *v56; // rcx
  std::string *v57; // rdx
  unsigned __int64 v58; // r8
  unsigned __int64 *v59; // rdx
  std::string *v60; // rbx
  std::string *v61; // rcx
  std::string *v62; // rdx
  unsigned __int64 v63; // r8
  unsigned __int64 *v64; // rdx
  std::string *v65; // rdx
  unsigned __int64 v66; // r8
  unsigned __int64 *v67; // rdx
  std::string *v68; // rbx
  std::string *v69; // rcx
  std::string *v70; // rdx
  unsigned __int64 v71; // r8
  unsigned __int64 *v72; // rdx
  char *end_ptr; // [rsp+28h] [rbp-49h] BYREF
  char *v74; // [rsp+30h] [rbp-41h] BYREF
  char *v75; // [rsp+38h] [rbp-39h] BYREF
  char *v76; // [rsp+40h] [rbp-31h] BYREF
  char *v77; // [rsp+48h] [rbp-29h] BYREF
  char *v78; // [rsp+50h] [rbp-21h] BYREF
  char *v79[2]; // [rsp+58h] [rbp-19h] BYREF
  std::string _Str; // [rsp+68h] [rbp-9h] BYREF

  v79[1] = (char *)-2i64;
  v5 = 0;
  for ( i = line->_Mypair._Myval2._Myfirst;
        v5 < (unsigned __int64)(line->_Mypair._Myval2._Mylast - line->_Mypair._Myval2._Myfirst);
        i = line->_Mypair._Myval2._Myfirst )
  {
    Ptr = &i[v5];
    if ( Ptr->_Mypair._Myval2._Myres >= 0x10 )
      Ptr = (std::string *)Ptr->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(Ptr->_Mypair._Myval2._Bx._Buf, "FIRENORMCENTRE") )
    {
      v8 = &i[v5 + 1];
      if ( v8->_Mypair._Myval2._Myres >= 0x10 )
        v8 = (std::string *)v8->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v8->_Mypair._Myval2._Bx._Buf[0] )
      {
        v9 = -1i64;
        do
          ++v9;
        while ( v8->_Mypair._Myval2._Bx._Buf[v9] );
      }
      else
      {
        v9 = 0i64;
      }
      std::string::assign(&_Str, v8->_Mypair._Myval2._Bx._Buf, v9);
      p_Str = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v11 = strtof(p_Str->_Mypair._Myval2._Bx._Buf, &end_ptr);
      if ( p_Str == (std::string *)end_ptr )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxCentre[0].x = v11;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v12 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v13 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v13 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v13) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v13) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v12 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v12);
      }
      v5 += 2;
      v14 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v14->_Mypair._Myval2._Myres >= 0x10 )
        v14 = (std::string *)v14->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v14->_Mypair._Myval2._Bx._Buf[0] )
      {
        v15 = -1i64;
        do
          ++v15;
        while ( v14->_Mypair._Myval2._Bx._Buf[v15] );
      }
      else
      {
        v15 = 0i64;
      }
      std::string::assign(&_Str, v14->_Mypair._Myval2._Bx._Buf, v15);
      v16 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v16 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v17 = strtof(v16->_Mypair._Myval2._Bx._Buf, &v74);
      if ( v16 == (std::string *)v74 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxCentre[0].y = v17;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v18 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v19 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v19 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v19) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v19) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v18 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v18);
      }
    }
    Myfirst = line->_Mypair._Myval2._Myfirst;
    v21 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v21->_Mypair._Myval2._Myres >= 0x10 )
      v21 = (std::string *)v21->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v21->_Mypair._Myval2._Bx._Buf, "FIRENORMSPEED") )
    {
      v22 = &Myfirst[++v5];
      if ( v22->_Mypair._Myval2._Myres >= 0x10 )
        v22 = (std::string *)v22->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v22->_Mypair._Myval2._Bx._Buf[0] )
      {
        v23 = -1i64;
        do
          ++v23;
        while ( v22->_Mypair._Myval2._Bx._Buf[v23] );
      }
      else
      {
        v23 = 0i64;
      }
      std::string::assign(&_Str, v22->_Mypair._Myval2._Bx._Buf, v23);
      v24 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v24 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v25 = strtof(v24->_Mypair._Myval2._Bx._Buf, &v75);
      if ( v24 == (std::string *)v75 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxSpeed[0] = v25;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v26 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v27 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v27 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v27) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v27) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v26 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v26);
      }
    }
    v28 = line->_Mypair._Myval2._Myfirst;
    v29 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v29->_Mypair._Myval2._Myres >= 0x10 )
      v29 = (std::string *)v29->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v29->_Mypair._Myval2._Bx._Buf, "FIRECAMVECCENTRE") )
    {
      v30 = &v28[v5 + 1];
      if ( v30->_Mypair._Myval2._Myres >= 0x10 )
        v30 = (std::string *)v30->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v30->_Mypair._Myval2._Bx._Buf[0] )
      {
        v31 = -1i64;
        do
          ++v31;
        while ( v30->_Mypair._Myval2._Bx._Buf[v31] );
      }
      else
      {
        v31 = 0i64;
      }
      std::string::assign(&_Str, v30->_Mypair._Myval2._Bx._Buf, v31);
      v32 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v32 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v33 = strtof(v32->_Mypair._Myval2._Bx._Buf, &v76);
      if ( v32 == (std::string *)v76 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxCentre[1].x = v33;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v34 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v35 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v35 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v35) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v35) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v34 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v34);
      }
      v5 += 2;
      v36 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v36->_Mypair._Myval2._Myres >= 0x10 )
        v36 = (std::string *)v36->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v36->_Mypair._Myval2._Bx._Buf[0] )
      {
        v37 = -1i64;
        do
          ++v37;
        while ( v36->_Mypair._Myval2._Bx._Buf[v37] );
      }
      else
      {
        v37 = 0i64;
      }
      std::string::assign(&_Str, v36->_Mypair._Myval2._Bx._Buf, v37);
      v38 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v38 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v39 = strtof(v38->_Mypair._Myval2._Bx._Buf, &v77);
      if ( v38 == (std::string *)v77 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxCentre[1].y = v39;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        std::_Wrap_alloc<std::allocator<unsigned char>>::deallocate(
          (std::_Wrap_alloc<std::allocator<AgSuspendingEvent> > *)&_Str,
          (AgSuspendingEvent *)_Str._Mypair._Myval2._Bx._Ptr,
          _Str._Mypair._Myval2._Myres + 1);
    }
    v40 = line->_Mypair._Myval2._Myfirst;
    v41 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v41->_Mypair._Myval2._Myres >= 0x10 )
      v41 = (std::string *)v41->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v41->_Mypair._Myval2._Bx._Buf, "FIRECAMVECSPEED") )
    {
      v42 = &v40[++v5];
      if ( v42->_Mypair._Myval2._Myres >= 0x10 )
        v42 = (std::string *)v42->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v42->_Mypair._Myval2._Bx._Buf[0] )
      {
        v43 = -1i64;
        do
          ++v43;
        while ( v42->_Mypair._Myval2._Bx._Buf[v43] );
      }
      else
      {
        v43 = 0i64;
      }
      std::string::assign(&_Str, v42->_Mypair._Myval2._Bx._Buf, v43);
      v44 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v44 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v45 = strtof(v44->_Mypair._Myval2._Bx._Buf, &v78);
      if ( v44 == (std::string *)v78 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[0].fxSpeed[1] = v45;
      std::string::~string(&_Str);
    }
    v46 = line->_Mypair._Myval2._Myfirst;
    v47 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v47->_Mypair._Myval2._Myres >= 0x10 )
      v47 = (std::string *)v47->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v47->_Mypair._Myval2._Bx._Buf, "LIGHTNORMCENTRE") )
    {
      v48 = &v46[v5 + 1];
      if ( v48->_Mypair._Myval2._Myres >= 0x10 )
        v48 = (std::string *)v48->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v48->_Mypair._Myval2._Bx._Buf[0] )
      {
        v49 = -1i64;
        do
          ++v49;
        while ( v48->_Mypair._Myval2._Bx._Buf[v49] );
      }
      else
      {
        v49 = 0i64;
      }
      std::string::assign(&_Str, v48->_Mypair._Myval2._Bx._Buf, v49);
      v50 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v50 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v51 = strtof(v50->_Mypair._Myval2._Bx._Buf, v79);
      if ( v50 == (std::string *)v79[0] )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      globalShaderSettings->modelFXSettings[1].fxCentre[0].x = v51;
      std::string::~string(&_Str);
      v5 += 2;
      v52 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v52->_Mypair._Myval2._Myres >= 0x10 )
        v52 = (std::string *)v52->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v52->_Mypair._Myval2._Bx._Buf[0] )
      {
        v53 = -1i64;
        do
          ++v53;
        while ( v52->_Mypair._Myval2._Bx._Buf[v53] );
      }
      else
      {
        v53 = 0i64;
      }
      std::string::assign(&_Str, v52->_Mypair._Myval2._Bx._Buf, v53);
      globalShaderSettings->modelFXSettings[1].fxCentre[0].y = std::stof(&_Str, v54);
      std::string::~string(&_Str);
    }
    v55 = line->_Mypair._Myval2._Myfirst;
    v56 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v56->_Mypair._Myval2._Myres >= 0x10 )
      v56 = (std::string *)v56->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v56->_Mypair._Myval2._Bx._Buf, "LIGHTNORMSPEED") )
    {
      v57 = &v55[++v5];
      if ( v57->_Mypair._Myval2._Myres >= 0x10 )
        v57 = (std::string *)v57->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v57->_Mypair._Myval2._Bx._Buf[0] )
      {
        v58 = -1i64;
        do
          ++v58;
        while ( v57->_Mypair._Myval2._Bx._Buf[v58] );
      }
      else
      {
        v58 = 0i64;
      }
      std::string::assign(&_Str, v57->_Mypair._Myval2._Bx._Buf, v58);
      globalShaderSettings->modelFXSettings[1].fxSpeed[0] = std::stof(&_Str, v59);
      std::string::~string(&_Str);
    }
    v60 = line->_Mypair._Myval2._Myfirst;
    v61 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v61->_Mypair._Myval2._Myres >= 0x10 )
      v61 = (std::string *)v61->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v61->_Mypair._Myval2._Bx._Buf, "LIGHTCAMVECCENTRE") )
    {
      v62 = &v60[v5 + 1];
      if ( v62->_Mypair._Myval2._Myres >= 0x10 )
        v62 = (std::string *)v62->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v62->_Mypair._Myval2._Bx._Buf[0] )
      {
        v63 = -1i64;
        do
          ++v63;
        while ( v62->_Mypair._Myval2._Bx._Buf[v63] );
      }
      else
      {
        v63 = 0i64;
      }
      std::string::assign(&_Str, v62->_Mypair._Myval2._Bx._Buf, v63);
      globalShaderSettings->modelFXSettings[1].fxCentre[1].x = std::stof(&_Str, v64);
      std::string::~string(&_Str);
      v5 += 2;
      v65 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v65->_Mypair._Myval2._Myres >= 0x10 )
        v65 = (std::string *)v65->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v65->_Mypair._Myval2._Bx._Buf[0] )
      {
        v66 = -1i64;
        do
          ++v66;
        while ( v65->_Mypair._Myval2._Bx._Buf[v66] );
      }
      else
      {
        v66 = 0i64;
      }
      std::string::assign(&_Str, v65->_Mypair._Myval2._Bx._Buf, v66);
      globalShaderSettings->modelFXSettings[1].fxCentre[1].y = std::stof(&_Str, v67);
      std::string::~string(&_Str);
    }
    v68 = line->_Mypair._Myval2._Myfirst;
    v69 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v69->_Mypair._Myval2._Myres >= 0x10 )
      v69 = (std::string *)v69->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v69->_Mypair._Myval2._Bx._Buf, "LIGHTCAMVECSPEED") )
    {
      v70 = &v68[++v5];
      if ( v70->_Mypair._Myval2._Myres >= 0x10 )
        v70 = (std::string *)v70->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v70->_Mypair._Myval2._Bx._Buf[0] )
      {
        v71 = -1i64;
        do
          ++v71;
        while ( v70->_Mypair._Myval2._Bx._Buf[v71] );
      }
      else
      {
        v71 = 0i64;
      }
      std::string::assign(&_Str, v70->_Mypair._Myval2._Bx._Buf, v71);
      globalShaderSettings->modelFXSettings[1].fxSpeed[1] = std::stof(&_Str, v72);
      std::string::~string(&_Str);
    }
    ++v5;
  }
}

void __fastcall AppMain::processLightData(
        AppMain *this,
        const std::vector<std::string> *line,
        ShaderFxHelper::ShaderFxLightSetting *assetData)
{
  int v5; // esi
  std::string *i; // r9
  std::string *Ptr; // rcx
  std::string *v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  std::string *v11; // rdx
  __int64 v12; // rcx
  char v13; // al
  std::string *v14; // rdx
  __int64 v15; // rcx
  char v16; // al
  std::string *Myfirst; // rbx
  std::string *v18; // rcx
  std::string *v19; // rdx
  unsigned __int64 v20; // r8
  std::string *p_Str; // rbx
  float v22; // xmm6_4
  char *v23; // rcx
  char *v24; // rax
  std::string *v25; // rdx
  unsigned __int64 v26; // r8
  std::string *v27; // rbx
  float v28; // xmm6_4
  char *v29; // rcx
  char *v30; // rax
  std::string *v31; // rdx
  unsigned __int64 v32; // r8
  std::string *v33; // rbx
  float v34; // xmm6_4
  char *v35; // rcx
  char *v36; // rax
  std::string *v37; // rbx
  std::string *v38; // rcx
  std::string *v39; // rdx
  unsigned __int64 v40; // r8
  std::string *v41; // rbx
  float v42; // xmm6_4
  char *v43; // rcx
  char *v44; // rax
  std::string *v45; // rdx
  unsigned __int64 v46; // r8
  std::string *v47; // rbx
  float v48; // xmm6_4
  std::string *v49; // rdx
  unsigned __int64 v50; // r8
  std::string *v51; // rbx
  float v52; // xmm6_4
  std::string *v53; // r8
  std::string *v54; // rdx
  __int64 v55; // rcx
  char v56; // al
  __int64 v57; // rcx
  char v58; // al
  std::string *v59; // rdx
  unsigned __int64 v60; // r8
  std::string *v61; // rbx
  float v62; // xmm6_4
  std::string *v63; // rdx
  unsigned __int64 v64; // r8
  unsigned __int64 *v65; // rdx
  std::string *v66; // rdx
  unsigned __int64 v67; // r8
  unsigned __int64 *v68; // rdx
  std::string *v69; // rbx
  std::string *v70; // rcx
  std::string *v71; // rdx
  unsigned __int64 v72; // r8
  unsigned __int64 *v73; // rdx
  std::string *v74; // rbx
  std::string *v75; // rcx
  std::string *v76; // rdx
  unsigned __int64 v77; // r8
  unsigned __int64 *v78; // rdx
  std::string *v79; // rbx
  std::string *v80; // rcx
  std::string *v81; // rdx
  unsigned __int64 v82; // r8
  unsigned __int64 *v83; // rdx
  std::string *v84; // rbx
  std::string *v85; // rcx
  std::string *v86; // rdx
  unsigned __int64 v87; // r8
  unsigned __int64 *v88; // rdx
  std::string *v89; // rbx
  std::string *v90; // rcx
  std::string *v91; // rdx
  unsigned __int64 v92; // r8
  unsigned __int64 *v93; // rdx
  std::string *v94; // rbx
  std::string *v95; // rcx
  std::string *v96; // rdx
  unsigned __int64 v97; // r8
  unsigned __int64 *v98; // rdx
  int v99; // er8
  std::string *v100; // rbx
  std::string *v101; // rcx
  std::string *v102; // rdx
  unsigned __int64 v103; // r8
  unsigned __int64 *v104; // rdx
  int v105; // er8
  std::string *v106; // rdi
  std::string *v107; // rbx
  std::string *v108; // rcx
  std::string *v109; // rdx
  unsigned __int64 v110; // r8
  unsigned __int64 *v111; // rdx
  std::string *v112; // rdx
  unsigned __int64 v113; // r8
  unsigned __int64 *v114; // rdx
  std::string *v115; // rdx
  unsigned __int64 v116; // r8
  unsigned __int64 *v117; // rdx
  std::string *v118; // rdi
  std::string *v119; // rbx
  std::string *v120; // rcx
  std::string *v121; // rdx
  unsigned __int64 v122; // r8
  unsigned __int64 *v123; // rdx
  std::string *v124; // rdi
  std::string *v125; // rcx
  std::string *v126; // rbx
  unsigned __int64 v127; // r8
  unsigned __int64 *v128; // rdx
  std::string *v129; // rdi
  std::string *v130; // rbx
  std::string *v131; // rcx
  std::string *v132; // rdx
  unsigned __int64 v133; // r8
  unsigned __int64 *v134; // rdx
  std::string *v135; // rdi
  std::string *v136; // rcx
  std::string *v137; // rbx
  unsigned __int64 v138; // r8
  unsigned __int64 *v139; // rdx
  std::string *v140; // rdi
  std::string *v141; // rcx
  std::string *v142; // rbx
  unsigned __int64 v143; // r8
  unsigned __int64 *v144; // rdx
  std::string *v145; // rbx
  unsigned __int64 v146; // r8
  unsigned __int64 *v147; // rdx
  std::string *v148; // rbx
  unsigned __int64 v149; // r8
  unsigned __int64 *v150; // rdx
  std::string *v151; // rdi
  std::string *v152; // rcx
  std::string *v153; // rbx
  unsigned __int64 v154; // r8
  unsigned __int64 *v155; // rdx
  std::string *v156; // rdi
  std::string *v157; // rbx
  std::string *v158; // rcx
  std::string *v159; // rbx
  unsigned __int64 v160; // r8
  unsigned __int64 *v161; // rdx
  std::string *v162; // rdi
  std::string *v163; // rbx
  std::string *v164; // rcx
  std::string *v165; // rbx
  unsigned __int64 v166; // r8
  unsigned __int64 *v167; // rdx
  std::string *v168; // rdi
  std::string *v169; // rbx
  std::string *v170; // rcx
  std::string *v171; // rbx
  unsigned __int64 v172; // r8
  unsigned __int64 *v173; // rdx
  std::string *v174; // rdi
  std::string *v175; // rbx
  std::string *v176; // rcx
  std::string *v177; // rbx
  unsigned __int64 v178; // r8
  unsigned __int64 *v179; // rdx
  std::string *v180; // rdi
  std::string *v181; // rcx
  std::string *v182; // rbx
  unsigned __int64 v183; // r8
  unsigned __int64 *v184; // rdx
  std::string *v185; // rbx
  unsigned __int64 v186; // r8
  unsigned __int64 *v187; // rdx
  std::string *v188; // rbx
  unsigned __int64 v189; // r8
  unsigned __int64 *v190; // rdx
  std::string *v191; // rdi
  std::string *v192; // rcx
  std::string *v193; // rbx
  unsigned __int64 v194; // r8
  unsigned __int64 *v195; // rdx
  std::string *v196; // rdi
  std::string *v197; // rcx
  std::string *v198; // rbx
  unsigned __int64 v199; // r8
  unsigned __int64 *v200; // rdx
  std::string *v201; // rdi
  std::string *v202; // rcx
  std::string *v203; // rbx
  unsigned __int64 v204; // r8
  unsigned __int64 *v205; // rdx
  std::string *v206; // rdi
  std::string *v207; // rcx
  std::string *v208; // rbx
  unsigned __int64 v209; // r8
  unsigned __int64 *v210; // rdx
  std::string *v211; // rdi
  std::string *v212; // rcx
  std::string *v213; // rbx
  unsigned __int64 v214; // r8
  unsigned __int64 *v215; // rdx
  std::string *v216; // rdi
  std::string *v217; // rcx
  std::string *v218; // rbx
  unsigned __int64 v219; // r8
  unsigned __int64 *v220; // rdx
  int v221; // er8
  std::string *v222; // rdi
  std::string *v223; // rcx
  std::string *v224; // rbx
  unsigned __int64 v225; // r8
  unsigned __int64 *v226; // rdx
  int v227; // er8
  std::string *v228; // rdi
  std::string *v229; // rcx
  std::string *v230; // rbx
  unsigned __int64 v231; // r8
  unsigned __int64 *v232; // rdx
  int v233; // er8
  char *end_ptr; // [rsp+28h] [rbp-89h] BYREF
  char *v235; // [rsp+30h] [rbp-81h] BYREF
  char *v236; // [rsp+38h] [rbp-79h] BYREF
  char *v237; // [rsp+40h] [rbp-71h] BYREF
  char *v238; // [rsp+48h] [rbp-69h] BYREF
  char *v239; // [rsp+50h] [rbp-61h] BYREF
  char *v240[2]; // [rsp+58h] [rbp-59h] BYREF
  std::string _Str; // [rsp+68h] [rbp-49h] BYREF

  v240[1] = (char *)-2i64;
  v5 = 0;
  for ( i = line->_Mypair._Myval2._Myfirst;
        v5 < (unsigned __int64)(line->_Mypair._Myval2._Mylast - line->_Mypair._Myval2._Myfirst);
        i = line->_Mypair._Myval2._Myfirst )
  {
    Ptr = &i[v5];
    if ( Ptr->_Mypair._Myval2._Myres >= 0x10 )
      Ptr = (std::string *)Ptr->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(Ptr->_Mypair._Myval2._Bx._Buf, "DIRECTIONAL") )
    {
      assetData->type = 1;
      ++v5;
    }
    v8 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v8->_Mypair._Myval2._Myres >= 0x10 )
      v8 = (std::string *)v8->_Mypair._Myval2._Bx._Ptr;
    v9 = 0i64;
    while ( 1 )
    {
      v10 = v8->_Mypair._Myval2._Bx._Buf[v9++];
      if ( v10 != aSpot[v9 - 1] )
        break;
      if ( v9 == 5 )
      {
        assetData->type = 2;
        ++v5;
        break;
      }
    }
    v11 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v11->_Mypair._Myval2._Myres >= 0x10 )
      v11 = (std::string *)v11->_Mypair._Myval2._Bx._Ptr;
    v12 = 0i64;
    while ( 1 )
    {
      v13 = v11->_Mypair._Myval2._Bx._Buf[v12++];
      if ( v13 != aPoint[v12 - 1] )
        break;
      if ( v12 == 6 )
      {
        assetData->type = 0;
        ++v5;
        break;
      }
    }
    v14 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v14->_Mypair._Myval2._Myres >= 0x10 )
      v14 = (std::string *)v14->_Mypair._Myval2._Bx._Ptr;
    v15 = 0i64;
    while ( 1 )
    {
      v16 = v14->_Mypair._Myval2._Bx._Buf[v15++];
      if ( v16 != aAmbient[v15 - 1] )
        break;
      if ( v15 == 8 )
      {
        assetData->type = 3;
        ++v5;
        break;
      }
    }
    Myfirst = line->_Mypair._Myval2._Myfirst;
    v18 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v18->_Mypair._Myval2._Myres >= 0x10 )
      v18 = (std::string *)v18->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v18->_Mypair._Myval2._Bx._Buf, "DIRECTION") )
    {
      v19 = &Myfirst[v5 + 1];
      if ( v19->_Mypair._Myval2._Myres >= 0x10 )
        v19 = (std::string *)v19->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v19->_Mypair._Myval2._Bx._Buf[0] )
      {
        v20 = -1i64;
        do
          ++v20;
        while ( v19->_Mypair._Myval2._Bx._Buf[v20] );
      }
      else
      {
        v20 = 0i64;
      }
      std::string::assign(&_Str, v19->_Mypair._Myval2._Bx._Buf, v20);
      p_Str = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        p_Str = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v22 = strtof(p_Str->_Mypair._Myval2._Bx._Buf, &end_ptr);
      if ( p_Str == (std::string *)end_ptr )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->direction[0] = v22;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v23 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v24 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v24 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v24) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v24) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v23 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v23);
      }
      v25 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
      if ( v25->_Mypair._Myval2._Myres >= 0x10 )
        v25 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v25->_Mypair._Myval2._Bx._Buf[0] )
      {
        v26 = -1i64;
        do
          ++v26;
        while ( v25->_Mypair._Myval2._Bx._Buf[v26] );
      }
      else
      {
        v26 = 0i64;
      }
      std::string::assign(&_Str, v25->_Mypair._Myval2._Bx._Buf, v26);
      v27 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v27 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v28 = strtof(v27->_Mypair._Myval2._Bx._Buf, &v235);
      if ( v27 == (std::string *)v235 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->direction[1] = v28;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v29 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v30 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v30 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v30) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v30) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v29 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v29);
      }
      v5 += 3;
      v31 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v31->_Mypair._Myval2._Myres >= 0x10 )
        v31 = (std::string *)v31->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v31->_Mypair._Myval2._Bx._Buf[0] )
      {
        v32 = -1i64;
        do
          ++v32;
        while ( v31->_Mypair._Myval2._Bx._Buf[v32] );
      }
      else
      {
        v32 = 0i64;
      }
      std::string::assign(&_Str, v31->_Mypair._Myval2._Bx._Buf, v32);
      v33 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v33 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v34 = strtof(v33->_Mypair._Myval2._Bx._Buf, &v236);
      if ( v33 == (std::string *)v236 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->direction[2] = v34;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v35 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v36 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v36 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v36) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v36) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v35 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v35);
      }
    }
    v37 = line->_Mypair._Myval2._Myfirst;
    v38 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v38->_Mypair._Myval2._Myres >= 0x10 )
      v38 = (std::string *)v38->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v38->_Mypair._Myval2._Bx._Buf, "POSITION") )
    {
      v39 = &v37[v5 + 1];
      if ( v39->_Mypair._Myval2._Myres >= 0x10 )
        v39 = (std::string *)v39->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v39->_Mypair._Myval2._Bx._Buf[0] )
      {
        v40 = -1i64;
        do
          ++v40;
        while ( v39->_Mypair._Myval2._Bx._Buf[v40] );
      }
      else
      {
        v40 = 0i64;
      }
      std::string::assign(&_Str, v39->_Mypair._Myval2._Bx._Buf, v40);
      v41 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v41 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v42 = strtof(v41->_Mypair._Myval2._Bx._Buf, &v237);
      if ( v41 == (std::string *)v237 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->position[0] = v42;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
      {
        v43 = _Str._Mypair._Myval2._Bx._Ptr;
        if ( _Str._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (_Str._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v44 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
          if ( v44 >= _Str._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v44) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(_Str._Mypair._Myval2._Bx._Ptr - v44) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v43 = (char *)*((_QWORD *)_Str._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v43);
      }
      v45 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
      if ( v45->_Mypair._Myval2._Myres >= 0x10 )
        v45 = (std::string *)v45->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v45->_Mypair._Myval2._Bx._Buf[0] )
      {
        v46 = -1i64;
        do
          ++v46;
        while ( v45->_Mypair._Myval2._Bx._Buf[v46] );
      }
      else
      {
        v46 = 0i64;
      }
      std::string::assign(&_Str, v45->_Mypair._Myval2._Bx._Buf, v46);
      v47 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v47 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v48 = strtof(v47->_Mypair._Myval2._Bx._Buf, &v238);
      if ( v47 == (std::string *)v238 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->position[1] = v48;
      std::string::~string(&_Str);
      v5 += 3;
      v49 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v49->_Mypair._Myval2._Myres >= 0x10 )
        v49 = (std::string *)v49->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v49->_Mypair._Myval2._Bx._Buf[0] )
      {
        v50 = -1i64;
        do
          ++v50;
        while ( v49->_Mypair._Myval2._Bx._Buf[v50] );
      }
      else
      {
        v50 = 0i64;
      }
      std::string::assign(&_Str, v49->_Mypair._Myval2._Bx._Buf, v50);
      v51 = &_Str;
      if ( _Str._Mypair._Myval2._Myres >= 0x10 )
        v51 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v52 = strtof(v51->_Mypair._Myval2._Bx._Buf, &v239);
      if ( v51 == (std::string *)v239 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      assetData->position[2] = v52;
      std::string::~string(&_Str);
    }
    v53 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v53->_Mypair._Myval2._Myres < 0x10 )
      v54 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v54 = (std::string *)v53->_Mypair._Myval2._Bx._Ptr;
    v55 = 0i64;
    while ( 1 )
    {
      v56 = v54->_Mypair._Myval2._Bx._Buf[v55++];
      if ( v56 != aColor_0[v55 - 1] )
        break;
      if ( v55 == 6 )
      {
LABEL_135:
        v59 = &line->_Mypair._Myval2._Myfirst[v5 + 1];
        if ( v59->_Mypair._Myval2._Myres >= 0x10 )
          v59 = (std::string *)v59->_Mypair._Myval2._Bx._Ptr;
        _Str._Mypair._Myval2._Myres = 15i64;
        _Str._Mypair._Myval2._Mysize = 0i64;
        _Str._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( v59->_Mypair._Myval2._Bx._Buf[0] )
        {
          v60 = -1i64;
          do
            ++v60;
          while ( v59->_Mypair._Myval2._Bx._Buf[v60] );
        }
        else
        {
          v60 = 0i64;
        }
        std::string::assign(&_Str, v59->_Mypair._Myval2._Bx._Buf, v60);
        v61 = &_Str;
        if ( _Str._Mypair._Myval2._Myres >= 0x10 )
          v61 = (std::string *)_Str._Mypair._Myval2._Bx._Ptr;
        *errno() = 0;
        v62 = strtof(v61->_Mypair._Myval2._Bx._Buf, v240);
        if ( v61 == (std::string *)v240[0] )
          std::_Xinvalid_argument("invalid stof argument");
        if ( *errno() == 34 )
          std::_Xout_of_range("stof argument out of range");
        assetData->colour[0] = v62;
        std::string::~string(&_Str);
        v63 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
        if ( v63->_Mypair._Myval2._Myres >= 0x10 )
          v63 = (std::string *)v63->_Mypair._Myval2._Bx._Ptr;
        _Str._Mypair._Myval2._Myres = 15i64;
        _Str._Mypair._Myval2._Mysize = 0i64;
        _Str._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( v63->_Mypair._Myval2._Bx._Buf[0] )
        {
          v64 = -1i64;
          do
            ++v64;
          while ( v63->_Mypair._Myval2._Bx._Buf[v64] );
        }
        else
        {
          v64 = 0i64;
        }
        std::string::assign(&_Str, v63->_Mypair._Myval2._Bx._Buf, v64);
        assetData->colour[1] = std::stof(&_Str, v65);
        std::string::~string(&_Str);
        v5 += 3;
        v66 = &line->_Mypair._Myval2._Myfirst[v5];
        if ( v66->_Mypair._Myval2._Myres >= 0x10 )
          v66 = (std::string *)v66->_Mypair._Myval2._Bx._Ptr;
        _Str._Mypair._Myval2._Myres = 15i64;
        _Str._Mypair._Myval2._Mysize = 0i64;
        _Str._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( v66->_Mypair._Myval2._Bx._Buf[0] )
        {
          v67 = -1i64;
          do
            ++v67;
          while ( v66->_Mypair._Myval2._Bx._Buf[v67] );
        }
        else
        {
          v67 = 0i64;
        }
        std::string::assign(&_Str, v66->_Mypair._Myval2._Bx._Buf, v67);
        assetData->colour[2] = std::stof(&_Str, v68);
        std::string::~string(&_Str);
        goto LABEL_158;
      }
    }
    if ( v53->_Mypair._Myval2._Myres >= 0x10 )
      v53 = (std::string *)v53->_Mypair._Myval2._Bx._Ptr;
    v57 = 0i64;
    while ( 1 )
    {
      v58 = v53->_Mypair._Myval2._Bx._Buf[v57++];
      if ( v58 != aColour[v57 - 1] )
        break;
      if ( v57 == 7 )
        goto LABEL_135;
    }
LABEL_158:
    v69 = line->_Mypair._Myval2._Myfirst;
    v70 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v70->_Mypair._Myval2._Myres >= 0x10 )
      v70 = (std::string *)v70->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v70->_Mypair._Myval2._Bx._Buf, "INTENSITY") )
    {
      v71 = &v69[++v5];
      if ( v71->_Mypair._Myval2._Myres >= 0x10 )
        v71 = (std::string *)v71->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v71->_Mypair._Myval2._Bx._Buf[0] )
      {
        v72 = -1i64;
        do
          ++v72;
        while ( v71->_Mypair._Myval2._Bx._Buf[v72] );
      }
      else
      {
        v72 = 0i64;
      }
      std::string::assign(&_Str, v71->_Mypair._Myval2._Bx._Buf, v72);
      assetData->intensity = std::stof(&_Str, v73);
      std::string::~string(&_Str);
    }
    v74 = line->_Mypair._Myval2._Myfirst;
    v75 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v75->_Mypair._Myval2._Myres >= 0x10 )
      v75 = (std::string *)v75->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v75->_Mypair._Myval2._Bx._Buf, "CONEANGLE") )
    {
      v76 = &v74[++v5];
      if ( v76->_Mypair._Myval2._Myres >= 0x10 )
        v76 = (std::string *)v76->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v76->_Mypair._Myval2._Bx._Buf[0] )
      {
        v77 = -1i64;
        do
          ++v77;
        while ( v76->_Mypair._Myval2._Bx._Buf[v77] );
      }
      else
      {
        v77 = 0i64;
      }
      std::string::assign(&_Str, v76->_Mypair._Myval2._Bx._Buf, v77);
      assetData->coneAngleRad = std::stof(&_Str, v78);
      std::string::~string(&_Str);
      assetData->coneAngleRad = (float)(assetData->coneAngleRad * 3.1415927) / 180.0;
    }
    v79 = line->_Mypair._Myval2._Myfirst;
    v80 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v80->_Mypair._Myval2._Myres >= 0x10 )
      v80 = (std::string *)v80->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v80->_Mypair._Myval2._Bx._Buf, "PENUMBRA") )
    {
      v81 = &v79[++v5];
      if ( v81->_Mypair._Myval2._Myres >= 0x10 )
        v81 = (std::string *)v81->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v81->_Mypair._Myval2._Bx._Buf[0] )
      {
        v82 = -1i64;
        do
          ++v82;
        while ( v81->_Mypair._Myval2._Bx._Buf[v82] );
      }
      else
      {
        v82 = 0i64;
      }
      std::string::assign(&_Str, v81->_Mypair._Myval2._Bx._Buf, v82);
      assetData->penumbraRad = std::stof(&_Str, v83);
      std::string::~string(&_Str);
      assetData->penumbraRad = (float)(assetData->penumbraRad * 3.1415927) / 180.0;
    }
    v84 = line->_Mypair._Myval2._Myfirst;
    v85 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v85->_Mypair._Myval2._Myres >= 0x10 )
      v85 = (std::string *)v85->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v85->_Mypair._Myval2._Bx._Buf, "EMITSPECULAR") )
    {
      v86 = &v84[++v5];
      if ( v86->_Mypair._Myval2._Myres >= 0x10 )
        v86 = (std::string *)v86->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v86->_Mypair._Myval2._Bx._Buf[0] )
      {
        v87 = -1i64;
        do
          ++v87;
        while ( v86->_Mypair._Myval2._Bx._Buf[v87] );
      }
      else
      {
        v87 = 0i64;
      }
      std::string::assign(&_Str, v86->_Mypair._Myval2._Bx._Buf, v87);
      assetData->emitSpecular = std::stof(&_Str, v88) != 0.0;
      std::string::~string(&_Str);
    }
    v89 = line->_Mypair._Myval2._Myfirst;
    v90 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v90->_Mypair._Myval2._Myres >= 0x10 )
      v90 = (std::string *)v90->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v90->_Mypair._Myval2._Bx._Buf, "EMITDIFFUSE") )
    {
      v91 = &v89[++v5];
      if ( v91->_Mypair._Myval2._Myres >= 0x10 )
        v91 = (std::string *)v91->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v91->_Mypair._Myval2._Bx._Buf[0] )
      {
        v92 = -1i64;
        do
          ++v92;
        while ( v91->_Mypair._Myval2._Bx._Buf[v92] );
      }
      else
      {
        v92 = 0i64;
      }
      std::string::assign(&_Str, v91->_Mypair._Myval2._Bx._Buf, v92);
      assetData->emitDiffuse = std::stof(&_Str, v93) != 0.0;
      std::string::~string(&_Str);
    }
    v94 = line->_Mypair._Myval2._Myfirst;
    v95 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v95->_Mypair._Myval2._Myres >= 0x10 )
      v95 = (std::string *)v95->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v95->_Mypair._Myval2._Bx._Buf, "DECAYRATE") )
    {
      v96 = &v94[++v5];
      if ( v96->_Mypair._Myval2._Myres >= 0x10 )
        v96 = (std::string *)v96->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v96->_Mypair._Myval2._Bx._Buf[0] )
      {
        v97 = -1i64;
        do
          ++v97;
        while ( v96->_Mypair._Myval2._Bx._Buf[v97] );
      }
      else
      {
        v97 = 0i64;
      }
      std::string::assign(&_Str, v96->_Mypair._Myval2._Bx._Buf, v97);
      assetData->decayRate = std::stoi(&_Str, v98, v99);
      std::string::~string(&_Str);
    }
    v100 = line->_Mypair._Myval2._Myfirst;
    v101 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v101->_Mypair._Myval2._Myres >= 0x10 )
      v101 = (std::string *)v101->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v101->_Mypair._Myval2._Bx._Buf, "CASTSHADOWS") )
    {
      v102 = &v100[++v5];
      if ( v102->_Mypair._Myval2._Myres >= 0x10 )
        v102 = (std::string *)v102->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v102->_Mypair._Myval2._Bx._Buf[0] )
      {
        v103 = -1i64;
        do
          ++v103;
        while ( v102->_Mypair._Myval2._Bx._Buf[v103] );
      }
      else
      {
        v103 = 0i64;
      }
      std::string::assign(&_Str, v102->_Mypair._Myval2._Bx._Buf, v103);
      assetData->castShadow = std::stoi(&_Str, v104, v105) != 0;
      std::string::~string(&_Str);
    }
    v106 = line->_Mypair._Myval2._Myfirst;
    v107 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v107->_Mypair._Myval2._Myres < 0x10 )
      v108 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v108 = (std::string *)v107->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v108->_Mypair._Myval2._Bx._Buf, "GROUNDSHADOWCOLOR") )
      goto LABEL_235;
    if ( v107->_Mypair._Myval2._Myres >= 0x10 )
      v107 = (std::string *)v107->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v107->_Mypair._Myval2._Bx._Buf, "SHADOWCOLOR") )
    {
LABEL_235:
      v109 = &v106[v5 + 1];
      if ( v109->_Mypair._Myval2._Myres >= 0x10 )
        v109 = (std::string *)v109->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v109->_Mypair._Myval2._Bx._Buf[0] )
      {
        v110 = -1i64;
        do
          ++v110;
        while ( v109->_Mypair._Myval2._Bx._Buf[v110] );
      }
      else
      {
        v110 = 0i64;
      }
      std::string::assign(&_Str, v109->_Mypair._Myval2._Bx._Buf, v110);
      assetData->groundShadowColour[0] = std::stof(&_Str, v111);
      std::string::~string(&_Str);
      v112 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
      if ( v112->_Mypair._Myval2._Myres >= 0x10 )
        v112 = (std::string *)v112->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v112->_Mypair._Myval2._Bx._Buf[0] )
      {
        v113 = -1i64;
        do
          ++v113;
        while ( v112->_Mypair._Myval2._Bx._Buf[v113] );
      }
      else
      {
        v113 = 0i64;
      }
      std::string::assign(&_Str, v112->_Mypair._Myval2._Bx._Buf, v113);
      assetData->groundShadowColour[1] = std::stof(&_Str, v114);
      std::string::~string(&_Str);
      v5 += 3;
      v115 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v115->_Mypair._Myval2._Myres >= 0x10 )
        v115 = (std::string *)v115->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v115->_Mypair._Myval2._Bx._Buf[0] )
      {
        v116 = -1i64;
        do
          ++v116;
        while ( v115->_Mypair._Myval2._Bx._Buf[v116] );
      }
      else
      {
        v116 = 0i64;
      }
      std::string::assign(&_Str, v115->_Mypair._Myval2._Bx._Buf, v116);
      assetData->groundShadowColour[2] = std::stof(&_Str, v117);
      std::string::~string(&_Str);
    }
    v118 = line->_Mypair._Myval2._Myfirst;
    v119 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v119->_Mypair._Myval2._Myres < 0x10 )
      v120 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v120 = (std::string *)v119->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v120->_Mypair._Myval2._Bx._Buf, "GROUNDSHADOWCOLINTENSITY") )
      goto LABEL_261;
    if ( v119->_Mypair._Myval2._Myres >= 0x10 )
      v119 = (std::string *)v119->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v119->_Mypair._Myval2._Bx._Buf, "SHADOWINTENSITY") )
    {
LABEL_261:
      v121 = &v118[++v5];
      if ( v121->_Mypair._Myval2._Myres >= 0x10 )
        v121 = (std::string *)v121->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v121->_Mypair._Myval2._Bx._Buf[0] )
      {
        v122 = -1i64;
        do
          ++v122;
        while ( v121->_Mypair._Myval2._Bx._Buf[v122] );
      }
      else
      {
        v122 = 0i64;
      }
      std::string::assign(&_Str, v121->_Mypair._Myval2._Bx._Buf, v122);
      assetData->groundShadowIntensity = std::stof(&_Str, v123);
      std::string::~string(&_Str);
    }
    v124 = line->_Mypair._Myval2._Myfirst;
    v125 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v125->_Mypair._Myval2._Myres >= 0x10 )
      v125 = (std::string *)v125->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v125->_Mypair._Myval2._Bx._Buf, "GROUNDSHADOWBIAS") )
    {
      v126 = &v124[++v5];
      if ( v126->_Mypair._Myval2._Myres >= 0x10 )
        v126 = (std::string *)v126->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v126->_Mypair._Myval2._Bx._Buf[0] )
      {
        v127 = -1i64;
        do
          ++v127;
        while ( v126->_Mypair._Myval2._Bx._Buf[v127] );
      }
      else
      {
        v127 = 0i64;
      }
      std::string::assign(&_Str, v126->_Mypair._Myval2._Bx._Buf, v127);
      assetData->groundShadowBias = std::stof(&_Str, v128);
      std::string::~string(&_Str);
    }
    v129 = line->_Mypair._Myval2._Myfirst;
    v130 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v130->_Mypair._Myval2._Myres < 0x10 )
      v131 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v131 = (std::string *)v130->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v131->_Mypair._Myval2._Bx._Buf, "GROUNDSHADOWMAXSTR") )
      goto LABEL_285;
    if ( v130->_Mypair._Myval2._Myres >= 0x10 )
      v130 = (std::string *)v130->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v130->_Mypair._Myval2._Bx._Buf, "SHADOWMAXSTR") )
    {
LABEL_285:
      v132 = &v129[++v5];
      if ( v132->_Mypair._Myval2._Myres >= 0x10 )
        v132 = (std::string *)v132->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v132->_Mypair._Myval2._Bx._Buf[0] )
      {
        v133 = -1i64;
        do
          ++v133;
        while ( v132->_Mypair._Myval2._Bx._Buf[v133] );
      }
      else
      {
        v133 = 0i64;
      }
      std::string::assign(&_Str, v132->_Mypair._Myval2._Bx._Buf, v133);
      assetData->groundShadowMaxStrength = std::stof(&_Str, v134);
      std::string::~string(&_Str);
    }
    v135 = line->_Mypair._Myval2._Myfirst;
    v136 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v136->_Mypair._Myval2._Myres >= 0x10 )
      v136 = (std::string *)v136->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v136->_Mypair._Myval2._Bx._Buf, "GROUNDSHADOWMAX") )
    {
      v137 = &v135[++v5];
      if ( v137->_Mypair._Myval2._Myres >= 0x10 )
        v137 = (std::string *)v137->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v137->_Mypair._Myval2._Bx._Buf[0] )
      {
        v138 = -1i64;
        do
          ++v138;
        while ( v137->_Mypair._Myval2._Bx._Buf[v138] );
      }
      else
      {
        v138 = 0i64;
      }
      std::string::assign(&_Str, v137->_Mypair._Myval2._Bx._Buf, v138);
      assetData->groundShadowVisibility = std::stof(&_Str, v139);
      std::string::~string(&_Str);
    }
    v140 = line->_Mypair._Myval2._Myfirst;
    v141 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v141->_Mypair._Myval2._Myres >= 0x10 )
      v141 = (std::string *)v141->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v141->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWCOLOR") )
    {
      v142 = &v140[v5 + 1];
      if ( v142->_Mypair._Myval2._Myres >= 0x10 )
        v142 = (std::string *)v142->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v142->_Mypair._Myval2._Bx._Buf[0] )
      {
        v143 = -1i64;
        do
          ++v143;
        while ( v142->_Mypair._Myval2._Bx._Buf[v143] );
      }
      else
      {
        v143 = 0i64;
      }
      std::string::assign(&_Str, v142->_Mypair._Myval2._Bx._Buf, v143);
      assetData->bodySelfShadowColour[0] = std::stof(&_Str, v144);
      std::string::~string(&_Str);
      v145 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
      if ( v145->_Mypair._Myval2._Myres >= 0x10 )
        v145 = (std::string *)v145->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v145->_Mypair._Myval2._Bx._Buf[0] )
      {
        v146 = -1i64;
        do
          ++v146;
        while ( v145->_Mypair._Myval2._Bx._Buf[v146] );
      }
      else
      {
        v146 = 0i64;
      }
      std::string::assign(&_Str, v145->_Mypair._Myval2._Bx._Buf, v146);
      assetData->bodySelfShadowColour[1] = std::stof(&_Str, v147);
      std::string::~string(&_Str);
      v5 += 3;
      v148 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v148->_Mypair._Myval2._Myres >= 0x10 )
        v148 = (std::string *)v148->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v148->_Mypair._Myval2._Bx._Buf[0] )
      {
        v149 = -1i64;
        do
          ++v149;
        while ( v148->_Mypair._Myval2._Bx._Buf[v149] );
      }
      else
      {
        v149 = 0i64;
      }
      std::string::assign(&_Str, v148->_Mypair._Myval2._Bx._Buf, v149);
      assetData->bodySelfShadowColour[2] = std::stof(&_Str, v150);
      std::string::~string(&_Str);
    }
    v151 = line->_Mypair._Myval2._Myfirst;
    v152 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v152->_Mypair._Myval2._Myres >= 0x10 )
      v152 = (std::string *)v152->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v152->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWCOLINTENSITY") )
    {
      v153 = &v151[++v5];
      if ( v153->_Mypair._Myval2._Myres >= 0x10 )
        v153 = (std::string *)v153->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v153->_Mypair._Myval2._Bx._Buf[0] )
      {
        v154 = -1i64;
        do
          ++v154;
        while ( v153->_Mypair._Myval2._Bx._Buf[v154] );
      }
      else
      {
        v154 = 0i64;
      }
      std::string::assign(&_Str, v153->_Mypair._Myval2._Bx._Buf, v154);
      assetData->bodySelfShadowIntensity = std::stof(&_Str, v155);
      std::string::~string(&_Str);
    }
    v156 = line->_Mypair._Myval2._Myfirst;
    v157 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v157->_Mypair._Myval2._Myres < 0x10 )
      v158 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v158 = (std::string *)v157->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v158->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWBIAS") )
      goto LABEL_341;
    if ( v157->_Mypair._Myval2._Myres >= 0x10 )
      v157 = (std::string *)v157->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v157->_Mypair._Myval2._Bx._Buf, "SELFSHADOWBIAS") )
    {
LABEL_341:
      v159 = &v156[++v5];
      if ( v159->_Mypair._Myval2._Myres >= 0x10 )
        v159 = (std::string *)v159->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v159->_Mypair._Myval2._Bx._Buf[0] )
      {
        v160 = -1i64;
        do
          ++v160;
        while ( v159->_Mypair._Myval2._Bx._Buf[v160] );
      }
      else
      {
        v160 = 0i64;
      }
      std::string::assign(&_Str, v159->_Mypair._Myval2._Bx._Buf, v160);
      assetData->bodySelfShadowBias = std::stof(&_Str, v161);
      std::string::~string(&_Str);
    }
    v162 = line->_Mypair._Myval2._Myfirst;
    v163 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v163->_Mypair._Myval2._Myres < 0x10 )
      v164 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v164 = (std::string *)v163->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v164->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWMAXSTR") )
      goto LABEL_355;
    if ( v163->_Mypair._Myval2._Myres >= 0x10 )
      v163 = (std::string *)v163->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v163->_Mypair._Myval2._Bx._Buf, "SELFSHADOWMAXSTR") )
    {
LABEL_355:
      v165 = &v162[++v5];
      if ( v165->_Mypair._Myval2._Myres >= 0x10 )
        v165 = (std::string *)v165->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v165->_Mypair._Myval2._Bx._Buf[0] )
      {
        v166 = -1i64;
        do
          ++v166;
        while ( v165->_Mypair._Myval2._Bx._Buf[v166] );
      }
      else
      {
        v166 = 0i64;
      }
      std::string::assign(&_Str, v165->_Mypair._Myval2._Bx._Buf, v166);
      assetData->bodySelfShadowMaxStrength = std::stof(&_Str, v167);
      std::string::~string(&_Str);
    }
    v168 = line->_Mypair._Myval2._Myfirst;
    v169 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v169->_Mypair._Myval2._Myres < 0x10 )
      v170 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v170 = (std::string *)v169->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v170->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWMAX") )
      goto LABEL_369;
    if ( v169->_Mypair._Myval2._Myres >= 0x10 )
      v169 = (std::string *)v169->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v169->_Mypair._Myval2._Bx._Buf, "SHADOWMAX") )
    {
LABEL_369:
      v171 = &v168[++v5];
      if ( v171->_Mypair._Myval2._Myres >= 0x10 )
        v171 = (std::string *)v171->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v171->_Mypair._Myval2._Bx._Buf[0] )
      {
        v172 = -1i64;
        do
          ++v172;
        while ( v171->_Mypair._Myval2._Bx._Buf[v172] );
      }
      else
      {
        v172 = 0i64;
      }
      std::string::assign(&_Str, v171->_Mypair._Myval2._Bx._Buf, v172);
      assetData->bodySelfShadowVisibility = std::stof(&_Str, v173);
      std::string::~string(&_Str);
    }
    v174 = line->_Mypair._Myval2._Myfirst;
    v175 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v175->_Mypair._Myval2._Myres < 0x10 )
      v176 = &line->_Mypair._Myval2._Myfirst[v5];
    else
      v176 = (std::string *)v175->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v176->_Mypair._Myval2._Bx._Buf, "BODYSELFSHADOWHARDEDGE") )
      goto LABEL_383;
    if ( v175->_Mypair._Myval2._Myres >= 0x10 )
      v175 = (std::string *)v175->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v175->_Mypair._Myval2._Bx._Buf, "HARDSHADOWEDGE") )
    {
LABEL_383:
      v177 = &v174[++v5];
      if ( v177->_Mypair._Myval2._Myres >= 0x10 )
        v177 = (std::string *)v177->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v177->_Mypair._Myval2._Bx._Buf[0] )
      {
        v178 = -1i64;
        do
          ++v178;
        while ( v177->_Mypair._Myval2._Bx._Buf[v178] );
      }
      else
      {
        v178 = 0i64;
      }
      std::string::assign(&_Str, v177->_Mypair._Myval2._Bx._Buf, v178);
      assetData->bodySelfShadowHardEdge = std::stof(&_Str, v179);
      std::string::~string(&_Str);
    }
    v180 = line->_Mypair._Myval2._Myfirst;
    v181 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v181->_Mypair._Myval2._Myres >= 0x10 )
      v181 = (std::string *)v181->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v181->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWCOLOR") )
    {
      v182 = &v180[v5 + 1];
      if ( v182->_Mypair._Myval2._Myres >= 0x10 )
        v182 = (std::string *)v182->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v182->_Mypair._Myval2._Bx._Buf[0] )
      {
        v183 = -1i64;
        do
          ++v183;
        while ( v182->_Mypair._Myval2._Bx._Buf[v183] );
      }
      else
      {
        v183 = 0i64;
      }
      std::string::assign(&_Str, v182->_Mypair._Myval2._Bx._Buf, v183);
      assetData->skinSelfShadowColour[0] = std::stof(&_Str, v184);
      std::string::~string(&_Str);
      v185 = &line->_Mypair._Myval2._Myfirst[v5 + 2];
      if ( v185->_Mypair._Myval2._Myres >= 0x10 )
        v185 = (std::string *)v185->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v185->_Mypair._Myval2._Bx._Buf[0] )
      {
        v186 = -1i64;
        do
          ++v186;
        while ( v185->_Mypair._Myval2._Bx._Buf[v186] );
      }
      else
      {
        v186 = 0i64;
      }
      std::string::assign(&_Str, v185->_Mypair._Myval2._Bx._Buf, v186);
      assetData->skinSelfShadowColour[1] = std::stof(&_Str, v187);
      std::string::~string(&_Str);
      v5 += 3;
      v188 = &line->_Mypair._Myval2._Myfirst[v5];
      if ( v188->_Mypair._Myval2._Myres >= 0x10 )
        v188 = (std::string *)v188->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v188->_Mypair._Myval2._Bx._Buf[0] )
      {
        v189 = -1i64;
        do
          ++v189;
        while ( v188->_Mypair._Myval2._Bx._Buf[v189] );
      }
      else
      {
        v189 = 0i64;
      }
      std::string::assign(&_Str, v188->_Mypair._Myval2._Bx._Buf, v189);
      assetData->skinSelfShadowColour[2] = std::stof(&_Str, v190);
      std::string::~string(&_Str);
    }
    v191 = line->_Mypair._Myval2._Myfirst;
    v192 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v192->_Mypair._Myval2._Myres >= 0x10 )
      v192 = (std::string *)v192->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v192->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWCOLINTENSITY") )
    {
      v193 = &v191[++v5];
      if ( v193->_Mypair._Myval2._Myres >= 0x10 )
        v193 = (std::string *)v193->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v193->_Mypair._Myval2._Bx._Buf[0] )
      {
        v194 = -1i64;
        do
          ++v194;
        while ( v193->_Mypair._Myval2._Bx._Buf[v194] );
      }
      else
      {
        v194 = 0i64;
      }
      std::string::assign(&_Str, v193->_Mypair._Myval2._Bx._Buf, v194);
      assetData->skinSelfShadowIntensity = std::stof(&_Str, v195);
      std::string::~string(&_Str);
    }
    v196 = line->_Mypair._Myval2._Myfirst;
    v197 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v197->_Mypair._Myval2._Myres >= 0x10 )
      v197 = (std::string *)v197->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v197->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWBIAS") )
    {
      v198 = &v196[++v5];
      if ( v198->_Mypair._Myval2._Myres >= 0x10 )
        v198 = (std::string *)v198->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v198->_Mypair._Myval2._Bx._Buf[0] )
      {
        v199 = -1i64;
        do
          ++v199;
        while ( v198->_Mypair._Myval2._Bx._Buf[v199] );
      }
      else
      {
        v199 = 0i64;
      }
      std::string::assign(&_Str, v198->_Mypair._Myval2._Bx._Buf, v199);
      assetData->skinSelfShadowBias = std::stof(&_Str, v200);
      std::string::~string(&_Str);
    }
    v201 = line->_Mypair._Myval2._Myfirst;
    v202 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v202->_Mypair._Myval2._Myres >= 0x10 )
      v202 = (std::string *)v202->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v202->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWMAXSTR") )
    {
      v203 = &v201[++v5];
      if ( v203->_Mypair._Myval2._Myres >= 0x10 )
        v203 = (std::string *)v203->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v203->_Mypair._Myval2._Bx._Buf[0] )
      {
        v204 = -1i64;
        do
          ++v204;
        while ( v203->_Mypair._Myval2._Bx._Buf[v204] );
      }
      else
      {
        v204 = 0i64;
      }
      std::string::assign(&_Str, v203->_Mypair._Myval2._Bx._Buf, v204);
      assetData->skinSelfShadowMaxStrength = std::stof(&_Str, v205);
      std::string::~string(&_Str);
    }
    v206 = line->_Mypair._Myval2._Myfirst;
    v207 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v207->_Mypair._Myval2._Myres >= 0x10 )
      v207 = (std::string *)v207->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v207->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWMAX") )
    {
      v208 = &v206[++v5];
      if ( v208->_Mypair._Myval2._Myres >= 0x10 )
        v208 = (std::string *)v208->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v208->_Mypair._Myval2._Bx._Buf[0] )
      {
        v209 = -1i64;
        do
          ++v209;
        while ( v208->_Mypair._Myval2._Bx._Buf[v209] );
      }
      else
      {
        v209 = 0i64;
      }
      std::string::assign(&_Str, v208->_Mypair._Myval2._Bx._Buf, v209);
      assetData->skinSelfShadowVisibility = std::stof(&_Str, v210);
      std::string::~string(&_Str);
    }
    v211 = line->_Mypair._Myval2._Myfirst;
    v212 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v212->_Mypair._Myval2._Myres >= 0x10 )
      v212 = (std::string *)v212->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v212->_Mypair._Myval2._Bx._Buf, "SKINSELFSHADOWHARDEDGE") )
    {
      v213 = &v211[++v5];
      if ( v213->_Mypair._Myval2._Myres >= 0x10 )
        v213 = (std::string *)v213->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v213->_Mypair._Myval2._Bx._Buf[0] )
      {
        v214 = -1i64;
        do
          ++v214;
        while ( v213->_Mypair._Myval2._Bx._Buf[v214] );
      }
      else
      {
        v214 = 0i64;
      }
      std::string::assign(&_Str, v213->_Mypair._Myval2._Bx._Buf, v214);
      assetData->skinSelfShadowHardEdge = std::stof(&_Str, v215);
      std::string::~string(&_Str);
    }
    v216 = line->_Mypair._Myval2._Myfirst;
    v217 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v217->_Mypair._Myval2._Myres >= 0x10 )
      v217 = (std::string *)v217->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v217->_Mypair._Myval2._Bx._Buf, "SHADOWBLURSTR") )
    {
      v218 = &v216[++v5];
      if ( v218->_Mypair._Myval2._Myres >= 0x10 )
        v218 = (std::string *)v218->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v218->_Mypair._Myval2._Bx._Buf[0] )
      {
        v219 = -1i64;
        do
          ++v219;
        while ( v218->_Mypair._Myval2._Bx._Buf[v219] );
      }
      else
      {
        v219 = 0i64;
      }
      std::string::assign(&_Str, v218->_Mypair._Myval2._Bx._Buf, v219);
      assetData->shadowBlur = std::stoi(&_Str, v220, v221);
      std::string::~string(&_Str);
    }
    v222 = line->_Mypair._Myval2._Myfirst;
    v223 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v223->_Mypair._Myval2._Myres >= 0x10 )
      v223 = (std::string *)v223->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v223->_Mypair._Myval2._Bx._Buf, "SHADOWUSEFXAA") )
    {
      v224 = &v222[++v5];
      if ( v224->_Mypair._Myval2._Myres >= 0x10 )
        v224 = (std::string *)v224->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v224->_Mypair._Myval2._Bx._Buf[0] )
      {
        v225 = -1i64;
        do
          ++v225;
        while ( v224->_Mypair._Myval2._Bx._Buf[v225] );
      }
      else
      {
        v225 = 0i64;
      }
      std::string::assign(&_Str, v224->_Mypair._Myval2._Bx._Buf, v225);
      assetData->shadowUseFXAA = std::stoi(&_Str, v226, v227) != 0;
      std::string::~string(&_Str);
    }
    v228 = line->_Mypair._Myval2._Myfirst;
    v229 = &line->_Mypair._Myval2._Myfirst[v5];
    if ( v229->_Mypair._Myval2._Myres >= 0x10 )
      v229 = (std::string *)v229->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v229->_Mypair._Myval2._Bx._Buf, "SHADOWUSESLOPE") )
    {
      v230 = &v228[++v5];
      if ( v230->_Mypair._Myval2._Myres >= 0x10 )
        v230 = (std::string *)v230->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&_Str, 0, 0i64);
      if ( v230->_Mypair._Myval2._Bx._Buf[0] )
      {
        v231 = -1i64;
        do
          ++v231;
        while ( v230->_Mypair._Myval2._Bx._Buf[v231] );
      }
      else
      {
        v231 = 0i64;
      }
      std::string::assign(&_Str, v230->_Mypair._Myval2._Bx._Buf, v231);
      assetData->shadowUseSlope = std::stoi(&_Str, v232, v233) != 0;
      std::string::~string(&_Str);
    }
    ++v5;
  }
}

void __fastcall AppMain::processPostProcessData(
        AppMain *this,
        std::vector<std::string> *line,
        AppMain::_POSTPROCESS_SHADER_SETTINGS *postProcessSettings)
{
  int i; // esi
  std::string *Myfirst; // rbx
  std::string *Ptr; // rcx
  std::string *v8; // rdx
  unsigned __int64 v9; // r8
  std::string *v10; // rbx
  int v11; // edi
  char *v12; // rcx
  char *v13; // rax
  std::string *v14; // rdx
  __int64 v15; // rcx
  char v16; // al
  std::string *v17; // rdx
  unsigned __int64 v18; // r8
  std::string *v19; // rbx
  float v20; // xmm6_4
  char *v21; // rcx
  char *v22; // rax
  std::string *v23; // rbx
  std::string *v24; // rcx
  std::string *v25; // rdx
  unsigned __int64 v26; // r8
  std::string *v27; // rbx
  float v28; // xmm6_4
  std::string *v29; // rbx
  std::string *v30; // rcx
  std::string *v31; // rdx
  unsigned __int64 v32; // r8
  std::string *v33; // rbx
  float v34; // xmm6_4
  std::string *v35; // rbx
  std::string *v36; // rcx
  std::string *v37; // rdx
  unsigned __int64 v38; // r8
  std::string *v39; // rbx
  float v40; // xmm6_4
  std::string *v41; // rbx
  std::string *v42; // rcx
  std::string *v43; // rdx
  unsigned __int64 v44; // r8
  unsigned __int64 *v45; // rdx
  std::string *v46; // rbx
  std::string *v47; // rcx
  std::string *v48; // rdx
  unsigned __int64 v49; // r8
  unsigned __int64 *v50; // rdx
  int v51; // er8
  std::string *v52; // rbx
  std::string *v53; // rcx
  std::string *v54; // rdx
  unsigned __int64 v55; // r8
  unsigned __int64 *v56; // rdx
  int v57; // er8
  int v58; // ebx
  std::string *v59; // rbx
  std::string *v60; // rcx
  std::string *v61; // rdx
  unsigned __int64 v62; // r8
  unsigned __int64 *v63; // rdx
  int v64; // er8
  int v65; // ebx
  std::string *v66; // rbx
  std::string *v67; // rcx
  std::string *v68; // rdx
  unsigned __int64 v69; // r8
  unsigned __int64 *v70; // rdx
  int v71; // er8
  std::string *v72; // rbx
  std::string *v73; // r8
  std::string *v74; // rdx
  __int64 v75; // rcx
  char v76; // al
  std::string *v77; // rdx
  unsigned __int64 v78; // r8
  unsigned __int64 *v79; // rdx
  int v80; // er8
  std::string *v81; // rbx
  std::string *v82; // rcx
  char **v83; // rcx
  __int64 v84; // rax
  char v85; // dl
  bool v86; // zf
  std::string *v87; // rdi
  std::string *v88; // rbx
  std::string *v89; // rcx
  std::string *v90; // rdx
  unsigned __int64 v91; // r8
  unsigned __int64 *v92; // rdx
  std::string *v93; // rdi
  std::string *v94; // rbx
  std::string *v95; // rcx
  std::string *v96; // rdx
  unsigned __int64 v97; // r8
  unsigned __int64 *v98; // rdx
  std::string *v99; // rdi
  std::string *v100; // rbx
  std::string *v101; // rcx
  std::string *v102; // rdx
  unsigned __int64 v103; // r8
  unsigned __int64 *v104; // rdx
  std::string *v105; // rdi
  std::string *v106; // rbx
  std::string *v107; // rcx
  std::string *v108; // rdx
  unsigned __int64 v109; // r8
  unsigned __int64 *v110; // rdx
  std::string *v111; // rdi
  std::string *v112; // rbx
  std::string *v113; // rcx
  std::string *v114; // rdx
  unsigned __int64 v115; // r8
  unsigned __int64 *v116; // rdx
  std::string *v117; // rdi
  std::string *v118; // rbx
  std::string *v119; // rcx
  std::string *v120; // rdx
  unsigned __int64 v121; // r8
  unsigned __int64 *v122; // rdx
  std::string *v123; // rdx
  unsigned __int64 v124; // r8
  unsigned __int64 *v125; // rdx
  std::string *v126; // rdx
  unsigned __int64 v127; // r8
  unsigned __int64 *v128; // rdx
  std::string *v129; // rdi
  std::string *v130; // rcx
  std::string *v131; // rbx
  unsigned __int64 v132; // r8
  unsigned __int64 *v133; // rdx
  std::string *v134; // rdi
  std::string *v135; // rcx
  std::string *v136; // rbx
  unsigned __int64 v137; // r8
  unsigned __int64 *v138; // rdx
  std::string *v139; // rdi
  std::string *v140; // rcx
  std::string *v141; // rbx
  unsigned __int64 v142; // r8
  unsigned __int64 *v143; // rdx
  std::string *v144; // rdi
  std::string *v145; // rcx
  std::string *v146; // rbx
  unsigned __int64 v147; // r8
  unsigned __int64 *v148; // rdx
  std::string *v149; // rdi
  std::string *v150; // rcx
  std::string *v151; // rbx
  unsigned __int64 v152; // r8
  unsigned __int64 *v153; // rdx
  std::string *v154; // rdi
  std::string *v155; // rcx
  std::string *v156; // rbx
  unsigned __int64 v157; // r8
  unsigned __int64 *v158; // rdx
  std::string *v159; // rbx
  unsigned __int64 v160; // r8
  unsigned __int64 *v161; // rdx
  std::string *v162; // rbx
  unsigned __int64 v163; // r8
  unsigned __int64 *v164; // rdx
  std::string *v165; // rdi
  std::string *v166; // rcx
  std::string *v167; // rbx
  unsigned __int64 v168; // r8
  unsigned __int64 *v169; // rdx
  int v170; // er8
  std::string *v171; // rbx
  std::string *v172; // rcx
  char **v173; // rcx
  __int64 v174; // rax
  char v175; // dl
  bool v176; // zf
  std::string *v177; // rdi
  std::string *v178; // rcx
  std::string *v179; // rbx
  unsigned __int64 v180; // r8
  unsigned __int64 *v181; // rdx
  std::string *v182; // rdi
  std::string *v183; // rcx
  std::string *v184; // rbx
  unsigned __int64 v185; // r8
  unsigned __int64 *v186; // rdx
  std::string *v187; // rdi
  std::string *v188; // rcx
  std::string *v189; // rbx
  unsigned __int64 v190; // r8
  unsigned __int64 *v191; // rdx
  std::string *v192; // rdi
  std::string *v193; // rcx
  std::string *v194; // rbx
  unsigned __int64 v195; // r8
  unsigned __int64 *v196; // rdx
  std::string *v197; // rdi
  std::string *v198; // rcx
  std::string *v199; // rbx
  unsigned __int64 v200; // r8
  unsigned __int64 *v201; // rdx
  std::string *v202; // rdi
  std::string *v203; // rcx
  std::string *v204; // rbx
  unsigned __int64 v205; // r8
  unsigned __int64 *v206; // rdx
  std::string *v207; // rbx
  unsigned __int64 v208; // r8
  unsigned __int64 *v209; // rdx
  std::string *v210; // rbx
  unsigned __int64 v211; // r8
  unsigned __int64 *v212; // rdx
  std::string *v213; // rdi
  std::string *v214; // rcx
  std::string *v215; // rbx
  unsigned __int64 v216; // r8
  unsigned __int64 *v217; // rdx
  std::string *v218; // rdi
  std::string *v219; // rcx
  std::string *v220; // rbx
  unsigned __int64 v221; // r8
  unsigned __int64 *v222; // rdx
  std::string *v223; // rdi
  std::string *v224; // rcx
  std::string *v225; // rbx
  unsigned __int64 v226; // r8
  unsigned __int64 *v227; // rdx
  std::string *v228; // rdi
  std::string *v229; // rcx
  std::string *v230; // rbx
  unsigned __int64 v231; // r8
  unsigned __int64 *v232; // rdx
  std::string *v233; // rdi
  std::string *v234; // rcx
  std::string *v235; // rbx
  unsigned __int64 v236; // r8
  unsigned __int64 *v237; // rdx
  std::string *v238; // rdi
  std::string *v239; // rcx
  std::string *v240; // rbx
  unsigned __int64 v241; // r8
  unsigned __int64 *v242; // rdx
  std::string *v243; // rbx
  unsigned __int64 v244; // r8
  unsigned __int64 *v245; // rdx
  std::string *v246; // rbx
  unsigned __int64 v247; // r8
  unsigned __int64 *v248; // rdx
  std::string *v249; // rdi
  std::string *v250; // rcx
  std::string *v251; // rbx
  unsigned __int64 v252; // r8
  unsigned __int64 *v253; // rdx
  int v254; // er8
  std::string *v255; // rdi
  std::string *v256; // rcx
  std::string *v257; // rbx
  unsigned __int64 v258; // r8
  unsigned __int64 *v259; // rdx
  std::string *v260; // rdi
  std::string *v261; // rcx
  std::string *v262; // rbx
  unsigned __int64 v263; // r8
  unsigned __int64 *v264; // rdx
  int v265; // er8
  std::string *v266; // rdi
  std::string *v267; // rcx
  std::string *v268; // rbx
  unsigned __int64 v269; // r8
  unsigned __int64 *v270; // rdx
  std::string *v271; // rdi
  std::string *v272; // rcx
  std::string *v273; // rbx
  unsigned __int64 v274; // r8
  unsigned __int64 *v275; // rdx
  std::string *v276; // rbx
  unsigned __int64 v277; // r8
  unsigned __int64 *v278; // rdx
  std::string *v279; // rbx
  unsigned __int64 v280; // r8
  unsigned __int64 *v281; // rdx
  std::string *v282; // rdi
  std::string *v283; // rcx
  std::string *v284; // rbx
  unsigned __int64 v285; // r8
  unsigned __int64 *v286; // rdx
  std::string *v287; // rbx
  unsigned __int64 v288; // r8
  unsigned __int64 *v289; // rdx
  std::string *v290; // rbx
  unsigned __int64 v291; // r8
  unsigned __int64 *v292; // rdx
  std::string *v293; // rdi
  std::string *v294; // rcx
  std::string *v295; // rbx
  unsigned __int64 v296; // r8
  unsigned __int64 *v297; // rdx
  int v298; // er8
  std::string *v299; // rdi
  std::string *v300; // rcx
  std::string *v301; // rbx
  unsigned __int64 v302; // r8
  unsigned __int64 *v303; // rdx
  int v304; // er8
  std::string *v305; // rdi
  std::string *v306; // rcx
  std::string *v307; // rbx
  unsigned __int64 v308; // r8
  unsigned __int64 *v309; // rdx
  std::string *v310; // rdi
  std::string *v311; // rcx
  std::string *v312; // rbx
  unsigned __int64 v313; // r8
  unsigned __int64 *v314; // rdx
  std::string *v315; // rdi
  std::string *v316; // rcx
  std::string *v317; // rbx
  unsigned __int64 v318; // r8
  unsigned __int64 *v319; // rdx
  std::string *v320; // rdi
  std::string *v321; // rcx
  std::string *v322; // rbx
  unsigned __int64 v323; // r8
  unsigned __int64 *v324; // rdx
  int v325; // er8
  std::string *v326; // rdi
  std::string *v327; // rcx
  std::string *v328; // rbx
  unsigned __int64 v329; // r8
  unsigned __int64 *v330; // rdx
  std::string *v331; // rdi
  std::string *v332; // rcx
  std::string *v333; // rbx
  unsigned __int64 v334; // r8
  unsigned __int64 *v335; // rdx
  std::string *v336; // rdi
  std::string *v337; // rcx
  std::string *v338; // rbx
  unsigned __int64 v339; // r8
  unsigned __int64 *v340; // rdx
  std::string *v341; // rdi
  std::string *v342; // rcx
  std::string *v343; // rbx
  unsigned __int64 v344; // r8
  unsigned __int64 *v345; // rdx
  std::string *v346; // rdi
  std::string *v347; // rcx
  std::string *v348; // rbx
  unsigned __int64 v349; // r8
  unsigned __int64 *v350; // rdx
  std::string *v351; // rax
  std::string *v352; // rax
  std::string *v353; // rax
  unsigned __int64 *v354; // rdx
  int v355; // er8
  std::string *v356; // rax
  std::string *v357; // rax
  std::string *v358; // rax
  std::string *v359; // rax
  unsigned __int64 *v360; // rdx
  std::string *v361; // rax
  std::string *v362; // rax
  std::string *v363; // rax
  std::string *v364; // rax
  unsigned __int64 *v365; // rdx
  std::string *v366; // rax
  std::string *v367; // rax
  unsigned __int64 *v368; // rdx
  std::string *v369; // rax
  std::string *v370; // rax
  unsigned __int64 *v371; // rdx
  std::string *v372; // rax
  std::string *v373; // rax
  std::string *v374; // rax
  std::string *v375; // rax
  unsigned __int64 *v376; // rdx
  std::string *v377; // rax
  std::string *v378; // rax
  unsigned __int64 *v379; // rdx
  std::string *v380; // rax
  std::string *v381; // rax
  unsigned __int64 *v382; // rdx
  std::string *v383; // rax
  std::string *v384; // rax
  std::string *v385; // rax
  std::string *v386; // rax
  unsigned __int64 *v387; // rdx
  int v388; // er8
  std::string *v389; // rax
  std::string *v390; // rax
  std::string *v391; // rax
  std::string *v392; // rax
  unsigned __int64 *v393; // rdx
  std::string *v394; // rax
  std::string *v395; // rax
  std::string *v396; // rax
  std::string *v397; // rax
  unsigned __int64 *v398; // rdx
  std::string *v399; // rax
  std::string *v400; // rax
  std::string *v401; // rax
  std::string *v402; // rax
  unsigned __int64 *v403; // rdx
  std::string *v404; // rax
  std::string *v405; // rax
  std::string *v406; // rax
  std::string *v407; // rax
  unsigned __int64 *v408; // rdx
  std::string *v409; // rax
  std::string *v410; // rax
  std::string *v411; // rax
  std::string *v412; // rax
  unsigned __int64 *v413; // rdx
  std::string *v414; // rax
  std::string *v415; // rax
  std::string *v416; // rax
  std::string *v417; // rax
  unsigned __int64 *v418; // rdx
  int v419; // er8
  std::string *v420; // rax
  std::string *v421; // rax
  std::string *v422; // rax
  std::string *v423; // rax
  unsigned __int64 *v424; // rdx
  std::string *v425; // rax
  std::string *v426; // rax
  std::string *v427; // rax
  std::string *v428; // rax
  unsigned __int64 *v429; // rdx
  std::string *v430; // rax
  std::string *v431; // rax
  std::string *v432; // rax
  std::string *v433; // rax
  unsigned __int64 *v434; // rdx
  std::string *v435; // rax
  std::string *v436; // rax
  std::string *v437; // rax
  std::string *v438; // rax
  unsigned __int64 *v439; // rdx
  std::string *v440; // rax
  std::string *v441; // rax
  std::string *v442; // rax
  std::string *v443; // rax
  unsigned __int64 *v444; // rdx
  std::string *v445; // rax
  std::string *v446; // rax
  unsigned __int64 *v447; // rdx
  std::string *v448; // rax
  std::string *v449; // rax
  unsigned __int64 *v450; // rdx
  std::string *v451; // rax
  std::string *v452; // rax
  std::string *v453; // rax
  std::string *v454; // rax
  unsigned __int64 *v455; // rdx
  int v456; // er8
  std::string *v457; // rax
  std::string *v458; // rax
  std::string *v459; // rax
  std::string *v460; // rax
  unsigned __int64 *v461; // rdx
  std::string *v462; // rax
  std::string *v463; // rax
  std::string *v464; // rax
  std::string *v465; // rax
  unsigned __int64 *v466; // rdx
  std::string *v467; // rax
  std::string *v468; // rax
  std::string *v469; // rax
  std::string *v470; // rax
  unsigned __int64 *v471; // rdx
  std::string *v472; // rax
  std::string *v473; // rax
  std::string *v474; // rax
  std::string *v475; // rax
  unsigned __int64 *v476; // rdx
  int v477; // er8
  std::string *v478; // rax
  std::string *v479; // rax
  std::string *v480; // rax
  std::string *v481; // rax
  unsigned __int64 *v482; // rdx
  std::string *v483; // rax
  std::string *v484; // rax
  std::string *v485; // rax
  std::string *v486; // rax
  unsigned __int64 *v487; // rdx
  std::string *v488; // rax
  std::string *v489; // rax
  std::string *v490; // rax
  std::string *v491; // rax
  unsigned __int64 *v492; // rdx
  std::string *v493; // rax
  std::string *v494; // rax
  std::string *v495; // rax
  std::string *v496; // rax
  unsigned __int64 *v497; // rdx
  std::string *v498; // rax
  std::string *v499; // rax
  unsigned __int64 *v500; // rdx
  std::string *v501; // rax
  std::string *v502; // rax
  unsigned __int64 *v503; // rdx
  std::string *v504; // rax
  std::string *v505; // rax
  std::string *v506; // rax
  std::string *v507; // rax
  unsigned __int64 *v508; // rdx
  int v509; // er8
  std::string *v510; // rax
  std::string *v511; // rax
  std::string *v512; // rax
  std::string *v513; // rax
  unsigned __int64 *v514; // rdx
  std::string *v515; // rax
  std::string *v516; // rax
  std::string *v517; // rax
  std::string *v518; // rax
  unsigned __int64 *v519; // rdx
  std::string *v520; // rax
  std::string *v521; // rax
  std::string *v522; // rax
  std::string *v523; // rax
  unsigned __int64 *v524; // rdx
  std::string *v525; // rax
  std::string *v526; // rax
  std::string *v527; // rax
  std::string *v528; // rax
  unsigned __int64 *v529; // rdx
  int v530; // er8
  std::string *v531; // rax
  std::string *v532; // rax
  std::string *v533; // rax
  std::string *v534; // rax
  unsigned __int64 *v535; // rdx
  int v536; // er8
  std::string *v537; // rax
  std::string *v538; // rax
  std::string *v539; // rax
  std::string *v540; // rax
  unsigned __int64 *v541; // rdx
  int v542; // er8
  std::string *v543; // rax
  std::string *v544; // rax
  std::string *v545; // rax
  std::string *v546; // rax
  unsigned __int64 *v547; // rdx
  std::string *v548; // rax
  std::string *v549; // rax
  unsigned __int64 *v550; // rdx
  std::string *v551; // rax
  std::string *v552; // rax
  std::string *v553; // rax
  std::string *v554; // rax
  unsigned __int64 *v555; // rdx
  std::string *v556; // rax
  std::string *v557; // rax
  std::string *v558; // rax
  std::string *v559; // rax
  unsigned __int64 *v560; // rdx
  std::string *v561; // rax
  std::string *v562; // rax
  std::string *v563; // rax
  std::string *v564; // rax
  unsigned __int64 *v565; // rdx
  int v566; // er8
  std::string *v567; // rax
  std::string *v568; // rax
  std::string *v569; // rax
  std::string *v570; // rax
  unsigned __int64 *v571; // rdx
  std::string *v572; // rax
  std::string *v573; // rax
  std::string *v574; // rax
  std::string *v575; // rax
  unsigned __int64 *v576; // rdx
  std::string *v577; // rax
  std::string *v578; // rax
  std::string *v579; // rax
  std::string *v580; // rax
  unsigned __int64 *v581; // rdx
  char *end_ptr; // [rsp+28h] [rbp-E0h] BYREF
  char *v583; // [rsp+30h] [rbp-D8h] BYREF
  char *v584; // [rsp+38h] [rbp-D0h] BYREF
  char *v585; // [rsp+40h] [rbp-C8h] BYREF
  char *v586[2]; // [rsp+48h] [rbp-C0h] BYREF
  std::string v587; // [rsp+58h] [rbp-B0h] BYREF
  std::string v588; // [rsp+78h] [rbp-90h] BYREF
  std::string v589; // [rsp+98h] [rbp-70h] BYREF
  std::string v590; // [rsp+B8h] [rbp-50h] BYREF
  std::string v591; // [rsp+D8h] [rbp-30h] BYREF
  std::string _Str; // [rsp+F8h] [rbp-10h] BYREF
  std::string v593; // [rsp+118h] [rbp+10h] BYREF
  std::string v594; // [rsp+138h] [rbp+30h] BYREF
  std::string v595; // [rsp+158h] [rbp+50h] BYREF
  std::string v596; // [rsp+178h] [rbp+70h] BYREF
  std::string v597; // [rsp+198h] [rbp+90h] BYREF
  std::string v598; // [rsp+1B8h] [rbp+B0h] BYREF
  std::string v599; // [rsp+1D8h] [rbp+D0h] BYREF
  std::string v600; // [rsp+1F8h] [rbp+F0h] BYREF
  std::string v601; // [rsp+218h] [rbp+110h] BYREF
  std::string v602; // [rsp+238h] [rbp+130h] BYREF
  std::string v603; // [rsp+258h] [rbp+150h] BYREF
  std::string v604; // [rsp+278h] [rbp+170h] BYREF
  std::string v605; // [rsp+298h] [rbp+190h] BYREF
  std::string v606; // [rsp+2B8h] [rbp+1B0h] BYREF
  std::string v607; // [rsp+2D8h] [rbp+1D0h] BYREF
  std::string v608; // [rsp+2F8h] [rbp+1F0h] BYREF
  std::string v609; // [rsp+318h] [rbp+210h] BYREF
  std::string v610; // [rsp+338h] [rbp+230h] BYREF
  std::string v611; // [rsp+358h] [rbp+250h] BYREF
  std::string v612; // [rsp+378h] [rbp+270h] BYREF
  std::string v613; // [rsp+398h] [rbp+290h] BYREF
  std::string v614; // [rsp+3B8h] [rbp+2B0h] BYREF
  std::string v615; // [rsp+3D8h] [rbp+2D0h] BYREF
  std::string v616; // [rsp+3F8h] [rbp+2F0h] BYREF
  std::string v617; // [rsp+418h] [rbp+310h] BYREF
  std::string v618; // [rsp+438h] [rbp+330h] BYREF
  std::string v619; // [rsp+458h] [rbp+350h] BYREF
  std::string v620; // [rsp+478h] [rbp+370h] BYREF
  std::string v621; // [rsp+498h] [rbp+390h] BYREF
  std::string v622; // [rsp+4B8h] [rbp+3B0h] BYREF
  std::string v623; // [rsp+4D8h] [rbp+3D0h] BYREF
  std::string v624; // [rsp+4F8h] [rbp+3F0h] BYREF
  std::string v625; // [rsp+518h] [rbp+410h] BYREF
  std::string v626; // [rsp+538h] [rbp+430h] BYREF
  std::string v627; // [rsp+558h] [rbp+450h] BYREF
  std::string v628; // [rsp+578h] [rbp+470h] BYREF
  std::string v629; // [rsp+598h] [rbp+490h] BYREF
  std::string v630; // [rsp+5B8h] [rbp+4B0h] BYREF
  std::string v631; // [rsp+5D8h] [rbp+4D0h] BYREF
  std::string v632; // [rsp+5F8h] [rbp+4F0h] BYREF
  std::string v633; // [rsp+618h] [rbp+510h] BYREF
  std::string v634; // [rsp+638h] [rbp+530h] BYREF
  std::string v635; // [rsp+658h] [rbp+550h] BYREF
  std::string v636; // [rsp+678h] [rbp+570h] BYREF
  std::string v637; // [rsp+698h] [rbp+590h] BYREF
  std::string v638; // [rsp+6B8h] [rbp+5B0h] BYREF
  std::string v639; // [rsp+6D8h] [rbp+5D0h] BYREF
  std::string v640; // [rsp+6F8h] [rbp+5F0h] BYREF
  std::string v641; // [rsp+718h] [rbp+610h] BYREF
  std::string v642; // [rsp+738h] [rbp+630h] BYREF
  std::string v643; // [rsp+758h] [rbp+650h] BYREF
  std::string v644; // [rsp+778h] [rbp+670h] BYREF
  std::string v645; // [rsp+798h] [rbp+690h] BYREF
  std::string v646; // [rsp+7B8h] [rbp+6B0h] BYREF
  std::string v647; // [rsp+7D8h] [rbp+6D0h] BYREF
  std::string v648; // [rsp+7F8h] [rbp+6F0h] BYREF
  std::string v649; // [rsp+818h] [rbp+710h] BYREF
  std::string v650; // [rsp+838h] [rbp+730h] BYREF
  std::string v651; // [rsp+858h] [rbp+750h] BYREF
  std::string v652; // [rsp+878h] [rbp+770h] BYREF
  std::string v653; // [rsp+898h] [rbp+790h] BYREF
  std::string v654; // [rsp+8B8h] [rbp+7B0h] BYREF
  std::string v655; // [rsp+8D8h] [rbp+7D0h] BYREF
  std::string v656; // [rsp+8F8h] [rbp+7F0h] BYREF
  std::string v657; // [rsp+918h] [rbp+810h] BYREF
  std::string v658; // [rsp+938h] [rbp+830h] BYREF
  std::string v659; // [rsp+958h] [rbp+850h] BYREF
  std::string v660; // [rsp+978h] [rbp+870h] BYREF
  std::string v661; // [rsp+998h] [rbp+890h] BYREF
  std::string v662; // [rsp+9B8h] [rbp+8B0h] BYREF
  std::string v663; // [rsp+9D8h] [rbp+8D0h] BYREF
  std::string v664; // [rsp+9F8h] [rbp+8F0h] BYREF
  std::string v665; // [rsp+A18h] [rbp+910h] BYREF
  std::string v666; // [rsp+A38h] [rbp+930h] BYREF
  std::string v667; // [rsp+A58h] [rbp+950h] BYREF
  std::string v668; // [rsp+A78h] [rbp+970h] BYREF
  std::string v669; // [rsp+A98h] [rbp+990h] BYREF
  std::string v670; // [rsp+AB8h] [rbp+9B0h] BYREF
  std::string v671; // [rsp+AD8h] [rbp+9D0h] BYREF
  std::string v672; // [rsp+AF8h] [rbp+9F0h] BYREF
  std::string v673; // [rsp+B18h] [rbp+A10h] BYREF
  std::string v674; // [rsp+B38h] [rbp+A30h] BYREF
  std::string v675; // [rsp+B58h] [rbp+A50h] BYREF
  std::string v676; // [rsp+B78h] [rbp+A70h] BYREF
  std::string v677; // [rsp+B98h] [rbp+A90h] BYREF
  std::string v678; // [rsp+BB8h] [rbp+AB0h] BYREF
  std::string v679; // [rsp+BD8h] [rbp+AD0h] BYREF
  std::string v680; // [rsp+BF8h] [rbp+AF0h] BYREF
  std::string v681; // [rsp+C18h] [rbp+B10h] BYREF
  std::string v682; // [rsp+C38h] [rbp+B30h] BYREF
  std::string v683; // [rsp+C58h] [rbp+B50h] BYREF
  std::string v684; // [rsp+C78h] [rbp+B70h] BYREF
  std::string v685; // [rsp+C98h] [rbp+B90h] BYREF
  std::string v686; // [rsp+CB8h] [rbp+BB0h] BYREF
  std::string v687; // [rsp+CD8h] [rbp+BD0h] BYREF
  std::string v688; // [rsp+CF8h] [rbp+BF0h] BYREF
  std::string v689; // [rsp+D18h] [rbp+C10h] BYREF
  std::string v690; // [rsp+D38h] [rbp+C30h] BYREF
  std::string v691; // [rsp+D58h] [rbp+C50h] BYREF
  std::string v692; // [rsp+D78h] [rbp+C70h] BYREF
  std::string v693; // [rsp+D98h] [rbp+C90h] BYREF
  std::string v694; // [rsp+DB8h] [rbp+CB0h] BYREF
  std::string v695; // [rsp+DD8h] [rbp+CD0h] BYREF
  std::string v696; // [rsp+DF8h] [rbp+CF0h] BYREF
  std::string v697; // [rsp+E18h] [rbp+D10h] BYREF
  std::string v698; // [rsp+E38h] [rbp+D30h] BYREF
  std::string v699; // [rsp+E58h] [rbp+D50h] BYREF

  v586[1] = (char *)-2i64;
  for ( i = 0; i < (unsigned __int64)(line->_Mypair._Myval2._Mylast - line->_Mypair._Myval2._Myfirst); ++i )
  {
    Myfirst = line->_Mypair._Myval2._Myfirst;
    Ptr = &line->_Mypair._Myval2._Myfirst[i];
    if ( Ptr->_Mypair._Myval2._Myres >= 0x10 )
      Ptr = (std::string *)Ptr->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(Ptr->_Mypair._Myval2._Bx._Buf, "USEBLOOM") )
    {
      v8 = &Myfirst[++i];
      if ( v8->_Mypair._Myval2._Myres >= 0x10 )
        v8 = (std::string *)v8->_Mypair._Myval2._Bx._Ptr;
      v587._Mypair._Myval2._Myres = 15i64;
      v587._Mypair._Myval2._Mysize = 0i64;
      v587._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v8->_Mypair._Myval2._Bx._Buf[0] )
      {
        v9 = -1i64;
        do
          ++v9;
        while ( v8->_Mypair._Myval2._Bx._Buf[v9] );
      }
      else
      {
        v9 = 0i64;
      }
      std::string::assign(&v587, v8->_Mypair._Myval2._Bx._Buf, v9);
      v10 = &v587;
      if ( v587._Mypair._Myval2._Myres >= 0x10 )
        v10 = (std::string *)v587._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v11 = strtol(v10->_Mypair._Myval2._Bx._Buf, &end_ptr, 10);
      if ( v10 == (std::string *)end_ptr )
        std::_Xinvalid_argument("invalid stoi argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stoi argument out of range");
      postProcessSettings->bgBloomSettings.bloomOn = v11 != 0;
      if ( v587._Mypair._Myval2._Myres >= 0x10 )
      {
        v12 = v587._Mypair._Myval2._Bx._Ptr;
        if ( v587._Mypair._Myval2._Myres + 1 >= 0x1000 )
        {
          if ( (v587._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
            invalid_parameter_noinfo_noreturn();
          v13 = (char *)*((_QWORD *)v587._Mypair._Myval2._Bx._Ptr - 1);
          if ( v13 >= v587._Mypair._Myval2._Bx._Ptr )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(v587._Mypair._Myval2._Bx._Ptr - v13) < (char *)8 )
            invalid_parameter_noinfo_noreturn();
          if ( (char *)(v587._Mypair._Myval2._Bx._Ptr - v13) > (char *)0x27 )
            invalid_parameter_noinfo_noreturn();
          v12 = (char *)*((_QWORD *)v587._Mypair._Myval2._Bx._Ptr - 1);
        }
        operator delete(v12);
      }
      v587._Mypair._Myval2._Myres = 15i64;
      v587._Mypair._Myval2._Mysize = 0i64;
      v587._Mypair._Myval2._Bx._Buf[0] = 0;
    }
    v14 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v14->_Mypair._Myval2._Myres >= 0x10 )
      v14 = (std::string *)v14->_Mypair._Myval2._Bx._Ptr;
    v15 = 0i64;
    while ( 1 )
    {
      v16 = v14->_Mypair._Myval2._Bx._Buf[v15++];
      if ( v16 != aBasesat[v15 - 1] )
        break;
      if ( v15 == 8 )
      {
        v17 = &line->_Mypair._Myval2._Myfirst[++i];
        if ( v17->_Mypair._Myval2._Myres >= 0x10 )
          v17 = (std::string *)v17->_Mypair._Myval2._Bx._Ptr;
        v588._Mypair._Myval2._Myres = 15i64;
        v588._Mypair._Myval2._Mysize = 0i64;
        v588._Mypair._Myval2._Bx._Buf[0] = 0;
        if ( v17->_Mypair._Myval2._Bx._Buf[0] )
        {
          v18 = -1i64;
          do
            ++v18;
          while ( v17->_Mypair._Myval2._Bx._Buf[v18] );
        }
        else
        {
          v18 = 0i64;
        }
        std::string::assign(&v588, v17->_Mypair._Myval2._Bx._Buf, v18);
        v19 = &v588;
        if ( v588._Mypair._Myval2._Myres >= 0x10 )
          v19 = (std::string *)v588._Mypair._Myval2._Bx._Ptr;
        *errno() = 0;
        v20 = strtof(v19->_Mypair._Myval2._Bx._Buf, &v583);
        if ( v19 == (std::string *)v583 )
          std::_Xinvalid_argument("invalid stof argument");
        if ( *errno() == 34 )
          std::_Xout_of_range("stof argument out of range");
        postProcessSettings->bgBloomSettings.baseSaturation = v20;
        if ( v588._Mypair._Myval2._Myres >= 0x10 )
        {
          v21 = v588._Mypair._Myval2._Bx._Ptr;
          if ( v588._Mypair._Myval2._Myres + 1 >= 0x1000 )
          {
            if ( (v588._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
              invalid_parameter_noinfo_noreturn();
            v22 = (char *)*((_QWORD *)v588._Mypair._Myval2._Bx._Ptr - 1);
            if ( v22 >= v588._Mypair._Myval2._Bx._Ptr )
              invalid_parameter_noinfo_noreturn();
            if ( (char *)(v588._Mypair._Myval2._Bx._Ptr - v22) < (char *)8 )
              invalid_parameter_noinfo_noreturn();
            if ( (char *)(v588._Mypair._Myval2._Bx._Ptr - v22) > (char *)0x27 )
              invalid_parameter_noinfo_noreturn();
            v21 = (char *)*((_QWORD *)v588._Mypair._Myval2._Bx._Ptr - 1);
          }
          operator delete(v21);
        }
        v588._Mypair._Myval2._Myres = 15i64;
        v588._Mypair._Myval2._Mysize = 0i64;
        v588._Mypair._Myval2._Bx._Buf[0] = 0;
        break;
      }
    }
    v23 = line->_Mypair._Myval2._Myfirst;
    v24 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v24->_Mypair._Myval2._Myres >= 0x10 )
      v24 = (std::string *)v24->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v24->_Mypair._Myval2._Bx._Buf, "BASEINTENSITY") )
    {
      v25 = &v23[++i];
      if ( v25->_Mypair._Myval2._Myres >= 0x10 )
        v25 = (std::string *)v25->_Mypair._Myval2._Bx._Ptr;
      v589._Mypair._Myval2._Myres = 15i64;
      v589._Mypair._Myval2._Mysize = 0i64;
      v589._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v25->_Mypair._Myval2._Bx._Buf[0] )
      {
        v26 = -1i64;
        do
          ++v26;
        while ( v25->_Mypair._Myval2._Bx._Buf[v26] );
      }
      else
      {
        v26 = 0i64;
      }
      std::string::assign(&v589, v25->_Mypair._Myval2._Bx._Buf, v26);
      v27 = &v589;
      if ( v589._Mypair._Myval2._Myres >= 0x10 )
        v27 = (std::string *)v589._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v28 = strtof(v27->_Mypair._Myval2._Bx._Buf, &v584);
      if ( v27 == (std::string *)v584 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      postProcessSettings->bgBloomSettings.baseIntensity = v28;
      std::string::~string(&v589);
    }
    v29 = line->_Mypair._Myval2._Myfirst;
    v30 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v30->_Mypair._Myval2._Myres >= 0x10 )
      v30 = (std::string *)v30->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v30->_Mypair._Myval2._Bx._Buf, "BLOOMSAT") )
    {
      v31 = &v29[++i];
      if ( v31->_Mypair._Myval2._Myres >= 0x10 )
        v31 = (std::string *)v31->_Mypair._Myval2._Bx._Ptr;
      v590._Mypair._Myval2._Myres = 15i64;
      v590._Mypair._Myval2._Mysize = 0i64;
      v590._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v31->_Mypair._Myval2._Bx._Buf[0] )
      {
        v32 = -1i64;
        do
          ++v32;
        while ( v31->_Mypair._Myval2._Bx._Buf[v32] );
      }
      else
      {
        v32 = 0i64;
      }
      std::string::assign(&v590, v31->_Mypair._Myval2._Bx._Buf, v32);
      v33 = &v590;
      if ( v590._Mypair._Myval2._Myres >= 0x10 )
        v33 = (std::string *)v590._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v34 = strtof(v33->_Mypair._Myval2._Bx._Buf, &v585);
      if ( v33 == (std::string *)v585 )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      postProcessSettings->bgBloomSettings.bloomSaturation = v34;
      std::string::~string(&v590);
    }
    v35 = line->_Mypair._Myval2._Myfirst;
    v36 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v36->_Mypair._Myval2._Myres >= 0x10 )
      v36 = (std::string *)v36->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v36->_Mypair._Myval2._Bx._Buf, "BLOOMINTENSITY") )
    {
      v37 = &v35[++i];
      if ( v37->_Mypair._Myval2._Myres >= 0x10 )
        v37 = (std::string *)v37->_Mypair._Myval2._Bx._Ptr;
      v591._Mypair._Myval2._Myres = 15i64;
      v591._Mypair._Myval2._Mysize = 0i64;
      v591._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v37->_Mypair._Myval2._Bx._Buf[0] )
      {
        v38 = -1i64;
        do
          ++v38;
        while ( v37->_Mypair._Myval2._Bx._Buf[v38] );
      }
      else
      {
        v38 = 0i64;
      }
      std::string::assign(&v591, v37->_Mypair._Myval2._Bx._Buf, v38);
      v39 = &v591;
      if ( v591._Mypair._Myval2._Myres >= 0x10 )
        v39 = (std::string *)v591._Mypair._Myval2._Bx._Ptr;
      *errno() = 0;
      v40 = strtof(v39->_Mypair._Myval2._Bx._Buf, v586);
      if ( v39 == (std::string *)v586[0] )
        std::_Xinvalid_argument("invalid stof argument");
      if ( *errno() == 34 )
        std::_Xout_of_range("stof argument out of range");
      postProcessSettings->bgBloomSettings.bloomIntensity = v40;
      std::string::~string(&v591);
    }
    v41 = line->_Mypair._Myval2._Myfirst;
    v42 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v42->_Mypair._Myval2._Myres >= 0x10 )
      v42 = (std::string *)v42->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v42->_Mypair._Myval2._Bx._Buf, "BLURSTRENGTH") )
    {
      v43 = &v41[++i];
      if ( v43->_Mypair._Myval2._Myres >= 0x10 )
        v43 = (std::string *)v43->_Mypair._Myval2._Bx._Ptr;
      _Str._Mypair._Myval2._Myres = 15i64;
      _Str._Mypair._Myval2._Mysize = 0i64;
      _Str._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v43->_Mypair._Myval2._Bx._Buf[0] )
      {
        v44 = -1i64;
        do
          ++v44;
        while ( v43->_Mypair._Myval2._Bx._Buf[v44] );
      }
      else
      {
        v44 = 0i64;
      }
      std::string::assign(&_Str, v43->_Mypair._Myval2._Bx._Buf, v44);
      postProcessSettings->bgBloomSettings.blurStrength = std::stof(&_Str, v45);
      std::string::~string(&_Str);
    }
    v46 = line->_Mypair._Myval2._Myfirst;
    v47 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v47->_Mypair._Myval2._Myres >= 0x10 )
      v47 = (std::string *)v47->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v47->_Mypair._Myval2._Bx._Buf, "DOWNSAMPLESCALE") )
    {
      v48 = &v46[++i];
      if ( v48->_Mypair._Myval2._Myres >= 0x10 )
        v48 = (std::string *)v48->_Mypair._Myval2._Bx._Ptr;
      v593._Mypair._Myval2._Myres = 15i64;
      v593._Mypair._Myval2._Mysize = 0i64;
      v593._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v48->_Mypair._Myval2._Bx._Buf[0] )
      {
        v49 = -1i64;
        do
          ++v49;
        while ( v48->_Mypair._Myval2._Bx._Buf[v49] );
      }
      else
      {
        v49 = 0i64;
      }
      std::string::assign(&v593, v48->_Mypair._Myval2._Bx._Buf, v49);
      postProcessSettings->bgBloomSettings.downsampleScale = std::stoi(&v593, v50, v51);
      std::string::~string(&v593);
      if ( postProcessSettings->bgBloomSettings.downsampleScale < 1 )
        postProcessSettings->bgBloomSettings.downsampleScale = 1;
    }
    v52 = line->_Mypair._Myval2._Myfirst;
    v53 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v53->_Mypair._Myval2._Myres >= 0x10 )
      v53 = (std::string *)v53->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v53->_Mypair._Myval2._Bx._Buf, "BLOOMMETHOD") )
    {
      v54 = &v52[++i];
      if ( v54->_Mypair._Myval2._Myres >= 0x10 )
        v54 = (std::string *)v54->_Mypair._Myval2._Bx._Ptr;
      v594._Mypair._Myval2._Myres = 15i64;
      v594._Mypair._Myval2._Mysize = 0i64;
      v594._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v54->_Mypair._Myval2._Bx._Buf[0] )
      {
        v55 = -1i64;
        do
          ++v55;
        while ( v54->_Mypair._Myval2._Bx._Buf[v55] );
      }
      else
      {
        v55 = 0i64;
      }
      std::string::assign(&v594, v54->_Mypair._Myval2._Bx._Buf, v55);
      v58 = std::stoi(&v594, v56, v57);
      std::string::~string(&v594);
      postProcessSettings->bgBloomSettings.bloomMethod = v58 == 1;
    }
    v59 = line->_Mypair._Myval2._Myfirst;
    v60 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v60->_Mypair._Myval2._Myres >= 0x10 )
      v60 = (std::string *)v60->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v60->_Mypair._Myval2._Bx._Buf, "BLOOMQUALITY") )
    {
      v61 = &v59[++i];
      if ( v61->_Mypair._Myval2._Myres >= 0x10 )
        v61 = (std::string *)v61->_Mypair._Myval2._Bx._Ptr;
      v595._Mypair._Myval2._Myres = 15i64;
      v595._Mypair._Myval2._Mysize = 0i64;
      v595._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v61->_Mypair._Myval2._Bx._Buf[0] )
      {
        v62 = -1i64;
        do
          ++v62;
        while ( v61->_Mypair._Myval2._Bx._Buf[v62] );
      }
      else
      {
        v62 = 0i64;
      }
      std::string::assign(&v595, v61->_Mypair._Myval2._Bx._Buf, v62);
      v65 = std::stoi(&v595, v63, v64);
      std::string::~string(&v595);
      postProcessSettings->bgBloomSettings.bloomQuality = v65 == 1;
    }
    v66 = line->_Mypair._Myval2._Myfirst;
    v67 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v67->_Mypair._Myval2._Myres >= 0x10 )
      v67 = (std::string *)v67->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v67->_Mypair._Myval2._Bx._Buf, "BLURSIZE") )
    {
      v68 = &v66[++i];
      if ( v68->_Mypair._Myval2._Myres >= 0x10 )
        v68 = (std::string *)v68->_Mypair._Myval2._Bx._Ptr;
      v596._Mypair._Myval2._Myres = 15i64;
      v596._Mypair._Myval2._Mysize = 0i64;
      v596._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v68->_Mypair._Myval2._Bx._Buf[0] )
      {
        v69 = -1i64;
        do
          ++v69;
        while ( v68->_Mypair._Myval2._Bx._Buf[v69] );
      }
      else
      {
        v69 = 0i64;
      }
      std::string::assign(&v596, v68->_Mypair._Myval2._Bx._Buf, v69);
      postProcessSettings->bgBloomSettings.bloomDownSamplingBlurSize = std::stoi(&v596, v70, v71);
      std::string::~string(&v596);
    }
    v72 = line->_Mypair._Myval2._Myfirst;
    v73 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v73->_Mypair._Myval2._Myres < 0x10 )
      v74 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v74 = (std::string *)v73->_Mypair._Myval2._Bx._Ptr;
    v75 = 0i64;
    while ( 1 )
    {
      v76 = v74->_Mypair._Myval2._Bx._Buf[v75++];
      if ( v76 != aUsefog[v75 - 1] )
        break;
      if ( v75 == 7 )
        goto LABEL_151;
    }
    if ( v73->_Mypair._Myval2._Myres >= 0x10 )
      v73 = (std::string *)v73->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v73->_Mypair._Myval2._Bx._Buf, "USEGROUNDFOG") )
    {
LABEL_151:
      v77 = &v72[++i];
      if ( v77->_Mypair._Myval2._Myres >= 0x10 )
        v77 = (std::string *)v77->_Mypair._Myval2._Bx._Ptr;
      v597._Mypair._Myval2._Myres = 15i64;
      v597._Mypair._Myval2._Mysize = 0i64;
      v597._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v77->_Mypair._Myval2._Bx._Buf[0] )
      {
        v78 = -1i64;
        do
          ++v78;
        while ( v77->_Mypair._Myval2._Bx._Buf[v78] );
      }
      else
      {
        v78 = 0i64;
      }
      std::string::assign(&v597, v77->_Mypair._Myval2._Bx._Buf, v78);
      postProcessSettings->groundFogSettings.fogOn = std::stoi(&v597, v79, v80) != 0;
      std::string::~string(&v597);
    }
    v81 = line->_Mypair._Myval2._Myfirst;
    v82 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v82->_Mypair._Myval2._Myres >= 0x10 )
      v82 = (std::string *)v82->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v82->_Mypair._Myval2._Bx._Buf, "GROUNDFOGCALCTYPE") )
    {
      v83 = (char **)&v81[++i];
      if ( (unsigned __int64)v83[3] >= 0x10 )
        v83 = (char **)*v83;
      v84 = 0i64;
      while ( 1 )
      {
        v85 = *((_BYTE *)v83 + v84++);
        v86 = v85 == aAdd_1[v84 - 1];
        if ( v85 != aAdd_1[v84 - 1] )
          break;
        if ( v84 == 4 )
        {
          v86 = v85 == aAdd_1[3];
          break;
        }
      }
      postProcessSettings->groundFogSettings.calcType = !v86;
    }
    v87 = line->_Mypair._Myval2._Myfirst;
    v88 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v88->_Mypair._Myval2._Myres < 0x10 )
      v89 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v89 = (std::string *)v88->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v89->_Mypair._Myval2._Bx._Buf, "FOGDISTANCE") )
      goto LABEL_175;
    if ( v88->_Mypair._Myval2._Myres >= 0x10 )
      v88 = (std::string *)v88->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v88->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPDISTANCE") )
    {
LABEL_175:
      v90 = &v87[++i];
      if ( v90->_Mypair._Myval2._Myres >= 0x10 )
        v90 = (std::string *)v90->_Mypair._Myval2._Bx._Ptr;
      v598._Mypair._Myval2._Myres = 15i64;
      v598._Mypair._Myval2._Mysize = 0i64;
      v598._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v90->_Mypair._Myval2._Bx._Buf[0] )
      {
        v91 = -1i64;
        do
          ++v91;
        while ( v90->_Mypair._Myval2._Bx._Buf[v91] );
      }
      else
      {
        v91 = 0i64;
      }
      std::string::assign(&v598, v90->_Mypair._Myval2._Bx._Buf, v91);
      postProcessSettings->groundFogSettings.upFogDist = std::stof(&v598, v92);
      std::string::~string(&v598);
    }
    v93 = line->_Mypair._Myval2._Myfirst;
    v94 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v94->_Mypair._Myval2._Myres < 0x10 )
      v95 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v95 = (std::string *)v94->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v95->_Mypair._Myval2._Bx._Buf, "FOGDISTANCEGRADIENT") )
      goto LABEL_189;
    if ( v94->_Mypair._Myval2._Myres >= 0x10 )
      v94 = (std::string *)v94->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v94->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPDISTANCEGRADIENT") )
    {
LABEL_189:
      v96 = &v93[++i];
      if ( v96->_Mypair._Myval2._Myres >= 0x10 )
        v96 = (std::string *)v96->_Mypair._Myval2._Bx._Ptr;
      v599._Mypair._Myval2._Myres = 15i64;
      v599._Mypair._Myval2._Mysize = 0i64;
      v599._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v96->_Mypair._Myval2._Bx._Buf[0] )
      {
        v97 = -1i64;
        do
          ++v97;
        while ( v96->_Mypair._Myval2._Bx._Buf[v97] );
      }
      else
      {
        v97 = 0i64;
      }
      std::string::assign(&v599, v96->_Mypair._Myval2._Bx._Buf, v97);
      postProcessSettings->groundFogSettings.upFogDistExp = std::stof(&v599, v98);
      std::string::~string(&v599);
    }
    v99 = line->_Mypair._Myval2._Myfirst;
    v100 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v100->_Mypair._Myval2._Myres < 0x10 )
      v101 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v101 = (std::string *)v100->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v101->_Mypair._Myval2._Bx._Buf, "FOGHEIGHT") )
      goto LABEL_203;
    if ( v100->_Mypair._Myval2._Myres >= 0x10 )
      v100 = (std::string *)v100->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v100->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPHEIGHT") )
    {
LABEL_203:
      v102 = &v99[++i];
      if ( v102->_Mypair._Myval2._Myres >= 0x10 )
        v102 = (std::string *)v102->_Mypair._Myval2._Bx._Ptr;
      v600._Mypair._Myval2._Myres = 15i64;
      v600._Mypair._Myval2._Mysize = 0i64;
      v600._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v102->_Mypair._Myval2._Bx._Buf[0] )
      {
        v103 = -1i64;
        do
          ++v103;
        while ( v102->_Mypair._Myval2._Bx._Buf[v103] );
      }
      else
      {
        v103 = 0i64;
      }
      std::string::assign(&v600, v102->_Mypair._Myval2._Bx._Buf, v103);
      postProcessSettings->groundFogSettings.upFogHeight = (int)std::stof(&v600, v104);
      std::string::~string(&v600);
    }
    v105 = line->_Mypair._Myval2._Myfirst;
    v106 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v106->_Mypair._Myval2._Myres < 0x10 )
      v107 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v107 = (std::string *)v106->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v107->_Mypair._Myval2._Bx._Buf, "FOGHEIGHTGRADIENT") )
      goto LABEL_217;
    if ( v106->_Mypair._Myval2._Myres >= 0x10 )
      v106 = (std::string *)v106->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v106->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPHEIGHTGRADIENT") )
    {
LABEL_217:
      v108 = &v105[++i];
      if ( v108->_Mypair._Myval2._Myres >= 0x10 )
        v108 = (std::string *)v108->_Mypair._Myval2._Bx._Ptr;
      v601._Mypair._Myval2._Myres = 15i64;
      v601._Mypair._Myval2._Mysize = 0i64;
      v601._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v108->_Mypair._Myval2._Bx._Buf[0] )
      {
        v109 = -1i64;
        do
          ++v109;
        while ( v108->_Mypair._Myval2._Bx._Buf[v109] );
      }
      else
      {
        v109 = 0i64;
      }
      std::string::assign(&v601, v108->_Mypair._Myval2._Bx._Buf, v109);
      postProcessSettings->groundFogSettings.upFogHeightExp = std::stof(&v601, v110);
      std::string::~string(&v601);
    }
    v111 = line->_Mypair._Myval2._Myfirst;
    v112 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v112->_Mypair._Myval2._Myres < 0x10 )
      v113 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v113 = (std::string *)v112->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v113->_Mypair._Myval2._Bx._Buf, "FOGSTRENGTH") )
      goto LABEL_231;
    if ( v112->_Mypair._Myval2._Myres >= 0x10 )
      v112 = (std::string *)v112->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v112->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPSTRENGTH") )
    {
LABEL_231:
      v114 = &v111[++i];
      if ( v114->_Mypair._Myval2._Myres >= 0x10 )
        v114 = (std::string *)v114->_Mypair._Myval2._Bx._Ptr;
      v602._Mypair._Myval2._Myres = 15i64;
      v602._Mypair._Myval2._Mysize = 0i64;
      v602._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v114->_Mypair._Myval2._Bx._Buf[0] )
      {
        v115 = -1i64;
        do
          ++v115;
        while ( v114->_Mypair._Myval2._Bx._Buf[v115] );
      }
      else
      {
        v115 = 0i64;
      }
      std::string::assign(&v602, v114->_Mypair._Myval2._Bx._Buf, v115);
      postProcessSettings->groundFogSettings.upFogStrength = std::stof(&v602, v116);
      std::string::~string(&v602);
    }
    v117 = line->_Mypair._Myval2._Myfirst;
    v118 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v118->_Mypair._Myval2._Myres < 0x10 )
      v119 = &line->_Mypair._Myval2._Myfirst[i];
    else
      v119 = (std::string *)v118->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v119->_Mypair._Myval2._Bx._Buf, "FOGCOLOR") )
      goto LABEL_245;
    if ( v118->_Mypair._Myval2._Myres >= 0x10 )
      v118 = (std::string *)v118->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v118->_Mypair._Myval2._Bx._Buf, "GROUNDFOGUPCOLOR") )
    {
LABEL_245:
      v120 = &v117[i + 1];
      if ( v120->_Mypair._Myval2._Myres >= 0x10 )
        v120 = (std::string *)v120->_Mypair._Myval2._Bx._Ptr;
      v603._Mypair._Myval2._Myres = 15i64;
      v603._Mypair._Myval2._Mysize = 0i64;
      v603._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v120->_Mypair._Myval2._Bx._Buf[0] )
      {
        v121 = -1i64;
        do
          ++v121;
        while ( v120->_Mypair._Myval2._Bx._Buf[v121] );
      }
      else
      {
        v121 = 0i64;
      }
      std::string::assign(&v603, v120->_Mypair._Myval2._Bx._Buf, v121);
      postProcessSettings->groundFogSettings.upFogColour[0] = std::stof(&v603, v122);
      std::string::~string(&v603);
      v123 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v123->_Mypair._Myval2._Myres >= 0x10 )
        v123 = (std::string *)v123->_Mypair._Myval2._Bx._Ptr;
      v604._Mypair._Myval2._Myres = 15i64;
      v604._Mypair._Myval2._Mysize = 0i64;
      v604._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v123->_Mypair._Myval2._Bx._Buf[0] )
      {
        v124 = -1i64;
        do
          ++v124;
        while ( v123->_Mypair._Myval2._Bx._Buf[v124] );
      }
      else
      {
        v124 = 0i64;
      }
      std::string::assign(&v604, v123->_Mypair._Myval2._Bx._Buf, v124);
      postProcessSettings->groundFogSettings.upFogColour[1] = std::stof(&v604, v125);
      std::string::~string(&v604);
      i += 3;
      v126 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v126->_Mypair._Myval2._Myres >= 0x10 )
        v126 = (std::string *)v126->_Mypair._Myval2._Bx._Ptr;
      v605._Mypair._Myval2._Myres = 15i64;
      v605._Mypair._Myval2._Mysize = 0i64;
      v605._Mypair._Myval2._Bx._Buf[0] = 0;
      if ( v126->_Mypair._Myval2._Bx._Buf[0] )
      {
        v127 = -1i64;
        do
          ++v127;
        while ( v126->_Mypair._Myval2._Bx._Buf[v127] );
      }
      else
      {
        v127 = 0i64;
      }
      std::string::assign(&v605, v126->_Mypair._Myval2._Bx._Buf, v127);
      postProcessSettings->groundFogSettings.upFogColour[2] = std::stof(&v605, v128);
      std::string::~string(&v605);
      postProcessSettings->groundFogSettings.upFogColour[3] = 1.0;
    }
    v129 = line->_Mypair._Myval2._Myfirst;
    v130 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v130->_Mypair._Myval2._Myres >= 0x10 )
      v130 = (std::string *)v130->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v130->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNDISTANCE") )
    {
      v131 = &v129[++i];
      if ( v131->_Mypair._Myval2._Myres >= 0x10 )
        v131 = (std::string *)v131->_Mypair._Myval2._Bx._Ptr;
      v606._Mypair._Myval2._Mysize = 0i64;
      v606._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v606, 0, 0i64);
      if ( v131->_Mypair._Myval2._Bx._Buf[0] )
      {
        v132 = -1i64;
        do
          ++v132;
        while ( v131->_Mypair._Myval2._Bx._Buf[v132] );
      }
      else
      {
        v132 = 0i64;
      }
      std::string::assign(&v606, v131->_Mypair._Myval2._Bx._Buf, v132);
      postProcessSettings->groundFogSettings.downFogDist = std::stof(&v606, v133);
      std::string::~string(&v606);
    }
    v134 = line->_Mypair._Myval2._Myfirst;
    v135 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v135->_Mypair._Myval2._Myres >= 0x10 )
      v135 = (std::string *)v135->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v135->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNDISTANCEGRADIENT") )
    {
      v136 = &v134[++i];
      if ( v136->_Mypair._Myval2._Myres >= 0x10 )
        v136 = (std::string *)v136->_Mypair._Myval2._Bx._Ptr;
      v607._Mypair._Myval2._Mysize = 0i64;
      v607._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v607, 0, 0i64);
      if ( v136->_Mypair._Myval2._Bx._Buf[0] )
      {
        v137 = -1i64;
        do
          ++v137;
        while ( v136->_Mypair._Myval2._Bx._Buf[v137] );
      }
      else
      {
        v137 = 0i64;
      }
      std::string::assign(&v607, v136->_Mypair._Myval2._Bx._Buf, v137);
      postProcessSettings->groundFogSettings.downFogDistExp = std::stof(&v607, v138);
      std::string::~string(&v607);
    }
    v139 = line->_Mypair._Myval2._Myfirst;
    v140 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v140->_Mypair._Myval2._Myres >= 0x10 )
      v140 = (std::string *)v140->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v140->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNHEIGHT") )
    {
      v141 = &v139[++i];
      if ( v141->_Mypair._Myval2._Myres >= 0x10 )
        v141 = (std::string *)v141->_Mypair._Myval2._Bx._Ptr;
      v608._Mypair._Myval2._Mysize = 0i64;
      v608._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v608, 0, 0i64);
      if ( v141->_Mypair._Myval2._Bx._Buf[0] )
      {
        v142 = -1i64;
        do
          ++v142;
        while ( v141->_Mypair._Myval2._Bx._Buf[v142] );
      }
      else
      {
        v142 = 0i64;
      }
      std::string::assign(&v608, v141->_Mypair._Myval2._Bx._Buf, v142);
      postProcessSettings->groundFogSettings.downFogHeight = (int)std::stof(&v608, v143);
      std::string::~string(&v608);
    }
    v144 = line->_Mypair._Myval2._Myfirst;
    v145 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v145->_Mypair._Myval2._Myres >= 0x10 )
      v145 = (std::string *)v145->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v145->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNHEIGHTGRADIENT") )
    {
      v146 = &v144[++i];
      if ( v146->_Mypair._Myval2._Myres >= 0x10 )
        v146 = (std::string *)v146->_Mypair._Myval2._Bx._Ptr;
      v609._Mypair._Myval2._Mysize = 0i64;
      v609._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v609, 0, 0i64);
      if ( v146->_Mypair._Myval2._Bx._Buf[0] )
      {
        v147 = -1i64;
        do
          ++v147;
        while ( v146->_Mypair._Myval2._Bx._Buf[v147] );
      }
      else
      {
        v147 = 0i64;
      }
      std::string::assign(&v609, v146->_Mypair._Myval2._Bx._Buf, v147);
      postProcessSettings->groundFogSettings.downFogHeightExp = std::stof(&v609, v148);
      std::string::~string(&v609);
    }
    v149 = line->_Mypair._Myval2._Myfirst;
    v150 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v150->_Mypair._Myval2._Myres >= 0x10 )
      v150 = (std::string *)v150->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v150->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNSTRENGTH") )
    {
      v151 = &v149[++i];
      if ( v151->_Mypair._Myval2._Myres >= 0x10 )
        v151 = (std::string *)v151->_Mypair._Myval2._Bx._Ptr;
      v610._Mypair._Myval2._Mysize = 0i64;
      v610._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v610, 0, 0i64);
      if ( v151->_Mypair._Myval2._Bx._Buf[0] )
      {
        v152 = -1i64;
        do
          ++v152;
        while ( v151->_Mypair._Myval2._Bx._Buf[v152] );
      }
      else
      {
        v152 = 0i64;
      }
      std::string::assign(&v610, v151->_Mypair._Myval2._Bx._Buf, v152);
      postProcessSettings->groundFogSettings.downFogStrength = std::stof(&v610, v153);
      std::string::~string(&v610);
    }
    v154 = line->_Mypair._Myval2._Myfirst;
    v155 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v155->_Mypair._Myval2._Myres >= 0x10 )
      v155 = (std::string *)v155->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v155->_Mypair._Myval2._Bx._Buf, "GROUNDFOGDOWNCOLOR") )
    {
      v156 = &v154[i + 1];
      if ( v156->_Mypair._Myval2._Myres >= 0x10 )
        v156 = (std::string *)v156->_Mypair._Myval2._Bx._Ptr;
      v611._Mypair._Myval2._Mysize = 0i64;
      v611._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v611, 0, 0i64);
      if ( v156->_Mypair._Myval2._Bx._Buf[0] )
      {
        v157 = -1i64;
        do
          ++v157;
        while ( v156->_Mypair._Myval2._Bx._Buf[v157] );
      }
      else
      {
        v157 = 0i64;
      }
      std::string::assign(&v611, v156->_Mypair._Myval2._Bx._Buf, v157);
      postProcessSettings->groundFogSettings.downFogColour[0] = std::stof(&v611, v158);
      std::string::~string(&v611);
      v159 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v159->_Mypair._Myval2._Myres >= 0x10 )
        v159 = (std::string *)v159->_Mypair._Myval2._Bx._Ptr;
      v612._Mypair._Myval2._Mysize = 0i64;
      v612._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v612, 0, 0i64);
      if ( v159->_Mypair._Myval2._Bx._Buf[0] )
      {
        v160 = -1i64;
        do
          ++v160;
        while ( v159->_Mypair._Myval2._Bx._Buf[v160] );
      }
      else
      {
        v160 = 0i64;
      }
      std::string::assign(&v612, v159->_Mypair._Myval2._Bx._Buf, v160);
      postProcessSettings->groundFogSettings.downFogColour[1] = std::stof(&v612, v161);
      std::string::~string(&v612);
      i += 3;
      v162 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v162->_Mypair._Myval2._Myres >= 0x10 )
        v162 = (std::string *)v162->_Mypair._Myval2._Bx._Ptr;
      v613._Mypair._Myval2._Mysize = 0i64;
      v613._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v613, 0, 0i64);
      if ( v162->_Mypair._Myval2._Bx._Buf[0] )
      {
        v163 = -1i64;
        do
          ++v163;
        while ( v162->_Mypair._Myval2._Bx._Buf[v163] );
      }
      else
      {
        v163 = 0i64;
      }
      std::string::assign(&v613, v162->_Mypair._Myval2._Bx._Buf, v163);
      postProcessSettings->groundFogSettings.downFogColour[2] = std::stof(&v613, v164);
      std::string::~string(&v613);
      postProcessSettings->groundFogSettings.downFogColour[3] = 1.0;
    }
    v165 = line->_Mypair._Myval2._Myfirst;
    v166 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v166->_Mypair._Myval2._Myres >= 0x10 )
      v166 = (std::string *)v166->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v166->_Mypair._Myval2._Bx._Buf, "USESKYFOG") )
    {
      v167 = &v165[++i];
      if ( v167->_Mypair._Myval2._Myres >= 0x10 )
        v167 = (std::string *)v167->_Mypair._Myval2._Bx._Ptr;
      v614._Mypair._Myval2._Mysize = 0i64;
      v614._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v614, 0, 0i64);
      if ( v167->_Mypair._Myval2._Bx._Buf[0] )
      {
        v168 = -1i64;
        do
          ++v168;
        while ( v167->_Mypair._Myval2._Bx._Buf[v168] );
      }
      else
      {
        v168 = 0i64;
      }
      std::string::assign(&v614, v167->_Mypair._Myval2._Bx._Buf, v168);
      postProcessSettings->skyFogSettings.fogOn = std::stoi(&v614, v169, v170) != 0;
      std::string::~string(&v614);
    }
    v171 = line->_Mypair._Myval2._Myfirst;
    v172 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v172->_Mypair._Myval2._Myres >= 0x10 )
      v172 = (std::string *)v172->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v172->_Mypair._Myval2._Bx._Buf, "SKYFOGCALCTYPE") )
    {
      v173 = (char **)&v171[++i];
      if ( (unsigned __int64)v173[3] >= 0x10 )
        v173 = (char **)*v173;
      v174 = 0i64;
      while ( 1 )
      {
        v175 = *((_BYTE *)v173 + v174++);
        v176 = v175 == aAdd_1[v174 - 1];
        if ( v175 != aAdd_1[v174 - 1] )
          break;
        if ( v174 == 4 )
        {
          v176 = v175 == aAdd_1[3];
          break;
        }
      }
      postProcessSettings->skyFogSettings.calcType = !v176;
    }
    v177 = line->_Mypair._Myval2._Myfirst;
    v178 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v178->_Mypair._Myval2._Myres >= 0x10 )
      v178 = (std::string *)v178->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v178->_Mypair._Myval2._Bx._Buf, "SKYFOGUPDISTANCE") )
    {
      v179 = &v177[++i];
      if ( v179->_Mypair._Myval2._Myres >= 0x10 )
        v179 = (std::string *)v179->_Mypair._Myval2._Bx._Ptr;
      v615._Mypair._Myval2._Mysize = 0i64;
      v615._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v615, 0, 0i64);
      if ( v179->_Mypair._Myval2._Bx._Buf[0] )
      {
        v180 = -1i64;
        do
          ++v180;
        while ( v179->_Mypair._Myval2._Bx._Buf[v180] );
      }
      else
      {
        v180 = 0i64;
      }
      std::string::assign(&v615, v179->_Mypair._Myval2._Bx._Buf, v180);
      postProcessSettings->skyFogSettings.upFogDist = std::stof(&v615, v181);
      std::string::~string(&v615);
    }
    v182 = line->_Mypair._Myval2._Myfirst;
    v183 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v183->_Mypair._Myval2._Myres >= 0x10 )
      v183 = (std::string *)v183->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v183->_Mypair._Myval2._Bx._Buf, "SKYFOGUPDISTANCEGRADIENT") )
    {
      v184 = &v182[++i];
      if ( v184->_Mypair._Myval2._Myres >= 0x10 )
        v184 = (std::string *)v184->_Mypair._Myval2._Bx._Ptr;
      v616._Mypair._Myval2._Mysize = 0i64;
      v616._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v616, 0, 0i64);
      if ( v184->_Mypair._Myval2._Bx._Buf[0] )
      {
        v185 = -1i64;
        do
          ++v185;
        while ( v184->_Mypair._Myval2._Bx._Buf[v185] );
      }
      else
      {
        v185 = 0i64;
      }
      std::string::assign(&v616, v184->_Mypair._Myval2._Bx._Buf, v185);
      postProcessSettings->skyFogSettings.upFogDistExp = std::stof(&v616, v186);
      std::string::~string(&v616);
    }
    v187 = line->_Mypair._Myval2._Myfirst;
    v188 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v188->_Mypair._Myval2._Myres >= 0x10 )
      v188 = (std::string *)v188->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v188->_Mypair._Myval2._Bx._Buf, "SKYFOGUPHEIGHT") )
    {
      v189 = &v187[++i];
      if ( v189->_Mypair._Myval2._Myres >= 0x10 )
        v189 = (std::string *)v189->_Mypair._Myval2._Bx._Ptr;
      v617._Mypair._Myval2._Mysize = 0i64;
      v617._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v617, 0, 0i64);
      if ( v189->_Mypair._Myval2._Bx._Buf[0] )
      {
        v190 = -1i64;
        do
          ++v190;
        while ( v189->_Mypair._Myval2._Bx._Buf[v190] );
      }
      else
      {
        v190 = 0i64;
      }
      std::string::assign(&v617, v189->_Mypair._Myval2._Bx._Buf, v190);
      postProcessSettings->skyFogSettings.upFogHeight = (int)std::stof(&v617, v191);
      std::string::~string(&v617);
    }
    v192 = line->_Mypair._Myval2._Myfirst;
    v193 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v193->_Mypair._Myval2._Myres >= 0x10 )
      v193 = (std::string *)v193->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v193->_Mypair._Myval2._Bx._Buf, "SKYFOGUPHEIGHTGRADIENT") )
    {
      v194 = &v192[++i];
      if ( v194->_Mypair._Myval2._Myres >= 0x10 )
        v194 = (std::string *)v194->_Mypair._Myval2._Bx._Ptr;
      v618._Mypair._Myval2._Mysize = 0i64;
      v618._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v618, 0, 0i64);
      if ( v194->_Mypair._Myval2._Bx._Buf[0] )
      {
        v195 = -1i64;
        do
          ++v195;
        while ( v194->_Mypair._Myval2._Bx._Buf[v195] );
      }
      else
      {
        v195 = 0i64;
      }
      std::string::assign(&v618, v194->_Mypair._Myval2._Bx._Buf, v195);
      postProcessSettings->skyFogSettings.upFogHeightExp = std::stof(&v618, v196);
      std::string::~string(&v618);
    }
    v197 = line->_Mypair._Myval2._Myfirst;
    v198 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v198->_Mypair._Myval2._Myres >= 0x10 )
      v198 = (std::string *)v198->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v198->_Mypair._Myval2._Bx._Buf, "SKYFOGUPSTRENGTH") )
    {
      v199 = &v197[++i];
      if ( v199->_Mypair._Myval2._Myres >= 0x10 )
        v199 = (std::string *)v199->_Mypair._Myval2._Bx._Ptr;
      v619._Mypair._Myval2._Mysize = 0i64;
      v619._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v619, 0, 0i64);
      if ( v199->_Mypair._Myval2._Bx._Buf[0] )
      {
        v200 = -1i64;
        do
          ++v200;
        while ( v199->_Mypair._Myval2._Bx._Buf[v200] );
      }
      else
      {
        v200 = 0i64;
      }
      std::string::assign(&v619, v199->_Mypair._Myval2._Bx._Buf, v200);
      postProcessSettings->skyFogSettings.upFogStrength = std::stof(&v619, v201);
      std::string::~string(&v619);
    }
    v202 = line->_Mypair._Myval2._Myfirst;
    v203 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v203->_Mypair._Myval2._Myres >= 0x10 )
      v203 = (std::string *)v203->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v203->_Mypair._Myval2._Bx._Buf, "SKYFOGUPCOLOR") )
    {
      v204 = &v202[i + 1];
      if ( v204->_Mypair._Myval2._Myres >= 0x10 )
        v204 = (std::string *)v204->_Mypair._Myval2._Bx._Ptr;
      v620._Mypair._Myval2._Mysize = 0i64;
      v620._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v620, 0, 0i64);
      if ( v204->_Mypair._Myval2._Bx._Buf[0] )
      {
        v205 = -1i64;
        do
          ++v205;
        while ( v204->_Mypair._Myval2._Bx._Buf[v205] );
      }
      else
      {
        v205 = 0i64;
      }
      std::string::assign(&v620, v204->_Mypair._Myval2._Bx._Buf, v205);
      postProcessSettings->skyFogSettings.upFogColour[0] = std::stof(&v620, v206);
      std::string::~string(&v620);
      v207 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v207->_Mypair._Myval2._Myres >= 0x10 )
        v207 = (std::string *)v207->_Mypair._Myval2._Bx._Ptr;
      v621._Mypair._Myval2._Mysize = 0i64;
      v621._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v621, 0, 0i64);
      if ( v207->_Mypair._Myval2._Bx._Buf[0] )
      {
        v208 = -1i64;
        do
          ++v208;
        while ( v207->_Mypair._Myval2._Bx._Buf[v208] );
      }
      else
      {
        v208 = 0i64;
      }
      std::string::assign(&v621, v207->_Mypair._Myval2._Bx._Buf, v208);
      postProcessSettings->skyFogSettings.upFogColour[1] = std::stof(&v621, v209);
      std::string::~string(&v621);
      i += 3;
      v210 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v210->_Mypair._Myval2._Myres >= 0x10 )
        v210 = (std::string *)v210->_Mypair._Myval2._Bx._Ptr;
      v622._Mypair._Myval2._Mysize = 0i64;
      v622._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v622, 0, 0i64);
      if ( v210->_Mypair._Myval2._Bx._Buf[0] )
      {
        v211 = -1i64;
        do
          ++v211;
        while ( v210->_Mypair._Myval2._Bx._Buf[v211] );
      }
      else
      {
        v211 = 0i64;
      }
      std::string::assign(&v622, v210->_Mypair._Myval2._Bx._Buf, v211);
      postProcessSettings->skyFogSettings.upFogColour[2] = std::stof(&v622, v212);
      std::string::~string(&v622);
      postProcessSettings->skyFogSettings.upFogColour[3] = 1.0;
    }
    v213 = line->_Mypair._Myval2._Myfirst;
    v214 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v214->_Mypair._Myval2._Myres >= 0x10 )
      v214 = (std::string *)v214->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v214->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNDISTANCE") )
    {
      v215 = &v213[++i];
      if ( v215->_Mypair._Myval2._Myres >= 0x10 )
        v215 = (std::string *)v215->_Mypair._Myval2._Bx._Ptr;
      v623._Mypair._Myval2._Mysize = 0i64;
      v623._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v623, 0, 0i64);
      if ( v215->_Mypair._Myval2._Bx._Buf[0] )
      {
        v216 = -1i64;
        do
          ++v216;
        while ( v215->_Mypair._Myval2._Bx._Buf[v216] );
      }
      else
      {
        v216 = 0i64;
      }
      std::string::assign(&v623, v215->_Mypair._Myval2._Bx._Buf, v216);
      postProcessSettings->skyFogSettings.downFogDist = std::stof(&v623, v217);
      std::string::~string(&v623);
    }
    v218 = line->_Mypair._Myval2._Myfirst;
    v219 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v219->_Mypair._Myval2._Myres >= 0x10 )
      v219 = (std::string *)v219->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v219->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNDISTANCEGRADIENT") )
    {
      v220 = &v218[++i];
      if ( v220->_Mypair._Myval2._Myres >= 0x10 )
        v220 = (std::string *)v220->_Mypair._Myval2._Bx._Ptr;
      v624._Mypair._Myval2._Mysize = 0i64;
      v624._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v624, 0, 0i64);
      if ( v220->_Mypair._Myval2._Bx._Buf[0] )
      {
        v221 = -1i64;
        do
          ++v221;
        while ( v220->_Mypair._Myval2._Bx._Buf[v221] );
      }
      else
      {
        v221 = 0i64;
      }
      std::string::assign(&v624, v220->_Mypair._Myval2._Bx._Buf, v221);
      postProcessSettings->skyFogSettings.downFogDistExp = std::stof(&v624, v222);
      std::string::~string(&v624);
    }
    v223 = line->_Mypair._Myval2._Myfirst;
    v224 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v224->_Mypair._Myval2._Myres >= 0x10 )
      v224 = (std::string *)v224->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v224->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNHEIGHT") )
    {
      v225 = &v223[++i];
      if ( v225->_Mypair._Myval2._Myres >= 0x10 )
        v225 = (std::string *)v225->_Mypair._Myval2._Bx._Ptr;
      v625._Mypair._Myval2._Mysize = 0i64;
      v625._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v625, 0, 0i64);
      if ( v225->_Mypair._Myval2._Bx._Buf[0] )
      {
        v226 = -1i64;
        do
          ++v226;
        while ( v225->_Mypair._Myval2._Bx._Buf[v226] );
      }
      else
      {
        v226 = 0i64;
      }
      std::string::assign(&v625, v225->_Mypair._Myval2._Bx._Buf, v226);
      postProcessSettings->skyFogSettings.downFogHeight = (int)std::stof(&v625, v227);
      std::string::~string(&v625);
    }
    v228 = line->_Mypair._Myval2._Myfirst;
    v229 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v229->_Mypair._Myval2._Myres >= 0x10 )
      v229 = (std::string *)v229->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v229->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNHEIGHTGRADIENT") )
    {
      v230 = &v228[++i];
      if ( v230->_Mypair._Myval2._Myres >= 0x10 )
        v230 = (std::string *)v230->_Mypair._Myval2._Bx._Ptr;
      v626._Mypair._Myval2._Mysize = 0i64;
      v626._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v626, 0, 0i64);
      if ( v230->_Mypair._Myval2._Bx._Buf[0] )
      {
        v231 = -1i64;
        do
          ++v231;
        while ( v230->_Mypair._Myval2._Bx._Buf[v231] );
      }
      else
      {
        v231 = 0i64;
      }
      std::string::assign(&v626, v230->_Mypair._Myval2._Bx._Buf, v231);
      postProcessSettings->skyFogSettings.downFogHeightExp = std::stof(&v626, v232);
      std::string::~string(&v626);
    }
    v233 = line->_Mypair._Myval2._Myfirst;
    v234 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v234->_Mypair._Myval2._Myres >= 0x10 )
      v234 = (std::string *)v234->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v234->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNSTRENGTH") )
    {
      v235 = &v233[++i];
      if ( v235->_Mypair._Myval2._Myres >= 0x10 )
        v235 = (std::string *)v235->_Mypair._Myval2._Bx._Ptr;
      v627._Mypair._Myval2._Mysize = 0i64;
      v627._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v627, 0, 0i64);
      if ( v235->_Mypair._Myval2._Bx._Buf[0] )
      {
        v236 = -1i64;
        do
          ++v236;
        while ( v235->_Mypair._Myval2._Bx._Buf[v236] );
      }
      else
      {
        v236 = 0i64;
      }
      std::string::assign(&v627, v235->_Mypair._Myval2._Bx._Buf, v236);
      postProcessSettings->skyFogSettings.downFogStrength = std::stof(&v627, v237);
      std::string::~string(&v627);
    }
    v238 = line->_Mypair._Myval2._Myfirst;
    v239 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v239->_Mypair._Myval2._Myres >= 0x10 )
      v239 = (std::string *)v239->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v239->_Mypair._Myval2._Bx._Buf, "SKYFOGDOWNCOLOR") )
    {
      v240 = &v238[i + 1];
      if ( v240->_Mypair._Myval2._Myres >= 0x10 )
        v240 = (std::string *)v240->_Mypair._Myval2._Bx._Ptr;
      v628._Mypair._Myval2._Mysize = 0i64;
      v628._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v628, 0, 0i64);
      if ( v240->_Mypair._Myval2._Bx._Buf[0] )
      {
        v241 = -1i64;
        do
          ++v241;
        while ( v240->_Mypair._Myval2._Bx._Buf[v241] );
      }
      else
      {
        v241 = 0i64;
      }
      std::string::assign(&v628, v240->_Mypair._Myval2._Bx._Buf, v241);
      postProcessSettings->skyFogSettings.downFogColour[0] = std::stof(&v628, v242);
      std::string::~string(&v628);
      v243 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v243->_Mypair._Myval2._Myres >= 0x10 )
        v243 = (std::string *)v243->_Mypair._Myval2._Bx._Ptr;
      v629._Mypair._Myval2._Mysize = 0i64;
      v629._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v629, 0, 0i64);
      if ( v243->_Mypair._Myval2._Bx._Buf[0] )
      {
        v244 = -1i64;
        do
          ++v244;
        while ( v243->_Mypair._Myval2._Bx._Buf[v244] );
      }
      else
      {
        v244 = 0i64;
      }
      std::string::assign(&v629, v243->_Mypair._Myval2._Bx._Buf, v244);
      postProcessSettings->skyFogSettings.downFogColour[1] = std::stof(&v629, v245);
      std::string::~string(&v629);
      i += 3;
      v246 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v246->_Mypair._Myval2._Myres >= 0x10 )
        v246 = (std::string *)v246->_Mypair._Myval2._Bx._Ptr;
      v630._Mypair._Myval2._Mysize = 0i64;
      v630._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v630, 0, 0i64);
      if ( v246->_Mypair._Myval2._Bx._Buf[0] )
      {
        v247 = -1i64;
        do
          ++v247;
        while ( v246->_Mypair._Myval2._Bx._Buf[v247] );
      }
      else
      {
        v247 = 0i64;
      }
      std::string::assign(&v630, v246->_Mypair._Myval2._Bx._Buf, v247);
      postProcessSettings->skyFogSettings.downFogColour[2] = std::stof(&v630, v248);
      std::string::~string(&v630);
      postProcessSettings->skyFogSettings.downFogColour[3] = 1.0;
    }
    v249 = line->_Mypair._Myval2._Myfirst;
    v250 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v250->_Mypair._Myval2._Myres >= 0x10 )
      v250 = (std::string *)v250->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v250->_Mypair._Myval2._Bx._Buf, "USEWATER") )
    {
      v251 = &v249[++i];
      if ( v251->_Mypair._Myval2._Myres >= 0x10 )
        v251 = (std::string *)v251->_Mypair._Myval2._Bx._Ptr;
      v631._Mypair._Myval2._Mysize = 0i64;
      v631._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v631, 0, 0i64);
      if ( v251->_Mypair._Myval2._Bx._Buf[0] )
      {
        v252 = -1i64;
        do
          ++v252;
        while ( v251->_Mypair._Myval2._Bx._Buf[v252] );
      }
      else
      {
        v252 = 0i64;
      }
      std::string::assign(&v631, v251->_Mypair._Myval2._Bx._Buf, v252);
      postProcessSettings->waterSurfaceSettings.shaderOn = std::stoi(&v631, v253, v254) != 0;
      std::string::~string(&v631);
    }
    v255 = line->_Mypair._Myval2._Myfirst;
    v256 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v256->_Mypair._Myval2._Myres >= 0x10 )
      v256 = (std::string *)v256->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v256->_Mypair._Myval2._Bx._Buf, "WATERTRANS") )
    {
      v257 = &v255[++i];
      if ( v257->_Mypair._Myval2._Myres >= 0x10 )
        v257 = (std::string *)v257->_Mypair._Myval2._Bx._Ptr;
      v632._Mypair._Myval2._Mysize = 0i64;
      v632._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v632, 0, 0i64);
      if ( v257->_Mypair._Myval2._Bx._Buf[0] )
      {
        v258 = -1i64;
        do
          ++v258;
        while ( v257->_Mypair._Myval2._Bx._Buf[v258] );
      }
      else
      {
        v258 = 0i64;
      }
      std::string::assign(&v632, v257->_Mypair._Myval2._Bx._Buf, v258);
      postProcessSettings->waterSurfaceSettings.waterTranslation = std::stof(&v632, v259);
      std::string::~string(&v632);
    }
    v260 = line->_Mypair._Myval2._Myfirst;
    v261 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v261->_Mypair._Myval2._Myres >= 0x10 )
      v261 = (std::string *)v261->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v261->_Mypair._Myval2._Bx._Buf, "USEREFLECTION") )
    {
      v262 = &v260[++i];
      if ( v262->_Mypair._Myval2._Myres >= 0x10 )
        v262 = (std::string *)v262->_Mypair._Myval2._Bx._Ptr;
      v633._Mypair._Myval2._Mysize = 0i64;
      v633._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v633, 0, 0i64);
      if ( v262->_Mypair._Myval2._Bx._Buf[0] )
      {
        v263 = -1i64;
        do
          ++v263;
        while ( v262->_Mypair._Myval2._Bx._Buf[v263] );
      }
      else
      {
        v263 = 0i64;
      }
      std::string::assign(&v633, v262->_Mypair._Myval2._Bx._Buf, v263);
      postProcessSettings->waterSurfaceSettings.useReflection = std::stoi(&v633, v264, v265) != 0;
      std::string::~string(&v633);
    }
    v266 = line->_Mypair._Myval2._Myfirst;
    v267 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v267->_Mypair._Myval2._Myres >= 0x10 )
      v267 = (std::string *)v267->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v267->_Mypair._Myval2._Bx._Buf, "REFLECTSCALE") )
    {
      v268 = &v266[++i];
      if ( v268->_Mypair._Myval2._Myres >= 0x10 )
        v268 = (std::string *)v268->_Mypair._Myval2._Bx._Ptr;
      v634._Mypair._Myval2._Mysize = 0i64;
      v634._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v634, 0, 0i64);
      if ( v268->_Mypair._Myval2._Bx._Buf[0] )
      {
        v269 = -1i64;
        do
          ++v269;
        while ( v268->_Mypair._Myval2._Bx._Buf[v269] );
      }
      else
      {
        v269 = 0i64;
      }
      std::string::assign(&v634, v268->_Mypair._Myval2._Bx._Buf, v269);
      postProcessSettings->waterSurfaceSettings.reflectScale = std::stof(&v634, v270);
      std::string::~string(&v634);
    }
    v271 = line->_Mypair._Myval2._Myfirst;
    v272 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v272->_Mypair._Myval2._Myres >= 0x10 )
      v272 = (std::string *)v272->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v272->_Mypair._Myval2._Bx._Buf, "WINDDIRECTION") )
    {
      v273 = &v271[i + 1];
      if ( v273->_Mypair._Myval2._Myres >= 0x10 )
        v273 = (std::string *)v273->_Mypair._Myval2._Bx._Ptr;
      v635._Mypair._Myval2._Mysize = 0i64;
      v635._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v635, 0, 0i64);
      if ( v273->_Mypair._Myval2._Bx._Buf[0] )
      {
        v274 = -1i64;
        do
          ++v274;
        while ( v273->_Mypair._Myval2._Bx._Buf[v274] );
      }
      else
      {
        v274 = 0i64;
      }
      std::string::assign(&v635, v273->_Mypair._Myval2._Bx._Buf, v274);
      postProcessSettings->waterSurfaceSettings.windDirection[0] = std::stof(&v635, v275);
      std::string::~string(&v635);
      v276 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v276->_Mypair._Myval2._Myres >= 0x10 )
        v276 = (std::string *)v276->_Mypair._Myval2._Bx._Ptr;
      v636._Mypair._Myval2._Mysize = 0i64;
      v636._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v636, 0, 0i64);
      if ( v276->_Mypair._Myval2._Bx._Buf[0] )
      {
        v277 = -1i64;
        do
          ++v277;
        while ( v276->_Mypair._Myval2._Bx._Buf[v277] );
      }
      else
      {
        v277 = 0i64;
      }
      std::string::assign(&v636, v276->_Mypair._Myval2._Bx._Buf, v277);
      postProcessSettings->waterSurfaceSettings.windDirection[1] = std::stof(&v636, v278);
      std::string::~string(&v636);
      i += 3;
      v279 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v279->_Mypair._Myval2._Myres >= 0x10 )
        v279 = (std::string *)v279->_Mypair._Myval2._Bx._Ptr;
      v637._Mypair._Myval2._Mysize = 0i64;
      v637._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v637, 0, 0i64);
      if ( v279->_Mypair._Myval2._Bx._Buf[0] )
      {
        v280 = -1i64;
        do
          ++v280;
        while ( v279->_Mypair._Myval2._Bx._Buf[v280] );
      }
      else
      {
        v280 = 0i64;
      }
      std::string::assign(&v637, v279->_Mypair._Myval2._Bx._Buf, v280);
      postProcessSettings->waterSurfaceSettings.windDirection[2] = std::stof(&v637, v281);
      std::string::~string(&v637);
      postProcessSettings->waterSurfaceSettings.windDirection[3] = 1.0;
    }
    v282 = line->_Mypair._Myval2._Myfirst;
    v283 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v283->_Mypair._Myval2._Myres >= 0x10 )
      v283 = (std::string *)v283->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v283->_Mypair._Myval2._Bx._Buf, "WATERCOLOR") )
    {
      v284 = &v282[i + 1];
      if ( v284->_Mypair._Myval2._Myres >= 0x10 )
        v284 = (std::string *)v284->_Mypair._Myval2._Bx._Ptr;
      v638._Mypair._Myval2._Mysize = 0i64;
      v638._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v638, 0, 0i64);
      if ( v284->_Mypair._Myval2._Bx._Buf[0] )
      {
        v285 = -1i64;
        do
          ++v285;
        while ( v284->_Mypair._Myval2._Bx._Buf[v285] );
      }
      else
      {
        v285 = 0i64;
      }
      std::string::assign(&v638, v284->_Mypair._Myval2._Bx._Buf, v285);
      postProcessSettings->waterSurfaceSettings.waterCol[0] = std::stof(&v638, v286);
      std::string::~string(&v638);
      v287 = &line->_Mypair._Myval2._Myfirst[i + 2];
      if ( v287->_Mypair._Myval2._Myres >= 0x10 )
        v287 = (std::string *)v287->_Mypair._Myval2._Bx._Ptr;
      v639._Mypair._Myval2._Mysize = 0i64;
      v639._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v639, 0, 0i64);
      if ( v287->_Mypair._Myval2._Bx._Buf[0] )
      {
        v288 = -1i64;
        do
          ++v288;
        while ( v287->_Mypair._Myval2._Bx._Buf[v288] );
      }
      else
      {
        v288 = 0i64;
      }
      std::string::assign(&v639, v287->_Mypair._Myval2._Bx._Buf, v288);
      postProcessSettings->waterSurfaceSettings.waterCol[1] = std::stof(&v639, v289);
      std::string::~string(&v639);
      i += 3;
      v290 = &line->_Mypair._Myval2._Myfirst[i];
      if ( v290->_Mypair._Myval2._Myres >= 0x10 )
        v290 = (std::string *)v290->_Mypair._Myval2._Bx._Ptr;
      v640._Mypair._Myval2._Mysize = 0i64;
      v640._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v640, 0, 0i64);
      if ( v290->_Mypair._Myval2._Bx._Buf[0] )
      {
        v291 = -1i64;
        do
          ++v291;
        while ( v290->_Mypair._Myval2._Bx._Buf[v291] );
      }
      else
      {
        v291 = 0i64;
      }
      std::string::assign(&v640, v290->_Mypair._Myval2._Bx._Buf, v291);
      postProcessSettings->waterSurfaceSettings.waterCol[2] = std::stof(&v640, v292);
      std::string::~string(&v640);
    }
    v293 = line->_Mypair._Myval2._Myfirst;
    v294 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v294->_Mypair._Myval2._Myres >= 0x10 )
      v294 = (std::string *)v294->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v294->_Mypair._Myval2._Bx._Buf, "USESCREENFILTER") )
    {
      v295 = &v293[++i];
      if ( v295->_Mypair._Myval2._Myres >= 0x10 )
        v295 = (std::string *)v295->_Mypair._Myval2._Bx._Ptr;
      v641._Mypair._Myval2._Mysize = 0i64;
      v641._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v641, 0, 0i64);
      if ( v295->_Mypair._Myval2._Bx._Buf[0] )
      {
        v296 = -1i64;
        do
          ++v296;
        while ( v295->_Mypair._Myval2._Bx._Buf[v296] );
      }
      else
      {
        v296 = 0i64;
      }
      std::string::assign(&v641, v295->_Mypair._Myval2._Bx._Buf, v296);
      postProcessSettings->screenFilter.FilterOn = std::stoi(&v641, v297, v298);
      std::string::~string(&v641);
    }
    v299 = line->_Mypair._Myval2._Myfirst;
    v300 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v300->_Mypair._Myval2._Myres >= 0x10 )
      v300 = (std::string *)v300->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v300->_Mypair._Myval2._Bx._Buf, "USEBRISATCON") )
    {
      v301 = &v299[++i];
      if ( v301->_Mypair._Myval2._Myres >= 0x10 )
        v301 = (std::string *)v301->_Mypair._Myval2._Bx._Ptr;
      v642._Mypair._Myval2._Mysize = 0i64;
      v642._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v642, 0, 0i64);
      if ( v301->_Mypair._Myval2._Bx._Buf[0] )
      {
        v302 = -1i64;
        do
          ++v302;
        while ( v301->_Mypair._Myval2._Bx._Buf[v302] );
      }
      else
      {
        v302 = 0i64;
      }
      std::string::assign(&v642, v301->_Mypair._Myval2._Bx._Buf, v302);
      postProcessSettings->screenFilter.BriSatConOn = std::stoi(&v642, v303, v304);
      std::string::~string(&v642);
    }
    v305 = line->_Mypair._Myval2._Myfirst;
    v306 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v306->_Mypair._Myval2._Myres >= 0x10 )
      v306 = (std::string *)v306->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v306->_Mypair._Myval2._Bx._Buf, "BRIGHTNESS") )
    {
      v307 = &v305[++i];
      if ( v307->_Mypair._Myval2._Myres >= 0x10 )
        v307 = (std::string *)v307->_Mypair._Myval2._Bx._Ptr;
      v643._Mypair._Myval2._Mysize = 0i64;
      v643._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v643, 0, 0i64);
      if ( v307->_Mypair._Myval2._Bx._Buf[0] )
      {
        v308 = -1i64;
        do
          ++v308;
        while ( v307->_Mypair._Myval2._Bx._Buf[v308] );
      }
      else
      {
        v308 = 0i64;
      }
      std::string::assign(&v643, v307->_Mypair._Myval2._Bx._Buf, v308);
      postProcessSettings->screenFilter.Brightness = std::stof(&v643, v309);
      std::string::~string(&v643);
    }
    v310 = line->_Mypair._Myval2._Myfirst;
    v311 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v311->_Mypair._Myval2._Myres >= 0x10 )
      v311 = (std::string *)v311->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v311->_Mypair._Myval2._Bx._Buf, "SATURATION") )
    {
      v312 = &v310[++i];
      if ( v312->_Mypair._Myval2._Myres >= 0x10 )
        v312 = (std::string *)v312->_Mypair._Myval2._Bx._Ptr;
      v644._Mypair._Myval2._Mysize = 0i64;
      v644._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v644, 0, 0i64);
      if ( v312->_Mypair._Myval2._Bx._Buf[0] )
      {
        v313 = -1i64;
        do
          ++v313;
        while ( v312->_Mypair._Myval2._Bx._Buf[v313] );
      }
      else
      {
        v313 = 0i64;
      }
      std::string::assign(&v644, v312->_Mypair._Myval2._Bx._Buf, v313);
      postProcessSettings->screenFilter.Saturation = std::stof(&v644, v314);
      std::string::~string(&v644);
    }
    v315 = line->_Mypair._Myval2._Myfirst;
    v316 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v316->_Mypair._Myval2._Myres >= 0x10 )
      v316 = (std::string *)v316->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v316->_Mypair._Myval2._Bx._Buf, "CONTRAST") )
    {
      v317 = &v315[++i];
      if ( v317->_Mypair._Myval2._Myres >= 0x10 )
        v317 = (std::string *)v317->_Mypair._Myval2._Bx._Ptr;
      v645._Mypair._Myval2._Mysize = 0i64;
      v645._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v645, 0, 0i64);
      if ( v317->_Mypair._Myval2._Bx._Buf[0] )
      {
        v318 = -1i64;
        do
          ++v318;
        while ( v317->_Mypair._Myval2._Bx._Buf[v318] );
      }
      else
      {
        v318 = 0i64;
      }
      std::string::assign(&v645, v317->_Mypair._Myval2._Bx._Buf, v318);
      postProcessSettings->screenFilter.Contrast = std::stof(&v645, v319);
      std::string::~string(&v645);
    }
    v320 = line->_Mypair._Myval2._Myfirst;
    v321 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v321->_Mypair._Myval2._Myres >= 0x10 )
      v321 = (std::string *)v321->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v321->_Mypair._Myval2._Bx._Buf, "USEPSLEVELS") )
    {
      v322 = &v320[++i];
      if ( v322->_Mypair._Myval2._Myres >= 0x10 )
        v322 = (std::string *)v322->_Mypair._Myval2._Bx._Ptr;
      v646._Mypair._Myval2._Mysize = 0i64;
      v646._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v646, 0, 0i64);
      if ( v322->_Mypair._Myval2._Bx._Buf[0] )
      {
        v323 = -1i64;
        do
          ++v323;
        while ( v322->_Mypair._Myval2._Bx._Buf[v323] );
      }
      else
      {
        v323 = 0i64;
      }
      std::string::assign(&v646, v322->_Mypair._Myval2._Bx._Buf, v323);
      postProcessSettings->screenFilter.PSLevelsOn = std::stoi(&v646, v324, v325);
      std::string::~string(&v646);
    }
    v326 = line->_Mypair._Myval2._Myfirst;
    v327 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v327->_Mypair._Myval2._Myres >= 0x10 )
      v327 = (std::string *)v327->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v327->_Mypair._Myval2._Bx._Buf, "PSLEVELSINBLACK") )
    {
      v328 = &v326[++i];
      if ( v328->_Mypair._Myval2._Myres >= 0x10 )
        v328 = (std::string *)v328->_Mypair._Myval2._Bx._Ptr;
      v647._Mypair._Myval2._Mysize = 0i64;
      v647._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v647, 0, 0i64);
      if ( v328->_Mypair._Myval2._Bx._Buf[0] )
      {
        v329 = -1i64;
        do
          ++v329;
        while ( v328->_Mypair._Myval2._Bx._Buf[v329] );
      }
      else
      {
        v329 = 0i64;
      }
      std::string::assign(&v647, v328->_Mypair._Myval2._Bx._Buf, v329);
      postProcessSettings->screenFilter.PSLevelsInBlack = std::stof(&v647, v330);
      std::string::~string(&v647);
    }
    v331 = line->_Mypair._Myval2._Myfirst;
    v332 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v332->_Mypair._Myval2._Myres >= 0x10 )
      v332 = (std::string *)v332->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v332->_Mypair._Myval2._Bx._Buf, "PSLEVELSINWHITE") )
    {
      v333 = &v331[++i];
      if ( v333->_Mypair._Myval2._Myres >= 0x10 )
        v333 = (std::string *)v333->_Mypair._Myval2._Bx._Ptr;
      v648._Mypair._Myval2._Mysize = 0i64;
      v648._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v648, 0, 0i64);
      if ( v333->_Mypair._Myval2._Bx._Buf[0] )
      {
        v334 = -1i64;
        do
          ++v334;
        while ( v333->_Mypair._Myval2._Bx._Buf[v334] );
      }
      else
      {
        v334 = 0i64;
      }
      std::string::assign(&v648, v333->_Mypair._Myval2._Bx._Buf, v334);
      postProcessSettings->screenFilter.PSLevelsInWhite = std::stof(&v648, v335);
      std::string::~string(&v648);
    }
    v336 = line->_Mypair._Myval2._Myfirst;
    v337 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v337->_Mypair._Myval2._Myres >= 0x10 )
      v337 = (std::string *)v337->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v337->_Mypair._Myval2._Bx._Buf, "PSLEVELSINGAMMA") )
    {
      v338 = &v336[++i];
      if ( v338->_Mypair._Myval2._Myres >= 0x10 )
        v338 = (std::string *)v338->_Mypair._Myval2._Bx._Ptr;
      v649._Mypair._Myval2._Mysize = 0i64;
      v649._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v649, 0, 0i64);
      if ( v338->_Mypair._Myval2._Bx._Buf[0] )
      {
        v339 = -1i64;
        do
          ++v339;
        while ( v338->_Mypair._Myval2._Bx._Buf[v339] );
      }
      else
      {
        v339 = 0i64;
      }
      std::string::assign(&v649, v338->_Mypair._Myval2._Bx._Buf, v339);
      postProcessSettings->screenFilter.PSLevelsInGamma = std::stof(&v649, v340);
      std::string::~string(&v649);
    }
    v341 = line->_Mypair._Myval2._Myfirst;
    v342 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v342->_Mypair._Myval2._Myres >= 0x10 )
      v342 = (std::string *)v342->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v342->_Mypair._Myval2._Bx._Buf, "PSLEVELSOUTBLACK") )
    {
      v343 = &v341[++i];
      if ( v343->_Mypair._Myval2._Myres >= 0x10 )
        v343 = (std::string *)v343->_Mypair._Myval2._Bx._Ptr;
      v650._Mypair._Myval2._Mysize = 0i64;
      v650._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v650, 0, 0i64);
      if ( v343->_Mypair._Myval2._Bx._Buf[0] )
      {
        v344 = -1i64;
        do
          ++v344;
        while ( v343->_Mypair._Myval2._Bx._Buf[v344] );
      }
      else
      {
        v344 = 0i64;
      }
      std::string::assign(&v650, v343->_Mypair._Myval2._Bx._Buf, v344);
      postProcessSettings->screenFilter.PSLevelsOutBlack = std::stof(&v650, v345);
      std::string::~string(&v650);
    }
    v346 = line->_Mypair._Myval2._Myfirst;
    v347 = &line->_Mypair._Myval2._Myfirst[i];
    if ( v347->_Mypair._Myval2._Myres >= 0x10 )
      v347 = (std::string *)v347->_Mypair._Myval2._Bx._Ptr;
    if ( !strcmp(v347->_Mypair._Myval2._Bx._Buf, "PSLEVELSOUTWHITE") )
    {
      v348 = &v346[++i];
      if ( v348->_Mypair._Myval2._Myres >= 0x10 )
        v348 = (std::string *)v348->_Mypair._Myval2._Bx._Ptr;
      v651._Mypair._Myval2._Mysize = 0i64;
      v651._Mypair._Myval2._Myres = 0i64;
      std::string::_Tidy(&v651, 0, 0i64);
      if ( v348->_Mypair._Myval2._Bx._Buf[0] )
      {
        v349 = -1i64;
        do
          ++v349;
        while ( v348->_Mypair._Myval2._Bx._Buf[v349] );
      }
      else
      {
        v349 = 0i64;
      }
      std::string::assign(&v651, v348->_Mypair._Myval2._Bx._Buf, v349);
      postProcessSettings->screenFilter.PSLevelsOutWhite = std::stof(&v651, v350);
      std::string::~string(&v651);
    }
    v351 = std::string::c_str(&line->_Mypair._Myval2._Myfirst[i]);
    if ( !strcmp(v351->_Mypair._Myval2._Bx._Buf, "USEGRADIENT") )
    {
      v352 = std::vector<std::string>::operator[](line, ++i);
      v353 = std::string::c_str(v352);
      std::string::string(&v652, v353->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientOn = std::stoi(&v652, v354, v355);
      std::string::~string(&v652);
    }
    v356 = std::vector<std::string>::operator[](line, i);
    v357 = std::string::c_str(v356);
    if ( !strcmp(v357->_Mypair._Myval2._Bx._Buf, "GRADIENTOVERLAYOPACITY") )
    {
      v358 = std::vector<std::string>::operator[](line, ++i);
      v359 = std::string::c_str(v358);
      std::string::string(&v653, v359->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientOverlayOpacity = std::stof(&v653, v360);
      std::string::~string(&v653);
    }
    v361 = std::vector<std::string>::operator[](line, i);
    v362 = std::string::c_str(v361);
    if ( !strcmp(v362->_Mypair._Myval2._Bx._Buf, "GRADIENTSTARTCOL") )
    {
      v363 = std::vector<std::string>::operator[](line, i + 1);
      v364 = std::string::c_str(v363);
      std::string::string(&v654, v364->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientStartColour[0] = std::stof(&v654, v365);
      std::string::~string(&v654);
      v366 = std::vector<std::string>::operator[](line, i + 2);
      v367 = std::string::c_str(v366);
      std::string::string(&v655, v367->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientStartColour[1] = std::stof(&v655, v368);
      std::string::~string(&v655);
      i += 3;
      v369 = std::vector<std::string>::operator[](line, i);
      v370 = std::string::c_str(v369);
      std::string::string(&v656, v370->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientStartColour[2] = std::stof(&v656, v371);
      std::string::~string(&v656);
    }
    v372 = std::vector<std::string>::operator[](line, i);
    v373 = std::string::c_str(v372);
    if ( !strcmp(v373->_Mypair._Myval2._Bx._Buf, "GRADIENTENDCOL") )
    {
      v374 = std::vector<std::string>::operator[](line, i + 1);
      v375 = std::string::c_str(v374);
      std::string::string(&v657, v375->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientEndColour[0] = std::stof(&v657, v376);
      std::string::~string(&v657);
      v377 = std::vector<std::string>::operator[](line, i + 2);
      v378 = std::string::c_str(v377);
      std::string::string(&v658, v378->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientEndColour[1] = std::stof(&v658, v379);
      std::string::~string(&v658);
      i += 3;
      v380 = std::vector<std::string>::operator[](line, i);
      v381 = std::string::c_str(v380);
      std::string::string(&v659, v381->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->screenFilter.GradientEndColour[2] = std::stof(&v659, v382);
      std::string::~string(&v659);
    }
    v383 = std::vector<std::string>::operator[](line, i);
    v384 = std::string::c_str(v383);
    if ( !strcmp(v384->_Mypair._Myval2._Bx._Buf, "USEGODRAY") )
    {
      v385 = std::vector<std::string>::operator[](line, ++i);
      v386 = std::string::c_str(v385);
      std::string::string(&v660, v386->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.shaderOn = std::stoi(&v660, v387, v388) != 0;
      std::string::~string(&v660);
    }
    v389 = std::vector<std::string>::operator[](line, i);
    v390 = std::string::c_str(v389);
    if ( !strcmp(v390->_Mypair._Myval2._Bx._Buf, "GODDECAY") )
    {
      v391 = std::vector<std::string>::operator[](line, ++i);
      v392 = std::string::c_str(v391);
      std::string::string(&v661, v392->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.decay = std::stof(&v661, v393);
      std::string::~string(&v661);
    }
    v394 = std::vector<std::string>::operator[](line, i);
    v395 = std::string::c_str(v394);
    if ( !strcmp(v395->_Mypair._Myval2._Bx._Buf, "GODEXPOSURE") )
    {
      v396 = std::vector<std::string>::operator[](line, ++i);
      v397 = std::string::c_str(v396);
      std::string::string(&v662, v397->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.exposure = std::stof(&v662, v398);
      std::string::~string(&v662);
    }
    v399 = std::vector<std::string>::operator[](line, i);
    v400 = std::string::c_str(v399);
    if ( !strcmp(v400->_Mypair._Myval2._Bx._Buf, "GODWEIGHT") )
    {
      v401 = std::vector<std::string>::operator[](line, ++i);
      v402 = std::string::c_str(v401);
      std::string::string(&v663, v402->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.weight = std::stof(&v663, v403);
      std::string::~string(&v663);
    }
    v404 = std::vector<std::string>::operator[](line, i);
    v405 = std::string::c_str(v404);
    if ( !strcmp(v405->_Mypair._Myval2._Bx._Buf, "GODDENSITY") )
    {
      v406 = std::vector<std::string>::operator[](line, ++i);
      v407 = std::string::c_str(v406);
      std::string::string(&v664, v407->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.density = std::stof(&v664, v408);
      std::string::~string(&v664);
    }
    v409 = std::vector<std::string>::operator[](line, i);
    v410 = std::string::c_str(v409);
    if ( !strcmp(v410->_Mypair._Myval2._Bx._Buf, "GODBLURSTRENGTH") )
    {
      v411 = std::vector<std::string>::operator[](line, ++i);
      v412 = std::string::c_str(v411);
      std::string::string(&v665, v412->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->godRaySettings.blurStrength = std::stof(&v665, v413);
      std::string::~string(&v665);
    }
    v414 = std::vector<std::string>::operator[](line, i);
    v415 = std::string::c_str(v414);
    if ( !strcmp(v415->_Mypair._Myval2._Bx._Buf, "MONITORFILTERON") )
    {
      v416 = std::vector<std::string>::operator[](line, ++i);
      v417 = std::string::c_str(v416);
      std::string::string(&v666, v417->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.FilterOn = std::stoi(&v666, v418, v419) != 0;
      std::string::~string(&v666);
    }
    v420 = std::vector<std::string>::operator[](line, i);
    v421 = std::string::c_str(v420);
    if ( !strcmp(v421->_Mypair._Myval2._Bx._Buf, "MONITORBLUR") )
    {
      v422 = std::vector<std::string>::operator[](line, ++i);
      v423 = std::string::c_str(v422);
      std::string::string(&v667, v423->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.blur = std::stof(&v667, v424);
      std::string::~string(&v667);
    }
    v425 = std::vector<std::string>::operator[](line, i);
    v426 = std::string::c_str(v425);
    if ( !strcmp(v426->_Mypair._Myval2._Bx._Buf, "MONITORBRIGHTNESS") )
    {
      v427 = std::vector<std::string>::operator[](line, ++i);
      v428 = std::string::c_str(v427);
      std::string::string(&v668, v428->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.brightness = std::stof(&v668, v429);
      std::string::~string(&v668);
    }
    v430 = std::vector<std::string>::operator[](line, i);
    v431 = std::string::c_str(v430);
    if ( !strcmp(v431->_Mypair._Myval2._Bx._Buf, "MONITORSATURATION") )
    {
      v432 = std::vector<std::string>::operator[](line, ++i);
      v433 = std::string::c_str(v432);
      std::string::string(&v669, v433->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.saturation = std::stof(&v669, v434);
      std::string::~string(&v669);
    }
    v435 = std::vector<std::string>::operator[](line, i);
    v436 = std::string::c_str(v435);
    if ( !strcmp(v436->_Mypair._Myval2._Bx._Buf, "MONITORCONTRAST") )
    {
      v437 = std::vector<std::string>::operator[](line, ++i);
      v438 = std::string::c_str(v437);
      std::string::string(&v670, v438->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.contrast = std::stof(&v670, v439);
      std::string::~string(&v670);
    }
    v440 = std::vector<std::string>::operator[](line, i);
    v441 = std::string::c_str(v440);
    if ( !strcmp(v441->_Mypair._Myval2._Bx._Buf, "MONITORMIDTONESCOLSHIFT") )
    {
      v442 = std::vector<std::string>::operator[](line, i + 1);
      v443 = std::string::c_str(v442);
      std::string::string(&v671, v443->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.midTonesColShift[0] = std::stof(&v671, v444);
      std::string::~string(&v671);
      v445 = std::vector<std::string>::operator[](line, i + 2);
      v446 = std::string::c_str(v445);
      std::string::string(&v672, v446->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.midTonesColShift[1] = std::stof(&v672, v447);
      std::string::~string(&v672);
      i += 3;
      v448 = std::vector<std::string>::operator[](line, i);
      v449 = std::string::c_str(v448);
      std::string::string(&v673, v449->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->monitorFilter.midTonesColShift[2] = std::stof(&v673, v450);
      std::string::~string(&v673);
      postProcessSettings->monitorFilter.midTonesColShift[3] = 1.0;
    }
    v451 = std::vector<std::string>::operator[](line, i);
    v452 = std::string::c_str(v451);
    if ( !strcmp(v452->_Mypair._Myval2._Bx._Buf, "PREFIGHTUSEDOF") )
    {
      v453 = std::vector<std::string>::operator[](line, ++i);
      v454 = std::string::c_str(v453);
      std::string::string(&v674, v454->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.faceOffDofOn = std::stoi(&v674, v455, v456) != 0;
      std::string::~string(&v674);
    }
    v457 = std::vector<std::string>::operator[](line, i);
    v458 = std::string::c_str(v457);
    if ( !strcmp(v458->_Mypair._Myval2._Bx._Buf, "PREFIGHTDOFNEAR") )
    {
      v459 = std::vector<std::string>::operator[](line, ++i);
      v460 = std::string::c_str(v459);
      std::string::string(&v675, v460->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.faceOffDofNear = std::stof(&v675, v461);
      std::string::~string(&v675);
    }
    v462 = std::vector<std::string>::operator[](line, i);
    v463 = std::string::c_str(v462);
    if ( !strcmp(v463->_Mypair._Myval2._Bx._Buf, "PREFIGHTDOFFAR") )
    {
      v464 = std::vector<std::string>::operator[](line, ++i);
      v465 = std::string::c_str(v464);
      std::string::string(&v676, v465->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.faceOffDofFar = std::stof(&v676, v466);
      std::string::~string(&v676);
    }
    v467 = std::vector<std::string>::operator[](line, i);
    v468 = std::string::c_str(v467);
    if ( !strcmp(v468->_Mypair._Myval2._Bx._Buf, "PREFIGHTDOFSTRENGTH") )
    {
      v469 = std::vector<std::string>::operator[](line, ++i);
      v470 = std::string::c_str(v469);
      std::string::string(&v677, v470->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.faceOffDofStrength = std::stof(&v677, v471);
      std::string::~string(&v677);
    }
    v472 = std::vector<std::string>::operator[](line, i);
    v473 = std::string::c_str(v472);
    if ( !strcmp(v473->_Mypair._Myval2._Bx._Buf, "FIGHTUSEDOF") )
    {
      v474 = std::vector<std::string>::operator[](line, ++i);
      v475 = std::string::c_str(v474);
      std::string::string(&v678, v475->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.fightDofOn = std::stoi(&v678, v476, v477) != 0;
      std::string::~string(&v678);
    }
    v478 = std::vector<std::string>::operator[](line, i);
    v479 = std::string::c_str(v478);
    if ( !strcmp(v479->_Mypair._Myval2._Bx._Buf, "FIGHTDOFNEAR") )
    {
      v480 = std::vector<std::string>::operator[](line, ++i);
      v481 = std::string::c_str(v480);
      std::string::string(&v679, v481->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.fightDofNear = std::stof(&v679, v482);
      std::string::~string(&v679);
    }
    v483 = std::vector<std::string>::operator[](line, i);
    v484 = std::string::c_str(v483);
    if ( !strcmp(v484->_Mypair._Myval2._Bx._Buf, "FIGHTDOFFAR") )
    {
      v485 = std::vector<std::string>::operator[](line, ++i);
      v486 = std::string::c_str(v485);
      std::string::string(&v680, v486->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.fightDofFar = std::stof(&v680, v487);
      std::string::~string(&v680);
    }
    v488 = std::vector<std::string>::operator[](line, i);
    v489 = std::string::c_str(v488);
    if ( !strcmp(v489->_Mypair._Myval2._Bx._Buf, "FIGHTDOFSTRENGTH") )
    {
      v490 = std::vector<std::string>::operator[](line, ++i);
      v491 = std::string::c_str(v490);
      std::string::string(&v681, v491->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->dofSettings.fightDofStrength = std::stof(&v681, v492);
      std::string::~string(&v681);
    }
    v493 = std::vector<std::string>::operator[](line, i);
    v494 = std::string::c_str(v493);
    if ( !strcmp(v494->_Mypair._Myval2._Bx._Buf, "LIGHTNINGCOL") )
    {
      v495 = std::vector<std::string>::operator[](line, i + 1);
      v496 = std::string::c_str(v495);
      std::string::string(&v682, v496->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->extraBGSettings.lightningCol[0] = std::stof(&v682, v497);
      std::string::~string(&v682);
      v498 = std::vector<std::string>::operator[](line, i + 2);
      v499 = std::string::c_str(v498);
      std::string::string(&v683, v499->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->extraBGSettings.lightningCol[1] = std::stof(&v683, v500);
      std::string::~string(&v683);
      i += 3;
      v501 = std::vector<std::string>::operator[](line, i);
      v502 = std::string::c_str(v501);
      std::string::string(&v684, v502->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->extraBGSettings.lightningCol[2] = std::stof(&v684, v503);
      std::string::~string(&v684);
    }
    v504 = std::vector<std::string>::operator[](line, i);
    v505 = std::string::c_str(v504);
    if ( !strcmp(v505->_Mypair._Myval2._Bx._Buf, "CHARBLOOMON") )
    {
      v506 = std::vector<std::string>::operator[](line, ++i);
      v507 = std::string::c_str(v506);
      std::string::string(&v685, v507->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->charBloomSettings.bloomOn = std::stoi(&v685, v508, v509) != 0;
      std::string::~string(&v685);
    }
    v510 = std::vector<std::string>::operator[](line, i);
    v511 = std::string::c_str(v510);
    if ( !strcmp(v511->_Mypair._Myval2._Bx._Buf, "HILIGHTTHRESHOLD") )
    {
      v512 = std::vector<std::string>::operator[](line, ++i);
      v513 = std::string::c_str(v512);
      std::string::string(&v686, v513->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->charBloomSettings.highlightThreshold = std::stof(&v686, v514);
      std::string::~string(&v686);
    }
    v515 = std::vector<std::string>::operator[](line, i);
    v516 = std::string::c_str(v515);
    if ( !strcmp(v516->_Mypair._Myval2._Bx._Buf, "HILIGHTBRIGHTNESS") )
    {
      v517 = std::vector<std::string>::operator[](line, ++i);
      v518 = std::string::c_str(v517);
      std::string::string(&v687, v518->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->charBloomSettings.highlightBrightness = std::stof(&v687, v519);
      std::string::~string(&v687);
    }
    v520 = std::vector<std::string>::operator[](line, i);
    v521 = std::string::c_str(v520);
    if ( !strcmp(v521->_Mypair._Myval2._Bx._Buf, "HILIGHTBLURSTR") )
    {
      v522 = std::vector<std::string>::operator[](line, ++i);
      v523 = std::string::c_str(v522);
      std::string::string(&v688, v523->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->charBloomSettings.blurStrength = std::stof(&v688, v524);
      std::string::~string(&v688);
    }
    v525 = std::vector<std::string>::operator[](line, i);
    v526 = std::string::c_str(v525);
    if ( !strcmp(v526->_Mypair._Myval2._Bx._Buf, "HILIGHTSCALE") )
    {
      v527 = std::vector<std::string>::operator[](line, ++i);
      v528 = std::string::c_str(v527);
      std::string::string(&v689, v528->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->charBloomSettings.downsampleScale = std::stoi(&v689, v529, v530);
      std::string::~string(&v689);
    }
    v531 = std::vector<std::string>::operator[](line, i);
    v532 = std::string::c_str(v531);
    if ( !strcmp(v532->_Mypair._Myval2._Bx._Buf, "SHADOWLIGHTAREATYPE") )
    {
      v533 = std::vector<std::string>::operator[](line, ++i);
      v534 = std::string::c_str(v533);
      std::string::string(&v690, v534->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightType = std::stoi(&v690, v535, v536);
      std::string::~string(&v690);
    }
    v537 = std::vector<std::string>::operator[](line, i);
    v538 = std::string::c_str(v537);
    if ( !strcmp(v538->_Mypair._Myval2._Bx._Buf, "SHADOWLIGHTAREARADIUS") )
    {
      v539 = std::vector<std::string>::operator[](line, ++i);
      v540 = std::string::c_str(v539);
      std::string::string(&v691, v540->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightRadius = (float)std::stoi(&v691, v541, v542);
      std::string::~string(&v691);
    }
    v543 = std::vector<std::string>::operator[](line, i);
    v544 = std::string::c_str(v543);
    if ( !strcmp(v544->_Mypair._Myval2._Bx._Buf, "SHADOWLIGHTAREAPOS") )
    {
      v545 = std::vector<std::string>::operator[](line, i + 1);
      v546 = std::string::c_str(v545);
      std::string::string(&v692, v546->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightPos.x = std::stof(&v692, v547);
      std::string::~string(&v692);
      i += 2;
      v548 = std::vector<std::string>::operator[](line, i);
      v549 = std::string::c_str(v548);
      std::string::string(&v693, v549->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightPos.y = std::stof(&v693, v550);
      std::string::~string(&v693);
    }
    v551 = std::vector<std::string>::operator[](line, i);
    v552 = std::string::c_str(v551);
    if ( !strcmp(v552->_Mypair._Myval2._Bx._Buf, "SHADOWLIGHTAREAMIN") )
    {
      v553 = std::vector<std::string>::operator[](line, ++i);
      v554 = std::string::c_str(v553);
      std::string::string(&v694, v554->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightMinMax.x = std::stof(&v694, v555);
      std::string::~string(&v694);
    }
    v556 = std::vector<std::string>::operator[](line, i);
    v557 = std::string::c_str(v556);
    if ( !strcmp(v557->_Mypair._Myval2._Bx._Buf, "SHADOWLIGHTAREASTRENGTH") )
    {
      v558 = std::vector<std::string>::operator[](line, ++i);
      v559 = std::string::c_str(v558);
      std::string::string(&v695, v559->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->shadowLightAreaSettings.shadLightMinMax.y = std::stof(&v695, v560);
      std::string::~string(&v695);
    }
    v561 = std::vector<std::string>::operator[](line, i);
    v562 = std::string::c_str(v561);
    if ( !strcmp(v562->_Mypair._Myval2._Bx._Buf, "HEATHAZEON") )
    {
      v563 = std::vector<std::string>::operator[](line, ++i);
      v564 = std::string::c_str(v563);
      std::string::string(&v696, v564->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->heatHazeSettings.heatHazeOn = std::stoi(&v696, v565, v566) != 0;
      std::string::~string(&v696);
    }
    v567 = std::vector<std::string>::operator[](line, i);
    v568 = std::string::c_str(v567);
    if ( !strcmp(v568->_Mypair._Myval2._Bx._Buf, "HEATHAZENEAR") )
    {
      v569 = std::vector<std::string>::operator[](line, ++i);
      v570 = std::string::c_str(v569);
      std::string::string(&v697, v570->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->heatHazeSettings.heatHazeNear = std::stof(&v697, v571);
      std::string::~string(&v697);
    }
    v572 = std::vector<std::string>::operator[](line, i);
    v573 = std::string::c_str(v572);
    if ( !strcmp(v573->_Mypair._Myval2._Bx._Buf, "HEATHAZESPEED") )
    {
      v574 = std::vector<std::string>::operator[](line, ++i);
      v575 = std::string::c_str(v574);
      std::string::string(&v698, v575->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->heatHazeSettings.heatHazeSpeed = std::stof(&v698, v576);
      std::string::~string(&v698);
    }
    v577 = std::vector<std::string>::operator[](line, i);
    v578 = std::string::c_str(v577);
    if ( !strcmp(v578->_Mypair._Myval2._Bx._Buf, "HEATHAZESTRENGTH") )
    {
      v579 = std::vector<std::string>::operator[](line, ++i);
      v580 = std::string::c_str(v579);
      std::string::string(&v699, v580->_Mypair._Myval2._Bx._Buf);
      postProcessSettings->heatHazeSettings.heatHazeStrength = std::stof(&v699, v581);
      std::string::~string(&v699);
    }
  }
}

void __fastcall std::vector<extension::FutureAssetOptionFileSetting>::push_back(
        std::vector<extension::FutureAssetOptionFileSetting> *this,
        const extension::FutureAssetOptionFileSetting *_Val)
{
  extension::FutureAssetOptionFileSetting *Mylast; // rcx
  extension::FutureAssetOptionFileSetting *Myfirst; // rax
  signed __int64 v6; // rsi
  unsigned __int64 v7; // rdx
  extension::FutureAssetOptionFileSetting *v8; // rbx
  extension::FutureAssetOptionFileSetting *Ptr; // rax

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || (Myfirst = this->_Mypair._Myval2._Myfirst, this->_Mypair._Myval2._Myfirst > _Val) )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<extension::FutureAssetOptionFileSetting>::_Reserve(this, (unsigned __int64)_Val);
    v8 = this->_Mypair._Myval2._Mylast;
    if ( v8 )
    {
      v8->fileName._Mypair._Myval2._Myres = 15i64;
      v8->fileName._Mypair._Myval2._Mysize = 0i64;
      if ( v8->fileName._Mypair._Myval2._Myres < 0x10 )
        Ptr = v8;
      else
        Ptr = (extension::FutureAssetOptionFileSetting *)v8->fileName._Mypair._Myval2._Bx._Ptr;
      Ptr->fileName._Mypair._Myval2._Bx._Buf[0] = 0;
      std::string::assign(&v8->fileName, &_Val->fileName, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v8->bNoMotion = _Val->bNoMotion;
    }
  }
  else
  {
    v6 = (char *)_Val - (char *)Myfirst;
    v7 = (unsigned __int128)(((char *)_Val - (char *)Myfirst) * (__int128)0x6666666666666667i64) >> 64;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<extension::FutureAssetOptionFileSetting>::_Reserve(this, v7);
    std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting>>::construct<extension::FutureAssetOptionFileSetting,extension::FutureAssetOptionFileSetting &>(
      (std::_Wrap_alloc<std::allocator<extension::FutureAssetOptionFileSetting> > *)(5 * (v6 / 40)),
      this->_Mypair._Myval2._Mylast,
      &this->_Mypair._Myval2._Myfirst[v6 / 40]);
  }
  ++this->_Mypair._Myval2._Mylast;
}

void __fastcall AppMain::releasePS4ModelRoom(AppMain *this, bool bDeleteBufferOnly)
{
  unsigned int *p_m_FrameBufferID; // rdx
  unsigned int *p_m_TexID; // rdx
  GLuint v6; // er8
  unsigned int *v7; // rdi
  unsigned int *v8; // rax
  __int64 v9; // rsi
  __int64 v10; // rcx
  unsigned int *v11; // rdx
  unsigned int *v12; // rdx
  GLuint v13; // er8
  unsigned int *v14; // rax
  __int64 v15; // rcx
  unsigned int *v16; // rdx
  unsigned int *v17; // rdx
  GLuint v18; // er8
  unsigned int *v19; // rax
  __int64 v20; // rcx
  unsigned int *v21; // rdx
  unsigned int *v22; // rdx
  GLuint v23; // er8
  unsigned int *v24; // rax
  __int64 v25; // rcx
  unsigned int *v26; // rdx
  unsigned int *v27; // rdx
  GLuint v28; // er8
  unsigned int *v29; // rax
  __int64 v30; // rcx
  unsigned int *v31; // rdx
  unsigned int *v32; // rdx
  GLuint v33; // er8
  unsigned int *v34; // rax
  __int64 v35; // rcx
  unsigned int *v36; // rdx
  unsigned int *v37; // rdx
  GLuint v38; // er8
  unsigned int *v39; // rax
  __int64 v40; // rcx
  unsigned int *v41; // rdx
  unsigned int *v42; // rdx
  GLuint v43; // er8
  unsigned int *v44; // rax
  __int64 v45; // rcx
  unsigned int *v46; // rdx
  unsigned int *v47; // rdx
  GLuint v48; // er8
  unsigned int *v49; // rax
  __int64 v50; // rcx
  unsigned int *v51; // rdx
  unsigned int *v52; // rdx
  GLuint v53; // er8
  unsigned int *v54; // rax
  __int64 v55; // rcx
  unsigned int *v56; // rdx
  unsigned int *v57; // rdx
  GLuint v58; // er8
  unsigned int *v59; // rax
  __int64 v60; // rcx
  unsigned int *v61; // rdx
  unsigned int *v62; // rdx
  GLuint v63; // er8
  unsigned int *v64; // rax
  __int64 v65; // rcx
  Framework::GLManager *v66; // r9
  unsigned int v67; // ecx
  int v68; // er8
  unsigned int m_buffers; // edx
  unsigned int *systemRenderID; // rax
  unsigned int *v71; // rdx
  GLuint v72; // er8
  unsigned int *v73; // rax
  __int64 v74; // rcx
  unsigned int *v75; // rdx
  GLuint v76; // er8
  unsigned int *v77; // rax
  __int64 v78; // rcx
  unsigned int *v79; // rdx
  GLuint v80; // er8
  unsigned int *v81; // rax
  __int64 v82; // rcx
  unsigned int *v83; // rdx
  GLuint v84; // er8
  unsigned int *v85; // rax
  __int64 v86; // rcx
  unsigned int *v87; // rdx
  unsigned int *v88; // rdx
  GLuint v89; // er8
  unsigned int *v90; // rax
  __int64 v91; // rcx
  unsigned int *v92; // rdx
  unsigned int *v93; // rdx
  GLuint v94; // er8
  unsigned int *v95; // rax
  __int64 v96; // rcx
  unsigned int *v97; // rdx
  unsigned int *v98; // rdx
  GLuint v99; // er8
  unsigned int *v100; // rax
  __int64 v101; // rcx
  unsigned int *v102; // rdx
  unsigned int *v103; // rdx
  GLuint v104; // er8
  unsigned int *v105; // rax
  __int64 v106; // rcx
  unsigned int *v107; // rdx
  unsigned int *v108; // rdx
  GLuint v109; // er8
  unsigned int *v110; // rax
  __int64 v111; // rcx
  unsigned int *v112; // rdx
  unsigned int *v113; // rdx
  GLuint v114; // er8
  unsigned int *v115; // rax
  __int64 v116; // rcx
  unsigned int *v117; // rdx
  unsigned int *v118; // rdx
  GLuint v119; // er8
  unsigned int *v120; // rax
  __int64 v121; // rcx
  unsigned int *v122; // rdx
  unsigned int *v123; // rdx
  GLuint v124; // er8
  unsigned int *v125; // rax
  __int64 v126; // rcx
  unsigned int *v127; // rdx
  unsigned int *v128; // rdx
  GLuint v129; // er8
  unsigned int *v130; // rax
  __int64 v131; // rcx
  unsigned int *v132; // rdx
  unsigned int *v133; // rdx
  GLuint v134; // er8
  unsigned int *v135; // rax
  __int64 v136; // rcx
  unsigned int *v137; // rdx
  unsigned int *v138; // rdx
  GLuint v139; // er8
  unsigned int *v140; // rax
  __int64 v141; // rcx
  unsigned int *v142; // rdx
  unsigned int *v143; // rdx
  GLuint v144; // er8
  unsigned int *v145; // rax
  __int64 v146; // rcx
  unsigned int *v147; // rdx
  unsigned int *v148; // rdx
  GLuint v149; // er8
  unsigned int *v150; // rax
  __int64 v151; // rcx
  unsigned int *v152; // rdx
  unsigned int *v153; // rdx
  GLuint v154; // er8
  unsigned int *v155; // rax
  __int64 v156; // rcx
  unsigned int *v157; // rdx
  unsigned int *v158; // rdx
  GLuint v159; // er8
  unsigned int *v160; // rax
  __int64 v161; // rcx
  unsigned int *v162; // rdx
  unsigned int *v163; // rdx
  GLuint v164; // er8
  unsigned int *v165; // rax
  __int64 v166; // rcx
  unsigned int *v167; // rdx
  unsigned int *v168; // rdx
  GLuint v169; // er8
  unsigned int *v170; // rax
  __int64 v171; // rcx
  unsigned int *v172; // rdx
  GLuint v173; // er8
  unsigned int *v174; // rax
  __int64 v175; // rcx
  unsigned int *v176; // rdx
  unsigned int *v177; // rdx
  GLuint v178; // er8
  unsigned int *v179; // rax
  __int64 v180; // rcx
  unsigned int *v181; // rdx
  unsigned int *v182; // rdx
  GLuint v183; // er8
  unsigned int *v184; // rax
  __int64 v185; // rcx
  unsigned int *v186; // rdx
  unsigned int *v187; // rdx
  GLuint v188; // er8
  unsigned int *v189; // rax
  __int64 v190; // rcx
  unsigned int *v191; // rdx
  unsigned int *v192; // rdx
  GLuint v193; // er8
  unsigned int *v194; // rax
  __int64 v195; // rcx
  unsigned int *v196; // rdx
  unsigned int *v197; // rdx
  GLuint v198; // er8
  unsigned int *v199; // rax
  __int64 v200; // rcx
  unsigned int *v201; // rdx
  unsigned int *v202; // rdx
  GLuint v203; // er8
  unsigned int *v204; // rax
  __int64 v205; // rcx
  unsigned int *v206; // rdx
  unsigned int *v207; // rdx
  GLuint v208; // er8
  unsigned int *v209; // rax
  __int64 v210; // rcx
  unsigned int *v211; // rdx
  unsigned int *v212; // rdx
  GLuint v213; // er8
  unsigned int *v214; // rax
  __int64 v215; // rcx
  unsigned int *v216; // rdx
  unsigned int *v217; // rdx
  GLuint v218; // er8
  unsigned int *v219; // rax
  __int64 v220; // rcx
  unsigned int *v221; // rdx
  unsigned int *v222; // rdx
  GLuint v223; // er8
  unsigned int *v224; // rax
  __int64 v225; // rcx
  unsigned int *v226; // rdx
  unsigned int *v227; // rdx
  GLuint v228; // er8
  unsigned int *v229; // rax
  __int64 v230; // rcx
  unsigned int *v231; // rdx
  unsigned int *v232; // rdx
  GLuint v233; // er8
  unsigned int *v234; // rax
  __int64 v235; // rcx
  unsigned int *v236; // rdx
  unsigned int *v237; // rdx
  GLuint v238; // er8
  unsigned int *v239; // rax
  __int64 v240; // rcx
  unsigned int *v241; // rdx
  unsigned int *v242; // rdx
  GLuint v243; // er8
  unsigned int *v244; // rax
  __int64 v245; // rcx
  unsigned int *v246; // rdx
  unsigned int *v247; // rdx
  GLuint v248; // er8
  unsigned int *v249; // rax
  __int64 v250; // rcx
  unsigned int *v251; // rdx
  unsigned int *v252; // rdx
  GLuint v253; // er8
  unsigned int *v254; // rax
  __int64 v255; // rcx
  unsigned int *v256; // rdx
  unsigned int *v257; // rdx
  GLuint v258; // er8
  unsigned int *v259; // rax
  __int64 v260; // rcx
  unsigned int *v261; // rdx
  unsigned int *v262; // rdx
  GLuint v263; // er8
  unsigned int *v264; // rax
  __int64 v265; // rcx
  unsigned int *v266; // rdx
  unsigned int *v267; // rdx
  GLuint v268; // eax
  __int64 v269; // rdx
  __int64 v270; // rcx
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *v271; // rcx
  __int64 v272; // rcx
  __int64 v273; // rcx
  __int64 v274; // rcx
  __int64 v275; // rcx
  __int64 v276; // rcx
  __int64 v277; // rcx
  __int64 v278; // rcx
  _QWORD *v279; // rcx
  __int64 v280; // rcx
  __int64 v281; // rcx
  unsigned __int64 v282; // rdx
  std::unique_ptr<OGLModel * [0]> *p_ppModel; // rdi
  __int64 v284; // rsi
  OGLModel **Myval2; // rcx
  __int64 v286; // rdi
  int v287; // er8
  OGLModel ***p_pModel; // rdx
  OGLModel **pModel; // rax
  __int64 v290; // rcx
  __int64 v291; // rcx
  extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> *v292; // rax
  extension::ExThread::Runnable *v293; // rax
  OGLRender *m_pRender; // rdi
  std::unique_ptr<extension::ExThread::Runnable> obj; // [rsp+28h] [rbp-59h] BYREF
  void (__fastcall ***v296)(_QWORD, __int64); // [rsp+30h] [rbp-51h] BYREF
  __int64 v297[4]; // [rsp+38h] [rbp-49h] BYREF
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> asset; // [rsp+58h] [rbp-29h] BYREF
  char v299; // [rsp+69h] [rbp-18h]
  __int64 v300; // [rsp+70h] [rbp-11h]
  char v301; // [rsp+79h] [rbp-8h]
  __int64 v302; // [rsp+80h] [rbp-1h]
  char v303; // [rsp+89h] [rbp+8h]
  __int64 v304; // [rsp+90h] [rbp+Fh]
  char v305; // [rsp+99h] [rbp+18h]
  void *block; // [rsp+A0h] [rbp+1Fh]
  char v307; // [rsp+A9h] [rbp+28h]
  __int64 v308; // [rsp+B0h] [rbp+2Fh]

  v297[1] = -2i64;
  glDeleteRenderbuffersAG(1, this->m_pRender->m_renderTextures.m_RenderBufferID);
  this->m_pRender->m_renderTextures.m_RenderBufferID[0] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[1]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[1] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[2]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[2] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[3]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[3] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[4]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[4] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[5]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[5] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[6]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[6] = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_RenderBufferID[7]);
  this->m_pRender->m_renderTextures.m_RenderBufferID[7] = 0;
  p_m_FrameBufferID = &this->m_pRender->m_renderTextures.m_DepthMapTexture[0].m_FrameBufferID;
  if ( *p_m_FrameBufferID )
  {
    glDeleteRenderbuffersAG(1, p_m_FrameBufferID);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[0].m_FrameBufferID = 0;
  }
  p_m_TexID = &this->m_pRender->m_renderTextures.m_DepthMapTexture[0].m_TexID;
  v6 = *p_m_TexID;
  v7 = m_TexID;
  v8 = m_TexID;
  v9 = 32i64;
  v10 = 32i64;
  do
  {
    if ( v6 == *v8 )
      *v8 = 0;
    ++v8;
    --v10;
  }
  while ( v10 );
  glDeleteTextures(1, p_m_TexID);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[0].m_TexID = 0;
  v11 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_FrameBufferID;
  if ( *v11 )
  {
    glDeleteRenderbuffersAG(1, v11);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_FrameBufferID = 0;
  }
  v12 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_TexID;
  v13 = *v12;
  v14 = m_TexID;
  v15 = 32i64;
  do
  {
    if ( v13 == *v14 )
      *v14 = 0;
    ++v14;
    --v15;
  }
  while ( v15 );
  glDeleteTextures(1, v12);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[1].m_TexID = 0;
  v16 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[2].m_FrameBufferID;
  if ( *v16 )
  {
    glDeleteRenderbuffersAG(1, v16);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[2].m_FrameBufferID = 0;
  }
  v17 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[2].m_TexID;
  v18 = *v17;
  v19 = m_TexID;
  v20 = 32i64;
  do
  {
    if ( v18 == *v19 )
      *v19 = 0;
    ++v19;
    --v20;
  }
  while ( v20 );
  glDeleteTextures(1, v17);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[2].m_TexID = 0;
  v21 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[2].m_FrameBufferID;
  if ( *v21 )
  {
    glDeleteRenderbuffersAG(1, v21);
    this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[2].m_FrameBufferID = 0;
  }
  v22 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[2].m_TexID;
  v23 = *v22;
  v24 = m_TexID;
  v25 = 32i64;
  do
  {
    if ( v23 == *v24 )
      *v24 = 0;
    ++v24;
    --v25;
  }
  while ( v25 );
  glDeleteTextures(1, v22);
  this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[2].m_TexID = 0;
  v26 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_FrameBufferID;
  if ( *v26 )
  {
    glDeleteRenderbuffersAG(1, v26);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_FrameBufferID = 0;
  }
  v27 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_TexID;
  v28 = *v27;
  v29 = m_TexID;
  v30 = 32i64;
  do
  {
    if ( v28 == *v29 )
      *v29 = 0;
    ++v29;
    --v30;
  }
  while ( v30 );
  glDeleteTextures(1, v27);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[3].m_TexID = 0;
  v31 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_FrameBufferID;
  if ( *v31 )
  {
    glDeleteRenderbuffersAG(1, v31);
    this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_FrameBufferID = 0;
  }
  v32 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_TexID;
  v33 = *v32;
  v34 = m_TexID;
  v35 = 32i64;
  do
  {
    if ( v33 == *v34 )
      *v34 = 0;
    ++v34;
    --v35;
  }
  while ( v35 );
  glDeleteTextures(1, v32);
  this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[3].m_TexID = 0;
  v36 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[4].m_FrameBufferID;
  if ( *v36 )
  {
    glDeleteRenderbuffersAG(1, v36);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[4].m_FrameBufferID = 0;
  }
  v37 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[4].m_TexID;
  v38 = *v37;
  v39 = m_TexID;
  v40 = 32i64;
  do
  {
    if ( v38 == *v39 )
      *v39 = 0;
    ++v39;
    --v40;
  }
  while ( v40 );
  glDeleteTextures(1, v37);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[4].m_TexID = 0;
  v41 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[4].m_FrameBufferID;
  if ( *v41 )
  {
    glDeleteRenderbuffersAG(1, v41);
    this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[4].m_FrameBufferID = 0;
  }
  v42 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[4].m_TexID;
  v43 = *v42;
  v44 = m_TexID;
  v45 = 32i64;
  do
  {
    if ( v43 == *v44 )
      *v44 = 0;
    ++v44;
    --v45;
  }
  while ( v45 );
  glDeleteTextures(1, v42);
  this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[4].m_TexID = 0;
  v46 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_FrameBufferID;
  if ( *v46 )
  {
    glDeleteRenderbuffersAG(1, v46);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_FrameBufferID = 0;
  }
  v47 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_TexID;
  v48 = *v47;
  v49 = m_TexID;
  v50 = 32i64;
  do
  {
    if ( v48 == *v49 )
      *v49 = 0;
    ++v49;
    --v50;
  }
  while ( v50 );
  glDeleteTextures(1, v47);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[5].m_TexID = 0;
  v51 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_FrameBufferID;
  if ( *v51 )
  {
    glDeleteRenderbuffersAG(1, v51);
    this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_FrameBufferID = 0;
  }
  v52 = &this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_TexID;
  v53 = *v52;
  v54 = m_TexID;
  v55 = 32i64;
  do
  {
    if ( v53 == *v54 )
      *v54 = 0;
    ++v54;
    --v55;
  }
  while ( v55 );
  glDeleteTextures(1, v52);
  this->m_pRender->m_renderTextures.m_DepthMapForAlphaTexture[5].m_TexID = 0;
  v56 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_FrameBufferID;
  if ( *v56 )
  {
    glDeleteRenderbuffersAG(1, v56);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_FrameBufferID = 0;
  }
  v57 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID;
  v58 = *v57;
  v59 = m_TexID;
  v60 = 32i64;
  do
  {
    if ( v58 == *v59 )
      *v59 = 0;
    ++v59;
    --v60;
  }
  while ( v60 );
  glDeleteTextures(1, v57);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[6].m_TexID = 0;
  v61 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[7].m_FrameBufferID;
  if ( *v61 )
  {
    glDeleteRenderbuffersAG(1, v61);
    this->m_pRender->m_renderTextures.m_DepthMapTexture[7].m_FrameBufferID = 0;
  }
  v62 = &this->m_pRender->m_renderTextures.m_DepthMapTexture[7].m_TexID;
  v63 = *v62;
  v64 = m_TexID;
  v65 = 32i64;
  do
  {
    if ( v63 == *v64 )
      *v64 = 0;
    ++v64;
    --v65;
  }
  while ( v65 );
  glDeleteTextures(1, v62);
  this->m_pRender->m_renderTextures.m_DepthMapTexture[7].m_TexID = 0;
  if ( !bDeleteBufferOnly )
  {
    v66 = Framework::GLManager::glm;
    v67 = 0;
    v68 = this->m_pRender->m_renderTextures.m_ShadowRenderBufferID[0];
    if ( v68 > 0 )
    {
      m_buffers = Framework::GLManager::glm->m_config.m_buffers;
      if ( m_buffers )
      {
        systemRenderID = Framework::GLManager::glm->systemRenderID;
        do
        {
          if ( *systemRenderID == v68 )
            break;
          ++v67;
          ++systemRenderID;
        }
        while ( v67 < m_buffers );
      }
      if ( v67 == m_buffers )
      {
        Framework::GLManager::glm->m_buffer.m_freeIDs[Framework::GLManager::glm->m_buffer.m_firstOccupiedIndex] = v68;
        ++v66->m_buffer.m_firstOccupiedIndex;
      }
    }
    this->m_pRender->m_renderTextures.m_ShadowRenderBufferID[0] = 0;
    v71 = &this->m_pRender->m_renderTextures.m_ShadowDepthMap[0].m_TexID;
    v72 = *v71;
    v73 = m_TexID;
    v74 = 32i64;
    do
    {
      if ( v72 == *v73 )
        *v73 = 0;
      ++v73;
      --v74;
    }
    while ( v74 );
    glDeleteTextures(1, v71);
    this->m_pRender->m_renderTextures.m_ShadowDepthMap[0].m_TexID = 0;
    glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_ShadowRenderBufferID[1]);
    this->m_pRender->m_renderTextures.m_ShadowRenderBufferID[1] = 0;
    v75 = &this->m_pRender->m_renderTextures.m_ShadowDepthMap[1].m_TexID;
    v76 = *v75;
    v77 = m_TexID;
    v78 = 32i64;
    do
    {
      if ( v76 == *v77 )
        *v77 = 0;
      ++v77;
      --v78;
    }
    while ( v78 );
    glDeleteTextures(1, v75);
    this->m_pRender->m_renderTextures.m_ShadowDepthMap[1].m_TexID = 0;
    glDeleteRenderbuffersAG(1, this->m_pRender->m_renderTextures.m_ShadowTransRenderBufferID);
    this->m_pRender->m_renderTextures.m_ShadowTransRenderBufferID[0] = 0;
    v79 = &this->m_pRender->m_renderTextures.m_ShadowTransparencyMap[0].m_TexID;
    v80 = *v79;
    v81 = m_TexID;
    v82 = 32i64;
    do
    {
      if ( v80 == *v81 )
        *v81 = 0;
      ++v81;
      --v82;
    }
    while ( v82 );
    glDeleteTextures(1, v79);
    this->m_pRender->m_renderTextures.m_ShadowTransparencyMap[0].m_TexID = 0;
    glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_ShadowTransRenderBufferID[1]);
    this->m_pRender->m_renderTextures.m_ShadowTransRenderBufferID[1] = 0;
    v83 = &this->m_pRender->m_renderTextures.m_ShadowTransparencyMap[1].m_TexID;
    v84 = *v83;
    v85 = m_TexID;
    v86 = 32i64;
    do
    {
      if ( v84 == *v85 )
        *v85 = 0;
      ++v85;
      --v86;
    }
    while ( v86 );
    glDeleteTextures(1, v83);
    this->m_pRender->m_renderTextures.m_ShadowTransparencyMap[1].m_TexID = 0;
  }
  v87 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[0].m_FrameBufferID;
  if ( *v87 )
  {
    glDeleteRenderbuffersAG(1, v87);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[0].m_FrameBufferID = 0;
  }
  v88 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[0].m_TexID;
  v89 = *v88;
  v90 = m_TexID;
  v91 = 32i64;
  do
  {
    if ( v89 == *v90 )
      *v90 = 0;
    ++v90;
    --v91;
  }
  while ( v91 );
  glDeleteTextures(1, v88);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[0].m_TexID = 0;
  v92 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[1].m_FrameBufferID;
  if ( *v92 )
  {
    glDeleteRenderbuffersAG(1, v92);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[1].m_FrameBufferID = 0;
  }
  v93 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[1].m_TexID;
  v94 = *v93;
  v95 = m_TexID;
  v96 = 32i64;
  do
  {
    if ( v94 == *v95 )
      *v95 = 0;
    ++v95;
    --v96;
  }
  while ( v96 );
  glDeleteTextures(1, v93);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[1].m_TexID = 0;
  v97 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[2].m_FrameBufferID;
  if ( *v97 )
  {
    glDeleteRenderbuffersAG(1, v97);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[2].m_FrameBufferID = 0;
  }
  v98 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[2].m_TexID;
  v99 = *v98;
  v100 = m_TexID;
  v101 = 32i64;
  do
  {
    if ( v99 == *v100 )
      *v100 = 0;
    ++v100;
    --v101;
  }
  while ( v101 );
  glDeleteTextures(1, v98);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[2].m_TexID = 0;
  v102 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[3].m_FrameBufferID;
  if ( *v102 )
  {
    glDeleteRenderbuffersAG(1, v102);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[3].m_FrameBufferID = 0;
  }
  v103 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[3].m_TexID;
  v104 = *v103;
  v105 = m_TexID;
  v106 = 32i64;
  do
  {
    if ( v104 == *v105 )
      *v105 = 0;
    ++v105;
    --v106;
  }
  while ( v106 );
  glDeleteTextures(1, v103);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[3].m_TexID = 0;
  v107 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[4].m_FrameBufferID;
  if ( *v107 )
  {
    glDeleteRenderbuffersAG(1, v107);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[4].m_FrameBufferID = 0;
  }
  v108 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[4].m_TexID;
  v109 = *v108;
  v110 = m_TexID;
  v111 = 32i64;
  do
  {
    if ( v109 == *v110 )
      *v110 = 0;
    ++v110;
    --v111;
  }
  while ( v111 );
  glDeleteTextures(1, v108);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[4].m_TexID = 0;
  v112 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[5].m_FrameBufferID;
  if ( *v112 )
  {
    glDeleteRenderbuffersAG(1, v112);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[5].m_FrameBufferID = 0;
  }
  v113 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[5].m_TexID;
  v114 = *v113;
  v115 = m_TexID;
  v116 = 32i64;
  do
  {
    if ( v114 == *v115 )
      *v115 = 0;
    ++v115;
    --v116;
  }
  while ( v116 );
  glDeleteTextures(1, v113);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[5].m_TexID = 0;
  v117 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[6].m_FrameBufferID;
  if ( *v117 )
  {
    glDeleteRenderbuffersAG(1, v117);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[6].m_FrameBufferID = 0;
  }
  v118 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[6].m_TexID;
  v119 = *v118;
  v120 = m_TexID;
  v121 = 32i64;
  do
  {
    if ( v119 == *v120 )
      *v120 = 0;
    ++v120;
    --v121;
  }
  while ( v121 );
  glDeleteTextures(1, v118);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[6].m_TexID = 0;
  v122 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[7].m_FrameBufferID;
  if ( *v122 )
  {
    glDeleteRenderbuffersAG(1, v122);
    this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[7].m_FrameBufferID = 0;
  }
  v123 = &this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[7].m_TexID;
  v124 = *v123;
  v125 = m_TexID;
  v126 = 32i64;
  do
  {
    if ( v124 == *v125 )
      *v125 = 0;
    ++v125;
    --v126;
  }
  while ( v126 );
  glDeleteTextures(1, v123);
  this->m_pRender->m_renderTextures.m_FullScreenMaskTexture[7].m_TexID = 0;
  v127 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[0].m_FrameBufferID;
  if ( *v127 )
  {
    glDeleteRenderbuffersAG(1, v127);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[0].m_FrameBufferID = 0;
  }
  v128 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[0].m_TexID;
  v129 = *v128;
  v130 = m_TexID;
  v131 = 32i64;
  do
  {
    if ( v129 == *v130 )
      *v130 = 0;
    ++v130;
    --v131;
  }
  while ( v131 );
  glDeleteTextures(1, v128);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[0].m_TexID = 0;
  v132 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[1].m_FrameBufferID;
  if ( *v132 )
  {
    glDeleteRenderbuffersAG(1, v132);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[1].m_FrameBufferID = 0;
  }
  v133 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[1].m_TexID;
  v134 = *v133;
  v135 = m_TexID;
  v136 = 32i64;
  do
  {
    if ( v134 == *v135 )
      *v135 = 0;
    ++v135;
    --v136;
  }
  while ( v136 );
  glDeleteTextures(1, v133);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[1].m_TexID = 0;
  v137 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[2].m_FrameBufferID;
  if ( *v137 )
  {
    glDeleteRenderbuffersAG(1, v137);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[2].m_FrameBufferID = 0;
  }
  v138 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[2].m_TexID;
  v139 = *v138;
  v140 = m_TexID;
  v141 = 32i64;
  do
  {
    if ( v139 == *v140 )
      *v140 = 0;
    ++v140;
    --v141;
  }
  while ( v141 );
  glDeleteTextures(1, v138);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[2].m_TexID = 0;
  v142 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_FrameBufferID;
  if ( *v142 )
  {
    glDeleteRenderbuffersAG(1, v142);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_FrameBufferID = 0;
  }
  v143 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_TexID;
  v144 = *v143;
  v145 = m_TexID;
  v146 = 32i64;
  do
  {
    if ( v144 == *v145 )
      *v145 = 0;
    ++v145;
    --v146;
  }
  while ( v146 );
  glDeleteTextures(1, v143);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[3].m_TexID = 0;
  v147 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[4].m_FrameBufferID;
  if ( *v147 )
  {
    glDeleteRenderbuffersAG(1, v147);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[4].m_FrameBufferID = 0;
  }
  v148 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[4].m_TexID;
  v149 = *v148;
  v150 = m_TexID;
  v151 = 32i64;
  do
  {
    if ( v149 == *v150 )
      *v150 = 0;
    ++v150;
    --v151;
  }
  while ( v151 );
  glDeleteTextures(1, v148);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[4].m_TexID = 0;
  v152 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_FrameBufferID;
  if ( *v152 )
  {
    glDeleteRenderbuffersAG(1, v152);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_FrameBufferID = 0;
  }
  v153 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_TexID;
  v154 = *v153;
  v155 = m_TexID;
  v156 = 32i64;
  do
  {
    if ( v154 == *v155 )
      *v155 = 0;
    ++v155;
    --v156;
  }
  while ( v156 );
  glDeleteTextures(1, v153);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[5].m_TexID = 0;
  v157 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[6].m_FrameBufferID;
  if ( *v157 )
  {
    glDeleteRenderbuffersAG(1, v157);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[6].m_FrameBufferID = 0;
  }
  v158 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[6].m_TexID;
  v159 = *v158;
  v160 = m_TexID;
  v161 = 32i64;
  do
  {
    if ( v159 == *v160 )
      *v160 = 0;
    ++v160;
    --v161;
  }
  while ( v161 );
  glDeleteTextures(1, v158);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[6].m_TexID = 0;
  v162 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[7].m_FrameBufferID;
  if ( *v162 )
  {
    glDeleteRenderbuffersAG(1, v162);
    this->m_pRender->m_renderTextures.m_FullScreenTexture[7].m_FrameBufferID = 0;
  }
  v163 = &this->m_pRender->m_renderTextures.m_FullScreenTexture[7].m_TexID;
  v164 = *v163;
  v165 = m_TexID;
  v166 = 32i64;
  do
  {
    if ( v164 == *v165 )
      *v165 = 0;
    ++v165;
    --v166;
  }
  while ( v166 );
  glDeleteTextures(1, v163);
  this->m_pRender->m_renderTextures.m_FullScreenTexture[7].m_TexID = 0;
  v167 = &this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID;
  if ( *v167 )
  {
    glDeleteRenderbuffersAG(1, v167);
    this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID = 0;
  }
  v168 = &this->m_pRender->m_renderTextures.m_GameOutputTexture.m_TexID;
  v169 = *v168;
  v170 = m_TexID;
  v171 = 32i64;
  do
  {
    if ( v169 == *v170 )
      *v170 = 0;
    ++v170;
    --v171;
  }
  while ( v171 );
  glDeleteTextures(1, v168);
  this->m_pRender->m_renderTextures.m_GameOutputTexture.m_TexID = 0;
  glDeleteRenderbuffersAG(1, &this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID);
  this->m_pRender->m_renderTextures.m_GameOutputTexture.m_FrameBufferID = 0;
  v172 = &this->m_pRender->m_renderTextures.m_GameOutputTexture.m_TexID;
  v173 = *v172;
  v174 = m_TexID;
  v175 = 32i64;
  do
  {
    if ( v173 == *v174 )
      *v174 = 0;
    ++v174;
    --v175;
  }
  while ( v175 );
  glDeleteTextures(1, v172);
  this->m_pRender->m_renderTextures.m_GameOutputTexture.m_TexID = 0;
  v176 = &this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID;
  if ( *v176 )
  {
    glDeleteRenderbuffersAG(1, v176);
    this->m_pRender->m_renderTextures.m_TempTexture.m_FrameBufferID = 0;
  }
  v177 = &this->m_pRender->m_renderTextures.m_TempTexture.m_TexID;
  v178 = *v177;
  v179 = m_TexID;
  v180 = 32i64;
  do
  {
    if ( v178 == *v179 )
      *v179 = 0;
    ++v179;
    --v180;
  }
  while ( v180 );
  glDeleteTextures(1, v177);
  this->m_pRender->m_renderTextures.m_TempTexture.m_TexID = 0;
  v181 = &this->m_pRender->m_renderTextures.m_DownsampledTexture.m_FrameBufferID;
  if ( *v181 )
  {
    glDeleteRenderbuffersAG(1, v181);
    this->m_pRender->m_renderTextures.m_DownsampledTexture.m_FrameBufferID = 0;
  }
  v182 = &this->m_pRender->m_renderTextures.m_DownsampledTexture.m_TexID;
  v183 = *v182;
  v184 = m_TexID;
  v185 = 32i64;
  do
  {
    if ( v183 == *v184 )
      *v184 = 0;
    ++v184;
    --v185;
  }
  while ( v185 );
  glDeleteTextures(1, v182);
  this->m_pRender->m_renderTextures.m_DownsampledTexture.m_TexID = 0;
  v186 = &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID;
  if ( *v186 )
  {
    glDeleteRenderbuffersAG(1, v186);
    this->m_pRender->m_renderTextures.m_BloomMapTexture.m_FrameBufferID = 0;
  }
  v187 = &this->m_pRender->m_renderTextures.m_BloomMapTexture.m_TexID;
  v188 = *v187;
  v189 = m_TexID;
  v190 = 32i64;
  do
  {
    if ( v188 == *v189 )
      *v189 = 0;
    ++v189;
    --v190;
  }
  while ( v190 );
  glDeleteTextures(1, v187);
  this->m_pRender->m_renderTextures.m_BloomMapTexture.m_TexID = 0;
  v191 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID;
  if ( *v191 )
  {
    glDeleteRenderbuffersAG(1, v191);
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_FrameBufferID = 0;
  }
  v192 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_TexID;
  v193 = *v192;
  v194 = m_TexID;
  v195 = 32i64;
  do
  {
    if ( v193 == *v194 )
      *v194 = 0;
    ++v194;
    --v195;
  }
  while ( v195 );
  glDeleteTextures(1, v192);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[0].m_TexID = 0;
  v196 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID;
  if ( *v196 )
  {
    glDeleteRenderbuffersAG(1, v196);
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_FrameBufferID = 0;
  }
  v197 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_TexID;
  v198 = *v197;
  v199 = m_TexID;
  v200 = 32i64;
  do
  {
    if ( v198 == *v199 )
      *v199 = 0;
    ++v199;
    --v200;
  }
  while ( v200 );
  glDeleteTextures(1, v197);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[1].m_TexID = 0;
  v201 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID;
  if ( *v201 )
  {
    glDeleteRenderbuffersAG(1, v201);
    this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_FrameBufferID = 0;
  }
  v202 = &this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_TexID;
  v203 = *v202;
  v204 = m_TexID;
  v205 = 32i64;
  do
  {
    if ( v203 == *v204 )
      *v204 = 0;
    ++v204;
    --v205;
  }
  while ( v205 );
  glDeleteTextures(1, v202);
  this->m_pRender->m_renderTextures.m_BloomMapDownSampleTexture[2].m_TexID = 0;
  v206 = &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID;
  if ( *v206 )
  {
    glDeleteRenderbuffersAG(1, v206);
    this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_FrameBufferID = 0;
  }
  v207 = &this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_TexID;
  v208 = *v207;
  v209 = m_TexID;
  v210 = 32i64;
  do
  {
    if ( v208 == *v209 )
      *v209 = 0;
    ++v209;
    --v210;
  }
  while ( v210 );
  glDeleteTextures(1, v207);
  this->m_pRender->m_renderTextures.m_BloomDepthMapTexture.m_TexID = 0;
  v211 = &this->m_pRender->m_renderTextures.m_ScreenBlurTexture.m_FrameBufferID;
  if ( *v211 )
  {
    glDeleteRenderbuffersAG(1, v211);
    this->m_pRender->m_renderTextures.m_ScreenBlurTexture.m_FrameBufferID = 0;
  }
  v212 = &this->m_pRender->m_renderTextures.m_ScreenBlurTexture.m_TexID;
  v213 = *v212;
  v214 = m_TexID;
  v215 = 32i64;
  do
  {
    if ( v213 == *v214 )
      *v214 = 0;
    ++v214;
    --v215;
  }
  while ( v215 );
  glDeleteTextures(1, v212);
  this->m_pRender->m_renderTextures.m_ScreenBlurTexture.m_TexID = 0;
  v216 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_FrameBufferID;
  if ( *v216 )
  {
    glDeleteRenderbuffersAG(1, v216);
    this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_FrameBufferID = 0;
  }
  v217 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_TexID;
  v218 = *v217;
  v219 = m_TexID;
  v220 = 32i64;
  do
  {
    if ( v218 == *v219 )
      *v219 = 0;
    ++v219;
    --v220;
  }
  while ( v220 );
  glDeleteTextures(1, v217);
  this->m_pRender->m_renderTextures.m_CombinedMaskTexture[0].m_TexID = 0;
  v221 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[1].m_FrameBufferID;
  if ( *v221 )
  {
    glDeleteRenderbuffersAG(1, v221);
    this->m_pRender->m_renderTextures.m_CombinedMaskTexture[1].m_FrameBufferID = 0;
  }
  v222 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[1].m_TexID;
  v223 = *v222;
  v224 = m_TexID;
  v225 = 32i64;
  do
  {
    if ( v223 == *v224 )
      *v224 = 0;
    ++v224;
    --v225;
  }
  while ( v225 );
  glDeleteTextures(1, v222);
  this->m_pRender->m_renderTextures.m_CombinedMaskTexture[1].m_TexID = 0;
  v226 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[2].m_FrameBufferID;
  if ( *v226 )
  {
    glDeleteRenderbuffersAG(1, v226);
    this->m_pRender->m_renderTextures.m_CombinedMaskTexture[2].m_FrameBufferID = 0;
  }
  v227 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[2].m_TexID;
  v228 = *v227;
  v229 = m_TexID;
  v230 = 32i64;
  do
  {
    if ( v228 == *v229 )
      *v229 = 0;
    ++v229;
    --v230;
  }
  while ( v230 );
  glDeleteTextures(1, v227);
  this->m_pRender->m_renderTextures.m_CombinedMaskTexture[2].m_TexID = 0;
  v231 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[3].m_FrameBufferID;
  if ( *v231 )
  {
    glDeleteRenderbuffersAG(1, v231);
    this->m_pRender->m_renderTextures.m_CombinedMaskTexture[3].m_FrameBufferID = 0;
  }
  v232 = &this->m_pRender->m_renderTextures.m_CombinedMaskTexture[3].m_TexID;
  v233 = *v232;
  v234 = m_TexID;
  v235 = 32i64;
  do
  {
    if ( v233 == *v234 )
      *v234 = 0;
    ++v234;
    --v235;
  }
  while ( v235 );
  glDeleteTextures(1, v232);
  this->m_pRender->m_renderTextures.m_CombinedMaskTexture[3].m_TexID = 0;
  v236 = &this->m_pRender->m_renderTextures.m_RenderBufferBloomDepthMapTexture.m_FrameBufferID;
  if ( *v236 )
  {
    glDeleteRenderbuffersAG(1, v236);
    this->m_pRender->m_renderTextures.m_RenderBufferBloomDepthMapTexture.m_FrameBufferID = 0;
  }
  v237 = &this->m_pRender->m_renderTextures.m_RenderBufferBloomDepthMapTexture.m_TexID;
  v238 = *v237;
  v239 = m_TexID;
  v240 = 32i64;
  do
  {
    if ( v238 == *v239 )
      *v239 = 0;
    ++v239;
    --v240;
  }
  while ( v240 );
  glDeleteTextures(1, v237);
  this->m_pRender->m_renderTextures.m_RenderBufferBloomDepthMapTexture.m_TexID = 0;
  v241 = &this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_FrameBufferID;
  if ( *v241 )
  {
    glDeleteRenderbuffersAG(1, v241);
    this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_FrameBufferID = 0;
  }
  v242 = &this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexID;
  v243 = *v242;
  v244 = m_TexID;
  v245 = 32i64;
  do
  {
    if ( v243 == *v244 )
      *v244 = 0;
    ++v244;
    --v245;
  }
  while ( v245 );
  glDeleteTextures(1, v242);
  this->m_pRender->m_renderTextures.m_ReflectionTexture[0].m_TexID = 0;
  v246 = &this->m_pRender->m_renderTextures.m_ReflectionTexture[1].m_FrameBufferID;
  if ( *v246 )
  {
    glDeleteRenderbuffersAG(1, v246);
    this->m_pRender->m_renderTextures.m_ReflectionTexture[1].m_FrameBufferID = 0;
  }
  v247 = &this->m_pRender->m_renderTextures.m_ReflectionTexture[1].m_TexID;
  v248 = *v247;
  v249 = m_TexID;
  v250 = 32i64;
  do
  {
    if ( v248 == *v249 )
      *v249 = 0;
    ++v249;
    --v250;
  }
  while ( v250 );
  glDeleteTextures(1, v247);
  this->m_pRender->m_renderTextures.m_ReflectionTexture[1].m_TexID = 0;
  v251 = &this->m_pRender->m_renderTextures.m_CharacterHighlights[0].m_FrameBufferID;
  if ( *v251 )
  {
    glDeleteRenderbuffersAG(1, v251);
    this->m_pRender->m_renderTextures.m_CharacterHighlights[0].m_FrameBufferID = 0;
  }
  v252 = &this->m_pRender->m_renderTextures.m_CharacterHighlights[0].m_TexID;
  v253 = *v252;
  v254 = m_TexID;
  v255 = 32i64;
  do
  {
    if ( v253 == *v254 )
      *v254 = 0;
    ++v254;
    --v255;
  }
  while ( v255 );
  glDeleteTextures(1, v252);
  this->m_pRender->m_renderTextures.m_CharacterHighlights[0].m_TexID = 0;
  v256 = &this->m_pRender->m_renderTextures.m_CharacterHighlights[1].m_FrameBufferID;
  if ( *v256 )
  {
    glDeleteRenderbuffersAG(1, v256);
    this->m_pRender->m_renderTextures.m_CharacterHighlights[1].m_FrameBufferID = 0;
  }
  v257 = &this->m_pRender->m_renderTextures.m_CharacterHighlights[1].m_TexID;
  v258 = *v257;
  v259 = m_TexID;
  v260 = 32i64;
  do
  {
    if ( v258 == *v259 )
      *v259 = 0;
    ++v259;
    --v260;
  }
  while ( v260 );
  glDeleteTextures(1, v257);
  this->m_pRender->m_renderTextures.m_CharacterHighlights[1].m_TexID = 0;
  if ( !bDeleteBufferOnly )
  {
    v261 = &this->m_pRender->m_renderTextures.m_CharacterTexture[0].m_FrameBufferID;
    if ( *v261 )
    {
      glDeleteRenderbuffersAG(1, v261);
      this->m_pRender->m_renderTextures.m_CharacterTexture[0].m_FrameBufferID = 0;
    }
    v262 = &this->m_pRender->m_renderTextures.m_CharacterTexture[0].m_TexID;
    v263 = *v262;
    v264 = m_TexID;
    v265 = 32i64;
    do
    {
      if ( v263 == *v264 )
        *v264 = 0;
      ++v264;
      --v265;
    }
    while ( v265 );
    glDeleteTextures(1, v262);
    this->m_pRender->m_renderTextures.m_CharacterTexture[0].m_TexID = 0;
    v266 = &this->m_pRender->m_renderTextures.m_CharacterTexture[1].m_FrameBufferID;
    if ( *v266 )
    {
      glDeleteRenderbuffersAG(1, v266);
      this->m_pRender->m_renderTextures.m_CharacterTexture[1].m_FrameBufferID = 0;
    }
    v267 = &this->m_pRender->m_renderTextures.m_CharacterTexture[1].m_TexID;
    v268 = *v267;
    do
    {
      if ( v268 == *v7 )
        *v7 = 0;
      ++v7;
      --v9;
    }
    while ( v9 );
    glDeleteTextures(1, v267);
    this->m_pRender->m_renderTextures.m_CharacterTexture[1].m_TexID = 0;
  }
  AppMain::ClearMotionBlurFrames(this, 0);
  AppMain::ClearMotionBlurFrames(this, 1);
  if ( !bDeleteBufferOnly )
  {
    v269 = *(_QWORD *)&AppMain::pApp;
    v270 = *(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64);
    asset.m_isNoCache = *(_BYTE *)(v270 + 33);
    v271 = *(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body **)(v270 + 40);
    asset.m_body.m_ptr = v271;
    if ( v271 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)&v271->m_refCount.m_ptr->m_sharedCount, 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    v272 = *(_QWORD *)(v269 + 11064);
    v299 = *(_BYTE *)(v272 + 49);
    v273 = *(_QWORD *)(v272 + 56);
    v300 = v273;
    if ( v273 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(v273 + 8) + 16i64), 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    v274 = *(_QWORD *)(v269 + 11064);
    v301 = *(_BYTE *)(v274 + 65);
    v275 = *(_QWORD *)(v274 + 72);
    v302 = v275;
    if ( v275 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(v275 + 8) + 16i64), 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    v276 = *(_QWORD *)(v269 + 11064);
    v303 = *(_BYTE *)(v276 + 81);
    v277 = *(_QWORD *)(v276 + 88);
    v304 = v277;
    if ( v277 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(v277 + 8) + 16i64), 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    v278 = *(_QWORD *)(v269 + 11064);
    v305 = *(_BYTE *)(v278 + 1);
    v279 = *(_QWORD **)(v278 + 8);
    block = v279;
    if ( v279 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)(v279[1] + 16i64), 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    v280 = *(_QWORD *)(v269 + 11064);
    v307 = *(_BYTE *)(v280 + 17);
    v281 = *(_QWORD *)(v280 + 24);
    v308 = v281;
    if ( v281 )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(v281 + 8) + 16i64), 1ui64);
      v269 = *(_QWORD *)&AppMain::pApp;
    }
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset((extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *)(*(_QWORD *)(v269 + 11064) + 32i64));
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset((extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 48i64));
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset((extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 64i64));
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset((extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 80i64));
    p_ppModel = &this->ModelRoomSettings.CharaInfo[0].ppModel;
    v284 = 4i64;
    do
    {
      LODWORD(p_ppModel[-1]._Mypair._Myval2) = 0;
      Myval2 = p_ppModel->_Mypair._Myval2;
      p_ppModel->_Mypair._Myval2 = 0i64;
      if ( Myval2 )
        operator delete(Myval2, v282);
      p_ppModel += 7;
      --v284;
    }
    while ( v284 );
    v286 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 8i64) + 16i64);
    if ( v286 && !*(_BYTE *)(v286 + 96) )
    {
      if ( (*(_QWORD *)(v286 + 88) & 1) == 0 )
        extension::AsyncStatus::waitFor((extension::AsyncStatus *)(v286 + 88), (extension::AsyncStatus::Step)v282);
      if ( *(_QWORD *)(v286 + 72) )
      {
        v287 = 0;
        p_pModel = &this->pModel;
        pModel = this->pModel;
        if ( pModel > (OGLModel **)&this->pModel || pModel + 43 < (OGLModel **)p_pModel )
        {
          v290 = 5i64;
          v287 = 44;
          do
          {
            *pModel = 0i64;
            pModel[1] = 0i64;
            pModel[2] = 0i64;
            pModel += 8;
            *(pModel - 5) = 0i64;
            *(pModel - 4) = 0i64;
            *(pModel - 3) = 0i64;
            *(pModel - 2) = 0i64;
            *(pModel - 1) = 0i64;
            --v290;
          }
          while ( v290 );
          *pModel = 0i64;
          pModel[1] = 0i64;
          pModel[2] = 0i64;
          pModel[3] = 0i64;
        }
        if ( v287 < 44i64 )
        {
          v291 = v287;
          do
            (*p_pModel)[v291++] = 0i64;
          while ( v291 < 44 );
        }
      }
    }
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset(*(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> **)(*(_QWORD *)&AppMain::pApp + 11064i64));
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::reset((extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption> *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 16i64));
    v292 = (extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> *)operator new(0x78ui64);
    extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>(
      v292,
      &asset);
    v297[2] = (__int64)v297;
    v297[0] = 0i64;
    v297[3] = (__int64)&v296;
    v296 = 0i64;
    obj._Mypair._Myval2 = v293;
    extension::SynchronizedQueue<extension::ExThread::Runnable>::enqueue(
      &extension::AsyncWorker::s_instance.m_loadJobConsumer.m_jobQueue,
      (std::unique_ptr<extension::ExThread::Runnable>)&obj);
    if ( v296 )
      (**v296)(v296, 1i64);
    if ( v297[0] )
      (**(void (__fastcall ***)(__int64, __int64))v297[0])(v297[0], 1i64);
    `eh vector destructor iterator'(
      &asset,
      0x10ui64,
      6ui64,
      (void (__fastcall *)(void *))extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::~BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>);
  }
  extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::reset(this->pTexture._Mypair._Myval2._Myfirst);
  extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::reset(this->pTexture._Mypair._Myval2._Myfirst + 1);
  m_pRender = this->m_pRender;
  OGLLightManager::deleteAllLights(&m_pRender->m_WorldLightManager);
  OGLLightManager::clear(&m_pRender->m_WorldLightManager);
  BattleStage::dispose(&this->stageGimmick);
}

void __fastcall extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::reset(
        extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption> *this)
{
  extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body *m_ptr; // rax
  extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body *v3; // rcx
  extension::RefCountablePtr<extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body> result; // [rsp+28h] [rbp-10h] BYREF

  extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body::GetSharedEmpty(&result);
  this->m_isNoCache = 0;
  m_ptr = result.m_ptr;
  if ( result.m_ptr )
  {
    _InterlockedExchangeAdd64((volatile signed __int64 *)&result.m_ptr->m_refCount.m_ptr->m_sharedCount, 1ui64);
    m_ptr = result.m_ptr;
  }
  v3 = this->m_body.m_ptr;
  this->m_body.m_ptr = m_ptr;
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd64(
           (volatile signed __int64 *)&v3->m_refCount.m_ptr->m_sharedCount,
           0xFFFFFFFFFFFFFFFFui64) == 1 )
      ((void (__fastcall *)(extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body *, __int64))v3->~RefCountableWeakSupportBase)(
        v3,
        1i64);
    m_ptr = result.m_ptr;
  }
  if ( m_ptr )
  {
    if ( _InterlockedExchangeAdd64(
           (volatile signed __int64 *)&m_ptr->m_refCount.m_ptr->m_sharedCount,
           0xFFFFFFFFFFFFFFFFui64) == 1 )
      ((void (__fastcall *)(extension::BasicFutureObject<OGLTexture,extension::FutureTextureOption>::Body *, __int64))result.m_ptr->~RefCountableWeakSupportBase)(
        result.m_ptr,
        1i64);
  }
}

__int64 __fastcall extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6>::run(
        extension::UnloadJob<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>,6> *this)
{
  extension::RefCountablePtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body> *p_m_body; // rbx
  __int64 v2; // rdi
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *m_ptr; // rax
  extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *v4; // rcx
  extension::RefCountablePtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body> result; // [rsp+28h] [rbp-10h] BYREF

  p_m_body = &this->m_asset[0].m_body;
  v2 = 6i64;
  do
  {
    extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body::GetSharedEmpty(&result);
    BYTE1(p_m_body[-1].m_ptr) = 0;
    m_ptr = result.m_ptr;
    if ( result.m_ptr )
    {
      _InterlockedExchangeAdd64((volatile signed __int64 *)&result.m_ptr->m_refCount.m_ptr->m_sharedCount, 1ui64);
      m_ptr = result.m_ptr;
    }
    v4 = p_m_body->m_ptr;
    p_m_body->m_ptr = m_ptr;
    if ( v4 )
    {
      if ( _InterlockedExchangeAdd64(
             (volatile signed __int64 *)&v4->m_refCount.m_ptr->m_sharedCount,
             0xFFFFFFFFFFFFFFFFui64) == 1 )
        ((void (__fastcall *)(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *, __int64))v4->~RefCountableWeakSupportBase)(
          v4,
          1i64);
      m_ptr = result.m_ptr;
    }
    if ( m_ptr
      && _InterlockedExchangeAdd64(
           (volatile signed __int64 *)&m_ptr->m_refCount.m_ptr->m_sharedCount,
           0xFFFFFFFFFFFFFFFFui64) == 1 )
    {
      ((void (__fastcall *)(extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body *, __int64))result.m_ptr->~RefCountableWeakSupportBase)(
        result.m_ptr,
        1i64);
    }
    p_m_body += 2;
    --v2;
  }
  while ( v2 );
  return 0i64;
}

void __fastcall AppMain::setEffectLightOn(AppMain *this, int charId, bool val)
{
  int v3; // edi
  char *v5; // r11
  __int64 v6; // r10
  __int64 *v7; // rdx
  __int64 v8; // rax
  int v9; // er9
  __int64 v10; // r8
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rcx

  v3 = 0;
  v5 = (char *)this + 56 * charId;
  if ( *((int *)v5 + 387768) > 0 )
  {
    v6 = 0i64;
    do
    {
      v7 = (__int64 *)(v6 + *((_QWORD *)v5 + 193885));
      v8 = *v7;
      if ( *v7 )
      {
        if ( *(_QWORD *)(v8 + 8456) )
        {
          v9 = 0;
          if ( *(_BYTE *)(v8 + 8464) )
          {
            v10 = 0i64;
            do
            {
              v11 = *(_QWORD *)(*(_QWORD *)(*v7 + 8456) + v10 + 328);
              if ( v11 )
              {
                v12 = *(_QWORD *)(v11 + 712);
                if ( v12 )
                {
                  if ( *(int *)v11 > 2 )
                  {
                    v13 = *(_QWORD *)(*(_QWORD *)(v12 + 288) + 288i64);
                    if ( v13 )
                      *(_BYTE *)(v13 + 4) = val;
                  }
                }
              }
              ++v9;
              v7 = (__int64 *)(v6 + *((_QWORD *)v5 + 193885));
              v10 += 1128i64;
            }
            while ( v9 < *(unsigned __int8 *)(*v7 + 8464) );
          }
        }
      }
      ++v3;
      v6 += 8i64;
    }
    while ( v3 < *((_DWORD *)v5 + 387768) );
  }
}

void __fastcall AppMain::setRenderCamera(AppMain *this, void *ptr, int no, float *position, float *look, float *up)
{
  float v7; // xmm8_4
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1

  this->posVec3 = *(OGLVec3 *)position;
  this->lookVec3 = *(OGLVec3 *)look;
  this->upVec3 = *(OGLVec3 *)up;
  v7 = (float)this->m_iScreenW / (float)this->m_iScreenH;
  OGLMatrix::setViewTrans(
    &this->ModelRoomSettings.mView,
    &this->ModelRoomSettings.mBillboard,
    &this->posVec3,
    &this->lookVec3,
    &this->upVec3);
  OGLMatrix::perspectiveFov(this->ModelRoomSettings.mProj, this->ModelRoomSettings.perseAngle, v7, 1.0, 4096.0);
  OGLMatrix::perspectiveFov(&this->ModelRoomSettings.mProj[1], this->ModelRoomSettings.perseAngle, v7, 1.0, 4096.0);
  OGLMatrix::perspectiveFov(&this->ModelRoomSettings.mProj[2], this->ModelRoomSettings.perseAngle, v7, 1.0, 4096.0);
  v8 = *(_OWORD *)&this->ModelRoomSettings.mProj[2].m[4];
  *(_OWORD *)this->ModelRoomSettings.mProj[3].m = *(_OWORD *)this->ModelRoomSettings.mProj[2].m;
  v9 = *(_OWORD *)&this->ModelRoomSettings.mProj[2].m[8];
  *(_OWORD *)&this->ModelRoomSettings.mProj[3].m[4] = v8;
  v10 = *(_OWORD *)&this->ModelRoomSettings.mProj[2].m[12];
  *(_OWORD *)&this->ModelRoomSettings.mProj[3].m[8] = v9;
  *(_OWORD *)&this->ModelRoomSettings.mProj[3].m[12] = v10;
}

void __fastcall AppMain::setRenderShadowLight(
        AppMain *this,
        void *ptr,
        int no,
        float *position,
        float *look,
        float *up)
{
  __int64 v7; // rdi
  OGLMatrix *v9; // rax
  OGLMatrix *v10; // rcx
  OGLMatrix **pShadowLightBillboard; // rdx
  OGLMatrix *v12; // rdx
  OGLMatrix **pShadowLight; // rcx
  OGLMatrix *v14; // [rsp+48h] [rbp+10h]

  v7 = no;
  if ( !this->pShadowLight[no] )
  {
    v9 = (OGLMatrix *)operator new(0x40ui64);
    *(_QWORD *)v9->m = 0i64;
    *(_QWORD *)&v9->m[2] = 0i64;
    *(_QWORD *)&v9->m[4] = 0i64;
    *(_QWORD *)&v9->m[6] = 0i64;
    *(_QWORD *)&v9->m[8] = 0i64;
    *(_QWORD *)&v9->m[10] = 0i64;
    *(_QWORD *)&v9->m[12] = 0i64;
    *(_QWORD *)&v9->m[14] = 0i64;
    this->pShadowLight[v7] = v9;
    v14 = (OGLMatrix *)operator new(0x40ui64);
    *(_QWORD *)v14->m = 0i64;
    *(_QWORD *)&v14->m[2] = 0i64;
    *(_QWORD *)&v14->m[4] = 0i64;
    *(_QWORD *)&v14->m[6] = 0i64;
    *(_QWORD *)&v14->m[8] = 0i64;
    *(_QWORD *)&v14->m[10] = 0i64;
    *(_QWORD *)&v14->m[12] = 0i64;
    *(_QWORD *)&v14->m[14] = 0i64;
    this->pShadowLightBillboard[v7] = v14;
    v10 = this->pShadowLight[v7];
    *(_QWORD *)&v10->m[8] = 0i64;
    *(_QWORD *)&v10->m[7] = 0i64;
    *(_QWORD *)v10->m = 1065353216i64;
    *(_QWORD *)&v10->m[5] = 1065353216i64;
    *(_QWORD *)&v10->m[10] = 1065353216i64;
    v10->m[15] = 1.0;
    *(_QWORD *)v10->m = 1065353216i64;
    v10->m[4] = 0.0;
    *(_QWORD *)&v10->m[12] = 0i64;
    *(_QWORD *)&v10->m[5] = 1065353216i64;
    v10->m[9] = 0.0;
    *(_QWORD *)&v10->m[2] = 0i64;
    *(_QWORD *)&v10->m[10] = 1065353216i64;
    v10->m[14] = 0.0;
    v10->m[7] = 0.0;
    v10->m[15] = 1.0;
  }
  pShadowLightBillboard = this->pShadowLightBillboard;
  this->posVec3.x = *position;
  this->posVec3.y = position[1];
  v12 = pShadowLightBillboard[v7];
  this->posVec3.z = position[2];
  this->lookVec3.x = *look;
  this->lookVec3.y = look[1];
  this->lookVec3.z = look[2];
  this->upVec3.x = *up;
  this->upVec3.y = up[1];
  pShadowLight = this->pShadowLight;
  this->upVec3.z = up[2];
  OGLMatrix::setViewTrans(pShadowLight[v7], v12, &this->posVec3, &this->lookVec3, &this->upVec3);
}

void __fastcall extension::AsyncContent<OGLMirror>::setResult(
        extension::AsyncContent<OGLMirror> *this,
        std::unique_ptr<OGLMirror> result)
{
  OGLMirrorData *m_MirrorData; // rax
  OGLMirror *Myval2; // rsi
  OGLMirrorData *v6; // rbx

  if ( (this->m_status.m_stateFlags.m_value._My_val & 1) == 0 )
  {
    m_MirrorData = result._Mypair._Myval2->m_MirrorData;
    if ( result._Mypair._Myval2->m_MirrorData )
    {
      result._Mypair._Myval2->m_MirrorData = 0i64;
      Myval2 = this->m_data._Mypair._Myval2;
      this->m_data._Mypair._Myval2 = (OGLMirror *)m_MirrorData;
      if ( Myval2 )
      {
        OGLMirror::finalize(Myval2, (unsigned __int64)result._Mypair._Myval2);
        operator delete(Myval2, 0x20ui64);
      }
    }
    else
    {
      this->m_errorCode = 5;
    }
    EnterCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_mutex);
    _InterlockedOr64((volatile signed __int64 *)&this->m_status, 1ui64);
    EnterCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_signalCondition.m_mutex);
    WakeAllConditionVariable((PCONDITION_VARIABLE)&extension::AsyncStatus::s_signalCondition.m_conditionVariable.m_data);
    LeaveCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_signalCondition.m_mutex);
    LeaveCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_mutex);
  }
  v6 = result._Mypair._Myval2->m_MirrorData;
  if ( result._Mypair._Myval2->m_MirrorData )
  {
    OGLMirror::finalize((OGLMirror *)v6, (unsigned __int64)result._Mypair._Myval2);
    operator delete(v6, 0x20ui64);
  }
}

void __fastcall extension::AsyncContent<OGLTexture>::setResult(
        extension::AsyncContent<Image> *this,
        std::unique_ptr<Image> result)
{
  Image *v4; // rax
  Image *Myval2; // rcx

  if ( (this->m_status.m_stateFlags.m_value._My_val & 1) == 0 )
  {
    v4 = (Image *)result._Mypair._Myval2->__vftable;
    if ( result._Mypair._Myval2->__vftable )
    {
      result._Mypair._Myval2->__vftable = 0i64;
      Myval2 = this->m_data._Mypair._Myval2;
      this->m_data._Mypair._Myval2 = v4;
      if ( Myval2 )
        ((void (__fastcall *)(Image *, __int64))Myval2->~OGLTexture)(Myval2, 1i64);
    }
    else
    {
      this->m_errorCode = 5;
    }
    EnterCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_mutex);
    _InterlockedOr64((volatile signed __int64 *)&this->m_status, 1ui64);
    EnterCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_signalCondition.m_mutex);
    WakeAllConditionVariable((PCONDITION_VARIABLE)&extension::AsyncStatus::s_signalCondition.m_conditionVariable.m_data);
    LeaveCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_signalCondition.m_mutex);
    LeaveCriticalSection((LPCRITICAL_SECTION)&extension::AsyncStatus::s_mutex);
  }
  if ( result._Mypair._Myval2->__vftable )
    (*(void (__fastcall **)(Image_vtbl *, __int64))result._Mypair._Myval2->~OGLTexture)(
      result._Mypair._Myval2->__vftable,
      1i64);
}

void __fastcall AppMain::setupLightUniforms(AppMain *this, int playerId)
{
  int v3; // er8
  OGLLightNode *m_pLightNodeList; // rbp
  int v6; // esi
  __int64 v7; // r14
  OGLModel *v8; // rbx
  int v9; // edi
  OGLMaterial *v10; // rcx
  int v11; // esi
  __int64 v12; // r14
  OGLModel *v13; // rbx
  int v14; // edi
  OGLMaterial *v15; // rcx
  int v16; // esi
  __int64 v17; // r14
  OGLModel *v18; // rbx
  int v19; // edi
  OGLMaterial *v20; // rcx
  int v21; // esi
  __int64 v22; // r14
  OGLModel *v23; // rbx
  int v24; // edi
  OGLMaterial *v25; // rcx
  __int64 v26; // rbx
  int v27; // er14
  __int64 i; // rsi
  __int64 v29; // rbx
  __int64 v30; // rcx
  OGLModel *v31; // rbx
  int v32; // edi
  OGLMaterial *v33; // rcx
  BattleStage *pBattleStage; // rcx
  int v35; // er14
  int GimmickOGLModelCount; // er12
  OGLModel *GimmickOGLModel; // rax
  OGLModel *v38; // rbx
  unsigned int m_ucMaterialCount; // eax
  __int64 v40; // rdi
  __int64 v41; // rsi
  OGLMaterial *v42; // rcx

  v3 = this->ModelRoomSettings.worldLightId[0];
  m_pLightNodeList = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
  if ( m_pLightNodeList )
  {
    if ( v3 != -1 )
    {
      while ( m_pLightNodeList->m_light.m_nId != v3 )
      {
        m_pLightNodeList = m_pLightNodeList->next;
        if ( !m_pLightNodeList )
          goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    m_pLightNodeList = 0i64;
  }
  if ( (unsigned int)(playerId + 1) <= 1 )
  {
    v6 = 0;
    if ( this->ModelRoomSettings.CharaInfo[0].iModelCount > 0 )
    {
      v7 = 0i64;
      do
      {
        v8 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2[v7];
        if ( v8 )
        {
          v9 = 0;
          if ( v8->m_ucMaterialCount )
          {
            do
            {
              v10 = &v8->m_pMaterial[v9];
              if ( v10 )
                OGLMaterial::prepShaderUniforms(
                  v10,
                  &m_pLightNodeList->m_light,
                  v8->m_skipSelfShadowLightId,
                  v8->m_lowAccuracyShadowBias,
                  v8->m_receiveShadowsFlg,
                  v8->m_createShadowFlg);
              ++v9;
            }
            while ( v9 < v8->m_ucMaterialCount );
          }
        }
        ++v6;
        ++v7;
      }
      while ( v6 < this->ModelRoomSettings.CharaInfo[0].iModelCount );
    }
    v11 = 0;
    if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
    {
      v12 = 0i64;
      do
      {
        v13 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2[v12];
        if ( v13 )
        {
          v14 = 0;
          if ( v13->m_ucMaterialCount )
          {
            do
            {
              v15 = &v13->m_pMaterial[v14];
              if ( v15 )
                OGLMaterial::prepShaderUniforms(
                  v15,
                  &m_pLightNodeList->m_light,
                  v13->m_skipSelfShadowLightId,
                  v13->m_lowAccuracyShadowBias,
                  v13->m_receiveShadowsFlg,
                  v13->m_createShadowFlg);
              ++v14;
            }
            while ( v14 < v13->m_ucMaterialCount );
          }
        }
        ++v11;
        ++v12;
      }
      while ( v11 < this->ModelRoomSettings.CharaInfo[2].iModelCount );
    }
  }
  if ( ((playerId + 1) & 0xFFFFFFFD) == 0 )
  {
    v16 = 0;
    if ( this->ModelRoomSettings.CharaInfo[1].iModelCount > 0 )
    {
      v17 = 0i64;
      do
      {
        v18 = this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2[v17];
        if ( v18 )
        {
          v19 = 0;
          if ( v18->m_ucMaterialCount )
          {
            do
            {
              v20 = &v18->m_pMaterial[v19];
              if ( v20 )
                OGLMaterial::prepShaderUniforms(
                  v20,
                  &m_pLightNodeList->m_light,
                  v18->m_skipSelfShadowLightId,
                  v18->m_lowAccuracyShadowBias,
                  v18->m_receiveShadowsFlg,
                  v18->m_createShadowFlg);
              ++v19;
            }
            while ( v19 < v18->m_ucMaterialCount );
          }
        }
        ++v16;
        ++v17;
      }
      while ( v16 < this->ModelRoomSettings.CharaInfo[1].iModelCount );
    }
    v21 = 0;
    if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
    {
      v22 = 0i64;
      do
      {
        v23 = this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2[v22];
        if ( v23 )
        {
          v24 = 0;
          if ( v23->m_ucMaterialCount )
          {
            do
            {
              v25 = &v23->m_pMaterial[v24];
              if ( v25 )
                OGLMaterial::prepShaderUniforms(
                  v25,
                  &m_pLightNodeList->m_light,
                  v23->m_skipSelfShadowLightId,
                  v23->m_lowAccuracyShadowBias,
                  v23->m_receiveShadowsFlg,
                  v23->m_createShadowFlg);
              ++v24;
            }
            while ( v24 < v23->m_ucMaterialCount );
          }
        }
        ++v21;
        ++v22;
      }
      while ( v21 < this->ModelRoomSettings.CharaInfo[3].iModelCount );
    }
  }
  v26 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 8i64) + 16i64);
  if ( v26 && !*(_BYTE *)(v26 + 96) )
  {
    if ( (*(_QWORD *)(v26 + 88) & 1) == 0 )
      extension::AsyncStatus::waitFor((extension::AsyncStatus *)(v26 + 88), (extension::AsyncStatus::Step)playerId);
    if ( *(_QWORD *)(v26 + 72) )
    {
      v27 = 0;
      for ( i = 0i64; ; ++i )
      {
        v29 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)&AppMain::pApp + 11064i64) + 8i64) + 16i64);
        if ( !v29 || *(_BYTE *)(v29 + 96) )
        {
          v30 = 0i64;
        }
        else
        {
          if ( (*(_QWORD *)(v29 + 88) & 1) == 0 )
            extension::AsyncStatus::waitFor(
              (extension::AsyncStatus *)(v29 + 88),
              (extension::AsyncStatus::Step)playerId);
          v30 = *(_QWORD *)(v29 + 72);
        }
        if ( v27 >= (int)((__int64)(*(_QWORD *)(v30 + 208) - *(_QWORD *)(v30 + 200)) >> 3) )
          break;
        v31 = this->pModel[i];
        if ( v31 )
        {
          v32 = 0;
          if ( v31->m_ucMaterialCount )
          {
            do
            {
              v33 = &v31->m_pMaterial[v32];
              if ( v33 )
                OGLMaterial::prepShaderUniforms(
                  v33,
                  &m_pLightNodeList->m_light,
                  v31->m_skipSelfShadowLightId,
                  v31->m_lowAccuracyShadowBias,
                  v31->m_receiveShadowsFlg,
                  v31->m_createShadowFlg);
              ++v32;
            }
            while ( v32 < v31->m_ucMaterialCount );
          }
        }
        ++v27;
      }
    }
  }
  pBattleStage = this->pBattleStage;
  if ( pBattleStage )
  {
    v35 = 0;
    GimmickOGLModelCount = BattleStage::getGimmickOGLModelCount(pBattleStage);
    if ( GimmickOGLModelCount > 0 )
    {
      do
      {
        GimmickOGLModel = BattleStage::getGimmickOGLModel(this->pBattleStage, v35);
        v38 = GimmickOGLModel;
        if ( GimmickOGLModel )
        {
          m_ucMaterialCount = GimmickOGLModel->m_ucMaterialCount;
          if ( m_ucMaterialCount )
          {
            v40 = 0i64;
            v41 = m_ucMaterialCount;
            do
            {
              v42 = &v38->m_pMaterial[v40];
              if ( v42 )
                OGLMaterial::prepShaderUniforms(
                  v42,
                  &m_pLightNodeList->m_light,
                  v38->m_skipSelfShadowLightId,
                  v38->m_lowAccuracyShadowBias,
                  v38->m_receiveShadowsFlg,
                  v38->m_createShadowFlg);
              ++v40;
              --v41;
            }
            while ( v41 );
          }
        }
        ++v35;
      }
      while ( v35 < GimmickOGLModelCount );
    }
  }
}

void __fastcall AppMain::setupModelRoomSettings(AppMain *this)
{
  if ( !this->pBattleStage )
  {
    this->ModelRoomSettings.cameraDist = 52.5;
    this->ModelRoomSettings.cameraHeight = 12.5;
    this->ModelRoomSettings.ZOffsetP1 = -10.0;
    this->ModelRoomSettings.cameraAngle = 0.0;
    *(_WORD *)&this->ModelRoomSettings.drawDebugTextures = 0;
    *(_QWORD *)this->ModelRoomSettings.framebufferColour = 0i64;
    this->ModelRoomSettings.framebufferColour[2] = 0;
    memset(&this->ModelRoomSettings.modelFillSettings, 0, 0xA8ui64);
    memset(&this->ModelRoomSettings.postfxUniforms, 0, sizeof(this->ModelRoomSettings.postfxUniforms));
    memset(&this->ModelRoomSettings.filterUniforms, 0, sizeof(this->ModelRoomSettings.filterUniforms));
    *(_QWORD *)this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.transparencyOn = 0i64;
    this->ModelRoomSettings.postprocessSettings.bufferTransparencySettings.opacity[1] = 0.0;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.extraBGSettings.monitorOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[1] = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomQuality = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.bgBloomSettings.baseSaturation = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomSaturation = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.bgBloomSettings.blurStrength = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightBrightness = 0i64;
    this->ModelRoomSettings.postprocessSettings.causticSettings = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.dofSettings.faceOffDofOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.dofSettings.faceOffDofFar = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.dofSettings.fightDofNear = 0i64;
    this->ModelRoomSettings.postprocessSettings.dofSettings.fightDofStrength = 0.0;
    memset(&this->ModelRoomSettings.postprocessSettings.groundFogSettings, 0, 0xA0ui64);
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.shaderOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.exposure = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.density = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.x = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelPos.z = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.godRaySettings.sunModelIndex = 0i64;
    *(_WORD *)&this->ModelRoomSettings.postprocessSettings.motionBlurSettings[0].motionBlurOn = 0;
    *(_WORD *)&this->ModelRoomSettings.postprocessSettings.motionBlurSettings[1].motionBlurOn = 0;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.FilterOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.Saturation = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsInWhite = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsOutBlack = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.GradientOn = 0i64;
    *(_QWORD *)this->ModelRoomSettings.postprocessSettings.screenFilter.GradientStartColour = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.GradientStartColour[2] = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.GradientEndColour[1] = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.monitorFilter.FilterOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.monitorFilter.brightness = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.monitorFilter.contrast = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.monitorFilter.midTonesColShift[1] = 0i64;
    this->ModelRoomSettings.postprocessSettings.monitorFilter.midTonesColShift[3] = 0.0;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.shaderOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.currentWaterTrans = 0i64;
    *(_QWORD *)this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.windDirection = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.windDirection[2] = 0i64;
    *(_QWORD *)this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterCol = 0i64;
    this->ModelRoomSettings.postprocessSettings.waterSurfaceSettings.waterCol[2] = 0.0;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaLowerThreshold = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.shadowLightAreaSettings.shadLightType = 0i64;
    this->ModelRoomSettings.postprocessSettings.shadowLightAreaSettings.shadLightPos = 0i64;
    this->ModelRoomSettings.postprocessSettings.shadowLightAreaSettings.shadLightMinMax = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeOn = 0i64;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.heatHazeSettings.heatHazeSpeed = 0i64;
    *(_WORD *)this->ModelRoomSettings.motionBlurShowBit = 3855;
    this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[0] = 1.0;
    this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[1] = 1.0;
    this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsInBlack = 0.0;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.extraBGSettings.lightningCol[2] = 1065353216i64;
    this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaOn = 1;
    this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaDispRange = 8.0;
    this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaNormScaleFactor = 0.5;
    this->ModelRoomSettings.postprocessSettings.fxaaSettings.fxaaLowerThreshold = 0.16666667;
    *(_WORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.FilterOn = 0;
    this->ModelRoomSettings.postprocessSettings.screenFilter.Brightness = 1.05;
    this->ModelRoomSettings.postprocessSettings.screenFilter.Saturation = 0.94999999;
    this->ModelRoomSettings.postprocessSettings.screenFilter.Contrast = 1.03;
    this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsOn = 0;
    this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsInWhite = 0.85000002;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsInGamma = 1065772646i64;
    strcpy((char *)&this->ModelRoomSettings.postprocessSettings.screenFilter.PSLevelsOutWhite, "33s?");
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientOverlayOpacity = 0.30000001;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientStartColour[0] = 0.40000001;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientStartColour[1] = 0.5;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientStartColour[2] = 0.44999999;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientEndColour[0] = 0.94999999;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientEndColour[1] = 1.0;
    this->ModelRoomSettings.postprocessSettings.screenFilter.GradientEndColour[2] = 0.97000003;
    *(_QWORD *)&this->ModelRoomSettings.postprocessSettings.monitorFilter.blur = 1065353216i64;
    this->ModelRoomSettings.postprocessSettings.monitorFilter.saturation = 1.0;
    this->ModelRoomSettings.postprocessSettings.monitorFilter.contrast = 1.0;
    this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightThreshold = 0.40000001;
    this->ModelRoomSettings.postprocessSettings.charBloomSettings.highlightBrightness = 1.0;
    this->ModelRoomSettings.postprocessSettings.charBloomSettings.blurStrength = 0.303;
    this->ModelRoomSettings.postprocessSettings.charBloomSettings.downsampleScale = 2;
    this->ModelRoomSettings.postprocessSettings.charBloomSettings.bloomOn = 0;
    this->ModelRoomSettings.postprocessSettings.bgBloomSettings.bloomDownSamplingBlurSize = 1;
  }
}

void __fastcall AppMain::setupShadowMatrices(AppMain *this, int charStack)
{
  int v2; // er8
  OGLRender *m_pRender; // rcx
  int v6; // edi
  OGLLightNode *i; // rax
  OGLLightNode *m_pLightNodeList; // rax
  float v9; // xmm6_4
  float t; // xmm7_4
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rcx
  OGLMatrix *v15; // rcx
  float v16; // xmm6_4
  float v17; // xmm0_4
  float v18; // xmm6_4
  int v19; // edx
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  OGLLightNode *v22; // rcx
  __int128 v23; // xmm2
  __int128 v24; // xmm3
  __int64 v25; // rcx
  OGLRender *v26; // rax
  OGLMatrix *v27; // r8
  int v28; // edx
  OGLLightNode *v29; // rcx
  __int64 v30; // r8
  OGLMatrix *v31; // rcx
  OGLRender *v32; // rax
  OGLMatrix v33; // [rsp+48h] [rbp-19h] BYREF

  v2 = this->ModelRoomSettings.worldLightId[0];
  if ( v2 != -1 )
  {
    m_pRender = this->m_pRender;
    v6 = 0;
    for ( i = m_pRender->m_WorldLightManager.m_pLightNodeList; i; i = i->next )
    {
      if ( i->m_light.m_nId == v2 )
        goto LABEL_7;
    }
    i = 0i64;
LABEL_7:
    if ( i->m_light.m_bCastsShadows )
    {
      memset(&v33.m[5], 0, 20);
      v33.m[15] = 0.0;
      v33.m[4] = 0.0;
      v33.m[14] = 0.0;
      *(_QWORD *)&v33.m[12] = 0i64;
      *(_QWORD *)&v33.m[2] = 0i64;
      m_pLightNodeList = m_pRender->m_WorldLightManager.m_pLightNodeList;
      *(_QWORD *)v33.m = 1065353216i64;
      *(_QWORD *)&v33.m[5] = 1065353216i64;
      *(_QWORD *)&v33.m[10] = 1065353216i64;
      v33.m[15] = 1.0;
      while ( m_pLightNodeList )
      {
        if ( m_pLightNodeList->m_light.m_nId == v2 )
          goto LABEL_13;
        m_pLightNodeList = m_pLightNodeList->next;
      }
      m_pLightNodeList = 0i64;
LABEL_13:
      if ( m_pLightNodeList->m_light.m_LightType != LIGHT_TYPE_DIR )
      {
        v15 = *this->pShadowLight;
        if ( v15 )
          v16 = sqrtf(
                  (float)((float)(v15->m[12] * v15->m[12]) + (float)(v15->m[13] * v15->m[13]))
                + (float)(v15->m[14] * v15->m[14]));
        else
          v16 = FLOAT_35_0;
        v17 = atanf(60.0 / v16);
        v18 = v16 - 60.0;
        if ( v18 < 0.0 )
          v18 = FLOAT_32_0;
        OGLMatrix::perspectiveFov(
          &v33,
          (float)((float)(v17 + v17) * 180.0) / 3.1415927,
          1.0,
          v18,
          (float)(v18 + 60.0) * 10.0);
        goto LABEL_31;
      }
      v9 = FLOAT_N15_0;
      t = FLOAT_15_0;
      if ( charStack == 2 )
      {
        if ( this->ModelRoomSettings.CharaInfo[2].iModelCount <= 0 )
          goto LABEL_24;
        BattleSystem::BattleController::GetActionSystem();
        v12 = *(_QWORD *)(v11 + 237248);
        if ( !v12 || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v12 + 1448i64))(v12) )
          goto LABEL_24;
      }
      else
      {
        if ( charStack != 3 )
          goto LABEL_24;
        if ( this->ModelRoomSettings.CharaInfo[3].iModelCount <= 0 )
          goto LABEL_24;
        BattleSystem::BattleController::GetActionSystem();
        v14 = *(_QWORD *)(v13 + 237256);
        if ( !v14 || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 1448i64))(v14) )
          goto LABEL_24;
      }
      v9 = FLOAT_N30_0;
      t = *(float *)&FLOAT_30_0;
LABEL_24:
      OGLMatrix::ortho(&v33, v9, t, v9, t, 32.0, 256.0);
LABEL_31:
      v19 = this->ModelRoomSettings.worldLightId[0];
      v20 = *(_OWORD *)&v33.m[12];
      v21 = *(_OWORD *)&v33.m[8];
      v22 = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
      v23 = *(_OWORD *)&v33.m[4];
      v24 = *(_OWORD *)v33.m;
      if ( v22 )
      {
        if ( v19 != -1 )
        {
          while ( v22->m_light.m_nId != v19 )
          {
            v22 = v22->next;
            if ( !v22 )
              goto LABEL_37;
          }
        }
        *(_OWORD *)v22->m_ProjLight.m = *(_OWORD *)v33.m;
        *(_OWORD *)&v22->m_ProjLight.m[4] = v23;
        *(_OWORD *)&v22->m_ProjLight.m[8] = v21;
        *(_OWORD *)&v22->m_ProjLight.m[12] = v20;
      }
LABEL_37:
      v25 = 284i64;
      if ( charStack != 2 )
        v25 = 300i64;
      v26 = this->m_pRender;
      *(_OWORD *)((char *)&v26->m_Width + v25 * 4) = v24;
      *(_OWORD *)(&v26->m_bWorldSetting + v25 * 4) = v23;
      *(_OWORD *)&v26->m_Proj.m[v25 + 3] = v21;
      *(_OWORD *)&v26->m_Proj.m[v25 + 7] = v20;
      v27 = *this->pShadowLight;
      if ( v27 )
      {
        v28 = this->ModelRoomSettings.worldLightId[0];
        v29 = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
        if ( v29 )
        {
          if ( v28 != -1 )
          {
            while ( v29->m_light.m_nId != v28 )
            {
              v29 = v29->next;
              if ( !v29 )
                goto LABEL_46;
            }
          }
          *(_OWORD *)v29->m_ViewLight.m = *(_OWORD *)v27->m;
          *(_OWORD *)&v29->m_ViewLight.m[4] = *(_OWORD *)&v27->m[4];
          *(_OWORD *)&v29->m_ViewLight.m[8] = *(_OWORD *)&v27->m[8];
          *(_OWORD *)&v29->m_ViewLight.m[12] = *(_OWORD *)&v27->m[12];
        }
LABEL_46:
        v30 = 252i64;
        v31 = *this->pShadowLight;
        if ( charStack != 2 )
          v30 = 268i64;
        v32 = this->m_pRender;
        *(_OWORD *)((char *)&v32->m_Width + v30 * 4) = *(_OWORD *)v31->m;
        *(_OWORD *)(&v32->m_bWorldSetting + v30 * 4) = *(_OWORD *)&v31->m[4];
        *(_OWORD *)&v32->m_Proj.m[v30 + 3] = *(_OWORD *)&v31->m[8];
        *(_OWORD *)&v32->m_Proj.m[v30 + 7] = *(_OWORD *)&v31->m[12];
      }
      LOBYTE(v6) = charStack != 2;
      OGLLightManager::calcShadowViewProjBiasMatrix(&this->m_pRender->m_WorldLightManager, v6);
    }
  }
}

void __fastcall AppMain::setupShadowMatrices(AppMain *this)
{
  OGLModel **Myval2; // rax
  OGLModel *v3; // rax
  float x; // xmm6_4
  float y; // xmm7_4
  BattleSystem::BattleController *v6; // rax
  Actor *v7; // rcx
  OGLModel **v8; // rax
  OGLModel **v9; // rax
  OGLModel *v10; // rax
  float v11; // xmm6_4
  float v12; // xmm7_4
  BattleSystem::BattleController *v13; // rax
  Actor *v14; // rcx
  OGLModel **v15; // rax
  float camPos; // [rsp+28h] [rbp-50h] BYREF
  float v17; // [rsp+2Ch] [rbp-4Ch]
  int v18; // [rsp+30h] [rbp-48h]
  BattleSystem::BattleController *v19; // [rsp+80h] [rbp+8h]
  BattleSystem::BattleController *v20; // [rsp+80h] [rbp+8h]

  Myval2 = this->ModelRoomSettings.CharaInfo[0].ppModel._Mypair._Myval2;
  if ( Myval2 )
  {
    v3 = *Myval2;
    x = v3->m_vCenterPosition.x;
    y = v3->m_vCenterPosition.y;
    if ( this->ModelRoomSettings.CharaInfo[2].iModelCount > 0 )
    {
      v6 = BattleSystem::BattleController::instance;
      if ( !BattleSystem::BattleController::instance )
      {
        v19 = (BattleSystem::BattleController *)operator new(0x3E578ui64);
        BattleSystem::BattleController::BattleController(v19);
        BattleSystem::BattleController::instance = v6;
      }
      v7 = v6->actSystem.pDrawActor[2];
      if ( v7 && v7->IsModelDraw(v7) )
      {
        v8 = this->ModelRoomSettings.CharaInfo[2].ppModel._Mypair._Myval2;
        x = (float)((*v8)->m_vCenterPosition.x + x) * 0.5;
        y = (float)((*v8)->m_vCenterPosition.y + y) * 0.5;
      }
    }
    camPos = x;
    v17 = y;
    v18 = 0;
    AppMain::updateGameLights(this, &camPos, this->ModelRoomSettings.fCamUp, 1);
    AppMain::setupShadowMatrices(this, 2);
  }
  v9 = this->ModelRoomSettings.CharaInfo[1].ppModel._Mypair._Myval2;
  if ( v9 )
  {
    v10 = *v9;
    v11 = v10->m_vCenterPosition.x;
    v12 = v10->m_vCenterPosition.y;
    if ( this->ModelRoomSettings.CharaInfo[3].iModelCount > 0 )
    {
      v13 = BattleSystem::BattleController::instance;
      if ( !BattleSystem::BattleController::instance )
      {
        v20 = (BattleSystem::BattleController *)operator new(0x3E578ui64);
        BattleSystem::BattleController::BattleController(v20);
        BattleSystem::BattleController::instance = v13;
      }
      v14 = v13->actSystem.pDrawActor[3];
      if ( v14 )
      {
        if ( v14->IsModelDraw(v14) )
        {
          v15 = this->ModelRoomSettings.CharaInfo[3].ppModel._Mypair._Myval2;
          v11 = (float)((*v15)->m_vCenterPosition.x + v11) * 0.5;
          v12 = (float)((*v15)->m_vCenterPosition.y + v12) * 0.5;
        }
      }
    }
    camPos = v11;
    v17 = v12;
    v18 = 0;
    AppMain::updateGameLights(this, &camPos, this->ModelRoomSettings.fCamUp, 1);
    AppMain::setupShadowMatrices(this, 3);
  }
}

__int64 __fastcall std::stoi(const std::string *_Str, unsigned __int64 *_Idx, int _Base)
{
  const std::string *Ptr; // rbx
  unsigned int v4; // edi
  char *end_ptr; // [rsp+38h] [rbp+10h] BYREF

  end_ptr = (char *)_Idx;
  Ptr = _Str;
  if ( _Str->_Mypair._Myval2._Myres >= 0x10 )
    Ptr = (const std::string *)_Str->_Mypair._Myval2._Bx._Ptr;
  *errno() = 0;
  v4 = strtol(Ptr->_Mypair._Myval2._Bx._Buf, &end_ptr, 10);
  if ( Ptr == (const std::string *)end_ptr )
    std::_Xinvalid_argument("invalid stoi argument");
  if ( *errno() == 34 )
    std::_Xout_of_range("stoi argument out of range");
  return v4;
}

void __fastcall AppMain::updateGameLights(AppMain *this, float *camPos, float *camUp, bool bShadow)
{
  int v4; // er10
  OGLLightNode *m_pLightNodeList; // rbx
  OGLLight::LightType m_LightType; // eax
  float v11; // xmm8_4
  float v12; // xmm7_4
  float v13; // xmm6_4
  void *v14; // rdx
  float v15; // xmm0_4
  float v16; // xmm10_4
  float v17; // xmm9_4
  float v18; // xmm7_4
  float v19; // xmm0_4
  float v20; // xmm7_4
  float v21; // xmm0_4
  float v22; // xmm6_4
  float v23; // xmm6_4
  float v24; // xmm4_4
  float v25; // xmm3_4
  float v26; // xmm1_4
  float v27; // xmm1_4
  float v28; // eax
  float v29; // xmm2_4
  float v30; // xmm0_4
  float v31; // xmm0_4
  float *m_fPosition; // r9
  float v33; // xmm3_4
  bool v34; // zf
  float v35; // eax
  float v36; // xmm1_4
  float v37; // xmm0_4
  float v38; // xmm0_4
  float v39; // xmm1_4
  float v40; // xmm2_4
  float v41; // xmm0_4
  AppMain *v42; // r10
  __int64 v43; // r11
  int *p_iModelCount; // rax
  bool v45; // cc
  __int64 v46; // rdx
  __int64 v47; // rdx
  __int64 v48; // rax
  __int64 v49; // r13
  __int64 v50; // rcx
  int *v51; // rax
  __int64 v52; // rcx
  int *v53; // rax
  int v54; // edi
  __int64 v55; // rsi
  __int64 v56; // r12
  __int64 v57; // rbx
  Framework::GLManager *v58; // rcx
  float v59; // xmm10_4
  float v60; // xmm9_4
  float v61; // xmm13_4
  float v62; // xmm12_4
  __int64 v63; // r15
  float v64; // xmm8_4
  float v65; // xmm7_4
  float v66; // xmm6_4
  float v67; // xmm0_4
  float v68; // xmm11_4
  float v69; // xmm9_4
  float v70; // xmm7_4
  float v71; // xmm0_4
  float v72; // xmm7_4
  float v73; // xmm0_4
  float v74; // xmm6_4
  float v75; // xmm6_4
  int v76; // xmm13_4
  int v77; // xmm12_4
  __int64 v78; // rax
  int v79; // xmm7_4
  float v80; // xmm6_4
  int v81; // xmm6_4
  __int64 v82; // r10
  int v83; // er8
  __int64 i; // r9
  __int64 v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rdx
  int *v88; // r11
  float *v89; // r9
  __int64 v90; // rdi
  __int64 v91; // r15
  __int64 v92; // rsi
  __int64 v93; // r14
  __int64 v94; // rbx
  OGLModel **pModel; // r10
  OGLModel *v96; // r10
  OGLLightNode *v97; // rdx
  float v98; // xmm1_4
  float v99; // xmm2_4
  float v100; // xmm3_4
  BattleStage *pBattleStage; // rcx
  int GimmickOGLModelCount; // er14
  int j; // esi
  BattleStage *v104; // rbx
  __int64 v105; // r11
  __int64 v106; // rdi
  __int64 v107; // rbx
  __int64 v108; // r9
  int v109; // edx
  int v110; // er10
  __int64 v111; // r8
  __int64 v112; // rcx
  __int64 v113; // rax
  float v114; // xmm0_4
  float v115; // xmm1_4
  float v116; // xmm2_4
  __int64 look; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v118; // [rsp+40h] [rbp-C8h]
  __int64 v119; // [rsp+48h] [rbp-C0h]
  __int64 v120; // [rsp+50h] [rbp-B8h]
  int *v121; // [rsp+58h] [rbp-B0h]
  __int64 v122; // [rsp+60h] [rbp-A8h] BYREF
  float v123; // [rsp+68h] [rbp-A0h]
  int v124; // [rsp+6Ch] [rbp-9Ch]
  int v125[2]; // [rsp+70h] [rbp-98h]
  int v126[6]; // [rsp+78h] [rbp-90h] BYREF
  int v127[12]; // [rsp+90h] [rbp-78h] BYREF
  int v130; // [rsp+1A0h] [rbp+98h]

  v4 = this->ModelRoomSettings.worldLightId[0];
  if ( v4 != -1 )
  {
    m_pLightNodeList = this->m_pRender->m_WorldLightManager.m_pLightNodeList;
    if ( m_pLightNodeList )
    {
      while ( m_pLightNodeList->m_light.m_nId != v4 )
      {
        m_pLightNodeList = m_pLightNodeList->next;
        if ( !m_pLightNodeList )
          goto LABEL_27;
      }
      if ( m_pLightNodeList->m_light.m_bOn )
      {
        m_LightType = m_pLightNodeList->m_light.m_LightType;
        if ( m_LightType == LIGHT_TYPE_DIR )
        {
          v11 = this->ModelRoomWorldLightSettings[0].direction[0];
          v12 = this->ModelRoomWorldLightSettings[0].direction[1];
          v13 = this->ModelRoomWorldLightSettings[0].direction[2];
          v15 = sqrtf((float)((float)(v11 * v11) + (float)(v12 * v12)) + (float)(v13 * v13));
          if ( v15 != 0.0 )
          {
            v11 = v11 / v15;
            v12 = v12 / v15;
            v13 = v13 / v15;
          }
          if ( this->cameraMotionPreview.iPreviewSide != -1 && !this->ModelRoomSettings.detachCameraFromLight )
          {
            v16 = acosf(v12);
            v17 = this->ModelRoomSettings.fCamLook[0] - this->ModelRoomSettings.fCamPos[0];
            v18 = this->ModelRoomSettings.fCamLook[2] - this->ModelRoomSettings.fCamPos[2];
            v19 = sqrtf((float)((float)(v17 * v17) + 0.0) + (float)(v18 * v18));
            if ( v19 != 0.0 )
            {
              v17 = v17 / v19;
              v18 = v18 / v19;
            }
            v20 = atan2f(v17, COERCE_FLOAT(LODWORD(v18) ^ _xmm));
            v21 = atan2f(v11, COERCE_FLOAT(LODWORD(v13) ^ _xmm));
            v22 = v21;
            if ( v21 < 0.0 )
              v22 = v21 + 6.2831855;
            v23 = v22 + v20;
            if ( v23 > 6.2831855 )
              v23 = v23 + -6.2831855;
            sinf(v23);
            v11 = v23;
            cosf(v16);
            v12 = v16;
            cosf(v23);
            LODWORD(v13) = LODWORD(v23) ^ _xmm;
          }
          v24 = *camPos;
          v25 = camPos[2];
          v124 = 1065353216;
          v26 = camPos[1];
          m_pLightNodeList->m_light.m_fDirection[0] = v11;
          v27 = v26 - (float)(v12 * 170.0);
          m_pLightNodeList->m_light.m_fDirection[1] = v12;
          *((float *)&v122 + 1) = v27;
          m_pLightNodeList->m_light.m_fDirection[2] = v13;
          v28 = this->ModelRoomWorldLightSettings[0].position[0];
          *(float *)&v122 = v24 - (float)(v11 * 170.0);
          v123 = v25 - (float)(v13 * 170.0);
          *(float *)&look = (float)(v11 * 10.0) + *(float *)&v122;
          v29 = this->ModelRoomWorldLightSettings[0].position[3];
          *((float *)&look + 1) = (float)(v12 * 10.0) + v27;
          v30 = this->ModelRoomWorldLightSettings[0].position[1];
          *(float *)&v118 = (float)(v13 * 10.0) + v123;
          m_pLightNodeList->m_light.m_fPosition[2] = this->ModelRoomWorldLightSettings[0].position[2];
          m_pLightNodeList->m_light.m_fPosition[1] = v30;
          m_pLightNodeList->m_light.m_fPosition[3] = v29;
          m_pLightNodeList->m_light.m_fPosition[0] = v28;
          if ( bShadow )
            AppMain::setRenderShadowLight(this, v14, 0, (float *)&v122, (float *)&look, camUp);
        }
        else
        {
          v31 = this->ModelRoomWorldLightSettings[0].position[3];
          m_fPosition = m_pLightNodeList->m_light.m_fPosition;
          v33 = this->ModelRoomWorldLightSettings[0].position[2];
          v34 = m_LightType == LIGHT_TYPE_SPOT;
          v35 = this->ModelRoomWorldLightSettings[0].position[0];
          if ( v34 )
          {
            v36 = this->ModelRoomWorldLightSettings[0].position[1];
            m_pLightNodeList->m_light.m_fPosition[3] = v31;
            v37 = m_pLightNodeList->m_light.m_fDirection[0] * 10.0;
            *m_fPosition = v35;
            m_pLightNodeList->m_light.m_fPosition[1] = v36;
            *(float *)&look = v37 + *m_fPosition;
            v38 = (float)(m_pLightNodeList->m_light.m_fDirection[1] * 10.0) + v36;
            v39 = (float)(m_pLightNodeList->m_light.m_fDirection[2] * 10.0) + v33;
            *((float *)&look + 1) = v38;
            *(float *)&v118 = v39;
          }
          else
          {
            v40 = this->ModelRoomWorldLightSettings[0].position[1];
            m_pLightNodeList->m_light.m_fPosition[3] = v31;
            *m_fPosition = v35;
            v41 = 0.0 - *m_fPosition;
            m_pLightNodeList->m_light.m_fPosition[1] = v40;
            *((float *)&look + 1) = 0.0 - v40;
            *(float *)&look = v41;
            *(float *)&v118 = 0.0 - v33;
          }
          m_pLightNodeList->m_light.m_fPosition[2] = v33;
          if ( bShadow )
            AppMain::setRenderShadowLight(this, camPos, 0, m_fPosition, (float *)&look, camPos);
        }
        *(_QWORD *)m_pLightNodeList->m_light.m_fEyePosition = *(_QWORD *)camPos;
        m_pLightNodeList->m_light.m_fEyePosition[2] = camPos[2];
      }
    }
  }
LABEL_27:
  if ( bShadow )
    return;
  v42 = this;
  v43 = 0i64;
  p_iModelCount = &this->ModelRoomSettings.CharaInfo[0].iModelCount;
  v121 = &this->ModelRoomSettings.CharaInfo[0].iModelCount;
  v122 = 0i64;
  do
  {
    v45 = *p_iModelCount <= 0;
    LODWORD(v120) = 0;
    if ( v45 )
      goto LABEL_81;
    v46 = 0i64;
    look = 0i64;
    do
    {
      v47 = *(_QWORD *)(v46 + *((_QWORD *)p_iModelCount + 1));
      v119 = v47;
      if ( !v47 )
        goto LABEL_80;
      if ( !*(_BYTE *)(v47 + 8464) )
        goto LABEL_80;
      v48 = *(_QWORD *)(v47 + 8456);
      if ( !v48 )
        goto LABEL_80;
      v49 = *(_QWORD *)(v48 + 328);
      if ( !v49 )
        goto LABEL_80;
      v50 = 2i64;
      v51 = v127;
      do
      {
        *((_QWORD *)v51 - 1) = 0i64;
        *v51 = 0;
        v51 += 4;
        --v50;
      }
      while ( v50 );
      v52 = 2i64;
      v53 = v126;
      do
      {
        *((_QWORD *)v53 - 1) = 0i64;
        *v53 = 0;
        v53 += 3;
        --v52;
      }
      while ( v52 );
      v54 = 0;
      v55 = 0i64;
      v56 = *(_QWORD *)(v49 + 712);
      do
      {
        if ( !v56 )
          goto LABEL_61;
        v57 = v56;
        if ( v55 != -1 )
        {
          while ( *(_DWORD *)v57 != v54 )
          {
            v57 = *(_QWORD *)(v57 + 288);
            if ( !v57 )
              goto LABEL_61;
          }
        }
        v58 = Framework::GLManager::glm;
        if ( *(_BYTE *)(v57 + 4) && !Framework::GLManager::glm->m_paused )
        {
          v59 = FLOAT_16_0;
          v60 = *(float *)(v47 + 280);
          v61 = *(float *)(v47 + 284);
          v62 = *(float *)(v47 + 288);
          if ( !*(_BYTE *)(v49 + 134) )
            v59 = *(float *)&FLOAT_1_0;
          v63 = v55 + v43;
          v64 = v42->ModelRoomPlayerLightSettings[0][0][v63].direction[0];
          v65 = v42->ModelRoomPlayerLightSettings[0][0][v63].direction[1];
          v66 = v42->ModelRoomPlayerLightSettings[0][0][v63].direction[2];
          *(float *)&v126[4 * v55 + 4] = (float)((float)((float)(v60 + *(float *)(v57 + 84)) - *(float *)(v57 + 68))
                                               / v59)
                                       + *(float *)(v57 + 68);
          v67 = sqrtf((float)((float)(v64 * v64) + (float)(v65 * v65)) + (float)(v66 * v66));
          if ( v67 != 0.0 )
          {
            v64 = v64 / v67;
            v65 = v65 / v67;
            v66 = v66 / v67;
          }
          v42 = this;
          if ( this->cameraMotionPreview.iPreviewSide != -1 && !this->ModelRoomSettings.detachCameraFromLight )
          {
            v68 = acosf(v65);
            v69 = v60 - this->ModelRoomSettings.fCamPos[0];
            v70 = v62 - this->ModelRoomSettings.fCamPos[2];
            v71 = sqrtf((float)((float)(v69 * v69) + 0.0) + (float)(v70 * v70));
            if ( v71 != 0.0 )
            {
              v69 = v69 / v71;
              v70 = v70 / v71;
            }
            v72 = atan2f(v69, COERCE_FLOAT(LODWORD(v70) ^ _xmm));
            v73 = atan2f(v64, COERCE_FLOAT(LODWORD(v66) ^ _xmm));
            v74 = v73;
            if ( v73 < 0.0 )
              v74 = v73 + 6.2831855;
            v75 = v74 + v72;
            if ( v75 > 6.2831855 )
              v75 = v75 + -6.2831855;
            sinf(v75);
            v64 = v75;
            cosf(v68);
            v65 = v68;
            cosf(v75);
            v42 = this;
            LODWORD(v66) = LODWORD(v75) ^ _xmm;
          }
          *(float *)&v76 = v61 + *(float *)(v57 + 88);
          *(float *)&v77 = v62 + *(float *)(v57 + 92);
          v47 = v119;
          v78 = 3 * v55;
          v43 = v122;
          *(float *)&v79 = (float)((float)(v65 - *(float *)(v57 + 100)) / v59) + *(float *)(v57 + 100);
          v80 = (float)(v66 - *(float *)(v57 + 104)) / v59;
          *(float *)&v125[v78] = (float)((float)(v64 - *(float *)(v57 + 96)) / v59) + *(float *)(v57 + 96);
          *(float *)&v81 = v80 + *(float *)(v57 + 104);
          v125[v78 + 1] = v79;
          v126[4 * v55 + 5] = v76;
          v127[4 * v55] = v77;
          v126[v78] = v81;
          v127[4 * v55 + 1] = LODWORD(v42->ModelRoomPlayerLightSettings[0][0][v63].position[3]);
LABEL_61:
          v58 = Framework::GLManager::glm;
        }
        ++v54;
        ++v55;
      }
      while ( v55 < 2 );
      v130 = 0;
      if ( *(_BYTE *)(v47 + 8464) )
      {
        v82 = 0i64;
        do
        {
          v83 = 0;
          for ( i = 0i64; i < 2; ++i )
          {
            v85 = *(_QWORD *)(v47 + 8456);
            if ( v85 )
            {
              v86 = *(_QWORD *)(v85 + v82 + 328);
              if ( v86 )
              {
                v87 = *(_QWORD *)(v86 + 712);
                if ( v87 )
                {
                  if ( i != -1 )
                  {
                    while ( *(_DWORD *)v87 != v83 )
                    {
                      v87 = *(_QWORD *)(v87 + 288);
                      if ( !v87 )
                        goto LABEL_76;
                    }
                  }
                  if ( *(_BYTE *)(v87 + 4) && !v58->m_paused )
                  {
                    *(_DWORD *)(v87 + 96) = v125[3 * i];
                    *(_DWORD *)(v87 + 100) = v125[3 * i + 1];
                    *(_DWORD *)(v87 + 104) = v126[3 * i];
                    *(_DWORD *)(v87 + 68) = v126[4 * i + 4];
                    *(_DWORD *)(v87 + 72) = v126[4 * i + 5];
                    *(_DWORD *)(v87 + 76) = v127[4 * i];
                    *(_DWORD *)(v87 + 80) = v127[4 * i + 1];
                    *(_QWORD *)(v87 + 108) = *(_QWORD *)camPos;
                    *(float *)(v87 + 116) = camPos[2];
                  }
                }
              }
LABEL_76:
              v47 = v119;
            }
            v58 = Framework::GLManager::glm;
            ++v83;
          }
          v82 += 1128i64;
          ++v130;
        }
        while ( v130 < *(unsigned __int8 *)(v47 + 8464) );
      }
      v43 = v122;
LABEL_80:
      v42 = this;
      v46 = look + 8;
      LODWORD(v120) = v120 + 1;
      v45 = (int)v120 < *v121;
      p_iModelCount = v121;
      look += 8i64;
    }
    while ( v45 );
LABEL_81:
    p_iModelCount += 14;
    v43 += 192i64;
    v121 = p_iModelCount;
    v122 = v43;
  }
  while ( v43 < 768 );
  v88 = v42->ModelRoomSettings.stageModelLightId[0][0];
  v89 = &v42->ModelRoomStageModelLightSettings[0][0][0].position[1];
  v90 = 0i64;
  v91 = 44i64;
  do
  {
    v92 = 0i64;
    v93 = 64i64;
    do
    {
      v94 = 3i64;
      do
      {
        if ( *v88 != -1 )
        {
          pModel = v42->pModel;
          if ( pModel[v90] )
          {
            v96 = pModel[v90];
            v97 = v96->m_pMaterial[v92].m_pLightManager->m_pLightNodeList;
            if ( v97 )
            {
              while ( v97->m_light.m_nId != *v88 )
              {
                v97 = v97->next;
                if ( !v97 )
                  goto LABEL_93;
              }
              if ( v97->m_light.m_bOn )
              {
                v98 = v96->m_mWorld.m[12] + *(v89 - 1);
                v99 = v96->m_mWorld.m[13] + *v89;
                v100 = v96->m_mWorld.m[14] + v89[1];
                v97->m_light.m_fPosition[3] = v89[2];
                v97->m_light.m_fPosition[0] = v98;
                v97->m_light.m_fPosition[1] = v99;
                v97->m_light.m_fPosition[2] = v100;
                *(_QWORD *)v97->m_light.m_fEyePosition = *(_QWORD *)camPos;
                v97->m_light.m_fEyePosition[2] = camPos[2];
              }
            }
          }
LABEL_93:
          v42 = this;
        }
        ++v88;
        v89 += 17;
        --v94;
      }
      while ( v94 );
      ++v92;
      --v93;
    }
    while ( v93 );
    ++v90;
    --v91;
  }
  while ( v91 );
  pBattleStage = v42->pBattleStage;
  if ( pBattleStage )
  {
    GimmickOGLModelCount = BattleStage::getGimmickOGLModelCount(pBattleStage);
    for ( j = 0; j < GimmickOGLModelCount; ++j )
    {
      v104 = this->pBattleStage;
      if ( BattleStage::getGimmickOGLModel(v104, j) )
      {
        if ( BattleStage::isGimmickOGLModelLocalLight(v104, j) )
        {
          v106 = *(unsigned __int8 *)(v105 + 8464);
          v107 = 0i64;
          if ( *(_BYTE *)(v105 + 8464) )
          {
            v108 = 0i64;
            do
            {
              v109 = 0;
              v110 = **(_DWORD **)(v108 + *(_QWORD *)(v105 + 8456) + 328);
              if ( v110 > 0 )
              {
                do
                {
                  v111 = *(_QWORD *)(v108 + *(_QWORD *)(v105 + 8456) + 328);
                  v112 = *(_QWORD *)(v111 + 712);
                  if ( v112 && v109 < *(_DWORD *)v111 )
                  {
                    if ( v109 > 0 )
                    {
                      v113 = (unsigned int)v109;
                      do
                      {
                        v112 = *(_QWORD *)(v112 + 288);
                        --v113;
                      }
                      while ( v113 );
                    }
                    if ( v112 )
                    {
                      v114 = *(float *)(v105 + 280) + *(float *)(v112 + 84);
                      v115 = *(float *)(v105 + 284) + *(float *)(v112 + 88);
                      v116 = *(float *)(v105 + 288) + *(float *)(v112 + 92);
                      *(_DWORD *)(v112 + 80) = 1065353216;
                      *(float *)(v112 + 68) = v114;
                      *(float *)(v112 + 72) = v115;
                      *(float *)(v112 + 76) = v116;
                      *(_QWORD *)(v112 + 108) = *(_QWORD *)camPos;
                      *(float *)(v112 + 116) = camPos[2];
                    }
                  }
                  ++v109;
                }
                while ( v109 < v110 );
              }
              ++v107;
              v108 += 1128i64;
            }
            while ( v107 < v106 );
          }
        }
      }
    }
  }
}

