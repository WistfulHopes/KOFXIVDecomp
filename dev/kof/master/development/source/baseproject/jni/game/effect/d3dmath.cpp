#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglshader.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/chartdata.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmodel.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/atomic"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglbone.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/oglinheritance/ogleffectvec3.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmirror.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xxatomic"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogleffect.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/ogllight.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglcurve.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglsprite.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglrender.h"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/silverware/git/sdk/aghash.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "dev/silverware/git/sdk/agstringutils.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglfog.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/particledata.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/effectcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agstring.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/baseproject/jni/game/effect/oglinheritance/ogleffectvec3.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglvec4.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglvec3.cpp"

std::piecewise_construct_t std::piecewise_construct; // 0x14089B537
float D3DMath::BezierCurveFunctionReturnY(float time, OGLVec2 startPos, OGLVec2 controlPos1, OGLVec2 controlPos2, OGLVec2 endPos); // 0x140120540
float D3DMath::GetChartDataY(float time, ChartData * pChartData); // 0x140120610
float D3DMath::GetChartDataYtoLifeFit(float time, float lastPos, ChartData * pChartData); // 0x140120A30
OGLVec4 D3DMath::ElipseFunction(long diffusionType, double r, double theta); // 0x140120EA0
OGLVec3 D3DMath::SphereLinear(OGLVec3 * start, OGLVec3 * end, float t); // 0x140120F90
OGLVec3 D3DMath::CubicHermiteSpline(OGLEffectVec3 * p0, OGLEffectVec3 * p1, OGLEffectVec3 * m0, OGLEffectVec3 * m1, float t); // 0x1401211F0
OGLVec3 D3DMath::KochanecBartels(OGLEffectVec3 p0, OGLEffectVec3 p1, OGLEffectVec3 p2, OGLEffectVec3 p3, float continuity, float tension, float bias, float t); // 0x1401213F0
OGLVec3 D3DMath::KochanecBartels(OGLEffectVec3 * p0, OGLEffectVec3 * p1, OGLEffectVec3 * p2, OGLEffectVec3 * p3, float continuity, float tension, float bias, float t); // 0x140121490
OGLEffectVec3 D3DMath::CollisionLineAndPlane(OGLEffectVec3 * p1, OGLEffectVec3 * p2, OGLEffectVec3 * planePoint, OGLEffectVec3 * planeNormal, bool * collisionFlag); // 0x140121810//decompilation failure at 14089B537!
OGLEffectVec3 *__fastcall OGLEffectVec3::operator*<double>(
        OGLEffectVec3 *this,
        OGLEffectVec3 *result,
        const long double *scaleFactor)
{
  OGLEffectVec3 *v3; // rax
  float v4; // xmm0_4

  *(_QWORD *)&result->x = 0i64;
  result->z = 0.0;
  result->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  v3 = result;
  v4 = *(double *)scaleFactor;
  result->x = v4 * this->x;
  result->y = (float)*(double *)scaleFactor * this->y;
  result->z = (float)*(double *)scaleFactor * this->z;
  return v3;
}

float __fastcall D3DMath::BezierCurveFunctionReturnY(
        float time,
        OGLVec2 startPos,
        OGLVec2 controlPos1,
        OGLVec2 controlPos2,
        OGLVec2 endPos)
{
  float v6; // xmm8_4

  v6 = (float)((float)(powf(1.0 - time, 3.0) * startPos.y)
             + (float)((float)((float)((float)((float)(1.0 - time) * (float)(1.0 - time)) * 3.0) * time) * controlPos1.y))
     + (float)((float)((float)(time * time) * (float)((float)(1.0 - time) * 3.0)) * controlPos2.y);
  return v6 + (float)(powf(time, 3.0) * endPos.y);
}

OGLEffectVec3 *__fastcall D3DMath::CollisionLineAndPlane(
        OGLEffectVec3 *result,
        OGLEffectVec3 *p1,
        OGLEffectVec3 *p2,
        OGLEffectVec3 *planePoint,
        OGLEffectVec3 *planeNormal,
        bool *collisionFlag)
{
  OGLVec3 *v6; // rdi
  OGLVec3 *v7; // rsi
  float v9; // xmm10_4
  float v10; // xmm11_4
  OGLVec3 *v11; // rax
  float v12; // xmm12_4
  float v13; // xmm14_4
  float v14; // xmm9_4
  float v15; // xmm13_4
  float v16; // xmm8_4
  float v17; // xmm6_4
  float v18; // xmm7_4
  OGLVec3 *v19; // rcx
  float v20; // xmm3_4
  float v21; // xmm2_4
  float v22; // xmm2_4
  float v23; // xmm1_4
  float v24; // xmm2_4
  float v25; // xmm8_4
  float v26; // xmm9_4

  v6 = &p1->OGLVec3;
  v7 = &p2->OGLVec3;
  v9 = 0.0;
  v10 = 0.0;
  v11 = &planePoint->OGLVec3;
  if ( !planePoint )
    v11 = 0i64;
  v12 = 0.0;
  if ( !p1 )
    v6 = 0i64;
  if ( !p2 )
    v7 = 0i64;
  v13 = v6->x - v11->x;
  v14 = v6->y - v11->y;
  v15 = v6->z - v11->z;
  v16 = v7->x - v11->x;
  v17 = v7->y - v11->y;
  v18 = v7->z - v11->z;
  if ( sqrtf((float)((float)(v14 * v14) + (float)(v13 * v13)) + (float)(v15 * v15)) == 0.0
    || sqrtf((float)((float)(v17 * v17) + (float)(v16 * v16)) + (float)(v18 * v18)) == 0.0 )
  {
    *(_QWORD *)&result->x = 0i64;
    result->z = 0.0;
  }
  else
  {
    v19 = &planeNormal->OGLVec3;
    if ( !planeNormal )
      v19 = 0i64;
    v20 = (float)((float)(v19->x * v16) + (float)(v17 * v19->y)) + (float)(v18 * v19->z);
    v21 = (float)((float)(v19->x * v13) + (float)(v14 * v19->y)) + (float)(v15 * v19->z);
    if ( (float)(v20 * v21) <= 0.00000011920929 )
    {
      *collisionFlag = 1;
      v22 = COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v21) & _xmm);
      v23 = COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v20) & _xmm);
      v24 = v22 / (float)(v23 + v22);
      v25 = (float)(v7->y - v6->y) * v24;
      v26 = (float)(v7->z - v6->z) * v24;
      v9 = (float)(v6->x + (float)((float)(v7->x - v6->x) * v24))
         + (float)((float)((float)(v6->x + (float)((float)(v7->x - v6->x) * v24)) - v7->x) * (float)(v19->x * -1.0));
      v10 = (float)(v6->y + v25) + (float)((float)((float)(v25 + v6->y) - v7->y) * (float)(v19->y * -1.0));
      v12 = (float)(v6->z + v26) + (float)((float)((float)(v26 + v6->z) - v7->z) * (float)(v19->z * -1.0));
    }
    result->x = v9;
    result->y = v10;
    result->z = v12;
  }
  result->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  return result;
}

OGLVec3 *__fastcall D3DMath::CubicHermiteSpline(
        OGLVec3 *result,
        OGLEffectVec3 *p0,
        OGLEffectVec3 *p1,
        OGLEffectVec3 *m0,
        OGLEffectVec3 *m1,
        float t)
{
  float v9; // xmm3_4
  float v10; // xmm4_4
  float v11; // xmm7_4
  OGLEffectVec3 *v12; // r8
  float v13; // xmm4_4
  OGLEffectVec3 *v14; // rax
  float *v15; // r8
  float *v16; // r9
  OGLVec3 *v17; // r10
  float v18; // xmm5_4
  OGLVec3 *v19; // rax
  float v20; // xmm1_4
  float v21; // xmm0_4
  float v22; // xmm1_4
  float x; // xmm0_4
  float v24; // xmm1_4
  float z; // xmm0_4
  float y; // xmm1_4
  OGLEffectVec3 *v27; // rax
  OGLEffectVec3 *v28; // rax
  OGLEffectVec3 *v29; // rax
  OGLEffectVec3 *v30; // rax
  OGLVec3 *v31; // r10
  __int64 v32; // r11
  float v33; // eax
  OGLVec3 v35; // [rsp+20h] [rbp-108h] BYREF
  OGLVec3 v36; // [rsp+30h] [rbp-F8h] BYREF
  OGLVec3 v37; // [rsp+40h] [rbp-E8h] BYREF
  OGLEffectVec3 resulta; // [rsp+50h] [rbp-D8h] BYREF
  OGLEffectVec3 v39; // [rsp+68h] [rbp-C0h] BYREF
  OGLEffectVec3 v40; // [rsp+80h] [rbp-A8h] BYREF
  OGLEffectVec3 v41; // [rsp+98h] [rbp-90h] BYREF
  OGLEffectVec3 v42; // [rsp+B0h] [rbp-78h] BYREF
  OGLEffectVec3 v43; // [rsp+C8h] [rbp-60h] BYREF
  OGLEffectVec3 v44[2]; // [rsp+E0h] [rbp-48h] BYREF

  *(_QWORD *)&result->x = 0i64;
  result->z = 0.0;
  v9 = (float)(t * t) * t;
  OGLEffectVec3::operator*(m1, &resulta, v9 - (float)(t * t));
  v11 = v10 * 3.0;
  OGLEffectVec3::operator*(v12, &v39, (float)(v10 * 3.0) - (float)(v9 + v9));
  v14 = OGLEffectVec3::operator*(m0, &v40, (float)(v9 - (float)(v13 + v13)) + t);
  if ( v14 )
    v19 = &v14->OGLVec3;
  else
    v19 = v17;
  v20 = v16[1];
  v37.x = *v16;
  v37.z = v16[2];
  v21 = v15[1];
  v37.y = v20;
  v22 = *v15;
  v36.y = v21;
  x = v19->x;
  v36.x = v22;
  v24 = v15[2];
  v35.x = x;
  z = v19->z;
  v36.z = v24;
  y = v19->y;
  v35.z = z;
  v35.y = y;
  v27 = OGLEffectVec3::operator*(p0, &v41, (float)(v18 - v11) + 1.0);
  v28 = OGLEffectVec3::operator+(v27, &v42, &v35);
  v29 = OGLEffectVec3::operator+(v28, &v43, &v36);
  v30 = OGLEffectVec3::operator+(v29, v44, &v37);
  if ( v30 )
    v31 = &v30->OGLVec3;
  v33 = v31->z;
  *(_QWORD *)v32 = *(_QWORD *)&v31->x;
  *(float *)(v32 + 8) = v33;
  return (OGLVec3 *)v32;
}

OGLVec4 *__fastcall D3DMath::ElipseFunction(OGLVec4 *result, int diffusionType, long double r, long double theta)
{
  int v5; // edx
  float v6; // xmm0_4
  double v7; // xmm0_8
  OGLVec4 *v8; // rax
  float v9; // xmm0_4
  double v10; // xmm0_8
  float v11; // xmm0_4
  float v12; // xmm0_4

  *(_QWORD *)&result->x = 0i64;
  *(_QWORD *)&result->z = 0i64;
  if ( diffusionType )
  {
    v5 = diffusionType - 1;
    if ( !v5 )
    {
      v9 = cos(theta) * r;
      result->z = v9;
      v10 = sin(theta);
      v8 = result;
      *(float *)&v10 = v10 * r;
      result->x = *(float *)&v10;
      return v8;
    }
    if ( v5 == 1 )
    {
      v6 = cos(theta) * r;
      result->x = v6;
      v7 = sin(theta);
      v8 = result;
      *(float *)&v7 = v7 * r;
      result->y = *(float *)&v7;
      return v8;
    }
  }
  else
  {
    v11 = cos(theta) * r;
    result->y = v11;
    v12 = sin(theta) * r;
    result->z = v12;
  }
  return result;
}

float __fastcall D3DMath::GetChartDataY(float time, ChartData *pChartData)
{
  std::vector<KeyData> *p_keyData; // r14
  KeyData *Myfirst; // rcx
  __int64 v5; // rax
  unsigned int v6; // edi
  unsigned __int64 v7; // rcx
  unsigned int i; // er9
  KeyData *v9; // rdx
  KeyData *Mylast; // rax
  KeyData *v11; // r8
  float v12; // xmm6_4
  int interpolationType; // edx
  int v14; // edx
  OGLEffectVec2 *v15; // rbp
  OGLEffectVec2 *p_BezierPosBack; // rsi
  KeyData *v17; // rax
  unsigned __int64 v18; // rdx
  OGLEffectVec2 *p_BezierPosFront; // rdi
  OGLEffectVec2 *v20; // rax
  OGLVec2 *v21; // rcx
  OGLVec2 *v22; // r9
  OGLVec2 *v23; // r8
  OGLVec2 *v24; // rdx
  OGLVec2 v25; // r9
  unsigned __int64 v26; // rcx
  KeyData *v27; // rdx
  __int64 p_Pos; // r8
  __int64 *v29; // rax
  OGLEffectVec2 *v30; // rcx
  __int64 v31; // xmm0_8
  OGLVec2 *v32; // rax

  if ( !pChartData )
    return 0.0;
  p_keyData = &pChartData->keyData;
  if ( (((char *)pChartData->keyData._Mypair._Myval2._Mylast - (char *)pChartData->keyData._Mypair._Myval2._Myfirst) & 0xFFFFFFFFFFFFFFC0ui64) == 0 )
    return 0.0;
  Myfirst = p_keyData->_Mypair._Myval2._Myfirst;
  if ( !(pChartData->keyData._Mypair._Myval2._Mylast - pChartData->keyData._Mypair._Myval2._Myfirst) )
    std::_Xout_of_range("invalid vector<T> subscript");
  v5 = pChartData->keyData._Mypair._Myval2._Mylast - Myfirst;
  if ( Myfirst->Pos.x <= time )
  {
    v6 = 0;
    if ( v5 )
    {
      v7 = 0i64;
      for ( i = 1; ; ++i )
      {
        v9 = p_keyData->_Mypair._Myval2._Myfirst;
        Mylast = p_keyData->_Mypair._Myval2._Mylast;
        if ( Mylast - p_keyData->_Mypair._Myval2._Myfirst - 1 == v7 )
          break;
        if ( Mylast - v9 <= v7 )
          std::_Xout_of_range("invalid vector<T> subscript");
        if ( time >= v9[v7].Pos.x )
        {
          v11 = p_keyData->_Mypair._Myval2._Myfirst;
          if ( p_keyData->_Mypair._Myval2._Mylast - p_keyData->_Mypair._Myval2._Myfirst <= (unsigned __int64)i )
            std::_Xout_of_range("invalid vector<T> subscript");
          if ( v11[(unsigned __int64)i].Pos.x > time )
          {
            if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
              std::_Xout_of_range("invalid vector<T> subscript");
            if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= (unsigned __int64)i )
              std::_Xout_of_range("invalid vector<T> subscript");
            if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
              std::_Xout_of_range("invalid vector<T> subscript");
            v12 = (float)(time - v11[v7].Pos.x) / (float)(v11[(unsigned __int64)i].Pos.x - v11[v7].Pos.x);
            if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
              std::_Xout_of_range("invalid vector<T> subscript");
            interpolationType = v11[v7].interpolationType;
            if ( !interpolationType )
            {
              v26 = v6 + 1;
              v27 = p_keyData->_Mypair._Myval2._Myfirst;
              if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v26 )
                std::_Xout_of_range("invalid vector<T> subscript");
              p_Pos = (__int64)&v11[v26].Pos;
              if ( p_keyData->_Mypair._Myval2._Mylast - v27 <= (unsigned __int64)v6 )
                std::_Xout_of_range("invalid vector<T> subscript");
              v29 = (__int64 *)(p_Pos + 8);
              v30 = &v27[(unsigned __int64)v6].Pos;
              if ( !p_Pos )
                v29 = 0i64;
              v31 = *v29;
              v32 = &v30->OGLVec2;
              if ( !v30 )
                v32 = 0i64;
              return (float)((float)(*((float *)&v31 + 1) - COERCE_FLOAT(HIDWORD(*(unsigned __int64 *)v32)))
                           / (float)(*(float *)&v31 - COERCE_FLOAT(*v32))
                           * (float)(*(float *)&v31 - COERCE_FLOAT(*v32))
                           * v12)
                   + COERCE_FLOAT(HIDWORD(*(unsigned __int64 *)v32));
            }
            v14 = interpolationType - 1;
            if ( !v14 )
              return std::vector<KeyData>::at(p_keyData, v6)->Pos.y;
            if ( v14 == 1 )
            {
              v15 = &std::vector<KeyData>::at(p_keyData, v6 + 1)->Pos;
              p_BezierPosBack = &std::vector<KeyData>::at(p_keyData, v6 + 1)->BezierPosBack;
              v17 = std::vector<KeyData>::at(p_keyData, v6);
              v18 = v6;
              p_BezierPosFront = &v17->BezierPosFront;
              v20 = &std::vector<KeyData>::at(p_keyData, v18)->Pos;
              v21 = &v15->OGLVec2;
              v22 = &p_BezierPosBack->OGLVec2;
              v23 = &p_BezierPosFront->OGLVec2;
              if ( !v15 )
                v21 = 0i64;
              v24 = &v20->OGLVec2;
              if ( !p_BezierPosBack )
                v22 = 0i64;
              if ( !p_BezierPosFront )
                v23 = 0i64;
              v25 = *v22;
              if ( !v20 )
                v24 = 0i64;
              return D3DMath::BezierCurveFunctionReturnY(v12, *v24, *v23, v25, *v21);
            }
          }
        }
        v7 = ++v6;
        if ( v6 >= (unsigned __int64)(p_keyData->_Mypair._Myval2._Mylast - p_keyData->_Mypair._Myval2._Myfirst) )
          return 0.0;
      }
      if ( Mylast - v9 <= (unsigned __int64)v6 )
        std::_Xout_of_range("invalid vector<T> subscript");
      return v9[(unsigned __int64)v6].Pos.y;
    }
    else
    {
      return 0.0;
    }
  }
  else
  {
    if ( !v5 )
      std::_Xout_of_range("invalid vector<T> subscript");
    return Myfirst->Pos.y;
  }
}

float __fastcall D3DMath::GetChartDataYtoLifeFit(float time, float lastPos, ChartData *pChartData)
{
  std::vector<KeyData> *p_keyData; // r14
  KeyData *Myfirst; // rcx
  unsigned int v6; // edi
  unsigned __int64 v7; // rcx
  unsigned int i; // er9
  KeyData *v9; // rdx
  KeyData *Mylast; // rax
  KeyData *v11; // r8
  float v12; // xmm6_4
  int interpolationType; // edx
  int v14; // edx
  OGLEffectVec2 *v15; // rbp
  OGLEffectVec2 *p_BezierPosBack; // rsi
  KeyData *v17; // rax
  unsigned __int64 v18; // rdx
  OGLEffectVec2 *p_BezierPosFront; // rdi
  OGLEffectVec2 *v20; // rax
  OGLVec2 *v21; // rcx
  OGLVec2 *v22; // r9
  OGLVec2 *v23; // r8
  OGLVec2 *v24; // rdx
  OGLVec2 v25; // r9
  unsigned __int64 v26; // rcx
  KeyData *v27; // rdx
  __int64 p_Pos; // r8
  __int64 *v29; // rax
  OGLEffectVec2 *v30; // rcx
  __int64 v31; // xmm0_8
  OGLVec2 *v32; // rax

  if ( !pChartData )
    return 0.0;
  p_keyData = &pChartData->keyData;
  if ( (((char *)pChartData->keyData._Mypair._Myval2._Mylast - (char *)pChartData->keyData._Mypair._Myval2._Myfirst) & 0xFFFFFFFFFFFFFFC0ui64) == 0 )
    return 0.0;
  Myfirst = p_keyData->_Mypair._Myval2._Myfirst;
  if ( !(pChartData->keyData._Mypair._Myval2._Mylast - pChartData->keyData._Mypair._Myval2._Myfirst) )
    std::_Xout_of_range("invalid vector<T> subscript");
  if ( (float)(Myfirst->Pos.x / lastPos) <= time )
  {
    if ( lastPos == 0.0 )
    {
      return 0.0;
    }
    else
    {
      v6 = 0;
      if ( pChartData->keyData._Mypair._Myval2._Mylast - Myfirst )
      {
        v7 = 0i64;
        for ( i = 1; ; ++i )
        {
          v9 = p_keyData->_Mypair._Myval2._Myfirst;
          Mylast = p_keyData->_Mypair._Myval2._Mylast;
          if ( Mylast - p_keyData->_Mypair._Myval2._Myfirst - 1 == v7 )
            break;
          if ( Mylast - v9 <= v7 )
            std::_Xout_of_range("invalid vector<T> subscript");
          if ( time >= (float)(v9[v7].Pos.x / lastPos) )
          {
            v11 = p_keyData->_Mypair._Myval2._Myfirst;
            if ( p_keyData->_Mypair._Myval2._Mylast - p_keyData->_Mypair._Myval2._Myfirst <= (unsigned __int64)i )
              std::_Xout_of_range("invalid vector<T> subscript");
            if ( (float)(v11[(unsigned __int64)i].Pos.x / lastPos) > time )
            {
              if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
                std::_Xout_of_range("invalid vector<T> subscript");
              if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= (unsigned __int64)i )
                std::_Xout_of_range("invalid vector<T> subscript");
              if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
                std::_Xout_of_range("invalid vector<T> subscript");
              v12 = (float)(time - (float)(v11[v7].Pos.x / lastPos))
                  / (float)((float)(v11[(unsigned __int64)i].Pos.x / lastPos) - (float)(v11[v7].Pos.x / lastPos));
              if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v7 )
                std::_Xout_of_range("invalid vector<T> subscript");
              interpolationType = v11[v7].interpolationType;
              if ( !interpolationType )
              {
                v26 = v6 + 1;
                v27 = p_keyData->_Mypair._Myval2._Myfirst;
                if ( p_keyData->_Mypair._Myval2._Mylast - v11 <= v26 )
                  std::_Xout_of_range("invalid vector<T> subscript");
                p_Pos = (__int64)&v11[v26].Pos;
                if ( p_keyData->_Mypair._Myval2._Mylast - v27 <= (unsigned __int64)v6 )
                  std::_Xout_of_range("invalid vector<T> subscript");
                v29 = (__int64 *)(p_Pos + 8);
                v30 = &v27[(unsigned __int64)v6].Pos;
                if ( !p_Pos )
                  v29 = 0i64;
                v31 = *v29;
                v32 = &v30->OGLVec2;
                if ( !v30 )
                  v32 = 0i64;
                return (float)((float)(*((float *)&v31 + 1) - COERCE_FLOAT(HIDWORD(*(unsigned __int64 *)v32)))
                             / (float)(*(float *)&v31 - COERCE_FLOAT(*v32))
                             * (float)(*(float *)&v31 - COERCE_FLOAT(*v32))
                             * v12)
                     + COERCE_FLOAT(HIDWORD(*(unsigned __int64 *)v32));
              }
              v14 = interpolationType - 1;
              if ( !v14 )
                return std::vector<KeyData>::at(p_keyData, v6)->Pos.y;
              if ( v14 == 1 )
              {
                v15 = &std::vector<KeyData>::at(p_keyData, v6 + 1)->Pos;
                p_BezierPosBack = &std::vector<KeyData>::at(p_keyData, v6 + 1)->BezierPosBack;
                v17 = std::vector<KeyData>::at(p_keyData, v6);
                v18 = v6;
                p_BezierPosFront = &v17->BezierPosFront;
                v20 = &std::vector<KeyData>::at(p_keyData, v18)->Pos;
                v21 = &v15->OGLVec2;
                v22 = &p_BezierPosBack->OGLVec2;
                v23 = &p_BezierPosFront->OGLVec2;
                if ( !v15 )
                  v21 = 0i64;
                v24 = &v20->OGLVec2;
                if ( !p_BezierPosBack )
                  v22 = 0i64;
                if ( !p_BezierPosFront )
                  v23 = 0i64;
                v25 = *v22;
                if ( !v20 )
                  v24 = 0i64;
                return D3DMath::BezierCurveFunctionReturnY(v12, *v24, *v23, v25, *v21);
              }
            }
          }
          v7 = ++v6;
          if ( v6 >= (unsigned __int64)(p_keyData->_Mypair._Myval2._Mylast - p_keyData->_Mypair._Myval2._Myfirst) )
            return 0.0;
        }
        if ( Mylast - v9 <= (unsigned __int64)v6 )
          std::_Xout_of_range("invalid vector<T> subscript");
        return v9[(unsigned __int64)v6].Pos.y;
      }
      else
      {
        return 0.0;
      }
    }
  }
  else
  {
    if ( !(pChartData->keyData._Mypair._Myval2._Mylast - Myfirst) )
      std::_Xout_of_range("invalid vector<T> subscript");
    return Myfirst->Pos.y;
  }
}

OGLVec3 *__fastcall D3DMath::KochanecBartels(
        OGLVec3 *result,
        OGLEffectVec3 *p0,
        OGLEffectVec3 *p1,
        OGLEffectVec3 *p2,
        OGLEffectVec3 *p3,
        float continuity,
        float tension,
        float bias,
        float t)
{
  float v9; // xmm7_4
  float v11; // xmm9_4
  OGLVec3 *v12; // rax
  float v14; // xmm3_4
  float v15; // xmm6_4
  float y; // xmm1_4
  OGLEffectVec3 *v17; // rax
  OGLEffectVec3 *v18; // rax
  OGLEffectVec3 *v19; // rax
  OGLEffectVec3 *v20; // rax
  float v21; // xmm4_4
  OGLEffectVec3 *v22; // rax
  __int64 v23; // r9
  OGLEffectVec3 *v24; // r11
  float v25; // xmm5_4
  float *p_x; // rcx
  float *v27; // rax
  int v28; // xmm1_4
  float v29; // xmm0_4
  float v30; // xmm9_4
  float v31; // xmm7_4
  float v32; // xmm0_4
  OGLEffectVec3 *v33; // rax
  OGLEffectVec3 *v34; // rax
  OGLEffectVec3 *v35; // rax
  OGLEffectVec3 *v36; // rax
  OGLEffectVec3 *v37; // rax
  OGLVec3 *v38; // rax
  float v39; // xmm1_4
  OGLEffectVec3 *v40; // rax
  OGLEffectVec3 *v41; // rax
  OGLEffectVec3 *v42; // rax
  OGLEffectVec3 *v43; // rax
  OGLEffectVec3 *v44; // rax
  __int64 v45; // r10
  __int64 v46; // r11
  OGLVec3 *v47; // rax
  float v48; // xmm1_4
  float z; // xmm0_4
  int v50; // xmm0_4
  OGLEffectVec3 *v51; // rax
  OGLEffectVec3 *v52; // rax
  OGLEffectVec3 *v53; // rax
  OGLEffectVec3 *v54; // rax
  float v55; // xmm4_4
  OGLEffectVec3 *v56; // rax
  OGLEffectVec3 *v57; // r11
  OGLVec3 v59; // [rsp+38h] [rbp-D0h] BYREF
  OGLEffectVec3 m1; // [rsp+48h] [rbp-C0h] BYREF
  OGLEffectVec3 m0; // [rsp+60h] [rbp-A8h] BYREF
  OGLEffectVec3 v62; // [rsp+78h] [rbp-90h] BYREF
  OGLEffectVec3 resulta; // [rsp+90h] [rbp-78h] BYREF
  OGLEffectVec3 v64; // [rsp+A8h] [rbp-60h] BYREF
  OGLEffectVec3 v65; // [rsp+C0h] [rbp-48h] BYREF
  OGLEffectVec3 v66; // [rsp+D8h] [rbp-30h] BYREF
  OGLEffectVec3 v67; // [rsp+F0h] [rbp-18h] BYREF
  OGLEffectVec3 v68; // [rsp+108h] [rbp+0h] BYREF
  OGLEffectVec3 v69; // [rsp+120h] [rbp+18h] BYREF
  OGLEffectVec3 v70; // [rsp+138h] [rbp+30h] BYREF
  OGLEffectVec3 v71; // [rsp+150h] [rbp+48h] BYREF
  long double scaleFactor; // [rsp+1B8h] [rbp+B0h] BYREF

  v9 = bias;
  v11 = continuity;
  v12 = &p1->OGLVec3;
  scaleFactor = DOUBLE_0_5;
  if ( !p1 )
    v12 = 0i64;
  v14 = 1.0 - tension;
  v15 = 1.0 - bias;
  y = v12->y;
  v59.x = v12->x;
  v59.z = v12->z;
  v59.y = y;
  v17 = OGLEffectVec3::operator-(p2, &v62, &v59);
  v18 = OGLEffectVec3::operator*<double>(v17, &resulta, &scaleFactor);
  v19 = OGLEffectVec3::operator*(v18, &v64, v14);
  v20 = OGLEffectVec3::operator*(v19, &v65, v15);
  v22 = OGLEffectVec3::operator*(v20, &v66, v21);
  p_x = &v22->x;
  if ( !v22 )
    p_x = 0i64;
  v27 = (float *)(v23 + 8);
  v28 = *((_DWORD *)p_x + 1);
  *(float *)&m1.__vftable = *p_x;
  v29 = p_x[2];
  v30 = v11 + v25;
  HIDWORD(m1.__vftable) = v28;
  v31 = v9 + v25;
  m1.x = v29;
  scaleFactor = DOUBLE_0_5;
  if ( !v23 )
    v27 = 0i64;
  v32 = v27[1];
  v59.x = *v27;
  v59.z = v27[2];
  v59.y = v32;
  v33 = OGLEffectVec3::operator-(v24, &v67, &v59);
  v34 = OGLEffectVec3::operator*<double>(v33, &v68, &scaleFactor);
  v35 = OGLEffectVec3::operator*(v34, &v69, v14);
  v36 = OGLEffectVec3::operator*(v35, &v70, v31);
  v37 = OGLEffectVec3::operator*(v36, &v71, v30);
  OGLEffectVec3::operator+(v37, &m0, (const OGLVec3 *)&m1);
  v38 = &p2->OGLVec3;
  scaleFactor = DOUBLE_0_5;
  if ( !p2 )
    v38 = 0i64;
  v39 = v38->y;
  *(float *)&m1.__vftable = v38->x;
  m1.x = v38->z;
  *((float *)&m1.__vftable + 1) = v39;
  v40 = OGLEffectVec3::operator-(p3, &v71, (const OGLVec3 *)&m1);
  v41 = OGLEffectVec3::operator*<double>(v40, &v70, &scaleFactor);
  v42 = OGLEffectVec3::operator*(v41, &v69, v14);
  v43 = OGLEffectVec3::operator*(v42, &v68, v15);
  v44 = OGLEffectVec3::operator*(v43, &v67, v30);
  if ( v44 )
    v47 = &v44->OGLVec3;
  else
    v47 = 0i64;
  v48 = v47->y;
  v59.x = v47->x;
  z = v47->z;
  if ( !v46 )
    v45 = 0i64;
  v59.y = v48;
  v59.z = z;
  scaleFactor = DOUBLE_0_5;
  v50 = *(_DWORD *)(v45 + 4);
  LODWORD(m1.__vftable) = *(_DWORD *)v45;
  m1.x = *(float *)(v45 + 8);
  HIDWORD(m1.__vftable) = v50;
  v51 = OGLEffectVec3::operator-(p2, &v66, (const OGLVec3 *)&m1);
  v52 = OGLEffectVec3::operator*<double>(v51, &v65, &scaleFactor);
  v53 = OGLEffectVec3::operator*(v52, &v64, v14);
  v54 = OGLEffectVec3::operator*(v53, &resulta, v31);
  v56 = OGLEffectVec3::operator*(v54, &v62, v55);
  OGLEffectVec3::operator+(v56, &m1, &v59);
  D3DMath::CubicHermiteSpline(result, v57, p2, &m0, &m1, t);
  return result;
}

OGLVec3 *__fastcall D3DMath::KochanecBartels(
        OGLVec3 *result,
        OGLEffectVec3 *p0,
        OGLEffectVec3 *p1,
        OGLEffectVec3 *p2,
        OGLEffectVec3 *p3,
        float continuity,
        float tension,
        float bias,
        float t)
{
  D3DMath::KochanecBartels(result, p0, p1, p2, p3, continuity, tension, bias, t);
  p0->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  p1->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  p2->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  p3->__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  return result;
}

OGLVec3 *__fastcall D3DMath::SphereLinear(OGLVec3 *result, OGLVec3 *start, OGLVec3 *end, float t)
{
  OGLVec3 *v4; // rbx
  float y; // xmm1_4
  float z; // xmm0_4
  float x; // xmm1_4
  float v9; // xmm0_4
  float v10; // xmm1_4
  float v11; // xmm7_4
  float v12; // xmm9_4
  OGLEffectVec3 *v13; // rax
  OGLVec3 *v14; // rax
  float v15; // xmm1_4
  float v16; // xmm0_4
  OGLEffectVec3 *v17; // rax
  OGLEffectVec3 *v18; // rax
  float v19; // xmm8_4
  float v20; // xmm7_4
  OGLEffectVec3 *v21; // rax
  OGLVec3 *v22; // rax
  float v23; // xmm1_4
  OGLEffectVec3 *v24; // rax
  OGLEffectVec3 *v25; // rax
  OGLEffectVec3 *v26; // rax
  OGLVec3 v28; // [rsp+28h] [rbp-89h] BYREF
  OGLEffectVec3 v29; // [rsp+38h] [rbp-79h] BYREF
  OGLEffectVec3 v30; // [rsp+50h] [rbp-61h] BYREF
  OGLEffectVec3 resulta; // [rsp+68h] [rbp-49h] BYREF
  OGLEffectVec3 v32; // [rsp+80h] [rbp-31h] BYREF
  OGLEffectVec3 v33; // [rsp+98h] [rbp-19h] BYREF
  OGLEffectVec3 v34; // [rsp+B0h] [rbp-1h] BYREF

  v4 = 0i64;
  *(_QWORD *)&result->x = 0i64;
  result->z = 0.0;
  y = start->y;
  v30.x = start->x;
  z = start->z;
  v30.y = y;
  x = end->x;
  v30.z = z;
  v9 = end->y;
  v29.x = x;
  v10 = end->z;
  v29.y = v9;
  v29.z = v10;
  v30.__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  v29.__vftable = (OGLEffectVec3_vtbl *)&OGLEffectVec3::`vftable';
  OGLVec3::normalize(&v30.OGLVec3, &v30.OGLVec3);
  OGLVec3::normalize(&v29.OGLVec3, &v29.OGLVec3);
  v11 = acosf((float)((float)(v29.y * v30.y) + (float)(v29.x * v30.x)) + (float)(v29.z * v30.z));
  v12 = sinf(v11);
  if ( v12 == 0.0 )
  {
    v13 = OGLEffectVec3::operator*(&v29, &resulta, t);
    if ( v13 )
      v14 = &v13->OGLVec3;
    else
      v14 = 0i64;
    v15 = v14->y;
    v28.x = v14->x;
    v16 = v14->z;
    v28.y = v15;
    v28.z = v16;
    v17 = OGLEffectVec3::operator*(&v30, &v32, 1.0 - t);
    v18 = OGLEffectVec3::operator+(v17, &v33, &v28);
    if ( v18 )
      v4 = &v18->OGLVec3;
    *(_QWORD *)&result->x = *(_QWORD *)&v4->x;
    result->z = v4->z;
  }
  else
  {
    v19 = sinf((float)(1.0 - t) * v11);
    v20 = v11 * t;
    sinf(v20);
    v21 = OGLEffectVec3::operator*(&v29, &v33, v20);
    if ( v21 )
      v22 = &v21->OGLVec3;
    else
      v22 = 0i64;
    v23 = v22->y;
    v28.x = v22->x;
    v28.z = v22->z;
    v28.y = v23;
    v24 = OGLEffectVec3::operator*(&v30, &v32, v19);
    v25 = OGLEffectVec3::operator+(v24, &resulta, &v28);
    v26 = OGLEffectVec3::operator/(v25, &v34, v12);
    if ( v26 )
      v4 = &v26->OGLVec3;
    *(_QWORD *)&result->x = *(_QWORD *)&v4->x;
    result->z = v4->z;
    OGLVec3::normalize(result, result);
  }
  return result;
}

