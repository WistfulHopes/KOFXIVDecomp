#include "program files (x86)/microsoft visual studio 14.0/vc/include/xhash"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/kof/master/development/source/baseproject/jni/game/util/restrictringbuffer.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/commandcheck.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/commanddataformat.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/kof/master/development/source/baseproject/jni/game/player/charafileformat/charafilebase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/unordered_map"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"

std::piecewise_construct_t std::piecewise_construct; // 0x14089B293
void InputKeyCheck::AddKey(const long key); // 0x1400D79C0
long InputKeyCheck::GetTrigger(unsigned long backFrame); // 0x1400D7A10
long InputKeyCheck::GetRelease(unsigned long backFrame); // 0x1400D7AA0
void CommandCheck::Init(long tag, const CommandData * pCmdDat, InputKeyCheck * pKeyBuf); // 0x1400D7B30
long CommandCheck::SameTimeTrigger(unsigned long uiInputFrame); // 0x1400D7DC0
long CommandCheck::SameTimeRelease(unsigned long uiInputFrame); // 0x1400D7EC0
long CommandCheck::ConvertInpToCmd(const long inputKey); // 0x1400D7FC0
bool CommandCheck::Match(const CommandData::KeyData & keyDat, unsigned long uiInputFrame, long iCAngle); // 0x1400D8070
bool CommandCheck::MatchSub(long cmdKey, long inputKey, bool bAndOp, bool bStrict); // 0x1400D8430
bool CommandCheck::IsValidCommand(const CommandData::Setting & cmdSet, long iCAngle, long iCAngleLooks, long iAddPreFrame, long & iExtendPriority, long & iRemainderFrame); // 0x1400D84D0
void CommandCheck::CheckAll(CommandEventListener & listener, long iCAngle, long iCAngleLooks, long iAddPreFrame); // 0x1400D8940
const CommandData::Setting * CommandCheck::ValidCommandFromIndex(CommandEventListener & listener, long iIndex); // 0x1400D8A70
const CommandData::Setting * CommandCheck::GetCommandSettingFromIndex(long iIndex); // 0x1400D8B10
const CommandData::AiCommandInfo * CommandCheck::GetAiCommandInfoFromIndex(long iIndex); // 0x1400D8B60
long CommandCheck::CompGroupPriority(const CommandData::Setting & wk1, const CommandData::Setting & wk2); // 0x1400D8BB0
void InputKeyHistory::AddKey(const long key); // 0x1400D8C10//decompilation failure at 14089B293!
std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *__fastcall std::_List_buy<std::pair<std::string const,CommandCheck::CommandSettingMapData>>::_Buynode<std::piecewise_construct_t const &,std::tuple<std::string &&>,std::tuple<>>(
        std::_List_buy<std::pair<std::string const ,CommandCheck::CommandSettingMapData>> *this,
        std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *_Next,
        std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *_Prev,
        const std::piecewise_construct_t *<_Val_0>,
        std::tuple<std::string &&> *<_Val_1>)
{
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v5; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v6; // rdi
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *p_Myval; // rbx
  std::string *Val; // rdx
  std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *Ptr; // rax

  v5 = std::_List_alloc<std::_List_base_types<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLCamera,void>::Body>>>>::_Buynode0(
         (std::_List_alloc<std::_List_base_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >> > *)this,
         (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)_Next,
         (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)_Prev);
  v6 = v5;
  p_Myval = &v5->_Myval;
  if ( v5 != (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)-16i64 )
  {
    Val = <_Val_1>->_Myfirst._Val;
    v5->_Myval.first._Mypair._Myval2._Myres = 15i64;
    v5->_Myval.first._Mypair._Myval2._Mysize = 0i64;
    if ( v5->_Myval.first._Mypair._Myval2._Myres < 0x10 )
      Ptr = &v5->_Myval;
    else
      Ptr = (std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > *)p_Myval->first._Mypair._Myval2._Bx._Ptr;
    Ptr->first._Mypair._Myval2._Bx._Buf[0] = 0;
    std::string::_Assign_rv((std::string *)&p_Myval->first, Val);
    p_Myval->second.m_ptr = 0i64;
    p_Myval->second.m_proxy.m_ptr = 0i64;
  }
  return v6;
}

std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >,bool> *__fastcall std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Insert<std::pair<std::string const,CommandCheck::CommandSettingMapData> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>(
        std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *this,
        std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >,bool> *result,
        std::pair<std::string const ,CommandCheck::CommandSettingMapData> *_Val,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > _Pnode)
{
  unsigned __int64 Mysize; // r15
  unsigned __int64 Myres; // r10
  std::pair<std::string const ,CommandCheck::CommandSettingMapData> *Ptr; // r9
  __int64 v10; // rdx
  unsigned __int64 i; // rcx
  unsigned __int64 v12; // r9
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *Myfirst; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *v14; // rsi
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Myhead; // rdi
  char **p_Myval; // rdx
  std::pair<std::string const ,CommandCheck::CommandSettingMapData> *v17; // rcx
  size_t v18; // r14
  size_t v19; // r8
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Next; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Prev; // rdx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *v23; // rdx
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> **p_Next; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *v25; // rcx
  unsigned __int64 v26; // [rsp+20h] [rbp-48h]
  std::pair<std::string const ,CommandCheck::CommandSettingMapData> *v27; // [rsp+80h] [rbp+18h]

  v27 = _Val;
  Mysize = _Val->first._Mypair._Myval2._Mysize;
  Myres = _Val->first._Mypair._Myval2._Myres;
  if ( Myres < 0x10 )
    Ptr = _Val;
  else
    Ptr = (std::pair<std::string const ,CommandCheck::CommandSettingMapData> *)_Val->first._Mypair._Myval2._Bx._Ptr;
  v10 = 0xCBF29CE484222325ui64;
  for ( i = 0i64; i < Mysize; ++i )
    v10 = 0x100000001B3i64 * ((unsigned __int8)Ptr->first._Mypair._Myval2._Bx._Buf[i] ^ (unsigned __int64)v10);
  v12 = 16 * (v10 & this->_Mask);
  v26 = v12;
  Myfirst = this->_Vec._Mypair._Myval2._Myfirst;
  v14 = *(std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> **)((char *)&Myfirst->_Ptr + v12);
  if ( v14 == this->_List._Mypair._Myval2._Myhead )
    Myhead = this->_List._Mypair._Myval2._Myhead;
  else
    Myhead = **(std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> ***)((char *)&Myfirst[1]._Ptr + v12);
  if ( Myhead != v14 )
  {
    do
    {
      Myhead = Myhead->_Prev;
      p_Myval = (char **)&Myhead->_Myval;
      if ( Myhead->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
        p_Myval = (char **)*p_Myval;
      if ( Myres < 0x10 )
        v17 = _Val;
      else
        v17 = (std::pair<std::string const ,CommandCheck::CommandSettingMapData> *)_Val->first._Mypair._Myval2._Bx._Ptr;
      v18 = Myhead->_Myval.first._Mypair._Myval2._Mysize;
      v19 = v18;
      if ( Mysize < v18 )
        v19 = Mysize;
      if ( (!v19 || !memcmp(v17, p_Myval, v19)) && Mysize >= v18 && Mysize <= v18 )
      {
        _Pnode._Ptr->_Prev->_Next = _Pnode._Ptr->_Next;
        _Pnode._Ptr->_Next->_Prev = _Pnode._Ptr->_Prev;
        --this->_List._Mypair._Myval2._Mysize;
        std::string::~string((std::string *)&_Pnode._Ptr->_Myval.first);
        operator delete(_Pnode._Ptr);
        result->first._Ptr = Myhead;
        result->second = 0;
        return result;
      }
      _Val = v27;
      Myres = v27->first._Mypair._Myval2._Myres;
    }
    while ( Myhead != v14 );
    v12 = v26;
  }
  Next = _Pnode._Ptr->_Next;
  if ( Myhead != _Pnode._Ptr->_Next )
  {
    _Pnode._Ptr->_Prev->_Next = Next;
    Next->_Prev->_Next = Myhead;
    Myhead->_Prev->_Next = _Pnode._Ptr;
    Prev = Myhead->_Prev;
    Myhead->_Prev = Next->_Prev;
    Next->_Prev = _Pnode._Ptr->_Prev;
    _Pnode._Ptr->_Prev = Prev;
  }
  v23 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *)((char *)this->_Vec._Mypair._Myval2._Myfirst + v12);
  if ( v23->_Ptr == this->_List._Mypair._Myval2._Myhead )
  {
    v23->_Ptr = _Pnode._Ptr;
    *(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *)((char *)this->_Vec._Mypair._Myval2._Myfirst + v12 + 8) = _Pnode;
  }
  else if ( v23->_Ptr == Myhead )
  {
    v23->_Ptr = _Pnode._Ptr;
  }
  else
  {
    p_Next = &v23[1]._Ptr->_Next;
    v25 = *p_Next;
    v23[1]._Ptr = *p_Next;
    if ( v25 != _Pnode._Ptr )
      *(std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> **)((char *)&this->_Vec._Mypair._Myval2._Myfirst[1]._Ptr + v12) = (*(std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> **)((char *)&this->_Vec._Mypair._Myval2._Myfirst[1]._Ptr + v12))->_Prev;
  }
  std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Check_size(this);
  result->first._Ptr = _Pnode._Ptr;
  result->second = 1;
  return result;
}

void __fastcall InputKeyCheck::AddKey(InputKeyCheck *this, const int key)
{
  RestrictRingBuffer<int> *Myval2; // r8
  int *pBuffer; // rcx
  unsigned int uiBufferMask; // ecx
  unsigned int uiBeginIndex; // edx
  int v6; // eax
  unsigned int uiDataSize; // eax

  Myval2 = this->pKeyBuffer._Mypair._Myval2;
  pBuffer = this->pKeyBuffer._Mypair._Myval2->pBuffer;
  if ( pBuffer )
  {
    pBuffer[Myval2->uiEndIndex] = key;
    uiBufferMask = Myval2->uiBufferMask;
    uiBeginIndex = Myval2->uiBeginIndex;
    v6 = uiBufferMask & (Myval2->uiEndIndex + 1);
    Myval2->uiEndIndex = v6;
    if ( v6 == uiBeginIndex )
      Myval2->uiBeginIndex = uiBufferMask & (uiBeginIndex + 1);
    uiDataSize = Myval2->uiDataSize;
    if ( Myval2->uiBufferSize != uiDataSize )
      Myval2->uiDataSize = uiDataSize + 1;
  }
}

void __fastcall InputKeyHistory::AddKey(InputKeyHistory *this, const int key)
{
  RestrictRingBuffer<InputKeyHistory::History> *Myval2; // r8
  InputKeyHistory::History *v4; // rdx
  InputKeyHistory::History *pBuffer; // rdx
  unsigned int uiBufferMask; // ecx
  unsigned int uiBeginIndex; // edx
  int v8; // eax
  unsigned int uiDataSize; // eax
  __int64 v10; // [rsp+8h] [rbp+8h]

  Myval2 = this->pKeyHistory._Mypair._Myval2;
  v10 = (unsigned int)key | 0x100000000i64;
  if ( this->pKeyHistory._Mypair._Myval2->uiDataSize
    && (v4 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - 1)]) != 0i64
    && v4->iKey == key )
  {
    if ( ++v4->iCount >= 100000 )
      v4->iCount = 99999;
  }
  else
  {
    pBuffer = Myval2->pBuffer;
    if ( pBuffer )
    {
      pBuffer[Myval2->uiEndIndex] = (InputKeyHistory::History)v10;
      uiBufferMask = Myval2->uiBufferMask;
      uiBeginIndex = Myval2->uiBeginIndex;
      v8 = uiBufferMask & (Myval2->uiEndIndex + 1);
      Myval2->uiEndIndex = v8;
      if ( v8 == uiBeginIndex )
        Myval2->uiBeginIndex = uiBufferMask & (uiBeginIndex + 1);
      uiDataSize = Myval2->uiDataSize;
      if ( Myval2->uiBufferSize != uiDataSize )
        Myval2->uiDataSize = uiDataSize + 1;
    }
  }
}

void __fastcall CommandCheck::CheckAll(
        CommandCheck *this,
        CommandEventListener *listener,
        int iCAngle,
        int iCAngleLooks,
        int iAddPreFrame)
{
  const CommandData *pCmdDat; // rcx
  const CommandData *v10; // rax
  int v11; // ebx
  __int64 v12; // rdi
  int v13; // er15
  CommandData::Setting *pSetting; // rbp
  bool v15; // sf
  int iExtendPriority[4]; // [rsp+40h] [rbp-38h] BYREF
  int iRemainderFrame; // [rsp+80h] [rbp+8h] BYREF

  pCmdDat = this->pCmdDat;
  if ( pCmdDat )
  {
    if ( pCmdDat->CheckFileID(&pCmdDat->CharaFileBase) )
    {
      v10 = this->pCmdDat;
      v11 = 0;
      if ( this->pCmdDat->dataHeader.iCommandCount > 0 )
      {
        v12 = 0i64;
        v13 = iAddPreFrame;
        do
        {
          pSetting = v10->pSetting;
          v15 = pSetting[v12].iInputDataID < 0;
          iRemainderFrame = 0;
          iExtendPriority[0] = 0;
          if ( !v15
            && CommandCheck::IsValidCommand(
                 this,
                 &pSetting[v12],
                 iCAngle,
                 iCAngleLooks,
                 v13,
                 iExtendPriority,
                 &iRemainderFrame) )
          {
            listener->RecvCommandEvent(
              listener,
              this->iCommandDataTag,
              v11,
              &pSetting[v11],
              iExtendPriority[0],
              iRemainderFrame);
          }
          v10 = this->pCmdDat;
          ++v11;
          ++v12;
        }
        while ( v11 < this->pCmdDat->dataHeader.iCommandCount );
      }
    }
  }
}

__int64 __fastcall CommandCheck::CompGroupPriority(const CommandData::Setting *wk1, const CommandData::Setting *wk2)
{
  __int64 iGroup; // rax
  int v3; // ecx
  int v4; // er8
  __int64 v5; // rax
  int v6; // edx

  if ( wk1->iPriority >= 10000 || wk2->iPriority >= 10000 )
    return 0i64;
  iGroup = wk1->iGroup;
  v3 = 0;
  if ( (unsigned int)iGroup > 0x1A )
    v4 = 0;
  else
    v4 = CommandCheck::ciCommandGroupPriority[iGroup];
  v5 = wk2->iGroup;
  if ( (unsigned int)v5 > 0x1A )
    v6 = 0;
  else
    v6 = CommandCheck::ciCommandGroupPriority[v5];
  if ( v4 < v6 )
    return 1i64;
  LOBYTE(v3) = v4 <= v6;
  return (unsigned int)(v3 - 1);
}

__int64 __fastcall CommandCheck::ConvertInpToCmd(const int inputKey)
{
  char v1; // r9
  unsigned int v2; // er8
  char v3; // al
  int v4; // ecx
  unsigned int v5; // edx

  v1 = inputKey;
  v2 = ((unsigned int)inputKey >> 4) & 1 | 2;
  v3 = inputKey;
  if ( (inputKey & 0x20) == 0 )
    v2 = ((unsigned int)inputKey >> 4) & 1;
  v4 = v2 | 4;
  if ( (v3 & 0x40) == 0 )
    v4 = v2;
  v5 = v4 | 8;
  if ( (v1 & 0x80) == 0 )
    v5 = v4;
  if ( (v1 & 0xF) == 0 )
    return v5 | 0x100;
  if ( (v1 & 4) != 0 )
  {
    if ( (v1 & 1) != 0 )
    {
      return v5 | 0x400;
    }
    else if ( (v1 & 2) != 0 )
    {
      return v5 | 0x1000;
    }
    else
    {
      return v5 | 0x800;
    }
  }
  else if ( (v1 & 8) != 0 )
  {
    if ( (v1 & 1) != 0 )
    {
      return v5 | 0x10;
    }
    else if ( (v1 & 2) != 0 )
    {
      return v5 | 0x40;
    }
    else
    {
      return v5 | 0x20;
    }
  }
  else if ( (v1 & 1) != 0 )
  {
    return v5 | 0x80;
  }
  else
  {
    if ( (v1 & 2) != 0 )
      v5 |= 0x200u;
    return v5;
  }
}

CommandData::AiCommandInfo *__fastcall CommandCheck::GetAiCommandInfoFromIndex(CommandCheck *this, int iIndex)
{
  __int64 v3; // rbx
  const CommandData *pCmdDat; // rcx

  v3 = iIndex;
  pCmdDat = this->pCmdDat;
  if ( pCmdDat
    && pCmdDat->CheckFileID(&pCmdDat->CharaFileBase)
    && (int)v3 >= 0
    && (int)v3 < this->pCmdDat->dataHeader.iCommandCount )
  {
    return &this->pCmdDat->pAiCmdInfo[v3];
  }
  else
  {
    return 0i64;
  }
}

CommandData::Setting *__fastcall CommandCheck::GetCommandSettingFromIndex(CommandCheck *this, int iIndex)
{
  __int64 v3; // rbx
  const CommandData *pCmdDat; // rcx

  v3 = iIndex;
  pCmdDat = this->pCmdDat;
  if ( pCmdDat
    && pCmdDat->CheckFileID(&pCmdDat->CharaFileBase)
    && (int)v3 >= 0
    && (int)v3 < this->pCmdDat->dataHeader.iCommandCount )
  {
    return &this->pCmdDat->pSetting[v3];
  }
  else
  {
    return 0i64;
  }
}

__int64 __fastcall InputKeyCheck::GetRelease(InputKeyCheck *this, unsigned int backFrame)
{
  RestrictRingBuffer<int> *Myval2; // r9
  unsigned int v4; // edx
  int v5; // er8
  unsigned int uiDelay; // ecx
  unsigned int uiDataSize; // eax
  int *v8; // rdx
  int v9; // edx
  unsigned int v10; // ecx
  unsigned int v11; // eax
  int *v12; // r9

  Myval2 = this->pKeyBuffer._Mypair._Myval2;
  v4 = backFrame + 1;
  v5 = 0;
  uiDelay = this->pKeyBuffer._Mypair._Myval2->uiDelay;
  uiDataSize = Myval2->uiDataSize;
  if ( uiDelay < uiDataSize
    && v4 < uiDataSize - uiDelay
    && (v8 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - v4 - 1)]) != 0i64 )
  {
    v9 = *v8;
  }
  else
  {
    v9 = 0;
  }
  v10 = Myval2->uiDelay;
  v11 = Myval2->uiDataSize;
  if ( v10 < v11 && backFrame < v11 - v10 )
  {
    v12 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - v10 - backFrame - 1)];
    if ( v12 )
      v5 = *v12;
  }
  return ~v5 & (v9 ^ (unsigned int)v5);
}

__int64 __fastcall InputKeyCheck::GetTrigger(InputKeyCheck *this, unsigned int backFrame)
{
  RestrictRingBuffer<int> *Myval2; // r8
  unsigned int v4; // edx
  int v5; // er9
  unsigned int uiDelay; // ecx
  unsigned int uiDataSize; // eax
  int *v8; // rdx
  int v9; // edx
  unsigned int v10; // ecx
  unsigned int v11; // eax
  int *v12; // r8

  Myval2 = this->pKeyBuffer._Mypair._Myval2;
  v4 = backFrame + 1;
  v5 = 0;
  uiDelay = this->pKeyBuffer._Mypair._Myval2->uiDelay;
  uiDataSize = Myval2->uiDataSize;
  if ( uiDelay < uiDataSize
    && v4 < uiDataSize - uiDelay
    && (v8 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - v4 - 1)]) != 0i64 )
  {
    v9 = *v8;
  }
  else
  {
    v9 = 0;
  }
  v10 = Myval2->uiDelay;
  v11 = Myval2->uiDataSize;
  if ( v10 < v11 && backFrame < v11 - v10 )
  {
    v12 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - v10 - backFrame - 1)];
    if ( v12 )
      v5 = *v12;
  }
  return v5 & (v9 ^ (unsigned int)v5);
}

void __fastcall CommandCheck::Init(CommandCheck *this, int tag, const CommandData *pCmdDat, InputKeyCheck *pKeyBuf)
{
  std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *p_cmdSetMap; // rsi
  __int64 iCommandCount; // rax
  float v7; // xmm0_4
  float v8; // xmm0_4
  unsigned __int64 v9; // rax
  int v10; // ebx
  __int64 v11; // r14
  char *v12; // rdx
  unsigned __int64 v13; // r8
  std::_List_buy<std::pair<std::string const ,CommandCheck::CommandSettingMapData>> *v14; // rcx
  const std::piecewise_construct_t *v15; // r9
  _OWORD *Ptr; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Next; // rbp
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v18; // rax
  unsigned __int64 Mysize; // rdx
  char *v20; // rcx
  char *v21; // rax
  std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > result; // [rsp+30h] [rbp-88h] BYREF
  std::tuple<std::string &&> v23; // [rsp+38h] [rbp-80h] BYREF
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >,bool> v24; // [rsp+40h] [rbp-78h] BYREF
  __int128 v25; // [rsp+50h] [rbp-68h]
  __int64 v26; // [rsp+60h] [rbp-58h]
  std::string _Keyval; // [rsp+68h] [rbp-50h] BYREF

  v26 = -2i64;
  this->pCmdDat = pCmdDat;
  this->pKeyBuf = pKeyBuf;
  this->iCommandDataTag = tag;
  this->bClimaxDebug = 0;
  p_cmdSetMap = (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)&this->cmdSetMap;
  std::list<std::pair<std::string const,CommandCheck::CommandSettingMapData>>::clear(&this->cmdSetMap._List);
  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
    p_cmdSetMap,
    8ui64);
  if ( pCmdDat )
  {
    iCommandCount = pCmdDat->dataHeader.iCommandCount;
    v7 = (float)(int)iCommandCount;
    if ( iCommandCount < 0 )
      v7 = v7 + 1.8446744e19;
    v8 = (float)(v7 / p_cmdSetMap->_Traitsobj._Mypair._Myval2._Myval2) + 0.5;
    v9 = 0i64;
    if ( v8 >= 9.223372e18 )
    {
      v8 = v8 - 9.223372e18;
      if ( v8 < 9.223372e18 )
        v9 = 0x8000000000000000ui64;
    }
    std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::rehash(
      (std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *)p_cmdSetMap,
      v9 + (unsigned int)(int)v8);
    v10 = 0;
    if ( pCmdDat->dataHeader.iCommandCount > 0 )
    {
      v11 = 0i64;
      do
      {
        v12 = pCmdDat->pSettingNames[v11];
        if ( v12 )
        {
          LODWORD(v25) = v10;
          *((_QWORD *)&v25 + 1) = &pCmdDat->pSetting[v10];
          _Keyval._Mypair._Myval2._Myres = 15i64;
          _Keyval._Mypair._Myval2._Mysize = 0i64;
          _Keyval._Mypair._Myval2._Bx._Buf[0] = 0;
          if ( *v12 )
          {
            v13 = -1i64;
            do
              ++v13;
            while ( v12[v13] );
          }
          else
          {
            v13 = 0i64;
          }
          std::string::assign(&_Keyval, v12, v13);
          std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>>>,0>>::lower_bound(
            (std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *)p_cmdSetMap,
            &result,
            &_Keyval);
          Ptr = result._Ptr;
          if ( result._Ptr == (std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *)p_cmdSetMap->_List._Mypair._Myval2._Myhead )
          {
            v23._Myfirst._Val = &_Keyval;
            Next = (std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *)p_cmdSetMap->_List._Mypair._Myval2._Myhead->_Next;
            v18 = std::_List_buy<std::pair<std::string const,CommandCheck::CommandSettingMapData>>::_Buynode<std::piecewise_construct_t const &,std::tuple<std::string &&>,std::tuple<>>(
                    v14,
                    Next,
                    Next->_Prev,
                    v15,
                    &v23);
            Mysize = p_cmdSetMap->_List._Mypair._Myval2._Mysize;
            if ( Mysize == 0x3FFFFFFFFFFFFFEi64 )
              std::_Xlength_error("list<T> too long");
            p_cmdSetMap->_List._Mypair._Myval2._Mysize = Mysize + 1;
            Next->_Prev = (std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *)v18;
            v18->_Prev->_Next = v18;
            std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Insert<std::pair<std::string const,CommandCheck::CommandSettingMapData> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>(
              (std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *)p_cmdSetMap,
              &v24,
              (std::pair<std::string const ,CommandCheck::CommandSettingMapData> *)&p_cmdSetMap->_List._Mypair._Myval2._Myhead->_Next->_Myval,
              (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >)p_cmdSetMap->_List._Mypair._Myval2._Myhead->_Next);
            Ptr = v24.first._Ptr;
          }
          else
          {
            v24.first._Ptr = (std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *)result._Ptr;
            v24.second = 0;
          }
          Ptr[3] = v25;
          if ( _Keyval._Mypair._Myval2._Myres >= 0x10 )
          {
            v20 = _Keyval._Mypair._Myval2._Bx._Ptr;
            if ( _Keyval._Mypair._Myval2._Myres + 1 >= 0x1000 )
            {
              if ( (_Keyval._Mypair._Myval2._Bx._Buf[0] & 0x1F) != 0 )
                invalid_parameter_noinfo_noreturn();
              v21 = (char *)*((_QWORD *)_Keyval._Mypair._Myval2._Bx._Ptr - 1);
              if ( v21 >= _Keyval._Mypair._Myval2._Bx._Ptr )
                invalid_parameter_noinfo_noreturn();
              if ( (char *)(_Keyval._Mypair._Myval2._Bx._Ptr - v21) < (char *)8 )
                invalid_parameter_noinfo_noreturn();
              if ( (char *)(_Keyval._Mypair._Myval2._Bx._Ptr - v21) > (char *)0x27 )
                invalid_parameter_noinfo_noreturn();
              v20 = (char *)*((_QWORD *)_Keyval._Mypair._Myval2._Bx._Ptr - 1);
            }
            operator delete(v20);
          }
        }
        ++v10;
        ++v11;
      }
      while ( v10 < pCmdDat->dataHeader.iCommandCount );
    }
  }
}

char __fastcall CommandCheck::IsValidCommand(
        CommandCheck *this,
        const CommandData::Setting *cmdSet,
        int iCAngle,
        int iCAngleLooks,
        int iAddPreFrame,
        int *iExtendPriority,
        int *iRemainderFrame)
{
  const CommandData *pCmdDat; // rdi
  __int64 iInputDataID; // rsi
  int iGroup; // eax
  int v15; // eax
  int iWaitFrame; // er13
  CommandData::Command *v17; // rcx
  __int64 iKeyCount; // rdx
  int iValidTerms; // er10
  int iPrecedeFrame; // er8
  CommandData::KeyData *pKey; // r14
  char v22; // r9
  __int64 v23; // rcx
  __int64 v24; // rax
  int iKey; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // esi
  __int64 v29; // rax
  char v30; // di
  unsigned int v31; // ebx
  __int64 v32; // rbp
  __int128 v33; // xmm0
  __int128 v34; // xmm0
  int v35; // edi
  int v36; // esi
  __int64 v37; // rax
  int *v38; // rax
  int v39; // esi
  int v40; // edi
  unsigned int v41; // er14
  bool v42; // zf
  int v43; // [rsp+20h] [rbp-98h]
  bool v44; // [rsp+24h] [rbp-94h]
  int v45; // [rsp+28h] [rbp-90h]
  int v46; // [rsp+2Ch] [rbp-8Ch]
  CommandData::KeyData *v47; // [rsp+30h] [rbp-88h]
  CommandData::KeyData v48; // [rsp+38h] [rbp-80h] BYREF
  CommandData::KeyData keyDat; // [rsp+50h] [rbp-68h] BYREF
  int *v50; // [rsp+68h] [rbp-50h]
  __int64 v51; // [rsp+70h] [rbp-48h]
  bool v52; // [rsp+C0h] [rbp+8h]
  char v53; // [rsp+C8h] [rbp+10h]

  pCmdDat = this->pCmdDat;
  iInputDataID = cmdSet->iInputDataID;
  if ( (int)iInputDataID >= this->pCmdDat->dataHeader.iInputDataCount )
    return 0;
  if ( this->bClimaxDebug )
  {
    iGroup = cmdSet->iGroup;
    if ( iGroup == 19 || iGroup == 25 )
    {
      v15 = CommandCheck::SameTimeTrigger(this, 0);
      if ( (CommandCheck::ConvertInpToCmd(v15) & 0xA) == 10 )
        return 1;
    }
  }
  iWaitFrame = cmdSet->iWaitFrame;
  v17 = &pCmdDat->pCmdData[iInputDataID];
  iKeyCount = v17->iKeyCount;
  if ( (int)iKeyCount < 1 )
    return 0;
  iValidTerms = cmdSet->iValidTerms;
  if ( (iValidTerms & 0x80u) == 0 )
    iCAngleLooks = iCAngle;
  v46 = cmdSet->iValidTerms;
  if ( iAddPreFrame <= 0 )
  {
    iPrecedeFrame = 2;
    if ( cmdSet->iPrecedeFrame >= 0 )
      iPrecedeFrame = cmdSet->iPrecedeFrame;
    iAddPreFrame = iPrecedeFrame;
  }
  if ( iWaitFrame <= 0 )
  {
    iWaitFrame = 6 * iKeyCount - 6;
    if ( iWaitFrame <= 0 )
      iWaitFrame = 1;
  }
  pKey = v17->pKey;
  v22 = 0;
  v23 = (int)iKeyCount - 1;
  v47 = pKey;
  v53 = 0;
  v44 = 0;
  v24 = v23;
  if ( pKey[v23].iInputType <= 1u )
  {
    iKey = pKey[v23].iKey;
    if ( (iKey & 0xF) != 0 )
    {
      v53 = 1;
      v22 = 1;
      if ( (iKey & 0x1FF0) == 0 && (int)iKeyCount > 1 && (pKey[v24 - 1].iInputType & 0xFFFFFFFD) == 0 )
      {
        v26 = pKey[v24 - 1].iKey;
        if ( (v26 & 0x1FF0) != 0 )
          v44 = (v26 & 0xF) == 0;
      }
    }
  }
  v27 = 0;
  v45 = 0;
  v28 = 0;
  v43 = 0;
  v29 = (__int64)&pKey[iKeyCount - 1];
  v51 = v29;
  while ( 1 )
  {
    v30 = 0;
    v31 = v27;
    v32 = v29;
    *iRemainderFrame = v27;
    *iExtendPriority = 0;
    if ( v22 && (iValidTerms & 0x20) == 0 )
    {
      v33 = *(_OWORD *)v29;
      *(_QWORD *)&keyDat.iChargeFrame = *(_QWORD *)(v29 + 16);
      *(_OWORD *)&keyDat.iKey = v33;
      keyDat.iKey = v33 & 0xF;
      keyDat.iInputType = 2;
      keyDat.iFlag &= ~2u;
      do
      {
        if ( CommandCheck::Match(this, (const CommandData::KeyData *)v32, v31, iCAngleLooks) )
          break;
        if ( !CommandCheck::Match(this, &keyDat, v31, iCAngleLooks) )
          goto $GOTO_NEXT_LOOP;
        ++v31;
      }
      while ( (int)(v28 + v31) < 10 );
    }
    if ( !v44 )
      break;
    v34 = *(_OWORD *)v32;
    *(_QWORD *)&v48.iChargeFrame = *(_QWORD *)(v32 + 16);
    *(_OWORD *)&v48.iKey = v34;
    v48.iInputType = 0;
    if ( (v48.iFlag & 2) != 0 )
      v48.iKey |= 0x100u;
    else
      v48.iKey |= *(_DWORD *)(v32 - 24) & 0x1EF0 | 0x100;
    v52 = CommandCheck::Match(this, &v48, v31, iCAngleLooks);
    v30 = v52;
    if ( v52 )
      goto LABEL_47;
$GOTO_NEXT_LOOP:
    --v28;
    v22 = v53;
    v27 = v45 + 1;
    v29 = v51;
    LOBYTE(iValidTerms) = v46;
    v45 = v27;
    v43 = v28;
    if ( v27 > iAddPreFrame )
      return v30;
  }
  v35 = 0;
  if ( !CommandCheck::Match(this, (const CommandData::KeyData *)v32, v31, iCAngleLooks) )
  {
LABEL_45:
    v30 = 0;
    goto $GOTO_NEXT_LOOP;
  }
  v36 = *(_DWORD *)(v32 + 16);
  while ( ++v35 < v36 )
  {
    if ( !CommandCheck::Match(this, (const CommandData::KeyData *)v32, ++v31, iCAngleLooks) )
    {
      v28 = v43;
      goto LABEL_45;
    }
  }
  v28 = v43;
  v30 = 1;
  v52 = 1;
LABEL_47:
  if ( (CommandData::KeyData *)v32 == pKey )
  {
    v42 = v30 == 0;
    v30 = v52;
    if ( !v42 )
      return v30;
    goto $GOTO_NEXT_LOOP;
  }
  v37 = v32 + 16;
  while ( 2 )
  {
    v38 = (int *)(v37 - 24);
    v32 -= 24i64;
    v50 = v38;
    if ( *(v38 - 1) == 1 )
    {
      ++v31;
      --iWaitFrame;
    }
    if ( iWaitFrame <= 0 )
    {
      v30 = 0;
      v28 = v43;
      goto $GOTO_NEXT_LOOP;
    }
    v39 = *v38;
    while ( 2 )
    {
      v40 = 0;
      if ( v39 > 1 )
      {
        v41 = v31;
        if ( CommandCheck::Match(this, (const CommandData::KeyData *)v32, v31, iCAngleLooks) )
        {
          while ( ++v40 < v39 )
          {
            if ( !CommandCheck::Match(this, (const CommandData::KeyData *)v32, ++v31, iCAngleLooks) )
              goto LABEL_57;
          }
          goto LABEL_64;
        }
LABEL_57:
        iWaitFrame = v41 - v31 + iWaitFrame - 1;
        goto LABEL_62;
      }
      if ( !CommandCheck::Match(this, (const CommandData::KeyData *)v32, v31, iCAngleLooks) )
      {
LABEL_61:
        --iWaitFrame;
LABEL_62:
        ++v31;
        if ( iWaitFrame <= 0 )
        {
          v30 = 0;
          v28 = v43;
          pKey = v47;
          goto $GOTO_NEXT_LOOP;
        }
        continue;
      }
      break;
    }
    while ( ++v40 < v39 )
    {
      if ( !CommandCheck::Match(this, (const CommandData::KeyData *)v32, ++v31, iCAngleLooks) )
        goto LABEL_61;
    }
LABEL_64:
    pKey = v47;
    if ( (CommandData::KeyData *)v32 != v47 )
    {
      v37 = (__int64)v50;
      continue;
    }
    return 1;
  }
}

bool __fastcall CommandCheck::Match(
        CommandCheck *this,
        const CommandData::KeyData *keyDat,
        unsigned int uiInputFrame,
        int iCAngle)
{
  bool v6; // di
  int iCompType; // er14
  int iInputType; // ecx
  bool v9; // r15
  bool bStrict; // si
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  RestrictRingBuffer<int> *v14; // rdx
  unsigned __int64 uiDelay; // rcx
  unsigned int v16; // eax
  int *v17; // rdx
  int v18; // er8
  int v19; // er8
  unsigned int v20; // edx
  char v21; // al
  bool result; // al
  unsigned int Release; // eax
  unsigned __int64 v24; // rcx
  int v25; // er10
  unsigned int v26; // er8
  int iKey; // edi
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // er11
  RestrictRingBuffer<int> *Myval2; // rdx
  unsigned int uiDataSize; // eax
  int *v33; // rdx
  unsigned int Trigger; // eax
  unsigned int v35; // er8
  int v36; // edi
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // er11
  InputKeyCheck *pKeyBuf; // r12
  unsigned int v41; // ecx
  unsigned int v42; // eax
  int *v43; // rdx
  int v44; // er8
  char v45; // dl
  char v46; // al
  int v47; // ebx
  int v48; // eax
  int v49; // er10
  unsigned int v50; // er11
  int v51; // er10
  int v52; // eax
  int v53; // ebx
  CommandCheck *v54; // rcx
  int v55; // er10
  unsigned int v56; // eax
  unsigned int v57; // er11

  v6 = iCAngle && (keyDat->iFlag & 1) == 0;
  iCompType = keyDat->iCompType;
  iInputType = keyDat->iInputType;
  v9 = iCompType == 0;
  bStrict = (keyDat->iFlag & 2) != 0;
  if ( iInputType )
  {
    v11 = iInputType - 1;
    if ( v11 )
    {
      v12 = v11 - 1;
      if ( !v12 )
      {
        Myval2 = this->pKeyBuf->pKeyBuffer._Mypair._Myval2;
        uiDelay = Myval2->uiDelay;
        uiDataSize = Myval2->uiDataSize;
        if ( (unsigned int)uiDelay < uiDataSize
          && uiInputFrame < uiDataSize - (unsigned int)uiDelay
          && (uiDelay = Myval2->uiBufferMask & (Myval2->uiEndIndex - (_DWORD)uiDelay - uiInputFrame - 1),
              (v33 = &Myval2->pBuffer[uiDelay]) != 0i64) )
        {
          v19 = *v33;
        }
        else
        {
          v19 = 0;
        }
LABEL_16:
        if ( v6 )
        {
          uiDelay = v19 & 0xFFFFFFFC;
          v20 = v19 & 0xFFFFFFFC | 2;
          v21 = v19;
          if ( (v19 & 1) == 0 )
            v20 = v19 & 0xFFFFFFFC;
          v19 = v20 | 1;
          if ( (v21 & 2) == 0 )
            v19 = v20;
        }
        return CommandCheck::MatchSub((CommandCheck *)uiDelay, keyDat->iKey, v19, v9, bStrict);
      }
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 != 1 )
          return 0;
        v14 = this->pKeyBuf->pKeyBuffer._Mypair._Myval2;
        uiDelay = v14->uiDelay;
        v16 = v14->uiDataSize;
        if ( (unsigned int)uiDelay < v16
          && uiInputFrame < v16 - (unsigned int)uiDelay
          && (uiDelay = v14->uiBufferMask & (v14->uiEndIndex - (_DWORD)uiDelay - uiInputFrame - 1),
              (v17 = &v14->pBuffer[uiDelay]) != 0i64) )
        {
          v18 = *v17;
        }
        else
        {
          v18 = 0;
        }
        v19 = ~v18;
        goto LABEL_16;
      }
      Release = InputKeyCheck::GetRelease(this->pKeyBuf, uiInputFrame);
      v25 = Release;
      if ( v6 )
      {
        v24 = Release;
        v26 = Release & 0xFFFFFFFC | 2;
        LOBYTE(v24) = Release & 1;
        if ( (Release & 1) == 0 )
          v26 = Release & 0xFFFFFFFC;
        v25 = v26 | 1;
        if ( (Release & 2) == 0 )
          v25 = v26;
      }
      if ( !iCompType )
      {
        v28 = (keyDat->iKey & 5) + (((keyDat->iKey & 0xFu) >> 1) & 5);
        v24 = (v28 >> 2) + (v28 & 3);
        v29 = v24 + 1;
        if ( (keyDat->iKey & 0x1FF0) == 0 )
          v29 = v24;
        if ( v29 >= 2 )
        {
          iKey = keyDat->iKey;
          if ( ((unsigned int)CommandCheck::ConvertInpToCmd(v25) & iKey) != 0 )
            v25 = CommandCheck::SameTimeRelease(this, v30);
        }
      }
    }
    else
    {
      Trigger = InputKeyCheck::GetTrigger(this->pKeyBuf, uiInputFrame);
      v25 = Trigger;
      if ( v6 )
      {
        v24 = Trigger;
        v35 = Trigger & 0xFFFFFFFC | 2;
        LOBYTE(v24) = Trigger & 1;
        if ( (Trigger & 1) == 0 )
          v35 = Trigger & 0xFFFFFFFC;
        v25 = v35 | 1;
        if ( (Trigger & 2) == 0 )
          v25 = v35;
      }
      if ( !iCompType )
      {
        v37 = (keyDat->iKey & 5) + (((keyDat->iKey & 0xFu) >> 1) & 5);
        v24 = (v37 >> 2) + (v37 & 3);
        v38 = v24 + 1;
        if ( (keyDat->iKey & 0x1FF0) == 0 )
          v38 = v24;
        if ( v38 >= 2 )
        {
          v36 = keyDat->iKey;
          if ( ((unsigned int)CommandCheck::ConvertInpToCmd(v25) & v36) != 0 )
            v25 = CommandCheck::SameTimeTrigger(this, v39);
        }
      }
    }
    return CommandCheck::MatchSub((CommandCheck *)v24, keyDat->iKey, v25, v9, bStrict);
  }
  pKeyBuf = this->pKeyBuf;
  v41 = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDelay;
  v42 = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDataSize;
  if ( v41 < v42
    && uiInputFrame < v42 - v41
    && (v43 = &pKeyBuf->pKeyBuffer._Mypair._Myval2->pBuffer[pKeyBuf->pKeyBuffer._Mypair._Myval2->uiBufferMask & (pKeyBuf->pKeyBuffer._Mypair._Myval2->uiEndIndex - v41 - uiInputFrame - 1)]) != 0i64 )
  {
    v44 = *v43;
  }
  else
  {
    LOBYTE(v44) = 0;
  }
  if ( v6 )
  {
    v45 = v44 & 0xFC | 2;
    v46 = v44;
    if ( (v44 & 1) == 0 )
      v45 = v44 & 0xFC;
    LOBYTE(v44) = v45 | 1;
    if ( (v46 & 2) == 0 )
      LOBYTE(v44) = v45;
  }
  v47 = keyDat->iKey;
  v48 = CommandCheck::ConvertInpToCmd(v44 & 0xF);
  if ( (v49 & 0x1FF0) == 0 || (v49 & v48) != 0 )
  {
    v51 = v49 & 0xF;
    v52 = v48 & 0xF;
    result = !bStrict || (v52 & v51) == v52;
  }
  else
  {
    result = 0;
  }
  v53 = v47 & 0xF;
  if ( result && v53 )
  {
    v55 = InputKeyCheck::GetTrigger(pKeyBuf, v50);
    if ( !iCompType )
    {
      v54 = (CommandCheck *)(v53 & 5);
      v56 = (_DWORD)v54 + (((unsigned __int8)(v53 & 0xF) >> 1) & 5);
      if ( (v56 & 3) + (v56 >> 2) >= 2 && ((unsigned int)CommandCheck::ConvertInpToCmd(v55) & v53) != 0 )
        LOBYTE(v55) = CommandCheck::SameTimeTrigger(this, v57);
    }
    return CommandCheck::MatchSub(v54, v53, v55 & 0xF0, v9, bStrict);
  }
  return result;
}

char __fastcall CommandCheck::MatchSub(CommandCheck *this, int cmdKey, int inputKey, bool bAndOp, bool bStrict)
{
  unsigned __int16 v6; // ax
  unsigned __int16 v7; // r10
  int v8; // er10
  int v9; // er11

  v6 = CommandCheck::ConvertInpToCmd(inputKey);
  if ( (v7 & 0x1FF0) == 0 || (v6 & v7 & 0x1FF0) != 0 )
  {
    v8 = v7 & 0xF;
    v9 = v6 & 0xF;
    if ( bStrict )
    {
      if ( bAndOp )
      {
        if ( v8 == v9 )
          return 1;
      }
      else if ( (v9 & v8) == v9 )
      {
        if ( !v8 )
          return 1;
        if ( (v6 & 0xF) != 0 )
          return 1;
      }
    }
    else if ( bAndOp )
    {
      if ( (v9 & v8) == v8 )
        return 1;
    }
    else if ( !v8 || (v8 & v9) != 0 )
    {
      return 1;
    }
  }
  return 0;
}

__int64 __fastcall CommandCheck::SameTimeRelease(CommandCheck *this, unsigned int uiInputFrame)
{
  unsigned int v2; // er11
  unsigned int v3; // ebp
  InputKeyCheck *pKeyBuf; // rax
  RestrictRingBuffer<int> *Myval2; // r10
  unsigned int uiDataSize; // er12
  unsigned int uiDelay; // edi
  unsigned int v8; // eax
  unsigned int v9; // ebx
  int *v10; // r8
  int v11; // er9
  unsigned int v12; // eax
  int *v13; // rdx
  int v14; // eax

  v2 = 0;
  v3 = uiInputFrame + 2;
  if ( uiInputFrame <= uiInputFrame + 2 )
  {
    pKeyBuf = this->pKeyBuf;
    Myval2 = pKeyBuf->pKeyBuffer._Mypair._Myval2;
    uiDataSize = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDataSize;
    uiDelay = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDelay;
    do
    {
      v8 = 0;
      v9 = uiInputFrame + 1;
      if ( uiDelay < uiDataSize )
        v8 = uiDataSize - uiDelay;
      if ( v9 < v8
        && (v10 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - uiInputFrame - 2)]) != 0i64 )
      {
        v11 = *v10;
      }
      else
      {
        v11 = 0;
      }
      v12 = 0;
      if ( uiDelay < uiDataSize )
        v12 = uiDataSize - uiDelay;
      if ( uiInputFrame < v12
        && (v13 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - uiInputFrame - 1)]) != 0i64 )
      {
        v14 = *v13;
      }
      else
      {
        v14 = 0;
      }
      uiInputFrame = v9;
      v2 |= ~v14 & (v11 ^ v14);
    }
    while ( v9 <= v3 );
  }
  return v2;
}

__int64 __fastcall CommandCheck::SameTimeTrigger(CommandCheck *this, unsigned int uiInputFrame)
{
  unsigned int v2; // er11
  unsigned int v3; // ebp
  InputKeyCheck *pKeyBuf; // rax
  RestrictRingBuffer<int> *Myval2; // r10
  unsigned int uiDataSize; // er12
  unsigned int uiDelay; // edi
  unsigned int v8; // eax
  unsigned int v9; // ebx
  int *v10; // r8
  int v11; // er9
  unsigned int v12; // eax
  int *v13; // rdx
  int v14; // eax

  v2 = 0;
  v3 = uiInputFrame + 2;
  if ( uiInputFrame <= uiInputFrame + 2 )
  {
    pKeyBuf = this->pKeyBuf;
    Myval2 = pKeyBuf->pKeyBuffer._Mypair._Myval2;
    uiDataSize = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDataSize;
    uiDelay = pKeyBuf->pKeyBuffer._Mypair._Myval2->uiDelay;
    do
    {
      v8 = 0;
      v9 = uiInputFrame + 1;
      if ( uiDelay < uiDataSize )
        v8 = uiDataSize - uiDelay;
      if ( v9 < v8
        && (v10 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - uiInputFrame - 2)]) != 0i64 )
      {
        v11 = *v10;
      }
      else
      {
        v11 = 0;
      }
      v12 = 0;
      if ( uiDelay < uiDataSize )
        v12 = uiDataSize - uiDelay;
      if ( uiInputFrame < v12
        && (v13 = &Myval2->pBuffer[Myval2->uiBufferMask & (Myval2->uiEndIndex - uiDelay - uiInputFrame - 1)]) != 0i64 )
      {
        v14 = *v13;
      }
      else
      {
        v14 = 0;
      }
      uiInputFrame = v9;
      v2 |= v14 & (v11 ^ v14);
    }
    while ( v9 <= v3 );
  }
  return v2;
}

CommandData::Setting *__fastcall CommandCheck::ValidCommandFromIndex(
        CommandCheck *this,
        CommandEventListener *listener,
        int iIndex)
{
  __int64 v4; // rdi
  const CommandData *pCmdDat; // rcx

  v4 = iIndex;
  pCmdDat = this->pCmdDat;
  if ( !pCmdDat
    || !pCmdDat->CheckFileID(&pCmdDat->CharaFileBase)
    || (int)v4 < 0
    || (int)v4 >= this->pCmdDat->dataHeader.iCommandCount )
  {
    return 0i64;
  }
  listener->RecvCommandEvent(listener, this->iCommandDataTag, v4, &this->pCmdDat->pSetting[v4], 0, 0);
  return &this->pCmdDat->pSetting[v4];
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Check_size(
        std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *this)
{
  signed __int64 Mysize; // rax
  __int64 Maxidx; // rdx
  float v4; // xmm0_4
  float v5; // xmm1_4

  Mysize = this->_List._Mypair._Myval2._Mysize;
  Maxidx = this->_Maxidx;
  v4 = (float)(int)Mysize;
  if ( Mysize < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)Maxidx;
  if ( Maxidx < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > this->_Traitsobj._Mypair._Myval2._Myval2 )
  {
    if ( (unsigned __int64)Maxidx >= 0x200 )
    {
      if ( (unsigned __int64)Maxidx < 0xFFFFFFFFFFFFFFFi64 )
        Maxidx *= 2i64;
      std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
        (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
        Maxidx);
      std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Reinsert(this);
    }
    else
    {
      std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
        (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
        8 * Maxidx);
      std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Reinsert(this);
    }
  }
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Reinsert(
        std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *this)
{
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Myhead; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Prev; // rdi
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Next; // rbx
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >,bool> result; // [rsp+20h] [rbp-18h] BYREF

  Myhead = this->_List._Mypair._Myval2._Myhead;
  if ( Myhead->_Next != Myhead )
  {
    Prev = Myhead->_Prev;
    do
    {
      Next = this->_List._Mypair._Myval2._Myhead->_Next;
      std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Insert<std::pair<std::string const,CommandCheck::CommandSettingMapData> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>(
        this,
        &result,
        &Next->_Myval,
        (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >)Next);
    }
    while ( Next != Prev );
  }
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *__fastcall std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::erase(
        std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *result,
        std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > _Plist)
{
  unsigned __int64 Mysize; // r9
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Ptr; // rdi
  std::pair<std::string const ,CommandCheck::CommandSettingMapData> *p_Myval; // r8
  unsigned __int64 v8; // rcx
  __int64 i; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // r8
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > > *v12; // rcx
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Next; // rbx

  Mysize = _Plist._Ptr->_Myval.first._Mypair._Myval2._Mysize;
  Ptr = _Plist._Ptr;
  p_Myval = &_Plist._Ptr->_Myval;
  if ( p_Myval->first._Mypair._Myval2._Myres >= 0x10 )
    p_Myval = (std::pair<std::string const ,CommandCheck::CommandSettingMapData> *)p_Myval->first._Mypair._Myval2._Bx._Ptr;
  v8 = 0i64;
  for ( i = 0xCBF29CE484222325ui64; v8 < Mysize; i = 0x100000001B3i64 * (v10 ^ i) )
    v10 = (unsigned __int8)p_Myval->first._Mypair._Myval2._Bx._Buf[v8++];
  v11 = 2 * (i & this->_Mask);
  v12 = &this->_Vec._Mypair._Myval2._Myfirst[v11];
  if ( v12[1]._Ptr == Ptr )
  {
    if ( v12->_Ptr == Ptr )
    {
      v12->_Ptr = this->_List._Mypair._Myval2._Myhead;
      this->_Vec._Mypair._Myval2._Myfirst[v11 + 1]._Ptr = this->_List._Mypair._Myval2._Myhead;
    }
    else
    {
      v12[1]._Ptr = Ptr->_Prev;
    }
    goto LABEL_11;
  }
  if ( v12->_Ptr == Ptr )
  {
    v12->_Ptr = Ptr->_Next;
LABEL_11:
    Ptr = _Plist._Ptr;
  }
  Next = Ptr->_Next;
  Ptr->_Prev->_Next = Ptr->_Next;
  Ptr->_Next->_Prev = Ptr->_Prev;
  --this->_List._Mypair._Myval2._Mysize;
  std::string::~string((std::string *)&Ptr->_Myval.first);
  operator delete(Ptr);
  result->_Ptr = Next;
  return result;
}

std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *__fastcall std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<OGLMirror,void>::Body>>>,0>>::lower_bound(
        std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body>,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > >,0> > *this,
        std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *result,
        const std::string *_Keyval)
{
  unsigned __int64 Myres; // r15
  const std::string *v4; // r14
  unsigned __int64 Mysize; // rdi
  unsigned __int64 v8; // rcx
  __int64 i; // rdx
  __int64 v10; // rax
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *Myfirst; // rcx
  unsigned __int64 Mask; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Myhead; // rbp
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Ptr; // r13
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *v17; // rbx
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *v18; // rax
  std::_List_node<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> >,void *> *Next; // rax
  char **p_Myval; // rcx
  const std::string *v21; // rdx
  unsigned __int64 v22; // rsi
  size_t v23; // r8
  char **v24; // rdx
  size_t v25; // rsi
  size_t v26; // r8
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,extension::RCWeakPtr<extension::BasicFutureObject<extension::exsound_detail::SoundBankImpl,void>::Body> > > > > *j; // [rsp+50h] [rbp+8h]

  Myres = _Keyval->_Mypair._Myval2._Myres;
  v4 = _Keyval;
  Mysize = _Keyval->_Mypair._Myval2._Mysize;
  if ( Myres >= 0x10 )
    _Keyval = (const std::string *)_Keyval->_Mypair._Myval2._Bx._Ptr;
  v8 = 0i64;
  for ( i = 0xCBF29CE484222325ui64; v8 < Mysize; i = 0x100000001B3i64 * (v10 ^ i) )
    v10 = (unsigned __int8)_Keyval->_Mypair._Myval2._Bx._Buf[v8++];
  Myfirst = this->_Vec._Mypair._Myval2._Myfirst;
  Mask = this->_Mask;
  Myhead = this->_List._Mypair._Myval2._Myhead;
  v14 = i & Mask;
  v15 = 2 * (i & Mask);
  Ptr = Myfirst[v15]._Ptr;
  v17 = Myfirst[2 * v14]._Ptr;
  v18 = &Myfirst[v15 + 1];
  for ( j = v18; ; v18 = j )
  {
    if ( Ptr == Myhead )
      Next = Myhead;
    else
      Next = v18->_Ptr->_Next;
    if ( v17 == Next )
    {
      result->_Ptr = Myhead;
      return result;
    }
    p_Myval = (char **)&v17->_Myval;
    if ( Myres < 0x10 )
      v21 = v4;
    else
      v21 = (const std::string *)v4->_Mypair._Myval2._Bx._Ptr;
    if ( v17->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
      p_Myval = (char **)*p_Myval;
    v22 = v17->_Myval.first._Mypair._Myval2._Mysize;
    v23 = Mysize;
    if ( v22 < Mysize )
      v23 = v17->_Myval.first._Mypair._Myval2._Mysize;
    if ( (!v23 || !memcmp(p_Myval, v21, v23)) && v22 >= Mysize && v22 <= Mysize )
      break;
    v17 = v17->_Next;
  }
  v24 = (char **)&v17->_Myval;
  if ( v17->_Myval.first._Mypair._Myval2._Myres >= 0x10 )
    v24 = (char **)*v24;
  if ( Myres >= 0x10 )
    v4 = (const std::string *)v4->_Mypair._Myval2._Bx._Ptr;
  v25 = v17->_Myval.first._Mypair._Myval2._Mysize;
  v26 = v25;
  if ( Mysize < v25 )
    v26 = Mysize;
  if ( v26 && memcmp(v4, v24, v26) || Mysize < v25 || Mysize > v25 )
    v17 = Myhead;
  result->_Ptr = v17;
  return result;
}

void __fastcall std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::rehash(
        std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string >,std::equal_to<std::string > >,std::allocator<std::pair<std::string const ,CommandCheck::CommandSettingMapData> >,0> > *this,
        unsigned __int64 _Buckets)
{
  unsigned __int64 v4; // rdx
  signed __int64 Mysize; // rax
  float v6; // xmm1_4
  float v7; // xmm1_4
  float v8; // xmm0_4
  bool v9; // sf
  float v10; // xmm0_4
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Myhead; // rax
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Prev; // rdi
  std::_List_node<std::pair<std::string const ,CommandCheck::CommandSettingMapData>,void *> *Next; // rbx
  std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >,bool> result; // [rsp+20h] [rbp-18h] BYREF

  v4 = 8i64;
  if ( _Buckets > 8 )
  {
    while ( v4 < 0x7FFFFFFFFFFFFFFi64 )
    {
      v4 *= 2i64;
      if ( v4 >= _Buckets )
        goto LABEL_4;
    }
    if ( v4 < _Buckets )
      std::_Xout_of_range("invalid hash bucket count");
  }
LABEL_4:
  Mysize = this->_List._Mypair._Myval2._Mysize;
  v6 = (float)(int)Mysize;
  if ( Mysize < 0 )
    v6 = v6 + 1.8446744e19;
  v7 = v6 / this->_Traitsobj._Mypair._Myval2._Myval2;
  v8 = (float)(int)v4;
  if ( (v4 & 0x8000000000000000ui64) != 0i64 )
    v8 = v8 + 1.8446744e19;
  if ( v8 <= v7 )
  {
    do
    {
      if ( v4 >= 0x7FFFFFFFFFFFFFFi64 )
        break;
      v9 = (v4 & 0x4000000000000000i64) != 0;
      v4 *= 2i64;
      v10 = (float)(int)v4;
      if ( v9 )
        v10 = v10 + 1.8446744e19;
    }
    while ( v10 <= v7 );
  }
  std::_Hash<std::_Umap_traits<std::string,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,extension::RCWeakPtr<extension::BasicFutureObject<extension::AsyncAsset,extension::FutureAssetOption>::Body>>>,0>>::_Init(
    (std::_Hash<std::_Umap_traits<extension::SoundHashKey,int,std::_Uhash_compare<extension::SoundHashKey,extension::SoundHashKey::Hasher,std::equal_to<extension::SoundHashKey> >,std::allocator<std::pair<extension::SoundHashKey const ,int> >,0> > *)this,
    v4);
  Myhead = this->_List._Mypair._Myval2._Myhead;
  if ( Myhead->_Next != Myhead )
  {
    Prev = Myhead->_Prev;
    do
    {
      Next = this->_List._Mypair._Myval2._Myhead->_Next;
      std::_Hash<std::_Umap_traits<std::string,CommandCheck::CommandSettingMapData,std::_Uhash_compare<std::string,std::hash<std::string>,std::equal_to<std::string>>,std::allocator<std::pair<std::string const,CommandCheck::CommandSettingMapData>>,0>>::_Insert<std::pair<std::string const,CommandCheck::CommandSettingMapData> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const,CommandCheck::CommandSettingMapData>>>>>(
        this,
        &result,
        &Next->_Myval,
        (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::string const ,CommandCheck::CommandSettingMapData> > > >)Next);
    }
    while ( Next != Prev );
  }
}

