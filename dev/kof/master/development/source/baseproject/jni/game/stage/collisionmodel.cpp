#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/kof/master/development/source/baseproject/jni/game/stage/collisionmodel.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/lib/etc/math.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglvec3.cpp"
#include "dev/kof/master/development/source/baseproject/jni/framework/ogl/oglmatrix.cpp"

enum `anonymous-namespace'::VECTORNAME
{
	VEC_NTL = 0,
	VEC_NTR = 1,
	VEC_NBL = 2,
	VEC_NBR = 3,
	VEC_FTL = 4,
	VEC_FTR = 5,
	VEC_FBL = 6,
	VEC_FBR = 7,
};
enum `anonymous-namespace'::FACENAME
{
	FACE_T = 0,
	FACE_B = 1,
	FACE_R = 2,
	FACE_L = 3,
	FACE_N = 4,
	FACE_F = 5,
};
enum `anonymous-namespace'::BOARD_VECTORNAME
{
	BOARD_VEC_TL = 0,
	BOARD_VEC_TR = 1,
	BOARD_VEC_DR = 2,
	BOARD_VEC_DL = 3,
};
std::piecewise_construct_t std::piecewise_construct; // 0x1408A0B3D
enum `anonymous-namespace'::RESERVEPARAMS_BITS
{
	RESERVEPARAMS_CULLING = 1,
	RESERVEPARAMS_OBB = 2,
	RESERVEPARAMS_TRANS = 4,
	RESERVEPARAMS_ON = 65535,
	RESERVEPARAMS_OFF = 0,
};
CollisionModel::CollisionModel(const CollisionModel * pSrc); // 0x14021F000
CollisionModel::~CollisionModel(); // 0x14021F0A0
void CollisionModel::release(); // 0x14021F0B0
void CollisionModel::copy(const CollisionModel * pSrc); // 0x14021F1D0
void CollisionModel::transform(const OGLMatrix & mat); // 0x14021F3E0
bool CollisionModel::collisionTest(CollisionModel & model); // 0x14021F450
void CollisionModel::initialize(CollisionModel::MODELTYPE type, long vertexSize); // 0x14021F4F0
void CollisionModel::setupCubeModel(const CollisionModel::CubeModelParams & params); // 0x14021F670
void CollisionModel::setCullingParams_CubeModel(); // 0x14021F7B0
const OGLVec3 * CollisionModel::getTransVertex_CubeModel(); // 0x14021F970
void CollisionModel::setupSphereModel(const CollisionModel::SphereModelParams & params); // 0x14021FB30
void CollisionModel::setupBoardModel(const CollisionModel::BoardModelParams & params); // 0x14021FC10
const OGLVec3 * CollisionModel::getTransVertex_BoardModel(); // 0x14021FDB0
void CollisionModel::setupFrustumModel(const OGLMatrix & matProjection, const OGLMatrix & matView); // 0x14021FF70
bool CollisionModel::collisionTest_FrustumVsCube(CollisionModel & view, CollisionModel & cube); // 0x1402204D0
bool CollisionModel::collisionTest_CubeLineHitTest(CollisionModel & cube1, CollisionModel & cube2, long lineCount); // 0x140220700//decompilation failure at 1408A0B3D!
void __fastcall CollisionModel::CollisionModel(CollisionModel *this, const CollisionModel *pSrc)
{
  *(_QWORD *)&this->m_transform.m[4] = 0i64;
  *(_QWORD *)&this->m_transform.m[6] = 0i64;
  *(_QWORD *)&this->m_transform.m[14] = 0i64;
  *(_QWORD *)&this->m_obbCenter.x = 0i64;
  this->m_obbCenter.z = 0.0;
  *(_QWORD *)&this->m_obbDistance.x = 0i64;
  this->m_obbDistance.z = 0.0;
  this->m_modelType = MODELTYPE_NONE;
  this->m_pPoints = 0i64;
  this->m_pointCount = 0;
  *(_QWORD *)&this->m_transform.m[15] = 1065353216i64;
  this->m_bRefreshTransVertex = 0;
  this->m_pFaceCenters = 0i64;
  this->m_pFaceNormals = 0i64;
  *(_QWORD *)this->m_transform.m = 1065353216i64;
  this->m_transform.m[4] = 0.0;
  *(_QWORD *)&this->m_transform.m[8] = 0i64;
  *(_QWORD *)&this->m_transform.m[12] = 0i64;
  *(_QWORD *)&this->m_transform.m[5] = 1065353216i64;
  *(_QWORD *)&this->m_transform.m[2] = 0i64;
  *(_QWORD *)&this->m_transform.m[10] = 1065353216i64;
  this->m_transform.m[14] = 0.0;
  this->m_transform.m[7] = 0.0;
  this->m_pTransVertex = 0i64;
  this->m_pObbVectors = 0i64;
  this->m_pCubeParams = 0i64;
  CollisionModel::copy(this, pSrc);
}

// attributes: thunk
void __fastcall CollisionModel::~CollisionModel(CollisionModel *this)
{
  CollisionModel::release(this);
}

bool __fastcall CollisionModel::collisionTest(CollisionModel *this, CollisionModel *model)
{
  CollisionModel::MODELTYPE m_modelType; // er8
  CollisionModel::MODELTYPE v3; // eax
  int m_reserveRefreshParamsBits; // er9
  int v6; // er8

  m_modelType = this->m_modelType;
  if ( this->m_modelType )
  {
    v3 = model->m_modelType;
    if ( model->m_modelType )
    {
      if ( m_modelType == MODELTYPE_FRUSTUM )
      {
        if ( v3 == MODELTYPE_CUBE || v3 == MODELTYPE_FRUSTUM )
          return CollisionModel::collisionTest_FrustumVsCube(this, this, model);
      }
      else if ( m_modelType == MODELTYPE_CUBE )
      {
        if ( v3 == MODELTYPE_FRUSTUM )
          return CollisionModel::collisionTest_FrustumVsCube(this, model, this);
        if ( v3 == MODELTYPE_CUBE )
        {
          m_reserveRefreshParamsBits = this->m_reserveRefreshParamsBits;
          if ( (m_reserveRefreshParamsBits & 2) != 0 )
            this->m_reserveRefreshParamsBits = m_reserveRefreshParamsBits ^ 2;
          v6 = model->m_reserveRefreshParamsBits;
          if ( (v6 & 2) != 0
            && (model->m_modelType == MODELTYPE_CUBE
             || model->m_modelType == MODELTYPE_SPHERE
             || model->m_modelType == MODELTYPE_BOARD
             || model->m_modelType == MODELTYPE_FRUSTUM) )
          {
            model->m_reserveRefreshParamsBits = v6 ^ 2;
          }
        }
      }
    }
  }
  return 1;
}

char __fastcall CollisionModel::collisionTest_CubeLineHitTest(
        CollisionModel *this,
        CollisionModel *cube1,
        CollisionModel *cube2,
        int lineCount)
{
  int v4; // esi
  CollisionModel::MODELTYPE m_modelType; // edx
  CollisionModel *v7; // r9
  __int32 v8; // edx
  __int32 v9; // edx
  __int32 v10; // edx
  OGLVec3 *m_pPoints; // rbx
  const OGLVec3 *TransVertex_CubeModel; // rax
  int v13; // eax
  OGLVec3 *m_pFaceCenters; // rdx
  OGLVec3 *m_pFaceNormals; // r8
  float *v16; // r12
  OGLVec3 *v17; // rax
  float *v18; // rcx
  OGLVec3 *v19; // rax
  OGLVec3 *v20; // rax
  OGLVec3 *v21; // rax
  OGLVec3 *v22; // rax
  OGLVec3 *v23; // rax
  OGLVec3 *v24; // rax
  float *p_z; // r15
  int v26; // er12
  signed __int64 v27; // r13
  float v28; // xmm12_4
  float v29; // xmm13_4
  float v30; // xmm14_4
  float *v31; // rax
  float v32; // xmm15_4
  float v33; // xmm8_4
  float v34; // xmm9_4
  float v35; // xmm8_4
  float v36; // xmm6_4
  float v37; // xmm9_4
  float v38; // xmm12_4
  float *v39; // rdi
  float *v40; // r14
  float *v41; // rsi
  float *v42; // rbp
  float v43; // xmm13_4
  float v44; // xmm1_4
  float v45; // xmm14_4
  float v46; // xmm2_4
  float v47; // xmm5_4
  float v48; // xmm4_4
  float v49; // xmm7_4
  float v50; // xmm8_4
  float v51; // xmm15_4
  float v52; // xmm0_4
  float v53; // xmm3_4
  float v54; // xmm4_4
  float v55; // xmm5_4
  float v56; // xmm2_4
  float v57; // xmm1_4
  float v58; // xmm0_4
  float v59; // xmm13_4
  float v60; // xmm7_4
  float v61; // xmm14_4
  float v62; // xmm0_4
  float v63; // xmm3_4
  float v64; // xmm4_4
  float v65; // xmm2_4
  float v66; // xmm5_4
  float v67; // xmm1_4
  float v68; // xmm13_4
  float v69; // xmm7_4
  float v70; // xmm1_4
  float v71; // xmm4_4
  float v72; // xmm9_4
  float v73; // xmm12_4
  float v74; // xmm3_4
  float v75; // xmm2_4
  float v76; // xmm1_4
  float v77; // xmm7_4
  float v78; // xmm6_4
  float v79; // xmm13_4
  float v80; // xmm0_4
  float v82; // [rsp+20h] [rbp-138h]
  float *v83; // [rsp+28h] [rbp-130h]
  float v84; // [rsp+30h] [rbp-128h]
  float v85; // [rsp+30h] [rbp-128h]
  float *p_x; // [rsp+38h] [rbp-120h]
  float v87; // [rsp+40h] [rbp-118h]
  float v88; // [rsp+44h] [rbp-114h]
  float v89; // [rsp+48h] [rbp-110h]
  float v90; // [rsp+4Ch] [rbp-10Ch]
  float v91; // [rsp+50h] [rbp-108h]
  int v92; // [rsp+54h] [rbp-104h]
  int v93; // [rsp+58h] [rbp-100h]
  OGLVec3 *v94; // [rsp+60h] [rbp-F8h]
  OGLVec3 *v95; // [rsp+68h] [rbp-F0h]
  float v97; // [rsp+168h] [rbp+10h]
  float v98; // [rsp+170h] [rbp+18h]
  float v99; // [rsp+178h] [rbp+20h]

  v4 = 12;
  m_modelType = cube1->m_modelType;
  v7 = this;
  if ( (int)cube2 < 12 )
    v4 = (int)cube2;
  v93 = v4;
  v8 = m_modelType - 1;
  if ( !v8 )
  {
    TransVertex_CubeModel = CollisionModel::getTransVertex_CubeModel(cube1);
    goto LABEL_12;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    cube1->m_bRefreshTransVertex = 0;
    m_pPoints = 0i64;
    goto LABEL_13;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    TransVertex_CubeModel = CollisionModel::getTransVertex_BoardModel(cube1);
LABEL_12:
    v7 = this;
    m_pPoints = (OGLVec3 *)TransVertex_CubeModel;
    goto LABEL_13;
  }
  if ( v10 == 1 )
  {
    m_pPoints = cube1->m_pPoints;
    cube1->m_bRefreshTransVertex = 0;
  }
  else
  {
    m_pPoints = 0i64;
  }
LABEL_13:
  v13 = 0;
  v92 = 0;
  if ( v4 > 0 )
  {
    m_pFaceCenters = cube1->m_pFaceCenters;
    m_pFaceNormals = cube1->m_pFaceNormals;
    v94 = m_pFaceCenters;
    v95 = m_pFaceNormals;
LABEL_15:
    switch ( v13 )
    {
      case 0:
        p_x = &v7->m_pPoints->x;
        v16 = p_x + 12;
        goto LABEL_30;
      case 1:
        v17 = v7->m_pPoints;
        v18 = &v17[1].x;
        v16 = &v17[5].x;
        goto LABEL_29;
      case 2:
        v19 = v7->m_pPoints;
        v18 = &v19[2].x;
        v16 = &v19[6].x;
        goto LABEL_29;
      case 3:
        v20 = v7->m_pPoints;
        v18 = &v20[3].x;
        goto LABEL_28;
      case 4:
        p_x = &v7->m_pPoints->x;
        v16 = p_x + 3;
        goto LABEL_30;
      case 5:
        v21 = v7->m_pPoints;
        v18 = &v21[4].x;
        v16 = &v21[5].x;
        goto LABEL_29;
      case 6:
        v22 = v7->m_pPoints;
        v18 = &v22[2].x;
        v16 = &v22[3].x;
        goto LABEL_29;
      case 7:
        v20 = v7->m_pPoints;
        v18 = &v20[6].x;
        goto LABEL_28;
      case 8:
        p_x = &v7->m_pPoints->x;
        v16 = p_x + 6;
        goto LABEL_30;
      case 9:
        v23 = v7->m_pPoints;
        v18 = &v23[1].x;
        v16 = &v23[3].x;
        goto LABEL_29;
      case 10:
        v24 = v7->m_pPoints;
        v18 = &v24[4].x;
        v16 = &v24[6].x;
        goto LABEL_29;
      case 11:
        v20 = v7->m_pPoints;
        v18 = &v20[5].x;
LABEL_28:
        v16 = &v20[7].x;
LABEL_29:
        p_x = v18;
LABEL_30:
        v83 = v16;
        break;
      default:
        break;
    }
    p_z = &m_pFaceCenters->z;
    v26 = 0;
    v27 = (char *)m_pFaceNormals - (char *)m_pFaceCenters;
    v28 = *p_x;
    v29 = p_x[1];
    v30 = p_x[2];
    v31 = v83;
    v98 = *p_x;
    v97 = v29;
    v99 = v30;
    v32 = *v83;
    v82 = *v83;
    while ( 1 )
    {
      v33 = (float)((float)(*(float *)((char *)p_z + v27 - 4) * (float)(v29 - *(p_z - 1)))
                  + (float)(*(float *)((char *)p_z + v27 - 8) * (float)(v28 - *(p_z - 2))))
          + (float)(*(float *)((char *)p_z + v27) * (float)(v30 - *p_z));
      v34 = (float)((float)(*(float *)((char *)p_z + v27 - 4) * (float)(v31[1] - *(p_z - 1)))
                  + (float)(*(float *)((char *)p_z + v27 - 8) * (float)(v32 - *(p_z - 2))))
          + (float)(*(float *)((char *)p_z + v27) * (float)(v31[2] - *p_z));
      if ( v33 >= 0.0 && v34 >= 0.0 || v33 <= 0.0 && v34 <= 0.0 )
        goto LABEL_81;
      v35 = COERCE_FLOAT(LODWORD(v33) & _xmm)
          / (float)(COERCE_FLOAT(LODWORD(v34) & _xmm) + COERCE_FLOAT(LODWORD(v33) & _xmm));
      v36 = (float)((float)(v31[1] - v29) * v35) + v29;
      v37 = (float)((float)(v32 - v28) * v35) + v28;
      v38 = (float)((float)(v31[2] - v30) * v35) + v30;
      if ( v26 == 1 )
        break;
      if ( v26 != 2 )
      {
        if ( v26 != 3 )
        {
          if ( v26 == 4 )
          {
            v39 = &m_pPoints->x;
            v41 = &m_pPoints[1].x;
            v42 = &m_pPoints[3].x;
            v40 = &m_pPoints[2].x;
          }
          else if ( v26 == 5 )
          {
            v39 = &m_pPoints[5].x;
            v41 = &m_pPoints[4].x;
            v42 = &m_pPoints[6].x;
            v40 = &m_pPoints[7].x;
          }
          else
          {
            v39 = &m_pPoints[4].x;
            v40 = &m_pPoints->x;
            v41 = &m_pPoints[5].x;
            v42 = &m_pPoints[1].x;
          }
          goto LABEL_48;
        }
        v39 = &m_pPoints[4].x;
        v41 = &m_pPoints->x;
        v40 = &m_pPoints[6].x;
        goto LABEL_47;
      }
      v39 = &m_pPoints[1].x;
      v41 = &m_pPoints[5].x;
      v42 = &m_pPoints[7].x;
      v40 = &m_pPoints[3].x;
LABEL_48:
      v43 = *v41;
      v44 = v38 - v41[2];
      v45 = v41[1];
      v46 = v41[2] - v39[2];
      v47 = *v41 - *v39;
      v48 = v45 - v39[1];
      v49 = (float)((float)(v37 - *v41) * v46) - (float)(v44 * v47);
      v50 = (float)(v44 * v48) - (float)((float)(v36 - v45) * v46);
      v91 = v49;
      v51 = (float)((float)(v36 - v45) * v47) - (float)((float)(v37 - *v41) * v48);
      v52 = sqrtf((float)((float)(v49 * v49) + (float)(v50 * v50)) + (float)(v51 * v51));
      if ( v52 != 0.0 )
      {
        v50 = v50 / v52;
        v91 = v49 / v52;
        v51 = v51 / v52;
      }
      v53 = v37 - *v42;
      v54 = v42[1] - v45;
      v55 = *v42 - v43;
      v56 = v42[2] - v41[2];
      v57 = v38 - v42[2];
      v58 = v36 - v42[1];
      v59 = (float)(v58 * v55) - (float)(v53 * v54);
      v60 = (float)(v53 * v56) - (float)(v57 * v55);
      v90 = v59;
      v61 = (float)(v57 * v54) - (float)(v58 * v56);
      v89 = v60;
      v62 = sqrtf((float)((float)(v60 * v60) + (float)(v61 * v61)) + (float)(v59 * v59));
      if ( v62 != 0.0 )
      {
        v89 = v60 / v62;
        v90 = v59 / v62;
        v61 = v61 / v62;
      }
      v63 = v37 - *v40;
      v64 = v40[1] - v42[1];
      v65 = v40[2] - v42[2];
      v66 = *v40 - *v42;
      v67 = v38 - v40[2];
      v84 = v36 - v40[1];
      v68 = (float)(v63 * v65) - (float)(v67 * v66);
      v69 = (float)(v67 * v64) - (float)(v84 * v65);
      v85 = (float)(v84 * v66) - (float)(v63 * v64);
      v88 = v68;
      v87 = v69;
      v70 = sqrtf((float)((float)(v68 * v68) + (float)(v69 * v69)) + (float)(v85 * v85));
      if ( v70 != 0.0 )
      {
        v85 = v85 / v70;
        v87 = v69 / v70;
        v88 = v68 / v70;
      }
      v71 = v39[1];
      v72 = v37 - *v39;
      v73 = v38 - v39[2];
      v74 = *v39 - *v40;
      v75 = v71 - v40[1];
      v76 = v39[2] - v40[2];
      v77 = (float)(v73 * v75) - (float)((float)(v36 - v71) * v76);
      v78 = (float)((float)(v36 - v71) * v74) - (float)(v72 * v75);
      v79 = (float)(v72 * v76) - (float)(v73 * v74);
      v80 = sqrtf((float)((float)(v79 * v79) + (float)(v77 * v77)) + (float)(v78 * v78));
      if ( v80 != 0.0 )
      {
        v77 = v77 / v80;
        v79 = v79 / v80;
        v78 = v78 / v80;
      }
      if ( (v50 <= 0.050000001 && v61 <= 0.050000001 && v87 <= 0.050000001 && v77 <= 0.050000001
         || v50 >= -0.050000001 && v61 >= -0.050000001 && v87 >= -0.050000001 && v77 >= -0.050000001)
        && (v91 <= 0.050000001 && v89 <= 0.050000001 && v88 <= 0.050000001 && v79 <= 0.050000001
         || v91 >= -0.050000001 && v89 >= -0.050000001 && v88 >= -0.050000001 && v79 >= -0.050000001)
        && (v51 <= 0.050000001 && v90 <= 0.050000001 && v85 <= 0.050000001 && v78 <= 0.050000001
         || v51 >= -0.050000001 && v90 >= -0.050000001 && v85 >= -0.050000001 && v78 >= -0.050000001) )
      {
        return 1;
      }
      v31 = v83;
      v32 = v82;
      v30 = v99;
      v29 = v97;
      v28 = v98;
LABEL_81:
      ++v26;
      p_z += 3;
      if ( v26 >= 6 )
      {
        v13 = v92 + 1;
        v92 = v13;
        if ( v13 >= v93 )
          return 0;
        v7 = this;
        m_pFaceCenters = v94;
        m_pFaceNormals = v95;
        goto LABEL_15;
      }
    }
    v39 = &m_pPoints[7].x;
    v41 = &m_pPoints[6].x;
    v40 = &m_pPoints[3].x;
LABEL_47:
    v42 = &m_pPoints[2].x;
    goto LABEL_48;
  }
  return 0;
}

bool __fastcall CollisionModel::collisionTest_FrustumVsCube(
        CollisionModel *this,
        CollisionModel *view,
        CollisionModel *cube)
{
  OGLVec3 *m_pPoints; // r9
  const OGLVec3 *TransVertex_CubeModel; // rax
  CollisionModel::CALCULATIONTYPE calculationType; // esi
  OGLVec3 *m_pFaceNormals; // rdx
  __int64 v9; // r8
  OGLVec3 *m_pFaceCenters; // rcx
  float y; // xmm4_4
  int v12; // eax
  float z; // xmm3_4
  float x; // xmm5_4
  int v16; // er9

  if ( (view->m_reserveRefreshParamsBits & 1) != 0 )
  {
    if ( view->m_modelType != MODELTYPE_CUBE )
    {
      if ( view->m_modelType == MODELTYPE_SPHERE || view->m_modelType == MODELTYPE_BOARD )
        goto LABEL_7;
      if ( view->m_modelType != MODELTYPE_FRUSTUM )
        goto LABEL_8;
    }
    CollisionModel::setCullingParams_CubeModel(view);
LABEL_7:
    view->m_reserveRefreshParamsBits ^= 1u;
  }
LABEL_8:
  if ( (cube->m_reserveRefreshParamsBits & 1) == 0 )
    goto LABEL_15;
  if ( cube->m_modelType != MODELTYPE_CUBE )
  {
    if ( cube->m_modelType == MODELTYPE_SPHERE || cube->m_modelType == MODELTYPE_BOARD )
      goto LABEL_14;
    if ( cube->m_modelType != MODELTYPE_FRUSTUM )
      goto LABEL_15;
  }
  CollisionModel::setCullingParams_CubeModel(cube);
LABEL_14:
  cube->m_reserveRefreshParamsBits ^= 1u;
LABEL_15:
  switch ( cube->m_modelType )
  {
    case MODELTYPE_CUBE:
      TransVertex_CubeModel = CollisionModel::getTransVertex_CubeModel(cube);
      goto LABEL_24;
    case MODELTYPE_SPHERE:
      cube->m_bRefreshTransVertex = 0;
      m_pPoints = 0i64;
      break;
    case MODELTYPE_BOARD:
      TransVertex_CubeModel = CollisionModel::getTransVertex_BoardModel(cube);
LABEL_24:
      m_pPoints = (OGLVec3 *)TransVertex_CubeModel;
      break;
    case MODELTYPE_FRUSTUM:
      m_pPoints = cube->m_pPoints;
      cube->m_bRefreshTransVertex = 0;
      break;
    default:
      m_pPoints = 0i64;
      break;
  }
  calculationType = CALCULATIONTYPE_DEFAULT;
  if ( cube->m_modelType == MODELTYPE_CUBE )
    calculationType = cube->m_pCubeParams->calculationType;
  if ( cube->m_pointCount <= 0 )
  {
LABEL_39:
    if ( calculationType == CALCULATIONTYPE_EASY )
      return 0;
    if ( CollisionModel::collisionTest_CubeLineHitTest(view, cube, (CollisionModel *)4, (int)m_pPoints) )
      return 1;
    if ( calculationType == CALCULATIONTYPE_DEFAULT )
      return 0;
    return CollisionModel::collisionTest_CubeLineHitTest(cube, view, (CollisionModel *)0xC, v16) != 0;
  }
  else
  {
    m_pFaceNormals = view->m_pFaceNormals;
    v9 = 0i64;
    m_pPoints = (OGLVec3 *)((char *)m_pPoints + 8);
    m_pFaceCenters = view->m_pFaceCenters;
    while ( 1 )
    {
      y = m_pPoints[-1].y;
      v12 = 0;
      z = m_pPoints[-1].z;
      x = m_pPoints->x;
      if ( (float)((float)((float)((float)(y - m_pFaceCenters->x) * m_pFaceNormals->x)
                         + (float)((float)(z - m_pFaceCenters->y) * m_pFaceNormals->y))
                 + (float)((float)(m_pPoints->x - m_pFaceCenters->z) * m_pFaceNormals->z)) > 0.0 )
        v12 = 1;
      if ( (float)((float)((float)((float)(m_pPoints[-1].z - m_pFaceCenters[1].y) * m_pFaceNormals[1].y)
                         + (float)((float)(m_pPoints[-1].y - m_pFaceCenters[1].x) * m_pFaceNormals[1].x))
                 + (float)((float)(m_pPoints->x - m_pFaceCenters[1].z) * m_pFaceNormals[1].z)) > 0.0 )
        ++v12;
      if ( (float)((float)((float)((float)(z - m_pFaceCenters[2].y) * m_pFaceNormals[2].y)
                         + (float)((float)(y - m_pFaceCenters[2].x) * m_pFaceNormals[2].x))
                 + (float)((float)(x - m_pFaceCenters[2].z) * m_pFaceNormals[2].z)) > 0.0 )
        ++v12;
      if ( (float)((float)((float)((float)(z - m_pFaceCenters[3].y) * m_pFaceNormals[3].y)
                         + (float)((float)(y - m_pFaceCenters[3].x) * m_pFaceNormals[3].x))
                 + (float)((float)(x - m_pFaceCenters[3].z) * m_pFaceNormals[3].z)) > 0.0 )
        ++v12;
      if ( v12 >= 4 )
        return 1;
      ++v9;
      ++m_pPoints;
      if ( v9 >= cube->m_pointCount )
        goto LABEL_39;
    }
  }
}

void __fastcall CollisionModel::copy(CollisionModel *this, const CollisionModel *pSrc)
{
  unsigned __int64 m_pointCount; // rax
  unsigned __int64 v5; // rdi
  OGLVec3 *v6; // rax
  _DWORD *p_z; // rcx
  int v8; // er8
  __int64 v9; // rdx
  OGLVec3 *m_pPoints; // rax
  OGLVec3 *v11; // rcx
  CollisionModel::MODELTYPE m_modelType; // ecx
  __int32 v13; // ecx
  __int32 v14; // ecx
  _QWORD *v15; // rax
  CollisionModel::CubeModelParams *m_pCubeParams; // rdx
  _QWORD *v17; // r8
  float y; // xmm1_4
  char *v19; // rax
  CollisionModel::CubeModelParams *v20; // rdx
  float x; // xmm1_4
  float v22; // ecx
  _QWORD *v23; // rax
  CollisionModel::CubeModelParams *v24; // rcx
  _QWORD *v25; // rdx
  float z; // xmm1_4
  float v27; // xmm2_4

  CollisionModel::release(this);
  this->m_modelType = pSrc->m_modelType;
  m_pointCount = pSrc->m_pointCount;
  this->m_pointCount = m_pointCount;
  if ( (int)m_pointCount > 0 )
  {
    v5 = m_pointCount;
    v6 = (OGLVec3 *)operator new[](saturated_mul(m_pointCount, 0xCui64));
    if ( v6 )
    {
      if ( v5 )
      {
        p_z = (_DWORD *)&v6->z;
        do
        {
          *((_QWORD *)p_z - 1) = 0i64;
          *p_z = 0;
          p_z += 3;
          --v5;
        }
        while ( v5 );
      }
    }
    else
    {
      v6 = 0i64;
    }
    v8 = 0;
    this->m_pPoints = v6;
    if ( this->m_pointCount > 0 )
    {
      v9 = 0i64;
      do
      {
        m_pPoints = pSrc->m_pPoints;
        ++v9;
        v11 = this->m_pPoints;
        ++v8;
        *(_QWORD *)&v11[v9 - 1].x = *(_QWORD *)&m_pPoints[v9 - 1].x;
        v11[v9 - 1].z = m_pPoints[v9 - 1].z;
      }
      while ( v8 < this->m_pointCount );
    }
  }
  m_modelType = this->m_modelType;
  this->m_reserveRefreshParamsBits = 0xFFFF;
  this->m_bRefreshTransVertex = 1;
  v13 = m_modelType - 1;
  if ( v13 )
  {
    v14 = v13 - 1;
    if ( v14 )
    {
      if ( v14 == 1 )
      {
        v15 = operator new(0x18ui64);
        m_pCubeParams = pSrc->m_pCubeParams;
        v17 = v15;
        v15[1] = 0i64;
        *((_DWORD *)v15 + 4) = 0;
        *(float *)v15 = m_pCubeParams->size.x;
        *((_DWORD *)v15 + 1) = LODWORD(m_pCubeParams->size.y);
        *(float *)&v15 = m_pCubeParams->size.z;
        y = m_pCubeParams->position.y;
        *((_DWORD *)v17 + 3) = LODWORD(m_pCubeParams->position.x);
        *((float *)v17 + 4) = y;
        *((_DWORD *)v17 + 2) = (_DWORD)v15;
        *((_BYTE *)v17 + 20) = LOBYTE(m_pCubeParams->position.z);
        *((_BYTE *)v17 + 21) = BYTE1(m_pCubeParams->position.z);
        this->m_pCubeParams = (CollisionModel::CubeModelParams *)v17;
      }
    }
    else
    {
      v19 = (char *)operator new(0x10ui64);
      v20 = pSrc->m_pCubeParams;
      *(_QWORD *)(v19 + 4) = 0i64;
      *((_DWORD *)v19 + 3) = 0;
      *(float *)v19 = v20->size.x;
      x = v20->position.x;
      v22 = v20->size.y;
      *((_DWORD *)v19 + 2) = LODWORD(v20->size.z);
      *((float *)v19 + 3) = x;
      *((float *)v19 + 1) = v22;
      this->m_pCubeParams = (CollisionModel::CubeModelParams *)v19;
    }
  }
  else
  {
    v23 = operator new(0x1Cui64);
    v24 = pSrc->m_pCubeParams;
    v25 = v23;
    *v23 = 0i64;
    v23[1] = 0i64;
    v23[2] = 0i64;
    *(float *)&v23 = v24->size.x;
    z = v24->position.z;
    *((_DWORD *)v25 + 1) = LODWORD(v24->position.y);
    *((float *)v25 + 2) = z;
    *(_DWORD *)v25 = (_DWORD)v23;
    *(float *)&v23 = v24->position.x;
    v27 = v24->position.z;
    *((_DWORD *)v25 + 4) = LODWORD(v24->position.y);
    *((float *)v25 + 5) = v27;
    *((_DWORD *)v25 + 3) = (_DWORD)v23;
    *((_DWORD *)v25 + 6) = v24->calculationType;
    this->m_pCubeParams = (CollisionModel::CubeModelParams *)v25;
  }
}

OGLVec3 *__fastcall CollisionModel::getTransVertex_BoardModel(CollisionModel *this)
{
  int v3; // edi
  unsigned __int64 m_pointCount; // rsi
  OGLVec3 *v5; // rax
  _DWORD *p_z; // rcx
  __int64 v7; // rdx
  OGLVec3 *m_pPoints; // rax
  OGLVec3 *m_pTransVertex; // rcx

  if ( this->m_transform.m[0] == 1.0
    && this->m_transform.m[5] == 1.0
    && this->m_transform.m[10] == 1.0
    && this->m_transform.m[12] == 0.0
    && this->m_transform.m[13] == 0.0
    && this->m_transform.m[14] == 0.0
    && LOBYTE(this->m_pCubeParams->position.z) )
  {
    this->m_bRefreshTransVertex = 0;
    return this->m_pPoints;
  }
  else
  {
    if ( this->m_bRefreshTransVertex )
    {
      v3 = 0;
      this->m_bRefreshTransVertex = 0;
      if ( !this->m_pTransVertex )
      {
        m_pointCount = this->m_pointCount;
        v5 = (OGLVec3 *)operator new[](saturated_mul(m_pointCount, 0xCui64));
        if ( v5 )
        {
          if ( m_pointCount )
          {
            p_z = (_DWORD *)&v5->z;
            do
            {
              *((_QWORD *)p_z - 1) = 0i64;
              *p_z = 0;
              p_z += 3;
              --m_pointCount;
            }
            while ( m_pointCount );
          }
        }
        else
        {
          v5 = 0i64;
        }
        this->m_pTransVertex = v5;
      }
      if ( this->m_pointCount > 0 )
      {
        v7 = 0i64;
        do
        {
          m_pPoints = this->m_pPoints;
          ++v3;
          m_pTransVertex = this->m_pTransVertex;
          m_pTransVertex[v7].x = (float)((float)((float)(this->m_transform.m[4] * m_pPoints[v7].y)
                                               + (float)(this->m_transform.m[0] * m_pPoints[v7].x))
                                       + (float)(this->m_transform.m[8] * m_pPoints[v7].z))
                               + this->m_transform.m[12];
          m_pTransVertex[v7].y = (float)((float)((float)(this->m_transform.m[5] * m_pPoints[v7].y)
                                               + (float)(this->m_transform.m[1] * m_pPoints[v7].x))
                                       + (float)(m_pPoints[v7].z * this->m_transform.m[9]))
                               + this->m_transform.m[13];
          m_pTransVertex[v7].z = (float)((float)((float)(this->m_transform.m[6] * m_pPoints[v7].y)
                                               + (float)(this->m_transform.m[2] * m_pPoints[v7].x))
                                       + (float)(m_pPoints[v7].z * this->m_transform.m[10]))
                               + this->m_transform.m[14];
          ++v7;
        }
        while ( v3 < this->m_pointCount );
      }
    }
    return this->m_pTransVertex;
  }
}

OGLVec3 *__fastcall CollisionModel::getTransVertex_CubeModel(CollisionModel *this)
{
  int v3; // edi
  unsigned __int64 m_pointCount; // rsi
  OGLVec3 *v5; // rax
  _DWORD *p_z; // rcx
  __int64 v7; // rdx
  OGLVec3 *m_pPoints; // rax
  OGLVec3 *m_pTransVertex; // rcx

  if ( this->m_transform.m[0] == 1.0
    && this->m_transform.m[5] == 1.0
    && this->m_transform.m[10] == 1.0
    && this->m_transform.m[12] == 0.0
    && this->m_transform.m[13] == 0.0
    && this->m_transform.m[14] == 0.0 )
  {
    this->m_bRefreshTransVertex = 0;
    return this->m_pPoints;
  }
  else
  {
    if ( this->m_bRefreshTransVertex )
    {
      v3 = 0;
      this->m_bRefreshTransVertex = 0;
      if ( !this->m_pTransVertex )
      {
        m_pointCount = this->m_pointCount;
        v5 = (OGLVec3 *)operator new[](saturated_mul(m_pointCount, 0xCui64));
        if ( v5 )
        {
          if ( m_pointCount )
          {
            p_z = (_DWORD *)&v5->z;
            do
            {
              *((_QWORD *)p_z - 1) = 0i64;
              *p_z = 0;
              p_z += 3;
              --m_pointCount;
            }
            while ( m_pointCount );
          }
        }
        else
        {
          v5 = 0i64;
        }
        this->m_pTransVertex = v5;
      }
      if ( this->m_pointCount > 0 )
      {
        v7 = 0i64;
        do
        {
          m_pPoints = this->m_pPoints;
          ++v3;
          m_pTransVertex = this->m_pTransVertex;
          m_pTransVertex[v7].x = (float)((float)((float)(this->m_transform.m[0] * m_pPoints[v7].x)
                                               + (float)(this->m_transform.m[4] * m_pPoints[v7].y))
                                       + (float)(this->m_transform.m[8] * m_pPoints[v7].z))
                               + this->m_transform.m[12];
          m_pTransVertex[v7].y = (float)((float)((float)(m_pPoints[v7].y * this->m_transform.m[5])
                                               + (float)(this->m_transform.m[1] * m_pPoints[v7].x))
                                       + (float)(m_pPoints[v7].z * this->m_transform.m[9]))
                               + this->m_transform.m[13];
          m_pTransVertex[v7].z = (float)((float)((float)(m_pPoints[v7].y * this->m_transform.m[6])
                                               + (float)(this->m_transform.m[2] * m_pPoints[v7].x))
                                       + (float)(m_pPoints[v7].z * this->m_transform.m[10]))
                               + this->m_transform.m[14];
          ++v7;
        }
        while ( v3 < this->m_pointCount );
      }
    }
    return this->m_pTransVertex;
  }
}

void __fastcall CollisionModel::initialize(CollisionModel *this, CollisionModel::MODELTYPE type, int vertexSize)
{
  int v3; // ebx
  __int64 v6; // rdi
  OGLVec3 *v7; // rax
  _DWORD *p_z; // rcx
  __int32 v9; // esi
  __int32 v10; // esi
  _QWORD *v11; // rax

  v3 = vertexSize;
  if ( this->m_modelType == type && this->m_pointCount == vertexSize )
  {
    this->m_reserveRefreshParamsBits = 0xFFFF;
    return;
  }
  CollisionModel::release(this);
  this->m_modelType = type;
  if ( v3 < 1 )
    v3 = 1;
  v6 = v3;
  this->m_pointCount = v3;
  v7 = (OGLVec3 *)operator new[](saturated_mul(v3, 0xCui64));
  if ( v7 )
  {
    p_z = (_DWORD *)&v7->z;
    do
    {
      *((_QWORD *)p_z - 1) = 0i64;
      *p_z = 0;
      p_z += 3;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    v7 = 0i64;
  }
  this->m_pPoints = v7;
  this->m_reserveRefreshParamsBits = 0xFFFF;
  v9 = type - 1;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 != 1 )
        return;
      v11 = operator new(0x18ui64);
      v11[1] = 0i64;
      *(_QWORD *)((char *)v11 + 12) = 0i64;
      *v11 = 0i64;
      *((_DWORD *)v11 + 2) = 0;
      *((_DWORD *)v11 + 4) = 0;
      *((_WORD *)v11 + 10) = 0;
    }
    else
    {
      v11 = operator new(0x10ui64);
      *(_QWORD *)((char *)v11 + 4) = 0i64;
      v11[1] = 0i64;
      *v11 = 0i64;
      *((_DWORD *)v11 + 3) = 0;
    }
  }
  else
  {
    v11 = operator new(0x1Cui64);
    *v11 = 0i64;
    v11[1] = 0i64;
    v11[2] = 0i64;
    *v11 = 0i64;
    v11[1] = 0i64;
    v11[2] = 0i64;
    *((_DWORD *)v11 + 6) = 0;
  }
  this->m_pCubeParams = (CollisionModel::CubeModelParams *)v11;
}

void __fastcall CollisionModel::release(CollisionModel *this, unsigned __int64 a2)
{
  OGLVec3 *m_pPoints; // rcx
  OGLVec3 *m_pFaceCenters; // rcx
  OGLVec3 *m_pFaceNormals; // rcx
  OGLVec3 *m_pTransVertex; // rcx
  OGLVec3 *m_pObbVectors; // rcx
  CollisionModel::CubeModelParams *m_pCubeParams; // rcx
  unsigned __int64 v9; // rdx

  m_pPoints = this->m_pPoints;
  if ( m_pPoints )
  {
    operator delete(m_pPoints, a2);
    this->m_pPoints = 0i64;
  }
  m_pFaceCenters = this->m_pFaceCenters;
  if ( m_pFaceCenters )
  {
    operator delete(m_pFaceCenters, a2);
    this->m_pFaceCenters = 0i64;
  }
  m_pFaceNormals = this->m_pFaceNormals;
  if ( m_pFaceNormals )
  {
    operator delete(m_pFaceNormals, a2);
    this->m_pFaceNormals = 0i64;
  }
  m_pTransVertex = this->m_pTransVertex;
  if ( m_pTransVertex )
  {
    operator delete(m_pTransVertex, a2);
    this->m_pTransVertex = 0i64;
  }
  m_pObbVectors = this->m_pObbVectors;
  if ( m_pObbVectors )
  {
    operator delete(m_pObbVectors, a2);
    this->m_pObbVectors = 0i64;
  }
  switch ( this->m_modelType )
  {
    case MODELTYPE_CUBE:
      m_pCubeParams = this->m_pCubeParams;
      if ( m_pCubeParams )
      {
        v9 = 28i64;
        goto LABEL_20;
      }
      break;
    case MODELTYPE_SPHERE:
      m_pCubeParams = this->m_pCubeParams;
      if ( m_pCubeParams )
      {
        v9 = 16i64;
        goto LABEL_20;
      }
      break;
    case MODELTYPE_BOARD:
      m_pCubeParams = this->m_pCubeParams;
      if ( m_pCubeParams )
      {
        v9 = 24i64;
LABEL_20:
        operator delete(m_pCubeParams, v9);
        this->m_pCubeParams = 0i64;
      }
      break;
  }
  this->m_modelType = MODELTYPE_NONE;
  this->m_pPoints = 0i64;
  this->m_pointCount = 0;
  *(_QWORD *)&this->m_transform.m[15] = 1065353216i64;
  this->m_bRefreshTransVertex = 0;
  this->m_pFaceCenters = 0i64;
  this->m_pFaceNormals = 0i64;
  *(_QWORD *)this->m_transform.m = 1065353216i64;
  this->m_transform.m[4] = 0.0;
  *(_QWORD *)&this->m_transform.m[8] = 0i64;
  *(_QWORD *)&this->m_transform.m[12] = 0i64;
  *(_QWORD *)&this->m_transform.m[5] = 1065353216i64;
  *(_QWORD *)&this->m_transform.m[2] = 0i64;
  *(_QWORD *)&this->m_transform.m[10] = 1065353216i64;
  this->m_transform.m[14] = 0.0;
  this->m_transform.m[7] = 0.0;
  this->m_pTransVertex = 0i64;
  this->m_pObbVectors = 0i64;
  this->m_pCubeParams = 0i64;
}

void __fastcall CollisionModel::setCullingParams_CubeModel(CollisionModel *this)
{
  OGLVec3 *v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rdx
  _DWORD *p_z; // rcx
  OGLVec3 *v6; // rax
  _DWORD *v7; // rcx

  if ( !this->m_pFaceCenters )
  {
    v2 = (OGLVec3 *)operator new[](0x48ui64);
    v3 = 6i64;
    if ( v2 )
    {
      v4 = 6i64;
      p_z = (_DWORD *)&v2->z;
      do
      {
        *((_QWORD *)p_z - 1) = 0i64;
        *p_z = 0;
        p_z += 3;
        --v4;
      }
      while ( v4 );
    }
    else
    {
      v2 = 0i64;
    }
    this->m_pFaceCenters = v2;
    v6 = (OGLVec3 *)operator new[](0x48ui64);
    if ( v6 )
    {
      v7 = (_DWORD *)&v6->z;
      do
      {
        *((_QWORD *)v7 - 1) = 0i64;
        *v7 = 0;
        v7 += 3;
        --v3;
      }
      while ( v3 );
    }
    else
    {
      v6 = 0i64;
    }
    this->m_pFaceNormals = v6;
  }
  anonymous_namespace_::func2(
    this->m_pFaceCenters,
    this->m_pFaceNormals,
    (const OGLVec3 *)this->m_pPoints + 4,
    (const OGLVec3 *)this->m_pPoints + 1,
    this->m_pPoints,
    (const OGLVec3 *)this->m_pPoints + 5);
  anonymous_namespace_::func2(
    this->m_pFaceCenters + 1,
    this->m_pFaceNormals + 1,
    (const OGLVec3 *)this->m_pPoints + 7,
    (const OGLVec3 *)this->m_pPoints + 2,
    (const OGLVec3 *)this->m_pPoints + 3,
    (const OGLVec3 *)this->m_pPoints + 6);
  anonymous_namespace_::func2(
    this->m_pFaceCenters + 2,
    this->m_pFaceNormals + 2,
    (const OGLVec3 *)this->m_pPoints + 5,
    (const OGLVec3 *)this->m_pPoints + 3,
    (const OGLVec3 *)this->m_pPoints + 1,
    (const OGLVec3 *)this->m_pPoints + 7);
  anonymous_namespace_::func2(
    this->m_pFaceCenters + 3,
    this->m_pFaceNormals + 3,
    (const OGLVec3 *)this->m_pPoints + 6,
    this->m_pPoints,
    (const OGLVec3 *)this->m_pPoints + 2,
    (const OGLVec3 *)this->m_pPoints + 4);
  anonymous_namespace_::func2(
    this->m_pFaceCenters + 4,
    this->m_pFaceNormals + 4,
    this->m_pPoints,
    (const OGLVec3 *)this->m_pPoints + 3,
    (const OGLVec3 *)this->m_pPoints + 2,
    (const OGLVec3 *)this->m_pPoints + 1);
  anonymous_namespace_::func2(
    this->m_pFaceCenters + 5,
    this->m_pFaceNormals + 5,
    (const OGLVec3 *)this->m_pPoints + 5,
    (const OGLVec3 *)this->m_pPoints + 6,
    (const OGLVec3 *)this->m_pPoints + 7,
    (const OGLVec3 *)this->m_pPoints + 4);
}

void __fastcall CollisionModel::setupBoardModel(CollisionModel *this, const CollisionModel::BoardModelParams *params)
{
  __int64 v4; // rdi
  OGLVec3 *v5; // rax
  _DWORD *p_z; // rcx
  CollisionModel::CubeModelParams *m_pCubeParams; // rcx
  CollisionModel::CubeModelParams *v8; // rax
  float z; // xmm5_4
  float x; // xmm4_4
  float v11; // xmm3_4
  float y; // xmm2_4
  float v13; // xmm5_4
  float v14; // xmm0_4
  OGLVec3 *m_pPoints; // rax
  float v16; // xmm1_4
  float v17; // xmm4_4
  OGLVec3 *v18; // rax
  OGLVec3 *v19; // rax
  OGLVec3 *v20; // rax
  _QWORD *v21; // [rsp+30h] [rbp+8h]

  if ( this->m_modelType == MODELTYPE_BOARD && this->m_pointCount == 4 )
  {
    this->m_reserveRefreshParamsBits = 0xFFFF;
  }
  else
  {
    CollisionModel::release(this, (unsigned __int64)params);
    v4 = 4i64;
    this->m_modelType = MODELTYPE_BOARD;
    this->m_pointCount = 4;
    v5 = (OGLVec3 *)operator new[](saturated_mul(4ui64, 0xCui64));
    if ( v5 )
    {
      p_z = (_DWORD *)&v5->z;
      do
      {
        *((_QWORD *)p_z - 1) = 0i64;
        *p_z = 0;
        p_z += 3;
        --v4;
      }
      while ( v4 );
    }
    else
    {
      v5 = 0i64;
    }
    this->m_pPoints = v5;
    this->m_reserveRefreshParamsBits = 0xFFFF;
    v21 = operator new(0x18ui64);
    v21[1] = 0i64;
    *(_QWORD *)((char *)v21 + 12) = 0i64;
    *v21 = 0i64;
    *((_DWORD *)v21 + 2) = 0;
    *((_DWORD *)v21 + 4) = 0;
    *((_WORD *)v21 + 10) = 0;
    this->m_pCubeParams = (CollisionModel::CubeModelParams *)v21;
  }
  this->m_pCubeParams->size.x = params->width;
  this->m_pCubeParams->size.y = params->height;
  m_pCubeParams = this->m_pCubeParams;
  *(_QWORD *)&m_pCubeParams->size.z = *(_QWORD *)&params->position.x;
  m_pCubeParams->position.y = params->position.z;
  LOBYTE(this->m_pCubeParams->position.z) = params->bBillboard;
  BYTE1(this->m_pCubeParams->position.z) = params->bEasyCalculation;
  v8 = this->m_pCubeParams;
  z = v8->size.z;
  x = v8->position.x;
  v11 = v8->size.x + z;
  y = v8->position.y;
  v13 = z - v8->size.x;
  v14 = v8->size.y;
  m_pPoints = this->m_pPoints;
  v16 = v14 + x;
  v17 = x - v14;
  m_pPoints->x = v13;
  m_pPoints->z = y;
  m_pPoints->y = v16;
  v18 = this->m_pPoints;
  v18[1].x = v11;
  v18[1].y = v16;
  v18[1].z = y;
  v19 = this->m_pPoints;
  v19[2].x = v11;
  v19[2].y = v17;
  v19[2].z = y;
  v20 = this->m_pPoints;
  v20[3].x = v13;
  v20[3].y = v17;
  v20[3].z = y;
}

void __fastcall CollisionModel::setupCubeModel(CollisionModel *this, const CollisionModel::CubeModelParams *params)
{
  CollisionModel::CubeModelParams *m_pCubeParams; // r8
  CollisionModel::CubeModelParams *v5; // rax
  float x; // xmm5_4
  float y; // xmm4_4
  float v8; // xmm6_4
  float z; // xmm3_4
  float v10; // xmm5_4
  float v11; // xmm2_4
  float v12; // xmm4_4
  float v13; // xmm0_4
  OGLVec3 *m_pPoints; // rax
  float v15; // xmm1_4
  float v16; // xmm3_4
  OGLVec3 *v17; // rax
  OGLVec3 *v18; // rax
  OGLVec3 *v19; // rax
  OGLVec3 *v20; // rax
  OGLVec3 *v21; // rax
  OGLVec3 *v22; // rax
  OGLVec3 *v23; // rax

  CollisionModel::initialize(this, MODELTYPE_CUBE, 8);
  m_pCubeParams = this->m_pCubeParams;
  *(_QWORD *)&m_pCubeParams->size.x = *(_QWORD *)&params->size.x;
  m_pCubeParams->size.z = params->size.z;
  this->m_pCubeParams->position = params->position;
  this->m_pCubeParams->calculationType = params->calculationType;
  v5 = this->m_pCubeParams;
  x = v5->position.x;
  y = v5->position.y;
  v8 = v5->size.x + x;
  z = v5->position.z;
  v10 = x - v5->size.x;
  v11 = v5->size.y + y;
  v12 = y - v5->size.y;
  v13 = v5->size.z;
  m_pPoints = this->m_pPoints;
  v15 = v13 + z;
  v16 = z - v13;
  m_pPoints->x = v10;
  m_pPoints->y = v11;
  m_pPoints->z = v15;
  v17 = this->m_pPoints;
  v17[1].x = v8;
  v17[1].y = v11;
  v17[1].z = v15;
  v18 = this->m_pPoints;
  v18[2].x = v10;
  v18[2].y = v12;
  v18[2].z = v15;
  v19 = this->m_pPoints;
  v19[3].x = v8;
  v19[3].y = v12;
  v19[3].z = v15;
  v20 = this->m_pPoints;
  v20[4].x = v10;
  v20[4].y = v11;
  v20[4].z = v16;
  v21 = this->m_pPoints;
  v21[5].x = v8;
  v21[5].y = v11;
  v21[5].z = v16;
  v22 = this->m_pPoints;
  v22[6].x = v10;
  v22[6].y = v12;
  v22[6].z = v16;
  v23 = this->m_pPoints;
  v23[7].x = v8;
  v23[7].y = v12;
  v23[7].z = v16;
}

void __fastcall CollisionModel::setupFrustumModel(
        CollisionModel *this,
        const OGLMatrix *matProjection,
        const OGLMatrix *matView)
{
  __int64 v6; // rbx
  OGLVec3 *v7; // rax
  _DWORD *p_z; // rcx
  __int128 v9; // xmm2
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  OGLVec3 *m_pPoints; // rax
  float v13; // xmm5_4
  float v14; // xmm4_4
  float v15; // xmm3_4
  float v16; // xmm15_4
  float v17; // xmm14_4
  float v18; // xmm11_4
  float v19; // xmm10_4
  float v20; // xmm13_4
  float v21; // xmm12_4
  float v22; // xmm8_4
  float v23; // xmm6_4
  float v24; // xmm2_4
  float v25; // xmm1_4
  float v26; // xmm0_4
  float v27; // xmm2_4
  float v28; // xmm9_4
  float v29; // xmm7_4
  float v30; // xmm0_4
  float v31; // xmm9_4
  OGLVec3 *v32; // rax
  float v33; // xmm1_4
  OGLVec3 *v34; // rax
  float v35; // xmm14_4
  float v36; // xmm5_4
  float v37; // xmm2_4
  float v38; // xmm15_4
  float v39; // xmm1_4
  float v40; // xmm3_4
  float v41; // xmm13_4
  float v42; // xmm2_4
  float v43; // xmm1_4
  OGLVec3 *v44; // rax
  float v45; // xmm1_4
  float v46; // xmm8_4
  float v47; // xmm1_4
  float v48; // xmm0_4
  float v49; // xmm6_4
  float v50; // xmm1_4
  float v51; // xmm0_4
  float v52; // xmm2_4
  OGLVec3 *v53; // rax
  float v54; // xmm2_4
  float v55; // xmm0_4
  float v56; // xmm0_4
  float v57; // xmm2_4
  float v58; // xmm2_4
  float v59; // xmm11_4
  float v60; // xmm0_4
  float v61; // xmm10_4
  OGLVec3 *v62; // rax
  float v63; // xmm2_4
  float v64; // xmm1_4
  float v65; // xmm9_4
  float v66; // xmm0_4
  float v67; // xmm7_4
  OGLVec3 *v68; // rax
  float v69; // xmm2_4
  float v70; // xmm1_4
  OGLVec3 *v71; // rax
  float v72; // [rsp+28h] [rbp-E0h]
  float v73; // [rsp+2Ch] [rbp-DCh]
  OGLMatrix v74[3]; // [rsp+38h] [rbp-D0h] BYREF
  float v75; // [rsp+148h] [rbp+40h]
  float v76; // [rsp+158h] [rbp+50h]
  float v77; // [rsp+160h] [rbp+58h]

  if ( this->m_modelType == MODELTYPE_FRUSTUM && this->m_pointCount == 8 )
  {
    this->m_reserveRefreshParamsBits = 0xFFFF;
  }
  else
  {
    CollisionModel::release(this, (unsigned __int64)matProjection);
    v6 = 8i64;
    this->m_modelType = MODELTYPE_FRUSTUM;
    this->m_pointCount = 8;
    v7 = (OGLVec3 *)operator new[](saturated_mul(8ui64, 0xCui64));
    if ( v7 )
    {
      p_z = (_DWORD *)&v7->z;
      do
      {
        *((_QWORD *)p_z - 1) = 0i64;
        *p_z = 0;
        p_z += 3;
        --v6;
      }
      while ( v6 );
    }
    else
    {
      v7 = 0i64;
    }
    this->m_pPoints = v7;
    this->m_reserveRefreshParamsBits = 0xFFFF;
  }
  v9 = *(_OWORD *)&matView->m[4];
  v10 = *(_OWORD *)&matView->m[12];
  *(_OWORD *)v74[0].m = *(_OWORD *)matView->m;
  v11 = *(_OWORD *)&matView->m[8];
  *(_OWORD *)&v74[0].m[4] = v9;
  *(_OWORD *)&v74[0].m[8] = v11;
  *(_OWORD *)&v74[0].m[12] = v10;
  if ( *(float *)&v9 == 0.0 )
    v74[0].m[4] = FLOAT_9_9999999eN9;
  OGLMatrix::multiply(v74, (OGLMatrix *)matProjection);
  OGLMatrix::inverse(v74);
  m_pPoints = this->m_pPoints;
  v13 = v74[0].m[3];
  v14 = v74[0].m[0];
  v15 = v74[0].m[1];
  v16 = v74[0].m[5];
  v17 = v74[0].m[6];
  v18 = v74[0].m[3] - v74[0].m[7];
  v19 = v74[0].m[0] - v74[0].m[4];
  v75 = v74[0].m[3] + v74[0].m[7];
  v20 = v74[0].m[11] * 0.0;
  v21 = v74[0].m[8] * 0.0;
  v22 = v74[0].m[9] * 0.0;
  v23 = v74[0].m[10] * 0.0;
  v76 = v74[0].m[0] + v74[0].m[4];
  v24 = v74[0].m[1] + v74[0].m[5];
  v25 = (float)((float)(v74[0].m[11] * 0.0) - (float)(v74[0].m[3] + v74[0].m[7])) + v74[0].m[15];
  v77 = v74[0].m[1] + v74[0].m[5];
  m_pPoints->x = (float)((float)((float)(v74[0].m[8] * 0.0) - (float)(v74[0].m[0] + v74[0].m[4])) + v74[0].m[12]) / v25;
  v26 = v22 - v24;
  v27 = v74[0].m[2];
  v28 = v74[0].m[2] + v17;
  v29 = v74[0].m[2] - v17;
  v72 = v74[0].m[2] + v17;
  m_pPoints->y = (float)(v26 + v74[0].m[13]) / v25;
  v30 = v23 - v28;
  v31 = v15 - v16;
  m_pPoints->z = (float)(v30 + v74[0].m[14]) / v25;
  v32 = this->m_pPoints;
  v33 = (float)(v20 + v18) + v74[0].m[15];
  v32[1].x = (float)((float)(v21 + v19) + v74[0].m[12]) / v33;
  v32[1].y = (float)((float)((float)(v15 - v16) + v22) + v74[0].m[13]) / v33;
  v32[1].z = (float)((float)(v29 + v23) + v74[0].m[14]) / v33;
  v34 = this->m_pPoints;
  v73 = v74[0].m[7] - v13;
  v35 = v17 - v27;
  v36 = v74[0].m[4] - v14;
  v37 = v75 + v20;
  v38 = v16 - v15;
  v39 = v20 + v73;
  v40 = v74[0].m[14];
  v41 = v74[0].m[12];
  v42 = v37 + v74[0].m[15];
  v43 = v39 + v74[0].m[15];
  v34[2].x = (float)((float)(v21 + (float)(v74[0].m[4] - v14)) + v74[0].m[12]) / v43;
  v34[2].y = (float)((float)(v38 + v22) + v74[0].m[13]) / v43;
  v34[2].z = (float)((float)(v35 + v23) + v40) / v43;
  v44 = this->m_pPoints;
  v45 = v77 + v22;
  v46 = v74[0].m[13];
  v47 = (float)(v45 + v74[0].m[13]) / v42;
  v44[3].x = (float)((float)(v76 + v21) + v41) / v42;
  v48 = v72 + v23;
  v44[3].y = v47;
  v49 = v74[0].m[10];
  v50 = (float)(v74[0].m[9] - v77) + v46;
  v51 = (float)(v48 + v40) / v42;
  v52 = v74[0].m[11] - v75;
  v44[3].z = v51;
  v53 = this->m_pPoints;
  v54 = v52 + v74[0].m[15];
  v55 = (float)((float)(v74[0].m[8] - v76) + v41) / v54;
  v53[4].y = v50 / v54;
  v53[4].x = v55;
  v56 = (float)((float)(v49 - v72) + v40) / v54;
  v57 = v74[0].m[11];
  v53[4].z = v56;
  v58 = v57 + v18;
  v59 = v74[0].m[15];
  v60 = v74[0].m[8] + v19;
  v61 = v74[0].m[9];
  v62 = this->m_pPoints;
  v63 = v58 + v74[0].m[15];
  v64 = (float)((float)(v74[0].m[9] + v31) + v46) / v63;
  v62[5].x = (float)(v60 + v41) / v63;
  v65 = v74[0].m[11];
  v62[5].y = v64;
  v66 = v49 + v29;
  v67 = v74[0].m[8];
  v62[5].z = (float)(v66 + v40) / v63;
  v68 = this->m_pPoints;
  v69 = (float)(v65 + v73) + v59;
  v68[6].y = (float)((float)(v61 + v38) + v46) / v69;
  v68[6].x = (float)((float)(v67 + v36) + v41) / v69;
  v70 = (float)(v75 + v65) + v59;
  v68[6].z = (float)((float)(v49 + v35) + v40) / v69;
  v71 = this->m_pPoints;
  v71[7].y = (float)((float)(v61 + v77) + v46) / v70;
  v71[7].z = (float)((float)(v49 + v72) + v40) / v70;
  v71[7].x = (float)((float)(v76 + v67) + v41) / v70;
}

void __fastcall CollisionModel::setupSphereModel(CollisionModel *this, const CollisionModel::SphereModelParams *params)
{
  OGLVec3 *v4; // rax
  CollisionModel::CubeModelParams *m_pCubeParams; // rcx
  _QWORD *v6; // [rsp+30h] [rbp+8h]

  if ( this->m_modelType != MODELTYPE_SPHERE || this->m_pointCount )
  {
    CollisionModel::release(this, (unsigned __int64)params);
    this->m_modelType = MODELTYPE_SPHERE;
    this->m_pointCount = 1;
    v4 = (OGLVec3 *)operator new[](saturated_mul(1ui64, 0xCui64));
    if ( v4 )
    {
      *(_QWORD *)&v4->x = 0i64;
      v4->z = 0.0;
    }
    else
    {
      v4 = 0i64;
    }
    this->m_pPoints = v4;
    this->m_reserveRefreshParamsBits = 0xFFFF;
    v6 = operator new(0x10ui64);
    *(_QWORD *)((char *)v6 + 4) = 0i64;
    v6[1] = 0i64;
    *v6 = 0i64;
    *((_DWORD *)v6 + 3) = 0;
    this->m_pCubeParams = (CollisionModel::CubeModelParams *)v6;
  }
  else
  {
    this->m_reserveRefreshParamsBits = 0xFFFF;
  }
  this->m_pCubeParams->size.x = params->radius;
  m_pCubeParams = this->m_pCubeParams;
  *(_QWORD *)&m_pCubeParams->size.y = *(_QWORD *)&params->position.x;
  m_pCubeParams->position.x = params->position.z;
}

void __fastcall CollisionModel::transform(CollisionModel *this, const OGLMatrix *mat)
{
  float *v2; // r8
  signed __int64 v3; // r9
  __int64 v4; // rdx

  v2 = &mat->m[1];
  v3 = (char *)this - (char *)mat;
  v4 = 2i64;
  do
  {
    *(float *)((char *)v2 + v3 + 12) = *(v2 - 1);
    *(float *)((char *)v2 + v3 + 16) = *v2;
    *(float *)((char *)v2 + v3 + 20) = v2[1];
    *(float *)((char *)v2 + v3 + 24) = v2[2];
    *(float *)((char *)v2 + v3 + 28) = v2[3];
    *(float *)((char *)v2 + v3 + 32) = v2[4];
    *(float *)((char *)v2 + v3 + 36) = v2[5];
    *(float *)((char *)v2 + v3 + 40) = v2[6];
    v2 += 8;
    --v4;
  }
  while ( v4 );
  this->m_bRefreshTransVertex = 1;
  this->m_reserveRefreshParamsBits = 0xFFFF;
}

