#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/silverware/git/sdk/agsharedinstance.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"

struct Codebook
{
	long dimensions; // 0x0
	long entries; // 0x4
	unsigned char * codeword_lengths; // 0x8
	float minimum_value; // 0x10
	float delta_value; // 0x14
	unsigned char value_bits; // 0x18
	unsigned char lookup_type; // 0x19
	unsigned char sequence_p; // 0x1A
	unsigned char sparse; // 0x1B
	unsigned long lookup_values; // 0x1C
	float * multiplicands; // 0x20
	unsigned long * codewords; // 0x28
	short fast_huffman[1024]; // 0x30
	unsigned long * sorted_codewords; // 0x830
	long * sorted_values; // 0x838
	long sorted_entries; // 0x840
};
struct Floor0
{
	unsigned char order; // 0x0
	unsigned short rate; // 0x2
	unsigned short bark_map_size; // 0x4
	unsigned char amplitude_bits; // 0x6
	unsigned char amplitude_offset; // 0x7
	unsigned char number_of_books; // 0x8
	unsigned char book_list[16]; // 0x9
};
struct Floor1
{
	unsigned char partitions; // 0x0
	unsigned char partition_class_list[32]; // 0x1
	unsigned char class_dimensions[16]; // 0x21
	unsigned char class_subclasses[16]; // 0x31
	unsigned char class_masterbooks[16]; // 0x41
	short subclass_books[8][16]; // 0x52
	unsigned short Xlist[250]; // 0x152
	unsigned char sorted_order[250]; // 0x346
	unsigned char neighbors[2][250]; // 0x440
	unsigned char floor1_multiplier; // 0x634
	unsigned char rangebits; // 0x635
	long values; // 0x638
};
union Floor
{
public:
	Floor0 floor0; // 0x0
	Floor1 floor1; // 0x0
};
struct Residue
{
	unsigned long begin; // 0x0
	unsigned long end; // 0x4
	unsigned long part_size; // 0x8
	unsigned char classifications; // 0xC
	unsigned char classbook; // 0xD
	unsigned char * * classdata; // 0x10
	short[8] * residue_books; // 0x18
};
struct MappingChannel
{
	unsigned char magnitude; // 0x0
	unsigned char angle; // 0x1
	unsigned char mux; // 0x2
};
struct Mapping
{
	unsigned short coupling_steps; // 0x0
	MappingChannel * chan; // 0x8
	unsigned char submaps; // 0x10
	unsigned char submap_floor[15]; // 0x11
	unsigned char submap_residue[15]; // 0x20
};
struct Mode
{
	unsigned char blockflag; // 0x0
	unsigned char mapping; // 0x1
	unsigned short windowtype; // 0x2
	unsigned short transformtype; // 0x4
};
struct CRCscan
{
	unsigned long goal_crc; // 0x0
	long bytes_left; // 0x4
	unsigned long crc_so_far; // 0x8
	long bytes_done; // 0xC
	unsigned long sample_loc; // 0x10
};
struct ProbedPage
{
	unsigned long page_start; // 0x0
	unsigned long page_end; // 0x4
	unsigned long after_previous_page_start; // 0x8
	unsigned long first_decoded_sample; // 0xC
	unsigned long last_decoded_sample; // 0x10
};
struct stb_vorbis
{
	unsigned long sample_rate; // 0x0
	long channels; // 0x4
	unsigned long setup_memory_required; // 0x8
	unsigned long temp_memory_required; // 0xC
	unsigned long setup_temp_memory_required; // 0x10
	_iobuf * f; // 0x18
	unsigned long f_start; // 0x20
	long close_on_free; // 0x24
	unsigned char * stream; // 0x28
	unsigned char * stream_start; // 0x30
	unsigned char * stream_end; // 0x38
	unsigned long stream_len; // 0x40
	unsigned char push_mode; // 0x44
	unsigned long first_audio_page_offset; // 0x48
	ProbedPage p_first; // 0x4C
	ProbedPage p_last; // 0x60
	_stb_vorbis_alloc alloc; // 0x78
	long setup_offset; // 0x88
	long temp_offset; // 0x8C
	long eof; // 0x90
	STBVorbisError error; // 0x94
	long blocksize[2]; // 0x98
	long blocksize_0; // 0xA0
	long blocksize_1; // 0xA4
	long codebook_count; // 0xA8
	Codebook * codebooks; // 0xB0
	long floor_count; // 0xB8
	unsigned short floor_types[64]; // 0xBC
	Floor * floor_config; // 0x140
	long residue_count; // 0x148
	unsigned short residue_types[64]; // 0x14C
	Residue * residue_config; // 0x1D0
	long mapping_count; // 0x1D8
	Mapping * mapping; // 0x1E0
	long mode_count; // 0x1E8
	Mode mode_config[64]; // 0x1EC
	unsigned long total_samples; // 0x36C
	float * channel_buffers[16]; // 0x370
	float * outputs[16]; // 0x3F0
	float * previous_window[16]; // 0x470
	long previous_length; // 0x4F0
	short * finalY[16]; // 0x4F8
	unsigned long current_loc; // 0x578
	long current_loc_valid; // 0x57C
	float * A[2]; // 0x580
	float * B[2]; // 0x590
	float * C[2]; // 0x5A0
	float * window[2]; // 0x5B0
	unsigned short * bit_reverse[2]; // 0x5C0
	unsigned long serial; // 0x5D0
	long last_page; // 0x5D4
	long segment_count; // 0x5D8
	unsigned char segments[255]; // 0x5DC
	unsigned char page_flag; // 0x6DB
	unsigned char bytes_in_seg; // 0x6DC
	unsigned char first_decode; // 0x6DD
	long next_seg; // 0x6E0
	long last_seg; // 0x6E4
	long last_seg_which; // 0x6E8
	unsigned long acc; // 0x6EC
	long valid_bits; // 0x6F0
	long packet_bytes; // 0x6F4
	long end_seg_with_known_loc; // 0x6F8
	unsigned long known_loc_for_packet; // 0x6FC
	long discard_samples_deferred; // 0x700
	unsigned long samples_output; // 0x704
	long page_crc_tests; // 0x708
	CRCscan scan[4]; // 0x70C
	long channel_buffer_start; // 0x75C
	long channel_buffer_end; // 0x760
};
void * setup_malloc(stb_vorbis * f, long sz); // 0x140039AD0
void * setup_temp_malloc(stb_vorbis * f, long sz); // 0x140039B20
void crc32_init(); // 0x140039B60
long ilog(long n); // 0x140039C20
float float32_unpack(unsigned long x); // 0x140039CE0
long compute_codewords(Codebook * c, unsigned char * len, long n, unsigned long * values); // 0x140039D30
void compute_accelerated_huffman(Codebook * c); // 0x140039F90
long uint32_compare(const void * p, const void * q); // 0x14003A0B0
void compute_sorted_huffman(Codebook * c, unsigned char * lengths, unsigned long * values); // 0x14003A0D0
long lookup1_values(long entries, long dim); // 0x14003A400
void compute_twiddle_factors(long n, float * A, float * B, float * C); // 0x14003A490
void compute_window(long n, float * window); // 0x14003A630
void compute_bitreverse(long n, unsigned short * rev); // 0x14003A7E0
long init_blocksize(stb_vorbis * f, long b, long n); // 0x14003A8A0
struct PointOGG
{
	unsigned short x; // 0x0
	unsigned short y; // 0x2
};
long point_compare(const void * p, const void * q); // 0x14003AA80
unsigned char get8(stb_vorbis * z); // 0x14003AAA0
unsigned long get32(stb_vorbis * f); // 0x14003AAF0
long getn(stb_vorbis * z, unsigned char * data, long n); // 0x14003AC20
void skip(stb_vorbis * z, long n); // 0x14003ACB0
long set_file_offset(stb_vorbis * f, unsigned long loc); // 0x14003AD10
long capture_pattern(stb_vorbis * f); // 0x14003ADD0
long start_page_no_capturepattern(stb_vorbis * f); // 0x14003AEB0
long start_page(stb_vorbis * f); // 0x14003B0D0
long start_packet(stb_vorbis * f); // 0x14003B110
long maybe_start_packet(stb_vorbis * f); // 0x14003B1B0
long next_segment(stb_vorbis * f); // 0x14003B2C0
long get8_packet_raw(stb_vorbis * f); // 0x14003B3D0
void flush_packet(stb_vorbis * f); // 0x14003B450
unsigned long get_bits(stb_vorbis * f, long n); // 0x14003B4D0
enum <unnamed-enum-VORBIS_packet_id>
{
	VORBIS_packet_id = 1,
	VORBIS_packet_comment = 3,
	VORBIS_packet_setup = 5,
};
long codebook_decode_scalar_raw(stb_vorbis * f, Codebook * c); // 0x14003B5B0
long codebook_decode_start(stb_vorbis * f, Codebook * c, long len); // 0x14003B860
long codebook_decode(stb_vorbis * f, Codebook * c, float * output, long len); // 0x14003B9F0
long codebook_decode_step(stb_vorbis * f, Codebook * c, float * output, long len, long step); // 0x14003BD50
long codebook_decode_deinterleave_repeat(stb_vorbis * f, Codebook * c, float * * outputs, long ch, long * c_inter_p, long * p_inter_p, long len, long total_decode); // 0x14003BF20
long codebook_decode_deinterleave_repeat_2(stb_vorbis * f, Codebook * c, float * * outputs, long * c_inter_p, long * p_inter_p, long len, long total_decode); // 0x14003C430
long residue_decode(stb_vorbis * f, Codebook * book, float * target, long offset, long n, long rtype); // 0x14003C920
void decode_residue(stb_vorbis * f, float * * residue_buffers, long ch, long n, long rn, unsigned char * do_not_decode); // 0x14003CA00
void imdct_step3_iter0_loop(long n, float * e, long i_off, long k_off, float * A); // 0x14003D380
void imdct_step3_inner_r_loop(long lim, float * e, long d0, long k_off, float * A, long k1); // 0x14003D540
void imdct_step3_inner_s_loop(long n, float * e, long i_off, long k_off, float * A, long a_off, long k0); // 0x14003D710
void imdct_step3_inner_s_loop_ld654(long n, float * e, long i_off, float * A, long base_n); // 0x14003D980
void inverse_mdct(float * buffer, long n, stb_vorbis * f, long blocktype); // 0x14003DC90
long do_floor(stb_vorbis * f, Mapping * map, long i, long n, float * target, short * finalY, unsigned char * step2_flag); // 0x14003ECB0
long vorbis_decode_initial(stb_vorbis * f, long * p_left_start, long * p_left_end, long * p_right_start, long * p_right_end, long * mode); // 0x14003F0F0
long vorbis_decode_packet_rest(stb_vorbis * f, long * len, Mode * m, long left_start, long left_end, long right_start, long right_end, long * p_left); // 0x14003F410
long vorbis_finish_frame(stb_vorbis * f, long len, long left, long right); // 0x1400400C0
void vorbis_pump_first_frame(stb_vorbis * f); // 0x1400403D0
long is_whole_packet_present(stb_vorbis * f, long end_page); // 0x140040470
long start_decoder(stb_vorbis * f); // 0x1400405F0
void vorbis_deinit(stb_vorbis * p); // 0x140041DC0
unsigned long stb_vorbis_get_file_offset(stb_vorbis * f); // 0x1400420A0
unsigned long vorbis_find_page(stb_vorbis * f, unsigned long * end, unsigned long * last); // 0x1400420E0
unsigned long stb_vorbis_stream_length_in_samples(stb_vorbis * f); // 0x1400424F0
long stb_vorbis_get_frame_float(stb_vorbis * f, long * channels, float * * * output); // 0x140042700
stb_vorbis * stb_vorbis_open_memory(unsigned char * data, long len, long * error, _stb_vorbis_alloc * alloc); // 0x140042850
union float_conv
{
public:
	float f; // 0x0
	long i; // 0x0
};
void copy_samples(short * dest, float * src, long len); // 0x140042A10
void compute_samples(long mask, short * output, long num_c, float * * data, long d_offset, long len); // 0x140042BB0
void compute_stereo_samples(short * output, long num_c, float * * data, long d_offset, long len); // 0x140042FC0
void convert_samples_short(long buf_c, short * * buffer, long b_offset, long data_c, float * * data, long d_offset, long samples); // 0x1400434D0
void convert_channels_short_interleaved(long buf_c, short * buffer, long data_c, float * * data, long d_offset, long len); // 0x1400435F0
long stb_vorbis_get_frame_short_interleaved(stb_vorbis * f, long num_c, short * buffer, long num_shorts); // 0x140043850
class oggCallBackInfo :
	AgSimpleThreadHost
{
public:
	stb_vorbis * v; // 0x10
	long * * state; // 0x18
	long * loadCount; // 0x20
	AgPointer<AgSharedInstance<AgMutex> > pMutex; // 0x28
	short * data; // 0x38
	unsigned char * data_in; // 0x40
	AgThread me; // 0x48
	oggCallBackInfo(oggCallBackInfo &);
	oggCallBackInfo(const oggCallBackInfo &);
	oggCallBackInfo();
	virtual void onExecuteThread();
	virtual ~oggCallBackInfo();
	oggCallBackInfo & operator=(oggCallBackInfo &);
	oggCallBackInfo & operator=(const oggCallBackInfo &);
};
unsigned long crc_table[256]; // 0x140AC2300
char channel_position[6][7]; // 0x140888BC0
std::piecewise_construct_t std::piecewise_construct; // 0x140888B19
unsigned char ogg_page_header[4]; // 0x140A2B1B8
float inverse_db_table[256]; // 0x140888BF0
void * oggCallBack(void * ptr); // 0x140043950
void oggCallBackInfo::onExecuteThread(); // 0x140043AD0
long stb_vorbis_decode_memory_plus(unsigned char * mem, long len, long * channels, long * sample, long * * threadState, long * loadCount, AgPointer<AgSharedInstance<AgMutex> > pThreadMutex, short * * output); // 0x140043AE0//decompilation failure at 140AC2300!
//decompilation failure at 140888BC0!
//decompilation failure at 140888B19!
//decompilation failure at 140A2B1B8!
//decompilation failure at 140888BF0!
AgPointer<AgSharedInstance<AgMutex> > *__fastcall AgPointer<AgSharedInstance<AgMutex>>::operator=(
        AgPointer<AgSharedInstance<AgMutex> > *this,
        const AgPointer<AgSharedInstance<AgMutex> > *rhs)
{
  AgReferenceCount *m_ref; // rdi
  int m_strongCount; // ebx
  AgReferenceCount *v6; // r8
  AgSharedInstance<AgMutex> *m_ptr; // rdx
  AgSharedInstance<AgMutex> *v8; // rax
  AgPointer<AgSharedInstance<AgMutex> > v10; // [rsp+20h] [rbp-18h] BYREF

  m_ref = rhs->m_ref;
  v10 = 0i64;
  if ( !m_ref )
    goto LABEL_5;
  m_strongCount = m_ref->m_strongCount;
  if ( !m_ref->m_strongCount )
    goto LABEL_5;
  while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( !m_ref->m_strongCount )
      goto LABEL_5;
  }
  if ( m_strongCount != -1 )
  {
    v6 = rhs->m_ref;
    m_ptr = rhs->m_ptr;
  }
  else
  {
LABEL_5:
    v6 = v10.m_ref;
    m_ptr = v10.m_ptr;
  }
  v8 = this->m_ptr;
  v10.m_ref = this->m_ref;
  this->m_ref = v6;
  this->m_ptr = m_ptr;
  v10.m_ptr = v8;
  AgPointer<AgSharedInstance<AgMutex>>::~AgPointer<AgSharedInstance<AgMutex>>(&v10);
  return this;
}

_BOOL8 __fastcall capture_pattern(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 v4; // cl
  int v5; // eax
  unsigned __int8 *v6; // rax
  unsigned __int8 v7; // cl
  int v8; // eax
  unsigned __int8 *v9; // rax
  unsigned __int8 v10; // cl
  int v11; // eax

  stream = f->stream;
  if ( stream )
  {
    if ( stream >= f->stream_end )
    {
      f->eof = 1;
      return 0i64;
    }
    v4 = *stream;
    f->stream = stream + 1;
  }
  else
  {
    v5 = fgetc(f->f);
    v4 = v5;
    if ( v5 == -1 )
      goto LABEL_8;
  }
  if ( v4 != 79 )
    return 0i64;
  v6 = f->stream;
  if ( v6 )
  {
    if ( v6 >= f->stream_end )
      goto LABEL_8;
    v7 = *v6;
    f->stream = v6 + 1;
  }
  else
  {
    v8 = fgetc(f->f);
    v7 = v8;
    if ( v8 == -1 )
      goto LABEL_8;
  }
  if ( v7 != 103 )
    return 0i64;
  v9 = f->stream;
  if ( !v9 )
  {
    v11 = fgetc(f->f);
    v10 = v11;
    if ( v11 != -1 )
      goto LABEL_18;
LABEL_8:
    f->eof = 1;
    return 0i64;
  }
  if ( v9 >= f->stream_end )
    goto LABEL_8;
  v10 = *v9;
  f->stream = v9 + 1;
LABEL_18:
  if ( v10 != 103 )
    return 0i64;
  return get8(f) == 83;
}

__int64 __fastcall codebook_decode(stb_vorbis *f, Codebook *c, float *output, int len)
{
  int v7; // er9
  int v9; // er9
  __int64 v10; // r8
  __int64 v11; // rdx
  __int64 v12; // r11
  float v13; // xmm1_4
  __int64 v14; // r14
  __int64 v15; // rsi
  float *v16; // r9
  unsigned __int64 v17; // r10
  float v18; // xmm1_4
  float v19; // xmm1_4
  float v20; // xmm1_4
  float v21; // xmm1_4
  float *v22; // rcx
  __int64 v23; // rdx
  float v24; // xmm1_4
  __int64 v25; // r10
  float *multiplicands; // r14
  float **p_multiplicands; // rbp
  float *v28; // r12
  __int64 v29; // rsi
  __m128 *v30; // rcx
  float *v31; // r8
  __int64 v32; // r14
  __int64 v33; // rsi
  unsigned __int64 v34; // r9
  float *v35; // r8
  __int64 v36; // rdx

  v7 = codebook_decode_start(f, c, (int)output);
  if ( v7 < 0 )
    return 0i64;
  if ( len > c->dimensions )
    len = c->dimensions;
  v9 = c->dimensions * v7;
  v10 = 0i64;
  v11 = len;
  v12 = v9;
  if ( c->sequence_p )
  {
    v13 = 0.0;
    if ( len >= 4i64 )
    {
      v14 = 4i64 * v9 - 8 - (_QWORD)output;
      v15 = 4i64 * v9 - (_QWORD)output;
      v16 = output + 2;
      v17 = ((unsigned __int64)(v11 - 4) >> 2) + 1;
      v10 = 4 * v17;
      do
      {
        v18 = v13 + *(float *)((char *)c->multiplicands + (unsigned __int64)v16 + v14);
        *(v16 - 2) = v18 + *(v16 - 2);
        v19 = (float)(v18 + c->minimum_value) + *(float *)((char *)c->multiplicands + (unsigned __int64)v16 + v14 + 4);
        *(v16 - 1) = v19 + *(v16 - 1);
        v20 = (float)(v19 + c->minimum_value) + *(float *)((char *)c->multiplicands + v15 + (unsigned __int64)v16);
        *v16 = v20 + *v16;
        v21 = (float)(v20 + c->minimum_value) + *(float *)((char *)c->multiplicands + v15 + (unsigned __int64)v16 + 4);
        v16[1] = v21 + v16[1];
        v16 += 4;
        v13 = v21 + c->minimum_value;
        --v17;
      }
      while ( v17 );
    }
    if ( v10 < v11 )
    {
      v22 = &output[v10];
      v23 = v11 - v10;
      do
      {
        v24 = v13 + *(float *)((char *)v22 + (unsigned __int64)c->multiplicands + 4 * v12 - (_QWORD)output);
        *v22 = v24 + *v22;
        ++v22;
        v13 = v24 + c->minimum_value;
        --v23;
      }
      while ( v23 );
    }
  }
  else
  {
    LODWORD(v25) = 0;
    if ( len > 0 && (unsigned int)len >= 8 )
    {
      multiplicands = c->multiplicands;
      p_multiplicands = &c->multiplicands;
      v28 = &output[len - 1];
      if ( (output > &multiplicands[len - 1 + v9] || v28 < &multiplicands[v9])
        && (output > (float *)p_multiplicands || v28 < (float *)p_multiplicands) )
      {
        v29 = len - (len & 7);
        v30 = (__m128 *)(output + 4);
        do
        {
          LODWORD(v25) = v25 + 8;
          v10 += 8i64;
          v30[-1] = _mm_add_ps(
                      _mm_add_ps(
                        *(__m128 *)((char *)multiplicands + (_QWORD)v30 + 4i64 * v9 - 16 - (_QWORD)output),
                        (__m128)0i64),
                      v30[-1]);
          *v30 = _mm_add_ps(
                   _mm_add_ps(
                     *(__m128 *)((char *)multiplicands + (_QWORD)v30 + 4i64 * v9 - (_QWORD)output),
                     (__m128)0i64),
                   *v30);
          v30 += 2;
        }
        while ( v10 < v29 );
      }
    }
    v25 = (int)v25;
    if ( (int)v25 < v11 )
    {
      if ( v11 - (int)v25 >= 4 )
      {
        v31 = &output[(int)v25 + 2];
        v32 = 4i64 * v9 - 8 - (_QWORD)output;
        v33 = 4i64 * v9 - (_QWORD)output;
        v34 = ((unsigned __int64)(v11 - (int)v25 - 4) >> 2) + 1;
        v25 = (int)v25 + 4 * v34;
        do
        {
          *(v31 - 2) = (float)(*(float *)((char *)v31 + v32 + (unsigned __int64)c->multiplicands) + 0.0) + *(v31 - 2);
          *(v31 - 1) = (float)(*(float *)((char *)v31 + v32 + (unsigned __int64)c->multiplicands + 4) + 0.0)
                     + *(v31 - 1);
          *v31 = (float)(*(float *)((char *)v31 + v33 + (unsigned __int64)c->multiplicands) + 0.0) + *v31;
          v31[1] = (float)(*(float *)((char *)v31 + v33 + (unsigned __int64)c->multiplicands + 4) + 0.0) + v31[1];
          v31 += 4;
          --v34;
        }
        while ( v34 );
      }
      if ( v25 < v11 )
      {
        v35 = &output[v25];
        v36 = v11 - v25;
        do
        {
          *v35 = (float)(*(float *)((char *)c->multiplicands + 4 * v12 - (_QWORD)output + (unsigned __int64)v35) + 0.0)
               + *v35;
          ++v35;
          --v36;
        }
        while ( v36 );
      }
    }
  }
  return 1i64;
}

__int64 __fastcall codebook_decode_deinterleave_repeat(
        stb_vorbis *f,
        Codebook *c,
        float **outputs,
        int ch,
        int *c_inter_p,
        int *p_inter_p,
        int len,
        int total_decode)
{
  int v12; // edi
  int v13; // er14
  __int64 v15; // rsi
  __int64 v16; // rbx
  int valid_bits; // eax
  float v18; // xmm6_4
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v21; // cl
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  unsigned int acc; // edx
  __int64 v26; // r8
  int v27; // ecx
  bool v28; // sf
  int v29; // er9
  int v30; // eax
  __int64 v31; // r11
  __int64 v32; // r8
  __int64 v33; // rcx
  unsigned __int64 v34; // rdx
  int v35; // edi
  float v36; // xmm6_4
  float *v37; // rax
  __int64 v38; // rsi
  int v39; // edi
  float v40; // xmm6_4
  float *v41; // rax
  __int64 v42; // rsi
  int v43; // edi
  float v44; // xmm6_4
  float *v45; // rax
  __int64 v46; // rsi
  float *v47; // rax
  __int64 v48; // rcx
  __int64 v49; // r9
  float *v50; // rax
  __int64 v51; // r10
  __int64 v52; // rdx
  unsigned __int64 v53; // r8
  float *v54; // rcx
  int v55; // edi
  __int64 v56; // rsi
  float *v57; // rcx
  int v58; // edi
  __int64 v59; // rsi
  float *v60; // rcx
  int v61; // edi
  __int64 v62; // rsi
  float *v63; // rcx
  __int64 v64; // rdx
  __int64 v65; // r9
  float *v66; // rcx
  int dimensions; // [rsp+78h] [rbp+10h]

  v12 = *c_inter_p;
  v13 = *p_inter_p;
  dimensions = c->dimensions;
  if ( !c->lookup_type )
  {
    f->error = VORBIS_invalid_stream;
    return 0i64;
  }
  if ( total_decode <= 0 )
  {
LABEL_66:
    *c_inter_p = v12;
    *p_inter_p = v13;
    return 1i64;
  }
  v15 = *c_inter_p;
  v16 = *p_inter_p;
  while ( 1 )
  {
    valid_bits = f->valid_bits;
    v18 = 0.0;
    if ( valid_bits <= 9 )
    {
      if ( !valid_bits )
        f->acc = 0;
      while ( 1 )
      {
        last_seg = f->last_seg;
        if ( last_seg && !f->bytes_in_seg || !f->bytes_in_seg && (last_seg || !next_segment(f)) )
          break;
        --f->bytes_in_seg;
        ++f->packet_bytes;
        stream = f->stream;
        if ( stream )
        {
          if ( stream < f->stream_end )
          {
            v21 = *stream;
            f->stream = stream + 1;
            goto LABEL_18;
          }
        }
        else
        {
          v22 = fgetc(f->f);
          v21 = v22;
          if ( v22 != -1 )
            goto LABEL_18;
        }
        v21 = 0;
        f->eof = 1;
LABEL_18:
        v23 = v21;
        if ( v21 != -1 )
        {
          v24 = f->valid_bits;
          f->acc += v23 << v24;
          f->valid_bits = v24 + 8;
          if ( v24 + 8 <= 24 )
            continue;
        }
        break;
      }
    }
    acc = f->acc;
    v26 = c->fast_huffman[acc & 0x3FF];
    if ( (int)v26 < 0 )
    {
      LODWORD(v26) = codebook_decode_scalar_raw(f, c);
      goto LABEL_28;
    }
    v27 = c->codeword_lengths[v26];
    v28 = f->valid_bits - v27 < 0;
    f->valid_bits -= v27;
    f->acc = acc >> v27;
    if ( v28 )
      break;
LABEL_28:
    if ( (int)v26 < 0 )
      goto LABEL_23;
    v29 = dimensions;
    if ( v12 + dimensions + ch * v13 > len * ch )
    {
      dimensions = v12 + ch * (len - v13);
      v29 = dimensions;
    }
    v30 = v26 * c->dimensions;
    v31 = v30;
    if ( c->sequence_p )
    {
      v32 = 0i64;
      if ( v29 >= 4i64 )
      {
        v33 = v30;
        v34 = ((unsigned __int64)(v29 - 4i64) >> 2) + 1;
        v32 = 4 * v34;
        do
        {
          v35 = v12 + 1;
          v36 = v18 + c->multiplicands[v33];
          v37 = outputs[v15];
          v38 = v15 + 1;
          v37[v16] = v36 + v37[v16];
          if ( v35 == ch )
          {
            v35 = 0;
            v38 = 0i64;
            ++v13;
            ++v16;
          }
          v39 = v35 + 1;
          v40 = v36 + c->multiplicands[v33 + 1];
          v41 = outputs[v38];
          v42 = v38 + 1;
          v41[v16] = v40 + v41[v16];
          if ( v39 == ch )
          {
            v39 = 0;
            v42 = 0i64;
            ++v13;
            ++v16;
          }
          v43 = v39 + 1;
          v44 = v40 + c->multiplicands[v33 + 2];
          v45 = outputs[v42];
          v46 = v42 + 1;
          v45[v16] = v44 + v45[v16];
          if ( v43 == ch )
          {
            v43 = 0;
            v46 = 0i64;
            ++v13;
            ++v16;
          }
          v12 = v43 + 1;
          v18 = v44 + c->multiplicands[v33 + 3];
          v47 = outputs[v46];
          v15 = v46 + 1;
          v47[v16] = v18 + v47[v16];
          if ( v12 == ch )
          {
            v12 = 0;
            v15 = 0i64;
            ++v13;
            ++v16;
          }
          v33 += 4i64;
          --v34;
        }
        while ( v34 );
      }
      if ( v32 < v29 )
      {
        v48 = v31 + v32;
        v49 = v29 - v32;
        do
        {
          ++v12;
          v18 = v18 + c->multiplicands[v48];
          v50 = outputs[v15++];
          v50[v16] = v18 + v50[v16];
          if ( v12 == ch )
          {
            v12 = 0;
            v15 = 0i64;
            ++v13;
            ++v16;
          }
          ++v48;
          --v49;
        }
        while ( v49 );
      }
    }
    else
    {
      v51 = 0i64;
      if ( v29 >= 4i64 )
      {
        v52 = v30;
        v53 = ((unsigned __int64)(v29 - 4i64) >> 2) + 1;
        v51 = 4 * v53;
        do
        {
          v54 = outputs[v15];
          v55 = v12 + 1;
          v56 = v15 + 1;
          v54[v16] = (float)(c->multiplicands[v52] + 0.0) + v54[v16];
          if ( v55 == ch )
          {
            v55 = 0;
            v56 = 0i64;
            ++v13;
            ++v16;
          }
          v57 = outputs[v56];
          v58 = v55 + 1;
          v59 = v56 + 1;
          v57[v16] = (float)(c->multiplicands[v52 + 1] + 0.0) + v57[v16];
          if ( v58 == ch )
          {
            v58 = 0;
            v59 = 0i64;
            ++v13;
            ++v16;
          }
          v60 = outputs[v59];
          v61 = v58 + 1;
          v62 = v59 + 1;
          v60[v16] = (float)(c->multiplicands[v52 + 2] + 0.0) + v60[v16];
          if ( v61 == ch )
          {
            v61 = 0;
            v62 = 0i64;
            ++v13;
            ++v16;
          }
          v63 = outputs[v62];
          v12 = v61 + 1;
          v15 = v62 + 1;
          v63[v16] = (float)(c->multiplicands[v52 + 3] + 0.0) + v63[v16];
          if ( v12 == ch )
          {
            v12 = 0;
            v15 = 0i64;
            ++v13;
            ++v16;
          }
          v52 += 4i64;
          --v53;
        }
        while ( v53 );
      }
      if ( v51 < v29 )
      {
        v64 = v30 + v51;
        v65 = v29 - v51;
        do
        {
          v66 = outputs[v15];
          ++v12;
          ++v15;
          v66[v16] = (float)(c->multiplicands[v64] + 0.0) + v66[v16];
          if ( v12 == ch )
          {
            v12 = 0;
            v15 = 0i64;
            ++v13;
            ++v16;
          }
          ++v64;
          --v65;
        }
        while ( v65 );
      }
    }
    total_decode -= dimensions;
    if ( total_decode <= 0 )
      goto LABEL_66;
  }
  f->valid_bits = 0;
LABEL_23:
  if ( f->bytes_in_seg || !f->last_seg )
    f->error = VORBIS_invalid_stream;
  return 0i64;
}

__int64 __fastcall codebook_decode_deinterleave_repeat_2(
        stb_vorbis *f,
        Codebook *c,
        float **outputs,
        int *c_inter_p,
        int *p_inter_p,
        int len,
        int total_decode)
{
  float **v7; // r15
  int v9; // edi
  stb_vorbis *v10; // rbx
  int v11; // ebp
  __int64 result; // rax
  __int64 v13; // rsi
  int valid_bits; // eax
  float v15; // xmm6_4
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v18; // cl
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  unsigned int acc; // edx
  __int64 v23; // r8
  int v24; // ecx
  bool v25; // sf
  int v26; // eax
  int v27; // er14
  __int64 v28; // r8
  __int64 v29; // r10
  __int64 v30; // rdx
  unsigned __int64 v31; // r9
  __int64 v32; // rcx
  int v33; // edi
  float v34; // xmm6_4
  float *v35; // rax
  __int64 v36; // rsi
  int v37; // edi
  float v38; // xmm6_4
  float *v39; // rax
  __int64 v40; // rsi
  int v41; // edi
  float v42; // xmm6_4
  float *v43; // rax
  __int64 v44; // rsi
  float *v45; // rax
  __int64 v46; // rdx
  __int64 v47; // r8
  __int64 v48; // rcx
  float *v49; // rax
  int v50; // er9
  float *v51; // rdx
  __int64 v52; // r8
  int v53; // eax
  int v54; // er10
  float *v55; // r11
  float *v56; // r15
  __int64 v57; // r8
  float *v58; // rdx
  signed __int64 v59; // r11
  float v60; // xmm1_4
  float *v61; // rdx
  int dimensions; // [rsp+98h] [rbp+10h]

  v7 = outputs;
  v9 = *c_inter_p;
  v10 = f;
  v11 = *p_inter_p;
  dimensions = c->dimensions;
  if ( !c->lookup_type )
  {
    f->error = VORBIS_invalid_stream;
    return 0i64;
  }
  if ( total_decode <= 0 )
  {
LABEL_59:
    *p_inter_p = v11;
    result = 1i64;
    *c_inter_p = v9;
    return result;
  }
  v13 = *c_inter_p;
  while ( 1 )
  {
    valid_bits = v10->valid_bits;
    v15 = 0.0;
    if ( valid_bits <= 9 )
    {
      if ( !valid_bits )
        v10->acc = 0;
      while ( 1 )
      {
        last_seg = v10->last_seg;
        if ( last_seg && !v10->bytes_in_seg || !v10->bytes_in_seg && (last_seg || !next_segment(v10)) )
          break;
        --v10->bytes_in_seg;
        ++v10->packet_bytes;
        stream = v10->stream;
        if ( stream )
        {
          if ( stream < v10->stream_end )
          {
            v18 = *stream;
            v10->stream = stream + 1;
            goto LABEL_18;
          }
        }
        else
        {
          v19 = fgetc(v10->f);
          v18 = v19;
          if ( v19 != -1 )
            goto LABEL_18;
        }
        v18 = 0;
        v10->eof = 1;
LABEL_18:
        v20 = v18;
        if ( v18 != -1 )
        {
          v21 = v10->valid_bits;
          v10->acc += v20 << v21;
          v10->valid_bits = v21 + 8;
          if ( v21 + 8 <= 24 )
            continue;
        }
        break;
      }
    }
    acc = v10->acc;
    v23 = c->fast_huffman[acc & 0x3FF];
    if ( (int)v23 < 0 )
    {
      LODWORD(v23) = codebook_decode_scalar_raw(v10, c);
      goto LABEL_28;
    }
    v24 = c->codeword_lengths[v23];
    v25 = v10->valid_bits - v24 < 0;
    v10->valid_bits -= v24;
    v10->acc = acc >> v24;
    if ( v25 )
      break;
LABEL_28:
    if ( (int)v23 < 0 )
      goto LABEL_23;
    v26 = dimensions;
    if ( v9 + dimensions + 2 * v11 > 2 * len )
    {
      v26 = v9 + 2 * (len - v11);
      dimensions = v26;
    }
    v27 = v23 * c->dimensions;
    if ( c->sequence_p )
    {
      v28 = v26;
      v29 = 0i64;
      if ( v26 >= 4i64 )
      {
        v30 = v27;
        v31 = ((unsigned __int64)(v26 - 4i64) >> 2) + 1;
        v32 = v11;
        v29 = 4 * v31;
        do
        {
          v33 = v9 + 1;
          v34 = v15 + c->multiplicands[v30];
          v35 = v7[v13];
          v36 = v13 + 1;
          v35[v32] = v34 + v35[v32];
          if ( v33 == 2 )
          {
            v33 = 0;
            v36 = 0i64;
            ++v11;
            ++v32;
          }
          v37 = v33 + 1;
          v38 = v34 + c->multiplicands[v30 + 1];
          v39 = v7[v36];
          v40 = v36 + 1;
          v39[v32] = v38 + v39[v32];
          if ( v37 == 2 )
          {
            v37 = 0;
            v40 = 0i64;
            ++v11;
            ++v32;
          }
          v41 = v37 + 1;
          v42 = v38 + c->multiplicands[v30 + 2];
          v43 = v7[v40];
          v44 = v40 + 1;
          v43[v32] = v42 + v43[v32];
          if ( v41 == 2 )
          {
            v41 = 0;
            v44 = 0i64;
            ++v11;
            ++v32;
          }
          v9 = v41 + 1;
          v15 = v42 + c->multiplicands[v30 + 3];
          v45 = v7[v44];
          v13 = v44 + 1;
          v45[v32] = v15 + v45[v32];
          if ( v9 == 2 )
          {
            v9 = 0;
            v13 = 0i64;
            ++v11;
            ++v32;
          }
          v30 += 4i64;
          --v31;
        }
        while ( v31 );
      }
      if ( v29 < v28 )
      {
        v46 = v29 + v27;
        v47 = v28 - v29;
        v48 = v11;
        do
        {
          ++v9;
          v15 = v15 + c->multiplicands[v46];
          v49 = v7[v13++];
          v49[v48] = v15 + v49[v48];
          if ( v9 == 2 )
          {
            v9 = 0;
            v13 = 0i64;
            ++v11;
            ++v48;
          }
          ++v46;
          --v47;
        }
        while ( v47 );
      }
    }
    else
    {
      v50 = 0;
      if ( v9 == 1 )
      {
        v51 = v7[v13];
        v9 = 0;
        v13 = 0i64;
        v52 = v11;
        v50 = 1;
        ++v11;
        v51[v52] = (float)(c->multiplicands[v27] + 0.0) + v51[v52];
      }
      v53 = dimensions;
      v54 = v50 + 1;
      v55 = *v7;
      v56 = v7[1];
      if ( v50 + 1 < dimensions )
      {
        v57 = (unsigned int)v50 + (__int64)v27;
        v58 = &v56[v11];
        v59 = (char *)v55 - (char *)v56;
        do
        {
          ++v11;
          v50 += 2;
          v54 += 2;
          *(float *)((char *)v58 + v59) = (float)(c->multiplicands[v57] + 0.0) + *(float *)((char *)v58 + v59);
          v60 = c->multiplicands[v57 + 1];
          v57 += 2i64;
          *v58 = (float)(v60 + 0.0) + *v58;
          ++v58;
        }
        while ( v54 < dimensions );
        v10 = f;
        v53 = dimensions;
      }
      v7 = outputs;
      if ( v50 < v53 )
      {
        v61 = outputs[v13];
        ++v9;
        ++v13;
        v61[v11] = (float)(c->multiplicands[v50 + v27] + 0.0) + v61[v11];
        if ( v9 == 2 )
        {
          v9 = 0;
          v13 = 0i64;
          ++v11;
        }
      }
    }
    total_decode -= dimensions;
    if ( total_decode <= 0 )
      goto LABEL_59;
  }
  v10->valid_bits = 0;
LABEL_23:
  if ( v10->bytes_in_seg || !v10->last_seg )
    v10->error = VORBIS_invalid_stream;
  return 0i64;
}

__int64 __fastcall codebook_decode_scalar_raw(stb_vorbis *f, Codebook *c)
{
  int valid_bits; // eax
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v7; // cl
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  signed __int64 entries; // rcx
  int v12; // eax
  unsigned int acc; // esi
  unsigned int v14; // er8
  int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // ecx
  int sorted_entries; // edx
  unsigned int v19; // er10
  int v20; // eax
  int v21; // ecx
  __int64 result; // rax
  unsigned int v23; // er10
  __int64 v24; // r9
  unsigned __int8 *codeword_lengths; // r8
  int v26; // eax
  int v27; // ecx

  valid_bits = f->valid_bits;
  if ( valid_bits <= 24 )
  {
    if ( !valid_bits )
      f->acc = 0;
    while ( 1 )
    {
      last_seg = f->last_seg;
      if ( last_seg && !f->bytes_in_seg || !f->bytes_in_seg && (last_seg || !next_segment(f)) )
        break;
      --f->bytes_in_seg;
      ++f->packet_bytes;
      stream = f->stream;
      if ( stream )
      {
        if ( stream < f->stream_end )
        {
          v7 = *stream;
          f->stream = stream + 1;
          goto LABEL_14;
        }
      }
      else
      {
        v8 = fgetc(f->f);
        v7 = v8;
        if ( v8 != -1 )
          goto LABEL_14;
      }
      v7 = 0;
      f->eof = 1;
LABEL_14:
      v9 = v7;
      if ( v7 != -1 )
      {
        v10 = f->valid_bits;
        f->acc += v9 << v10;
        f->valid_bits = v10 + 8;
        if ( v10 + 8 <= 24 )
          continue;
      }
      break;
    }
  }
  entries = c->entries;
  v12 = 0;
  if ( (int)entries <= 8 )
    LOBYTE(v12) = c->codewords == 0i64;
  else
    LOBYTE(v12) = c->sorted_codewords != 0i64;
  if ( !v12 )
  {
    v23 = 0;
    if ( (int)entries <= 0 )
    {
LABEL_35:
      f->error = VORBIS_invalid_stream;
    }
    else
    {
      v24 = 0i64;
      codeword_lengths = c->codeword_lengths;
      while ( *codeword_lengths == 0xFF || c->codewords[v24] != (f->acc & ((1 << *codeword_lengths) - 1)) )
      {
        ++codeword_lengths;
        ++v23;
        ++v24;
        if ( codeword_lengths - c->codeword_lengths >= entries )
          goto LABEL_35;
      }
      v26 = f->valid_bits;
      v27 = c->codeword_lengths[v23];
      if ( v26 >= v27 )
      {
        f->acc >>= v27;
        f->valid_bits = v26 - c->codeword_lengths[v23];
        return v23;
      }
    }
    result = 0xFFFFFFFFi64;
    f->valid_bits = 0;
    return result;
  }
  acc = f->acc;
  v14 = 0;
  v15 = 4 * ((2 * acc) ^ ((2 * acc) ^ (acc >> 1)) & 0x55555555);
  v16 = v15 ^ (v15 ^ (((2 * acc) ^ ((2 * acc) ^ (acc >> 1)) & 0x55555555) >> 2)) & 0x33333333;
  sorted_entries = c->sorted_entries;
  v17 = (16 * v16) ^ ((16 * v16) ^ (v16 >> 4)) & 0xF0F0F0F;
  v19 = __ROL4__((v17 << 8) ^ ((v17 << 8) ^ (v17 >> 8)) & 0xFF00FF, 16);
  while ( sorted_entries > 1 )
  {
    if ( c->sorted_codewords[(sorted_entries >> 1) + v14] > v19 )
    {
      sorted_entries >>= 1;
    }
    else
    {
      v14 += sorted_entries >> 1;
      sorted_entries -= sorted_entries >> 1;
    }
  }
  if ( !c->sparse )
    v14 = c->sorted_values[v14];
  v20 = f->valid_bits;
  v21 = c->codeword_lengths[v14];
  if ( v20 < v21 )
  {
    f->valid_bits = 0;
    return 0xFFFFFFFFi64;
  }
  else
  {
    f->acc = acc >> v21;
    f->valid_bits = v20 - v21;
    return v14;
  }
}

__int64 __fastcall codebook_decode_start(stb_vorbis *f, Codebook *c, int len)
{
  __int64 v3; // r8
  bool v6; // zf
  int valid_bits; // eax
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v11; // cl
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  unsigned int acc; // edx
  int v16; // ecx
  bool v17; // sf

  LODWORD(v3) = -1;
  if ( c->lookup_type )
  {
    valid_bits = f->valid_bits;
    if ( valid_bits <= 9 )
    {
      if ( !valid_bits )
        f->acc = 0;
      while ( 1 )
      {
        last_seg = f->last_seg;
        if ( last_seg && !f->bytes_in_seg || !f->bytes_in_seg && (last_seg || !next_segment(f)) )
          break;
        --f->bytes_in_seg;
        ++f->packet_bytes;
        stream = f->stream;
        if ( stream )
        {
          if ( stream < f->stream_end )
          {
            v11 = *stream;
            f->stream = stream + 1;
            goto LABEL_17;
          }
        }
        else
        {
          v12 = fgetc(f->f);
          v11 = v12;
          if ( v12 != -1 )
            goto LABEL_17;
        }
        v11 = 0;
        f->eof = 1;
LABEL_17:
        v13 = v11;
        if ( v11 != -1 )
        {
          v14 = f->valid_bits;
          f->acc += v13 << v14;
          f->valid_bits = v14 + 8;
          if ( v14 + 8 <= 24 )
            continue;
        }
        break;
      }
    }
    acc = f->acc;
    v3 = c->fast_huffman[acc & 0x3FF];
    if ( (int)v3 < 0 )
    {
      LODWORD(v3) = codebook_decode_scalar_raw(f, c);
    }
    else
    {
      v16 = c->codeword_lengths[v3];
      v17 = f->valid_bits - v16 < 0;
      f->valid_bits -= v16;
      f->acc = acc >> v16;
      if ( v17 )
      {
        f->valid_bits = 0;
        LODWORD(v3) = -1;
        goto LABEL_24;
      }
    }
    if ( (int)v3 >= 0 )
      return (unsigned int)v3;
LABEL_24:
    if ( f->bytes_in_seg || !f->last_seg )
      f->error = VORBIS_invalid_stream;
    return (unsigned int)v3;
  }
  v6 = f->eof == 0;
  f->error = VORBIS_invalid_stream;
  if ( v6 )
  {
    f->error = VORBIS_invalid_stream;
    return 0xFFFFFFFFi64;
  }
  return (unsigned int)v3;
}

__int64 __fastcall codebook_decode_step(stb_vorbis *f, Codebook *c, float *output, int len, int step)
{
  int v8; // ebp
  __int128 v9; // xmm1
  int v11; // edx
  __int64 v12; // r10
  int v13; // ebp
  __int64 v14; // r15
  int v15; // er8
  __int64 v16; // r9
  unsigned __int64 v17; // rsi
  __int128 v18; // xmm2
  __int128 v19; // xmm2
  __int128 v20; // xmm2
  __int128 v21; // xmm2
  int v22; // edx
  __int64 v23; // rcx
  __int64 v24; // r10
  __int128 v25; // xmm2

  v8 = codebook_decode_start(f, c, (int)output);
  v9 = 0i64;
  if ( v8 < 0 )
    return 0i64;
  if ( len > c->dimensions )
    len = c->dimensions;
  v11 = 0;
  v12 = len;
  v13 = c->dimensions * v8;
  v14 = 0i64;
  if ( len >= 4i64 )
  {
    v15 = 2 * step;
    v16 = v13;
    v17 = ((unsigned __int64)(len - 4i64) >> 2) + 1;
    v11 = 4 * v17;
    v14 = 4 * v17;
    do
    {
      v18 = v9;
      *(float *)&v18 = *(float *)&v9 + c->multiplicands[v16];
      output[v15 - 2 * step] = *(float *)&v18 + output[v15 - 2 * step];
      if ( c->sequence_p )
        v9 = v18;
      v19 = v9;
      *(float *)&v19 = *(float *)&v9 + c->multiplicands[v16 + 1];
      output[v15 - step] = *(float *)&v19 + output[v15 - step];
      if ( c->sequence_p )
        v9 = v19;
      v20 = v9;
      *(float *)&v20 = *(float *)&v9 + c->multiplicands[v16 + 2];
      output[v15] = *(float *)&v20 + output[v15];
      if ( c->sequence_p )
        v9 = v20;
      v21 = v9;
      *(float *)&v21 = *(float *)&v9 + c->multiplicands[v16 + 3];
      output[v15 + step] = *(float *)&v21 + output[v15 + step];
      if ( c->sequence_p )
        v9 = v21;
      v15 += 4 * step;
      v16 += 4i64;
      --v17;
    }
    while ( v17 );
  }
  if ( v14 < v12 )
  {
    v22 = step * v11;
    v23 = v14 + v13;
    v24 = v12 - v14;
    do
    {
      v25 = v9;
      *(float *)&v25 = *(float *)&v9 + c->multiplicands[v23];
      output[v22] = *(float *)&v25 + output[v22];
      if ( c->sequence_p )
        v9 = v25;
      v22 += step;
      ++v23;
      --v24;
    }
    while ( v24 );
  }
  return 1i64;
}

void __fastcall compute_accelerated_huffman(Codebook *c)
{
  __int16 *fast_huffman; // rdi
  __int64 i; // rcx
  int sorted_entries; // er11
  int v5; // er10
  unsigned __int8 *codeword_lengths; // rdi
  __int64 v7; // r9
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // eax

  fast_huffman = c->fast_huffman;
  for ( i = 1024i64; i; --i )
    *fast_huffman++ = -1;
  if ( c->sparse )
    sorted_entries = c->sorted_entries;
  else
    sorted_entries = c->entries;
  if ( sorted_entries > 0x7FFF )
    sorted_entries = 0x7FFF;
  v5 = 0;
  if ( sorted_entries > 0 )
  {
    codeword_lengths = c->codeword_lengths;
    v7 = 0i64;
    do
    {
      if ( codeword_lengths[v7] <= 0xAu )
      {
        if ( c->sparse )
        {
          v8 = 2 * c->sorted_codewords[v7];
          v9 = (v8 ^ (v8 ^ (c->sorted_codewords[v7] >> 1)) & 0x55555555) >> 2;
          v10 = 4 * (v8 ^ (v8 ^ (c->sorted_codewords[v7] >> 1)) & 0x55555555);
          v11 = (16 * (v10 ^ (v10 ^ v9) & 0x33333333)) ^ ((16 * (v10 ^ (v10 ^ v9) & 0x33333333)) ^ ((v10 ^ (v10 ^ v9) & 0x33333333) >> 4)) & 0xF0F0F0F;
          v12 = __ROL4__((v11 << 8) ^ ((v11 << 8) ^ (v11 >> 8)) & 0xFF00FF, 16);
        }
        else
        {
          v12 = c->codewords[v7];
        }
        for ( ; v12 < 0x400; v12 += 1 << codeword_lengths[v7] )
        {
          c->fast_huffman[v12] = v5;
          codeword_lengths = c->codeword_lengths;
        }
      }
      ++v5;
      ++v7;
    }
    while ( v5 < sorted_entries );
  }
}

void __fastcall compute_bitreverse(int n, unsigned __int16 *rev)
{
  char v3; // al
  __int64 v4; // r8
  unsigned int v5; // er9
  __int64 v6; // r11
  char v7; // r10
  int v8; // eax
  int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // eax

  if ( (__int64)n >> 3 > 0 )
  {
    v3 = ilog(n);
    v6 = v5;
    v7 = 36 - v3;
    do
    {
      v8 = 2 * v5;
      v9 = ((2 * v5) ^ (v5 >> 1)) & 0x55555555;
      ++v5;
      v10 = (4 * (v8 ^ v9)) ^ ((4 * (v8 ^ v9)) ^ ((v8 ^ (unsigned int)v9) >> 2)) & 0x33333333;
      v11 = (16 * v10) ^ ((16 * v10) ^ (v10 >> 4)) & 0xF0F0F0F;
      rev[v6++] = 4 * (__ROL4__((v11 << 8) ^ ((v11 << 8) ^ (v11 >> 8)) & 0xFF00FF, 16) >> v7);
    }
    while ( v6 < v4 );
  }
}

__int64 __fastcall compute_codewords(Codebook *c, unsigned __int8 *len, int n, unsigned int *values)
{
  __int64 v4; // r15
  signed int v8; // er9
  __int64 v9; // rax
  unsigned int *codewords; // rax
  unsigned __int8 v12; // dl
  __int64 v13; // r8
  __int64 v14; // rdx
  int v15; // ecx
  int v16; // eax
  int v17; // er11
  __int64 v18; // rsi
  unsigned __int8 *v19; // rbx
  __int64 v20; // r14
  unsigned int v21; // ebp
  int v22; // er8
  __int64 v23; // rax
  unsigned int v24; // er10
  unsigned int v25; // ecx
  unsigned int v26; // eax
  unsigned int v27; // ecx
  unsigned int *v28; // rax
  unsigned int v29; // edx
  __int64 v30; // rax
  __int64 v31; // rdx
  int v32; // ecx
  int v33; // eax
  int v34[32]; // [rsp+20h] [rbp-C8h] BYREF

  v4 = n;
  memset(v34, 0, sizeof(v34));
  v8 = 0;
  v9 = 0i64;
  if ( (int)v4 > 0 )
  {
    do
    {
      if ( len[v9] != 0xFF )
        break;
      ++v8;
      ++v9;
    }
    while ( v9 < v4 );
  }
  if ( v8 == (_DWORD)v4 )
    return 1i64;
  codewords = c->codewords;
  v12 = len[v8];
  if ( c->sparse )
  {
    *codewords = 0;
    *c->codeword_lengths = v12;
    *values = v8;
  }
  else
  {
    codewords[v8] = 0;
  }
  v13 = len[v8];
  v14 = 1i64;
  if ( len[v8] )
  {
    v15 = 31;
    do
    {
      v16 = 1 << v15--;
      v34[v14++] = v16;
    }
    while ( v14 <= v13 );
  }
  v17 = v8 + 1;
  if ( v8 + 1 < (int)v4 )
  {
    v18 = 1i64;
    v19 = &len[v17];
    v20 = v17;
    do
    {
      v21 = *v19;
      v22 = v21;
      if ( v21 != 255 )
      {
        if ( v21 >= 0x20 )
          return 0i64;
        v23 = *v19;
        if ( *v19 )
        {
          do
          {
            if ( v34[v23] )
              break;
            --v22;
            --v23;
          }
          while ( v23 > 0 );
        }
        if ( v22 <= 0 )
          return 0i64;
        v24 = v34[v22];
        v34[v22] = 0;
        v25 = (2 * v24) ^ ((2 * v24) ^ (v24 >> 1)) & 0x55555555;
        v26 = (4 * v25) ^ ((4 * v25) ^ (v25 >> 2)) & 0x33333333;
        v27 = (16 * v26) ^ ((16 * v26) ^ (v26 >> 4)) & 0xF0F0F0F;
        v28 = c->codewords;
        v29 = __ROL4__((v27 << 8) ^ ((v27 << 8) ^ (v27 >> 8)) & 0xFF00FF, 16);
        if ( c->sparse )
        {
          v28[v18] = v29;
          c->codeword_lengths[v18] = v21;
          values[v18] = v17;
        }
        else
        {
          v28[v20] = v29;
        }
        v30 = *v19;
        ++v18;
        if ( v22 != (_DWORD)v30 )
        {
          v31 = *v19;
          if ( v30 > v22 )
          {
            v32 = 32 - v30;
            do
            {
              v33 = 1 << v32++;
              v34[v31--] = v24 + v33;
            }
            while ( v31 > v22 );
          }
        }
      }
      ++v17;
      ++v20;
      ++v19;
    }
    while ( v17 < (int)v4 );
  }
  return 1i64;
}

void __fastcall compute_samples(int mask, __int16 *output, int num_c, float **data, int d_offset, int len)
{
  float **v6; // rbx
  int v7; // edi
  __int64 v8; // r14
  __int16 *v9; // rbp
  __int64 v10; // rsi
  __int64 v11; // r12
  __int64 v12; // r13
  char *v13; // r15
  float v14; // er11
  int v15; // ecx
  __int64 v16; // r9
  __int64 v17; // r10
  __int64 v18; // rcx
  float *v19; // rax
  char *v20; // r11
  char *v21; // rbx
  float *v22; // rdx
  char *v23; // rdi
  float *v24; // r8
  char *v25; // rsi
  unsigned __int64 v26; // rax
  float v27; // xmm1_4
  float v28; // xmm1_4
  float v29; // xmm0_4
  float v30; // xmm1_4
  char *v31; // rdx
  __int64 v32; // rcx
  __int16 *v33; // rdx
  int v34; // er8
  __int16 v35; // ax
  float v36; // xmm0_4
  int v37; // er8
  __int16 v38; // ax
  float v39; // xmm0_4
  int v40; // er8
  __int16 v41; // ax
  float v42; // xmm0_4
  int v43; // er8
  __int16 v44; // ax
  __int16 *v45; // r8
  int v46; // edx
  __int16 v47; // ax
  __int64 v48; // [rsp+0h] [rbp-118h] BYREF
  float v49; // [rsp+20h] [rbp-F8h]
  int v50; // [rsp+24h] [rbp-F4h]
  int v51; // [rsp+28h] [rbp-F0h]
  int v52; // [rsp+2Ch] [rbp-ECh]
  float **v53; // [rsp+30h] [rbp-E8h]
  __int64 v54; // [rsp+38h] [rbp-E0h]
  __int16 *v55; // [rsp+40h] [rbp-D8h]
  __int16 *v56; // [rsp+48h] [rbp-D0h]
  int v57[32]; // [rsp+50h] [rbp-C8h] BYREF

  v6 = data;
  v53 = data;
  v7 = mask;
  v56 = output;
  v52 = mask;
  v51 = 32;
  v49 = 0.0;
  v8 = num_c;
  if ( len > 0 )
  {
    v9 = output;
    v10 = 8i64;
    v11 = -(__int64)v57;
    v12 = 0i64;
    v13 = (char *)&v48 + 76;
    v55 = output;
    v54 = 8i64;
    v50 = len;
    do
    {
      memset(v57, 0, sizeof(v57));
      v14 = v49;
      v15 = v50;
      if ( LODWORD(v49) + v51 <= len )
        v15 = v51;
      v16 = 0i64;
      v51 = v15;
      v17 = v15;
      if ( v8 > 0 )
      {
        do
        {
          if ( (channel_position[v8][v16] & v7) != 0 )
          {
            v18 = 0i64;
            if ( v17 >= 4 )
            {
              v19 = v6[v16];
              v20 = (char *)(v13 - (char *)v19);
              v21 = (char *)(v13 - (char *)v19);
              v22 = (float *)((char *)v19 + v10);
              v23 = (char *)(v13 - (char *)v19);
              v24 = &v19[v12 + 1];
              v25 = (char *)(v13 - (char *)v19);
              v26 = ((unsigned __int64)(v17 - 4) >> 2) + 1;
              v18 = 4 * v26;
              do
              {
                v27 = *v24;
                v24 += 4;
                v28 = v27 + *(float *)&v21[(_QWORD)v22];
                *(float *)&v20[(_QWORD)v22 - 4] = *(v22 - 2) + *(float *)&v20[(_QWORD)v22 - 4];
                v29 = *v22 + *(float *)&v23[(_QWORD)v22 + 4];
                *(float *)&v21[(_QWORD)v22] = v28;
                v30 = v22[1] + *(float *)&v25[(_QWORD)v22 + 8];
                *(float *)&v23[(_QWORD)v22 + 4] = v29;
                *(float *)&v25[(_QWORD)v22 + 8] = v30;
                v22 += 4;
                --v26;
              }
              while ( v26 );
              v6 = v53;
              v7 = v52;
              v10 = v54;
            }
            if ( v18 < v17 )
            {
              v31 = (char *)v6[v16] + v11;
              do
              {
                *(float *)&v57[v18] = *(float *)((char *)v57 + (_QWORD)&v31[4 * v18]) + *(float *)&v57[v18];
                ++v18;
              }
              while ( v18 < v17 );
            }
          }
          ++v16;
        }
        while ( v16 < v8 );
        v9 = v55;
        v14 = v49;
      }
      v32 = 0i64;
      if ( v17 >= 4 )
      {
        v33 = v9;
        do
        {
          v49 = *(float *)&v57[v32] + 384.0;
          v34 = LODWORD(v49) - 1136656384;
          if ( (unsigned int)(LODWORD(v49) - 1136656384 + 0x8000) > 0xFFFF )
          {
            v35 = 0x7FFF;
            if ( v34 < 0 )
              v35 = 0x8000;
            LOWORD(v34) = v35;
          }
          v36 = *(float *)&v57[v32 + 1];
          *v33 = v34;
          v49 = v36 + 384.0;
          v37 = COERCE_INT(v36 + 384.0) - 1136656384;
          if ( (unsigned int)(v37 + 0x8000) > 0xFFFF )
          {
            v38 = 0x7FFF;
            if ( v37 < 0 )
              v38 = 0x8000;
            LOWORD(v37) = v38;
          }
          v39 = *(float *)&v57[v32 + 2];
          v33[1] = v37;
          v49 = v39 + 384.0;
          v40 = COERCE_INT(v39 + 384.0) - 1136656384;
          if ( (unsigned int)(v40 + 0x8000) > 0xFFFF )
          {
            v41 = 0x7FFF;
            if ( v40 < 0 )
              v41 = 0x8000;
            LOWORD(v40) = v41;
          }
          v42 = *(float *)&v57[v32 + 3];
          v33[2] = v40;
          v49 = v42 + 384.0;
          v43 = COERCE_INT(v42 + 384.0) - 1136656384;
          if ( (unsigned int)(v43 + 0x8000) > 0xFFFF )
          {
            v44 = 0x7FFF;
            if ( v43 < 0 )
              v44 = 0x8000;
            LOWORD(v43) = v44;
          }
          v33[3] = v43;
          v32 += 4i64;
          v33 += 4;
        }
        while ( v32 < v17 - 3 );
        v7 = v52;
      }
      if ( v32 < v17 )
      {
        v45 = &v56[v32 + v12];
        do
        {
          v49 = *(float *)&v57[v32] + 384.0;
          v46 = LODWORD(v49) - 1136656384;
          if ( (unsigned int)(LODWORD(v49) - 1136656384 + 0x8000) > 0xFFFF )
          {
            v47 = 0x7FFF;
            if ( v46 < 0 )
              v47 = 0x8000;
            LOWORD(v46) = v47;
          }
          *v45 = v46;
          ++v32;
          ++v45;
        }
        while ( v32 < v17 );
        v6 = v53;
      }
      v50 -= 32;
      v10 += 128i64;
      v9 += 32;
      LODWORD(v49) = LODWORD(v14) + 32;
      v12 += 32i64;
      v54 = v10;
      v13 -= 128;
      v55 = v9;
      v11 += 128i64;
    }
    while ( v12 < len );
  }
}

void __fastcall compute_sorted_huffman(Codebook *c, unsigned __int8 *lengths, unsigned int *values)
{
  int v3; // er9
  unsigned __int8 *v5; // r15
  __int64 v7; // r11
  unsigned __int8 *v8; // r8
  __int64 v9; // r10
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // edx
  __int64 v14; // r8
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // eax
  unsigned int v18; // edx
  int sorted_entries; // eax
  int v20; // er14
  __int64 v21; // r12
  __int64 v22; // rdi
  __int64 v23; // r13
  unsigned __int8 sparse; // bp
  __int64 v25; // rax
  unsigned __int8 v26; // r15
  int v27; // er9
  unsigned int v28; // eax
  unsigned int v29; // edx
  unsigned int v30; // eax
  unsigned int v31; // ecx
  int v32; // edx
  unsigned int v33; // er10

  v3 = 0;
  v5 = lengths;
  if ( c->sparse )
  {
    if ( c->sorted_entries > 0 )
    {
      v14 = 0i64;
      do
      {
        ++v14;
        ++v3;
        v15 = 2 * c->codewords[v14 - 1];
        v16 = (v15 ^ (v15 ^ (c->codewords[v14 - 1] >> 1)) & 0x55555555) >> 2;
        v17 = 4 * (v15 ^ (v15 ^ (c->codewords[v14 - 1] >> 1)) & 0x55555555);
        v18 = (16 * (v17 ^ (v17 ^ v16) & 0x33333333)) ^ ((16 * (v17 ^ (v17 ^ v16) & 0x33333333)) ^ ((v17 ^ (v17 ^ v16) & 0x33333333) >> 4)) & 0xF0F0F0F;
        c->sorted_codewords[v14 - 1] = __ROL4__((v18 << 8) ^ ((v18 << 8) ^ (v18 >> 8)) & 0xFF00FF, 16);
      }
      while ( v3 < c->sorted_entries );
    }
  }
  else if ( c->entries > 0 )
  {
    v7 = 0i64;
    v8 = lengths;
    v9 = 0i64;
    do
    {
      if ( c->sparse || (unsigned __int8)(*v8 - 11) <= 0xF3u )
      {
        v10 = 2 * c->codewords[v9];
        v11 = (v10 ^ (v10 ^ (c->codewords[v9] >> 1)) & 0x55555555) >> 2;
        v12 = 4 * (v10 ^ (v10 ^ (c->codewords[v9] >> 1)) & 0x55555555);
        v13 = (16 * (v12 ^ (v12 ^ v11) & 0x33333333)) ^ ((16 * (v12 ^ (v12 ^ v11) & 0x33333333)) ^ ((v12 ^ (v12 ^ v11) & 0x33333333) >> 4)) & 0xF0F0F0F;
        c->sorted_codewords[v7++] = __ROL4__((v13 << 8) ^ ((v13 << 8) ^ (v13 >> 8)) & 0xFF00FF, 16);
      }
      ++v3;
      ++v8;
      ++v9;
    }
    while ( v3 < c->entries );
  }
  qsort(c->sorted_codewords, c->sorted_entries, 4ui64, uint32_compare);
  c->sorted_codewords[c->sorted_entries] = -1;
  if ( c->sparse )
    sorted_entries = c->sorted_entries;
  else
    sorted_entries = c->entries;
  v20 = 0;
  v21 = sorted_entries;
  if ( sorted_entries > 0 )
  {
    v22 = 0i64;
    v23 = -(__int64)values;
    do
    {
      sparse = c->sparse;
      if ( sparse )
        v25 = *values;
      else
        v25 = v22;
      v26 = v5[v25];
      if ( sparse || (unsigned __int8)(v26 - 11) <= 0xF3u )
      {
        v27 = 0;
        v28 = 2 * *(unsigned int *)((char *)c->codewords + v23 + (unsigned __int64)values);
        v29 = (v28 ^ (v28 ^ (*(unsigned int *)((char *)c->codewords + v23 + (unsigned __int64)values) >> 1)) & 0x55555555) >> 2;
        v30 = 4
            * (v28 ^ (v28 ^ (*(unsigned int *)((char *)c->codewords + v23 + (unsigned __int64)values) >> 1)) & 0x55555555);
        v31 = (16 * (v30 ^ (v30 ^ v29) & 0x33333333)) ^ ((16 * (v30 ^ (v30 ^ v29) & 0x33333333)) ^ ((v30 ^ (v30 ^ v29) & 0x33333333) >> 4)) & 0xF0F0F0F;
        v32 = c->sorted_entries;
        v33 = __ROL4__((v31 << 8) ^ ((v31 << 8) ^ (v31 >> 8)) & 0xFF00FF, 16);
        while ( v32 > 1 )
        {
          if ( c->sorted_codewords[(v32 >> 1) + v27] > v33 )
          {
            v32 >>= 1;
          }
          else
          {
            v27 += v32 >> 1;
            v32 -= v32 >> 1;
          }
        }
        if ( sparse )
        {
          c->sorted_values[v27] = *values;
          c->codeword_lengths[v27] = v26;
        }
        else
        {
          c->sorted_values[v27] = v20;
        }
      }
      v5 = lengths;
      ++v20;
      ++v22;
      ++values;
    }
    while ( v22 < v21 );
  }
}

void __fastcall compute_stereo_samples(__int16 *output, int num_c, float **data, int d_offset, int len)
{
  int v5; // esi
  int v6; // er15
  __int64 v8; // r14
  __int64 v9; // r12
  __int64 v10; // rbx
  int v11; // er13
  int v12; // er11
  int v13; // ecx
  __int64 v14; // r10
  int v15; // eax
  __int64 v16; // rdx
  float *v17; // rcx
  float v18; // xmm2_4
  int v19; // xmm1_4
  int v20; // xmm1_4
  int v21; // xmm0_4
  int v22; // xmm2_4
  float v23; // xmm1_4
  int v24; // xmm0_4
  int v25; // xmm1_4
  float *v26; // r9
  float v27; // xmm1_4
  int v28; // xmm0_4
  int v29; // xmm1_4
  __int64 v30; // rdx
  float *v31; // rax
  float *v32; // rcx
  float *v33; // r9
  int v34; // xmm1_4
  int v35; // xmm0_4
  int v36; // xmm1_4
  int v37; // xmm0_4
  float *v38; // r9
  float v39; // xmm0_4
  __int64 v40; // rdx
  float *v41; // rax
  float *v42; // rcx
  float *v43; // r9
  float v44; // xmm1_4
  int v45; // xmm1_4
  int v46; // xmm0_4
  float v47; // xmm1_4
  int v48; // xmm1_4
  float *v49; // r9
  float v50; // xmm0_4
  __int64 v51; // rdx
  __int64 v52; // r9
  __int16 *v53; // rcx
  int v54; // er8
  __int16 v55; // ax
  float v56; // xmm0_4
  int v57; // er8
  __int16 v58; // ax
  float v59; // xmm0_4
  int v60; // er8
  __int16 v61; // ax
  float v62; // xmm0_4
  int v63; // er8
  __int16 v64; // ax
  __int16 *v65; // r8
  int v66; // ecx
  __int16 v67; // ax
  int v68; // [rsp+2Ch] [rbp-7Dh]
  int v70[32]; // [rsp+38h] [rbp-71h] BYREF

  v5 = len;
  v6 = 0;
  v8 = num_c;
  LODWORD(v9) = 16;
  if ( len > 0 )
  {
    v10 = 0i64;
    v68 = len;
    do
    {
      v11 = 2 * v6;
      memset(v70, 0, sizeof(v70));
      v12 = len;
      v13 = v5;
      if ( v6 + (int)v9 <= len )
        v13 = v9;
      v14 = 0i64;
      v9 = v13;
      if ( v8 > 0 )
      {
        do
        {
          v15 = channel_position[v8][v14] & 6;
          switch ( v15 )
          {
            case 6:
              v16 = 0i64;
              if ( v9 >= 4 )
              {
                v17 = &data[v14][v10];
                do
                {
                  v18 = v17[2];
                  *(float *)&v19 = *v17 + *(float *)&v70[2 * v16 + 1];
                  *(float *)&v70[2 * v16] = *v17 + *(float *)&v70[2 * v16];
                  v70[2 * v16 + 1] = v19;
                  *(float *)&v20 = v17[1] + *(float *)&v70[2 * v16 + 3];
                  *(float *)&v70[2 * v16 + 2] = v17[1] + *(float *)&v70[2 * v16 + 2];
                  *(float *)&v21 = v18 + *(float *)&v70[2 * v16 + 4];
                  *(float *)&v22 = v18 + *(float *)&v70[2 * v16 + 5];
                  v70[2 * v16 + 3] = v20;
                  v23 = v17[3];
                  v17 += 4;
                  v70[2 * v16 + 4] = v21;
                  *(float *)&v24 = v23 + *(float *)&v70[2 * v16 + 6];
                  *(float *)&v25 = v23 + *(float *)&v70[2 * v16 + 7];
                  v70[2 * v16 + 5] = v22;
                  v70[2 * v16 + 6] = v24;
                  v70[2 * v16 + 7] = v25;
                  v16 += 4i64;
                }
                while ( v16 < v9 - 3 );
              }
              if ( v16 < v9 )
              {
                v26 = &data[v14][v10 + v16];
                do
                {
                  v27 = *v26++;
                  *(float *)&v28 = v27 + *(float *)&v70[2 * v16];
                  *(float *)&v29 = v27 + *(float *)&v70[2 * v16 + 1];
                  v70[2 * v16] = v28;
                  v70[2 * v16++ + 1] = v29;
                }
                while ( v16 < v9 );
              }
              break;
            case 2:
              v30 = 0i64;
              if ( v9 >= 4 )
              {
                v31 = data[v14];
                v32 = &v31[v10 + 2];
                v33 = &v31[v10 + 1];
                do
                {
                  *(float *)&v34 = *(float *)&v70[2 * v30 + 2] + *v33;
                  v33 += 4;
                  *(float *)&v35 = *(v32 - 2) + *(float *)&v70[2 * v30];
                  v70[2 * v30 + 2] = v34;
                  *(float *)&v36 = v32[1] + *(float *)&v70[2 * v30 + 6];
                  v70[2 * v30] = v35;
                  *(float *)&v37 = *(float *)&v70[2 * v30 + 4] + *v32;
                  v32 += 4;
                  v70[2 * v30 + 6] = v36;
                  v70[2 * v30 + 4] = v37;
                  v30 += 4i64;
                }
                while ( v30 < v9 - 3 );
              }
              if ( v30 < v9 )
              {
                v38 = &data[v14][v10 + v30];
                do
                {
                  v39 = *v38++;
                  *(float *)&v70[2 * v30] = v39 + *(float *)&v70[2 * v30];
                  ++v30;
                }
                while ( v30 < v9 );
              }
              break;
            case 4:
              v40 = 0i64;
              if ( v9 >= 4 )
              {
                v41 = data[v14];
                v42 = &v41[v10 + 2];
                v43 = &v41[v10 + 1];
                do
                {
                  v44 = *v43;
                  v43 += 4;
                  *(float *)&v45 = v44 + *(float *)&v70[2 * v40 + 3];
                  *(float *)&v70[2 * v40 + 1] = *(v42 - 2) + *(float *)&v70[2 * v40 + 1];
                  *(float *)&v46 = *(float *)&v70[2 * v40 + 5] + *v42;
                  v70[2 * v40 + 3] = v45;
                  v47 = v42[1];
                  v42 += 4;
                  *(float *)&v48 = v47 + *(float *)&v70[2 * v40 + 7];
                  v70[2 * v40 + 5] = v46;
                  v70[2 * v40 + 7] = v48;
                  v40 += 4i64;
                }
                while ( v40 < v9 - 3 );
              }
              if ( v40 < v9 )
              {
                v49 = &data[v14][v10 + v40];
                do
                {
                  v50 = *v49++;
                  *(float *)&v70[2 * v40 + 1] = v50 + *(float *)&v70[2 * v40 + 1];
                  ++v40;
                }
                while ( v40 < v9 );
              }
              break;
          }
          ++v14;
        }
        while ( v14 < v8 );
        v5 = v68;
        v12 = len;
      }
      v51 = 0i64;
      v52 = 2 * (int)v9;
      if ( v52 >= 4 )
      {
        v53 = &output[v11];
        do
        {
          v54 = COERCE_INT(*(float *)&v70[v51] + 384.0) - 1136656384;
          if ( (unsigned int)(v54 + 0x8000) > 0xFFFF )
          {
            v55 = 0x7FFF;
            if ( v54 < 0 )
              v55 = 0x8000;
            LOWORD(v54) = v55;
          }
          v56 = *(float *)&v70[v51 + 1];
          *v53 = v54;
          v57 = COERCE_INT(v56 + 384.0) - 1136656384;
          if ( (unsigned int)(v57 + 0x8000) > 0xFFFF )
          {
            v58 = 0x7FFF;
            if ( v57 < 0 )
              v58 = 0x8000;
            LOWORD(v57) = v58;
          }
          v59 = *(float *)&v70[v51 + 2];
          v53[1] = v57;
          v60 = COERCE_INT(v59 + 384.0) - 1136656384;
          if ( (unsigned int)(v60 + 0x8000) > 0xFFFF )
          {
            v61 = 0x7FFF;
            if ( v60 < 0 )
              v61 = 0x8000;
            LOWORD(v60) = v61;
          }
          v62 = *(float *)&v70[v51 + 3];
          v53[2] = v60;
          v63 = COERCE_INT(v62 + 384.0) - 1136656384;
          if ( (unsigned int)(v63 + 0x8000) > 0xFFFF )
          {
            v64 = 0x7FFF;
            if ( v63 < 0 )
              v64 = 0x8000;
            LOWORD(v63) = v64;
          }
          v53[3] = v63;
          v51 += 4i64;
          v53 += 4;
        }
        while ( v51 < 2 * (int)v9 - 3i64 );
        v5 = v68;
      }
      if ( v51 < v52 )
      {
        v65 = &output[v51 + v11];
        do
        {
          v66 = COERCE_INT(*(float *)&v70[v51] + 384.0) - 1136656384;
          if ( (unsigned int)(v66 + 0x8000) > 0xFFFF )
          {
            v67 = 0x7FFF;
            if ( v66 < 0 )
              v67 = 0x8000;
            LOWORD(v66) = v67;
          }
          *v65 = v66;
          ++v51;
          ++v65;
        }
        while ( v51 < v52 );
        v12 = len;
      }
      v5 -= 16;
      v6 += 16;
      v10 += 16i64;
      v68 = v5;
    }
    while ( v6 < v12 );
  }
}

void __fastcall compute_twiddle_factors(int n, float *A, float *B, float *C)
{
  __int64 v6; // rsi
  float *v7; // rdi
  int v8; // er12
  signed __int64 v9; // r14
  int v10; // er15
  float v11; // xmm10_4
  __int64 v12; // r13
  float v13; // xmm6_4
  float v14; // xmm6_4
  int v15; // edi
  float v16; // xmm6_4

  v6 = (unsigned int)(n >> 3);
  if ( n >> 2 > 0 )
  {
    v7 = B + 1;
    v8 = 0;
    v9 = (char *)A - (char *)B;
    v10 = 1;
    v11 = (float)n;
    v12 = (unsigned int)(n >> 2);
    do
    {
      v13 = (float)((float)v8 * 3.1415927) / v11;
      *(float *)((char *)v7 + v9 - 4) = cosf(v13);
      *(_DWORD *)((char *)v7 + v9) = COERCE_UNSIGNED_INT(sinf(v13)) ^ _xmm;
      v14 = (float)((float)((float)v10 * 3.1415927) / v11) * 0.5;
      *(v7 - 1) = cosf(v14) * 0.5;
      v7 += 2;
      v8 += 4;
      v10 += 2;
      *(v7 - 2) = sinf(v14) * 0.5;
      --v12;
    }
    while ( v12 );
  }
  if ( (int)v6 > 0 )
  {
    v15 = 2;
    do
    {
      v16 = (float)((float)v15 * 3.1415927) / (float)n;
      *C = cosf(v16);
      v15 += 4;
      *((_DWORD *)C + 1) = COERCE_UNSIGNED_INT(sinf(v16)) ^ _xmm;
      C += 2;
      --v6;
    }
    while ( v6 );
  }
}

void __fastcall compute_window(int n, float *window)
{
  int v2; // ebx
  int v3; // edi
  float *v5; // rbp
  float *v6; // rsi
  float v7; // xmm1_4
  float v8; // xmm1_4

  v2 = 0;
  v3 = n >> 1;
  if ( n >> 1 > 0 )
  {
    if ( (unsigned int)v3 >= 2 )
    {
      v5 = window;
      do
      {
        _vdecl_sin2();
        v2 += 2;
        *(double *)v5 = _vdecl_sin2();
        v5 += 2;
      }
      while ( v2 < (int)(v3 - (v3 & 0x80000001)) );
    }
    if ( v2 < v3 )
    {
      v6 = &window[v2];
      do
      {
        v7 = sin(((double)v2++ + 0.5) / (double)v3 * 0.5 * 3.141592741012573);
        v8 = sin((float)(v7 * v7) * 1.570796370506287);
        *v6++ = v8;
      }
      while ( v2 < v3 );
    }
  }
}

void __fastcall convert_channels_short_interleaved(
        int buf_c,
        __int16 *buffer,
        int data_c,
        float **data,
        int d_offset,
        int len)
{
  __int64 v6; // rsi
  int v8; // edi
  __int64 v10; // r10
  __int64 v11; // r8
  int v12; // er11
  __int64 v13; // rdx
  float **v14; // rdi
  unsigned __int64 v15; // r9
  int v16; // ecx
  __int16 v17; // ax
  int v18; // ecx
  __int16 v19; // ax
  int v20; // ecx
  __int16 v21; // ax
  int v22; // ecx
  __int16 v23; // ax
  int v24; // ecx
  __int16 v25; // ax
  __int16 *v26; // rdi
  __int64 i; // rcx

  v6 = (unsigned int)buf_c;
  v8 = data_c;
  if ( buf_c == data_c || buf_c > 2 || data_c > 6 )
  {
    if ( buf_c < data_c )
      v8 = buf_c;
    v10 = v8;
    if ( len > 0i64 )
    {
      v11 = 0i64;
      do
      {
        v12 = 0;
        v13 = 0i64;
        if ( v10 >= 4 )
        {
          v14 = data + 2;
          v15 = ((unsigned __int64)(v10 - 4) >> 2) + 1;
          v12 = 4 * v15;
          v13 = 4 * v15;
          do
          {
            v16 = COERCE_INT((*(v14 - 2))[v11] + 384.0) - 1136656384;
            if ( (unsigned int)(v16 + 0x8000) > 0xFFFF )
            {
              v17 = 0x7FFF;
              if ( v16 < 0 )
                v17 = 0x8000;
              LOWORD(v16) = v17;
            }
            *buffer = v16;
            v18 = COERCE_INT((*(v14 - 1))[v11] + 384.0) - 1136656384;
            if ( (unsigned int)(v18 + 0x8000) > 0xFFFF )
            {
              v19 = 0x7FFF;
              if ( v18 < 0 )
                v19 = 0x8000;
              LOWORD(v18) = v19;
            }
            buffer[1] = v18;
            v20 = COERCE_INT((*v14)[v11] + 384.0) - 1136656384;
            if ( (unsigned int)(v20 + 0x8000) > 0xFFFF )
            {
              v21 = 0x7FFF;
              if ( v20 < 0 )
                v21 = 0x8000;
              LOWORD(v20) = v21;
            }
            buffer[2] = v20;
            v22 = COERCE_INT(v14[1][v11] + 384.0) - 1136656384;
            if ( (unsigned int)(v22 + 0x8000) > 0xFFFF )
            {
              v23 = 0x7FFF;
              if ( v22 < 0 )
                v23 = 0x8000;
              LOWORD(v22) = v23;
            }
            buffer[3] = v22;
            v14 += 4;
            buffer += 4;
            --v15;
          }
          while ( v15 );
        }
        if ( v13 < v10 )
        {
          v12 += v10 - v13;
          do
          {
            v24 = COERCE_INT(data[v13][v11] + 384.0) - 1136656384;
            if ( (unsigned int)(v24 + 0x8000) > 0xFFFF )
            {
              v25 = 0x7FFF;
              if ( v24 < 0 )
                v25 = 0x8000;
              LOWORD(v24) = v25;
            }
            *buffer = v24;
            ++v13;
            ++buffer;
          }
          while ( v13 < v10 );
        }
        if ( v12 < (int)v6 )
        {
          v26 = buffer;
          for ( i = (unsigned int)(v6 - v12); i; --i )
            *v26++ = 0;
          buffer += (unsigned int)(v6 - v12);
        }
        ++v11;
      }
      while ( v11 < len );
    }
  }
  else if ( buf_c > 0 )
  {
    do
    {
      compute_stereo_samples(buffer, v8, data, (int)data, len);
      --v6;
    }
    while ( v6 );
  }
}

void __fastcall convert_samples_short(
        int buf_c,
        __int16 **buffer,
        int b_offset,
        int data_c,
        float **data,
        int d_offset,
        int samples)
{
  __int64 v7; // rsi
  int v8; // edi
  __int64 v10; // rbx
  int *v11; // r14
  __int64 i; // rbx
  __int64 v13; // rbp
  __int16 **v14; // rdi
  signed __int64 v15; // r14
  int v16; // [rsp+20h] [rbp-28h]

  v7 = buf_c;
  v8 = data_c;
  if ( buf_c == data_c || buf_c > 2 || data_c > 6 )
  {
    LODWORD(i) = 0;
    if ( buf_c < data_c )
      v8 = buf_c;
    v13 = v8;
    if ( v8 > 0 )
    {
      v14 = buffer;
      v15 = (char *)data - (char *)buffer;
      LODWORD(i) = v13;
      do
      {
        copy_samples(*v14, *(float **)((char *)v14 + v15), samples);
        ++v14;
        --v13;
      }
      while ( v13 );
    }
    for ( i = (int)i; i < v7; memset(buffer[i++], 0, 2i64 * samples) )
      ;
  }
  else
  {
    v10 = 0i64;
    if ( buf_c > 0 )
    {
      v11 = channel_selector[buf_c];
      do
        compute_samples(*v11++, buffer[v10++], v8, data, v16, samples);
      while ( v10 < v7 );
    }
  }
}

void __fastcall copy_samples(__int16 *dest, float *src, int len)
{
  __int64 v4; // rbx
  __int64 v5; // r8
  __int16 *v6; // r9
  unsigned __int64 v7; // r11
  float *v8; // r10
  int v9; // ecx
  __int16 v10; // ax
  int v11; // ecx
  __int16 v12; // ax
  int v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  __int16 v16; // ax
  int v17; // ecx
  __int16 v18; // ax

  v4 = len;
  v5 = 0i64;
  if ( v4 >= 4 )
  {
    v6 = dest + 2;
    v7 = ((unsigned __int64)(v4 - 4) >> 2) + 1;
    v8 = src + 2;
    v5 = 4 * v7;
    do
    {
      v9 = COERCE_INT(*(v8 - 2) + 384.0) - 1136656384;
      if ( (unsigned int)(v9 + 0x8000) > 0xFFFF )
      {
        v10 = 0x7FFF;
        if ( v9 < 0 )
          v10 = 0x8000;
        LOWORD(v9) = v10;
      }
      *(v6 - 2) = v9;
      v11 = COERCE_INT(*(v8 - 1) + 384.0) - 1136656384;
      if ( (unsigned int)(v11 + 0x8000) > 0xFFFF )
      {
        v12 = 0x7FFF;
        if ( v11 < 0 )
          v12 = 0x8000;
        LOWORD(v11) = v12;
      }
      *(v6 - 1) = v11;
      v13 = COERCE_INT(*v8 + 384.0) - 1136656384;
      if ( (unsigned int)(v13 + 0x8000) > 0xFFFF )
      {
        v14 = 0x7FFF;
        if ( v13 < 0 )
          v14 = 0x8000;
        LOWORD(v13) = v14;
      }
      *v6 = v13;
      v15 = COERCE_INT(v8[1] + 384.0) - 1136656384;
      if ( (unsigned int)(v15 + 0x8000) > 0xFFFF )
      {
        v16 = 0x7FFF;
        if ( v15 < 0 )
          v16 = 0x8000;
        LOWORD(v15) = v16;
      }
      v6[1] = v15;
      v8 += 4;
      v6 += 4;
      --v7;
    }
    while ( v7 );
  }
  for ( ; v5 < v4; ++v5 )
  {
    v17 = COERCE_INT(src[v5] + 384.0) - 1136656384;
    if ( (unsigned int)(v17 + 0x8000) > 0xFFFF )
    {
      v18 = 0x7FFF;
      if ( v17 < 0 )
        v18 = 0x8000;
      LOWORD(v17) = v18;
    }
    dest[v5] = v17;
  }
}

__int64 crc32_init()
{
  int v0; // er9
  unsigned int *v1; // r10
  int v2; // ecx
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edx
  int v8; // eax
  int v9; // edx
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // ecx
  unsigned int v13; // edx
  int v14; // eax
  int v15; // edx
  unsigned int v16; // ecx
  int v17; // er8
  unsigned int v18; // edx
  int v19; // ecx
  unsigned int v20; // er8
  __int64 result; // rax

  v0 = 0;
  v1 = crc_table;
  do
  {
    v2 = 0;
    ++v1;
    if ( (unsigned int)(v0 << 24) >= 0x80000000 )
      v2 = 79764919;
    v3 = (v0 << 25) ^ v2;
    v4 = 0;
    if ( v3 >= 0x80000000 )
      v4 = 79764919;
    v5 = 2 * v3;
    v6 = 0;
    v7 = v5 ^ v4;
    if ( v7 >= 0x80000000 )
      v6 = 79764919;
    v8 = 2 * v7;
    v9 = 0;
    v10 = v8 ^ v6;
    if ( v10 >= 0x80000000 )
      v9 = 79764919;
    v11 = 2 * v10;
    v12 = 0;
    v13 = v11 ^ v9;
    if ( v13 >= 0x80000000 )
      v12 = 79764919;
    v14 = 2 * v13;
    v15 = 0;
    v16 = v14 ^ v12;
    if ( v16 >= 0x80000000 )
      v15 = 79764919;
    v17 = 0;
    v18 = (2 * v16) ^ v15;
    if ( v18 >= 0x80000000 )
      v17 = 79764919;
    v19 = 0;
    v20 = (2 * v18) ^ v17;
    if ( v20 >= 0x80000000 )
      v19 = 79764919;
    ++v0;
    result = 2 * v20;
    *(v1 - 1) = result ^ v19;
  }
  while ( v0 < 256 );
  return result;
}

void __fastcall decode_residue(
        stb_vorbis *f,
        float **residue_buffers,
        int ch,
        int n,
        int rn,
        unsigned __int8 *do_not_decode)
{
  Residue *v7; // r15
  __int64 len; // r13
  char *alloc_buffer; // r9
  __int64 classbook; // rcx
  Codebook *codebooks; // rax
  __int64 v12; // r12
  __int64 dimensions; // rsi
  __int64 v14; // rdi
  int temp_offset; // eax
  __int64 channels; // r8
  int v17; // edx
  int *p_rtype; // r10
  unsigned __int64 v19; // rcx
  __int64 v20; // rax
  void *v21; // rsp
  __int64 v22; // rcx
  int *i; // rdx
  __int64 v24; // rdi
  unsigned __int8 *v25; // rax
  float **v26; // r15
  int v27; // er11
  int v28; // ecx
  __int64 v29; // rax
  __int64 v30; // r15
  int v31; // er10
  int v32; // esi
  __int64 v33; // r14
  __int64 v34; // r9
  int v35; // eax
  int v36; // eax
  Codebook *v37; // rdi
  int v38; // eax
  unsigned __int8 *v39; // rax
  unsigned __int8 v40; // cl
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  unsigned int v44; // er8
  __int64 v45; // rdx
  int v46; // ecx
  bool v47; // sf
  int *v48; // r11
  __int64 j; // rdi
  int total_decode; // er8
  int v51; // edx
  __int64 v52; // r9
  int v53; // edx
  __int64 v54; // r14
  __int64 v55; // r9
  int v56; // eax
  int v57; // eax
  Codebook *v58; // rdi
  int v59; // eax
  unsigned __int8 *v60; // rax
  unsigned __int8 v61; // cl
  int v62; // eax
  int v63; // eax
  int v64; // ecx
  unsigned int v65; // er8
  __int64 v66; // rdx
  int v67; // ecx
  int *v68; // r11
  __int64 k; // rdi
  int v70; // er8
  int v71; // edx
  __int64 v72; // r9
  int v73; // eax
  __int64 v74; // rdx
  int v75; // er10
  __int64 v76; // rcx
  __int64 v77; // r12
  __int64 v78; // rsi
  __int64 v79; // r14
  int valid_bits; // eax
  Codebook *v81; // rdi
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v84; // cl
  int v85; // eax
  int v86; // eax
  int v87; // ecx
  unsigned int acc; // er8
  __int64 v89; // rdx
  int v90; // ecx
  __int64 v91; // r14
  __int64 v92; // rdi
  float **v93; // rsi
  signed __int64 v94; // r15
  __int64 v95; // rdx
  int rtype; // [rsp+40h] [rbp+0h] BYREF
  int v97; // [rsp+44h] [rbp+4h]
  int c_inter_p; // [rsp+48h] [rbp+8h] BYREF
  int *v99; // [rsp+50h] [rbp+10h]
  Residue *v100; // [rsp+58h] [rbp+18h]
  __int64 v101; // [rsp+60h] [rbp+20h]
  __int64 v102; // [rsp+68h] [rbp+28h]
  __int64 v103; // [rsp+70h] [rbp+30h]
  float **outputs; // [rsp+78h] [rbp+38h]
  int v105; // [rsp+80h] [rbp+40h]
  __int64 v106; // [rsp+88h] [rbp+48h]

  outputs = residue_buffers;
  v7 = &f->residue_config[rn];
  rtype = f->residue_types[rn];
  len = n;
  alloc_buffer = f->alloc.alloc_buffer;
  classbook = v7->classbook;
  codebooks = f->codebooks;
  v12 = ch;
  v100 = v7;
  dimensions = codebooks[classbook].dimensions;
  v14 = (int)((v7->end - v7->begin) / v7->part_size);
  temp_offset = f->temp_offset;
  v97 = (v7->end - v7->begin) / v7->part_size;
  v105 = temp_offset;
  if ( alloc_buffer )
  {
    LODWORD(channels) = f->channels;
    v17 = temp_offset - ((8 * channels * (v14 + 1) + 3) & 0xFFFFFFFC);
    if ( v17 >= f->setup_offset )
    {
      p_rtype = (int *)&alloc_buffer[v17];
      f->temp_offset = v17;
    }
    else
    {
      p_rtype = 0i64;
    }
  }
  else
  {
    channels = f->channels;
    v19 = 8 * channels * (v14 + 1);
    v20 = v19 + 15;
    if ( v19 + 15 <= v19 )
      v20 = 0xFFFFFFFFFFFFFF0i64;
    v21 = alloca(v20 & 0xFFFFFFFFFFFFFFF0ui64);
    p_rtype = &rtype;
  }
  v22 = 0i64;
  v99 = p_rtype;
  for ( i = &p_rtype[2 * (int)channels]; v22 < (int)channels; ++v22 )
  {
    *(_QWORD *)&p_rtype[2 * v22] = i;
    i += 2 * (int)v14;
  }
  v24 = 0i64;
  v106 = v12;
  if ( (int)v12 > 0 )
  {
    v25 = do_not_decode;
    v26 = outputs;
    do
    {
      if ( !v25[v24] )
      {
        memset(v26[v24], 0, 4 * len);
        v25 = do_not_decode;
      }
      ++v24;
    }
    while ( v24 < v12 );
    v7 = v100;
  }
  v27 = rtype;
  v101 = dimensions;
  if ( rtype != 2 || (_DWORD)v12 == 1 )
  {
    v73 = v97;
    v74 = 0i64;
    v103 = 0i64;
    while ( 1 )
    {
      v75 = 0;
      c_inter_p = 0;
      if ( v73 > 0 )
        break;
LABEL_142:
      v103 = ++v74;
      if ( v74 >= 8 )
        goto $done;
    }
    v76 = 0i64;
    v102 = 0i64;
    while ( 1 )
    {
      v77 = v106;
      if ( !v74 )
      {
        v78 = 0i64;
        if ( v106 > 0 )
          break;
      }
LABEL_129:
      v91 = 0i64;
      if ( v101 > 0 )
      {
        do
        {
          if ( v75 >= v73 )
            break;
          v92 = 0i64;
          if ( v77 > 0 )
          {
            v93 = outputs;
            v94 = (char *)v99 - (char *)outputs;
            do
            {
              if ( !do_not_decode[v92] )
              {
                v95 = v100->residue_books[*(unsigned __int8 *)(*(_QWORD *)(*(char **)((char *)v93 + v94) + v76) + v91)][v74];
                if ( (int)v95 >= 0 )
                {
                  if ( !residue_decode(
                          f,
                          &f->codebooks[v95],
                          *v93,
                          v100->begin + v75 * v100->part_size,
                          v100->part_size,
                          v27) )
                    goto $done;
                  v75 = c_inter_p;
                }
              }
              v76 = v102;
              ++v92;
              v74 = v103;
              ++v93;
              v27 = rtype;
            }
            while ( v92 < v77 );
            v73 = v97;
          }
          v76 = v102;
          ++v75;
          v74 = v103;
          ++v91;
          v27 = rtype;
          c_inter_p = v75;
        }
        while ( v91 < v101 );
        v7 = v100;
      }
      v74 = v103;
      v76 += 8i64;
      v27 = rtype;
      v102 = v76;
      if ( v75 >= v73 )
        goto LABEL_142;
    }
    v79 = v102;
    while ( 1 )
    {
      if ( !do_not_decode[v78] )
      {
        valid_bits = f->valid_bits;
        v81 = &f->codebooks[v7->classbook];
        if ( valid_bits <= 9 )
        {
          if ( !valid_bits )
            f->acc = 0;
          while ( 1 )
          {
            last_seg = f->last_seg;
            if ( last_seg && !f->bytes_in_seg || !f->bytes_in_seg && (last_seg || !next_segment(f)) )
              break;
            --f->bytes_in_seg;
            ++f->packet_bytes;
            stream = f->stream;
            if ( stream )
            {
              if ( stream < f->stream_end )
              {
                v84 = *stream;
                f->stream = stream + 1;
                goto LABEL_117;
              }
            }
            else
            {
              v85 = fgetc(f->f);
              v84 = v85;
              if ( v85 != -1 )
                goto LABEL_117;
            }
            v84 = 0;
            f->eof = 1;
LABEL_117:
            v86 = v84;
            if ( v84 != -1 )
            {
              v87 = f->valid_bits;
              f->acc += v86 << v87;
              f->valid_bits = v87 + 8;
              if ( v87 + 8 <= 24 )
                continue;
            }
            break;
          }
        }
        acc = f->acc;
        v89 = v81->fast_huffman[acc & 0x3FF];
        if ( (int)v89 < 0 )
        {
          LODWORD(v89) = codebook_decode_scalar_raw(f, v81);
        }
        else
        {
          v90 = v81->codeword_lengths[v89];
          v47 = f->valid_bits - v90 < 0;
          f->valid_bits -= v90;
          f->acc = acc >> v90;
          if ( v47 )
          {
            f->valid_bits = 0;
            LODWORD(v89) = -1;
          }
        }
        if ( v81->sparse )
          LODWORD(v89) = v81->sorted_values[(int)v89];
        if ( (_DWORD)v89 == -1 )
          goto $done;
        *(_QWORD *)(v79 + *(_QWORD *)&v99[2 * v78]) = v7->classdata[(int)v89];
      }
      if ( ++v78 >= v77 )
      {
        v75 = c_inter_p;
        v76 = v79;
        v74 = v103;
        v27 = rtype;
        v73 = v97;
        goto LABEL_129;
      }
    }
  }
  v28 = 0;
  v29 = 0i64;
  if ( (int)v12 > 0 )
  {
    do
    {
      if ( !do_not_decode[v29] )
        break;
      ++v28;
      ++v29;
    }
    while ( v29 < v12 );
  }
  if ( v28 != (_DWORD)v12 )
  {
    v30 = 0i64;
    while ( 1 )
    {
      v31 = v97;
      v32 = 0;
      if ( (_DWORD)v12 != 2 )
        break;
      if ( v97 > 0 )
      {
        v33 = 0i64;
        do
        {
          v34 = (__int64)v100;
          v35 = (LOBYTE(v100->begin) + (_BYTE)v32 * LOBYTE(v100->part_size)) & 1;
          rtype = (signed int)(v100->begin + v32 * v100->part_size) >> 1;
          c_inter_p = v35;
          if ( v30 )
          {
            v48 = v99;
          }
          else
          {
            v36 = f->valid_bits;
            v37 = &f->codebooks[v100->classbook];
            if ( v36 <= 9 )
            {
              if ( !v36 )
                f->acc = 0;
              while ( 1 )
              {
                v38 = f->last_seg;
                if ( v38 && !f->bytes_in_seg || !f->bytes_in_seg && (v38 || !next_segment(f)) )
                  break;
                --f->bytes_in_seg;
                ++f->packet_bytes;
                v39 = f->stream;
                if ( v39 )
                {
                  if ( v39 < f->stream_end )
                  {
                    v40 = *v39;
                    f->stream = v39 + 1;
                    goto LABEL_40;
                  }
                }
                else
                {
                  v41 = fgetc(f->f);
                  v40 = v41;
                  if ( v41 != -1 )
                    goto LABEL_40;
                }
                v40 = 0;
                f->eof = 1;
LABEL_40:
                v42 = v40;
                if ( v40 != -1 )
                {
                  v43 = f->valid_bits;
                  f->acc += v42 << v43;
                  f->valid_bits = v43 + 8;
                  if ( v43 + 8 <= 24 )
                    continue;
                }
                break;
              }
            }
            v44 = f->acc;
            v45 = v37->fast_huffman[v44 & 0x3FF];
            if ( (int)v45 < 0 )
            {
              LODWORD(v45) = codebook_decode_scalar_raw(f, v37);
            }
            else
            {
              v46 = v37->codeword_lengths[v45];
              v47 = f->valid_bits - v46 < 0;
              f->valid_bits -= v46;
              f->acc = v44 >> v46;
              if ( v47 )
              {
                f->valid_bits = 0;
                LODWORD(v45) = -1;
              }
            }
            if ( v37->sparse )
              LODWORD(v45) = v37->sorted_values[(int)v45];
            if ( (_DWORD)v45 == -1 )
              goto $done;
            v34 = (__int64)v100;
            v48 = v99;
            v31 = v97;
            *(_QWORD *)(v33 + *(_QWORD *)v99) = v100->classdata[(int)v45];
          }
          for ( j = 0i64; j < v101; ++v32 )
          {
            if ( v32 >= v31 )
              break;
            total_decode = *(_DWORD *)(v34 + 8);
            v51 = *(_DWORD *)v34 + v32 * total_decode;
            v52 = *(__int16 *)(*(_QWORD *)(v34 + 24)
                             + 2 * (v30 + 8i64 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v48 + v33) + j)));
            if ( (int)v52 < 0 )
            {
              v53 = total_decode + v51;
              rtype = v53 >> 1;
              c_inter_p = v53 & 1;
            }
            else
            {
              if ( !(unsigned int)codebook_decode_deinterleave_repeat_2(
                                    f,
                                    &f->codebooks[v52],
                                    outputs,
                                    &c_inter_p,
                                    &rtype,
                                    len,
                                    total_decode) )
                goto $done;
              v31 = v97;
              v48 = v99;
            }
            v34 = (__int64)v100;
            ++j;
          }
          v33 += 8i64;
        }
        while ( v32 < v31 );
      }
LABEL_95:
      if ( ++v30 >= 8 )
        goto $done;
    }
    if ( v97 <= 0 )
      goto LABEL_95;
    v54 = 0i64;
    while ( 1 )
    {
      v55 = (__int64)v100;
      v56 = (signed int)(v100->begin + v32 * v100->part_size) / (int)v12;
      c_inter_p = (signed int)(v100->begin + v32 * v100->part_size) % (int)v12;
      rtype = v56;
      if ( v30 )
      {
        v68 = v99;
      }
      else
      {
        v57 = f->valid_bits;
        v58 = &f->codebooks[v100->classbook];
        if ( v57 <= 9 )
        {
          if ( !v57 )
            f->acc = 0;
          while ( 1 )
          {
            v59 = f->last_seg;
            if ( v59 && !f->bytes_in_seg || !f->bytes_in_seg && (v59 || !next_segment(f)) )
              break;
            --f->bytes_in_seg;
            ++f->packet_bytes;
            v60 = f->stream;
            if ( v60 )
            {
              if ( v60 < f->stream_end )
              {
                v61 = *v60;
                f->stream = v60 + 1;
                goto LABEL_76;
              }
            }
            else
            {
              v62 = fgetc(f->f);
              v61 = v62;
              if ( v62 != -1 )
                goto LABEL_76;
            }
            v61 = 0;
            f->eof = 1;
LABEL_76:
            v63 = v61;
            if ( v61 != -1 )
            {
              v64 = f->valid_bits;
              f->acc += v63 << v64;
              f->valid_bits = v64 + 8;
              if ( v64 + 8 <= 24 )
                continue;
            }
            break;
          }
        }
        v65 = f->acc;
        v66 = v58->fast_huffman[v65 & 0x3FF];
        if ( (int)v66 < 0 )
        {
          LODWORD(v66) = codebook_decode_scalar_raw(f, v58);
        }
        else
        {
          v67 = v58->codeword_lengths[v66];
          v47 = f->valid_bits - v67 < 0;
          f->valid_bits -= v67;
          f->acc = v65 >> v67;
          if ( v47 )
          {
            f->valid_bits = 0;
            LODWORD(v66) = -1;
          }
        }
        if ( v58->sparse )
          LODWORD(v66) = v58->sorted_values[(int)v66];
        if ( (_DWORD)v66 == -1 )
          break;
        v55 = (__int64)v100;
        v68 = v99;
        v31 = v97;
        *(_QWORD *)(v54 + *(_QWORD *)v99) = v100->classdata[(int)v66];
      }
      for ( k = 0i64; k < v101; ++v32 )
      {
        if ( v32 >= v31 )
          break;
        v70 = *(_DWORD *)(v55 + 8);
        v71 = *(_DWORD *)v55 + v32 * v70;
        v72 = *(__int16 *)(*(_QWORD *)(v55 + 24)
                         + 2 * (v30 + 8i64 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v68 + v54) + k)));
        if ( (int)v72 < 0 )
        {
          c_inter_p = (v70 + v71) % (int)v12;
          rtype = (v70 + v71) / (int)v12;
        }
        else
        {
          if ( !(unsigned int)codebook_decode_deinterleave_repeat(
                                f,
                                &f->codebooks[v72],
                                outputs,
                                v12,
                                &c_inter_p,
                                &rtype,
                                len,
                                v70) )
            goto $done;
          v31 = v97;
          v68 = v99;
        }
        v55 = (__int64)v100;
        ++k;
      }
      v54 += 8i64;
      if ( v32 >= v31 )
        goto LABEL_95;
    }
  }
$done:
  f->temp_offset = v105;
}

__int64 __fastcall do_floor(stb_vorbis *f, Mapping *map, int i, int n, float *target, __int16 *finalY)
{
  int v6; // ebp
  __int64 v7; // rax
  __int16 *v9; // r9
  int v10; // edx
  int v11; // esi
  Floor *v12; // r8
  float *v13; // r13
  int v14; // er10
  unsigned __int8 *v15; // r12
  __int64 v16; // rcx
  __int16 v17; // ax
  int v18; // er14
  int v19; // er9
  int v20; // edx
  int v21; // er8
  unsigned int v22; // edi
  __int64 v23; // r11
  int v24; // ebx
  __int64 v25; // rdx
  unsigned int v26; // edi
  __int64 v27; // rcx
  int v28; // eax
  __int64 v29; // r15
  float *v30; // rax
  unsigned __int64 v31; // rbp
  int v32; // er8
  int v33; // er15
  __int64 v34; // r12
  __int64 v35; // rdx
  int v36; // er10
  int v37; // er8
  int v38; // er12
  __int64 v39; // r10
  int v40; // er8
  int v41; // er15
  __int64 v42; // rdx
  __int64 v43; // rdx
  int v44; // er10
  __int64 v45; // rsi
  int v46; // eax
  __int64 v47; // rdx
  __int64 v48; // rcx
  __m128 v49; // xmm1
  __m128 v50; // xmm1
  int v51; // edx
  __int64 v52; // rdx
  __m128 v53; // xmm2
  float *v54; // rax
  __m128 v55; // xmm2
  unsigned __int64 v56; // rcx
  __m128 v57; // xmm0
  float v58; // xmm1_4
  __int64 v59; // [rsp+0h] [rbp-58h]
  Floor *v60; // [rsp+8h] [rbp-50h]
  int v61; // [rsp+60h] [rbp+8h]
  int v62; // [rsp+68h] [rbp+10h]
  int v63; // [rsp+70h] [rbp+18h]
  unsigned __int8 *step2_flaga; // [rsp+90h] [rbp+38h]

  v6 = n >> 1;
  v62 = n >> 1;
  v7 = map->submap_floor[map->chan[i].mux];
  if ( f->floor_types[v7] )
  {
    v9 = finalY;
    v10 = 1;
    v11 = 0;
    v12 = &f->floor_config[v7];
    v13 = target;
    v14 = *finalY * v12->floor1.floor1_multiplier;
    v60 = v12;
    v63 = 1;
    if ( v12->floor1.values > 1 )
    {
      v15 = &v12->floor1.sorted_order[1];
      step2_flaga = &v12->floor1.sorted_order[1];
      do
      {
        v16 = *v15;
        v17 = v9[v16];
        if ( v17 >= 0 )
        {
          v18 = v12->floor1.Xlist[v16];
          v19 = v18 - v11;
          v20 = v12->floor1.floor1_multiplier * v17;
          v21 = 0;
          v61 = v20;
          v22 = abs32(v20 - v14);
          v23 = (v20 - v14) / (v18 - v11);
          v24 = v23 - 1;
          if ( v20 - v14 >= 0 )
            v24 = v23 + 1;
          v25 = v14;
          v26 = v22 - v19 * abs32(v23);
          v13[v11] = inverse_db_table[v14] * v13[v11];
          v27 = v11 + 1;
          v28 = v6;
          if ( v18 <= v6 )
            v28 = v18;
          v29 = v28;
          v59 = v28;
          if ( v27 < v28 )
          {
            if ( v28 - v27 >= 4 )
            {
              v30 = &v13[v27 + 2];
              v31 = ((unsigned __int64)(v29 - v27 - 4) >> 2) + 1;
              v27 += 4 * v31;
              do
              {
                v32 = v26 + v21;
                if ( v32 < v19 )
                {
                  v33 = v23;
                  v34 = v23;
                }
                else
                {
                  v32 -= v19;
                  v33 = v24;
                  v34 = v24;
                }
                v35 = v34 + v25;
                v36 = v33 + v14;
                v37 = v26 + v32;
                *(v30 - 2) = inverse_db_table[v35] * *(v30 - 2);
                if ( v37 < v19 )
                {
                  v38 = v36 + v23;
                  v39 = v23 + v35;
                }
                else
                {
                  v38 = v24 + v36;
                  v37 -= v19;
                  v39 = v24 + v35;
                }
                v40 = v26 + v37;
                *(v30 - 1) = inverse_db_table[v39] * *(v30 - 1);
                if ( v40 < v19 )
                {
                  v41 = v23;
                  v42 = v23;
                }
                else
                {
                  v40 -= v19;
                  v41 = v24;
                  v42 = v24;
                }
                v43 = v39 + v42;
                v21 = v26 + v40;
                v44 = v41 + v38;
                *v30 = inverse_db_table[v43] * *v30;
                if ( v21 < v19 )
                {
                  v14 = v23 + v44;
                  v25 = v23 + v43;
                }
                else
                {
                  v21 -= v19;
                  v14 = v24 + v44;
                  v25 = v24 + v43;
                }
                v30[1] = inverse_db_table[v25] * v30[1];
                v30 += 4;
                --v31;
              }
              while ( v31 );
              v13 = target;
              v29 = v59;
              v15 = step2_flaga;
            }
            if ( v27 < v29 )
            {
              v45 = v14;
              do
              {
                v21 += v26;
                if ( v21 < v19 )
                {
                  v46 = v23;
                  v47 = v23;
                }
                else
                {
                  v21 -= v19;
                  v46 = v24;
                  v47 = v24;
                }
                v45 += v47;
                v14 += v46;
                v13[v27] = inverse_db_table[v45] * v13[v27];
                ++v27;
              }
              while ( v27 < v29 );
            }
          }
          v14 = v61;
          v10 = v63;
          v11 = v18;
          v12 = v60;
          v6 = v62;
          v9 = finalY;
        }
        ++v10;
        ++v15;
        v63 = v10;
        step2_flaga = v15;
      }
      while ( v10 < v12->floor1.values );
    }
    if ( v11 < v6 )
    {
      if ( (unsigned int)(v6 - v11) >= 8 )
      {
        v48 = v11;
        v49 = (__m128)LODWORD(inverse_db_table[v14]);
        v50 = _mm_shuffle_ps(v49, v49, 0);
        v51 = (v6 - v11) % 8;
        do
        {
          v11 += 8;
          *(__m128 *)&v13[v48] = _mm_mul_ps(*(__m128 *)&v13[v48], v50);
          *(__m128 *)&v13[v48 + 4] = _mm_mul_ps(*(__m128 *)&v13[v48 + 4], v50);
          v48 += 8i64;
        }
        while ( v48 < v6 - v51 );
      }
      v52 = v11;
      if ( v11 < (__int64)v6 )
      {
        if ( v6 - (__int64)v11 >= 4 )
        {
          v53 = (__m128)LODWORD(inverse_db_table[v14]);
          v54 = &v13[v11 + 2];
          v55 = _mm_shuffle_ps(v53, v53, 0);
          v56 = ((unsigned __int64)(v6 - (__int64)v11 - 4) >> 2) + 1;
          v52 = v11 + 4 * v56;
          do
          {
            v57 = *(__m128 *)(v54 - 2);
            v54 += 4;
            *(__m128 *)(v54 - 6) = _mm_mul_ps(v57, v55);
            --v56;
          }
          while ( v56 );
        }
        if ( v52 < v6 )
        {
          v58 = inverse_db_table[v14];
          do
          {
            v13[v52] = v58 * v13[v52];
            ++v52;
          }
          while ( v52 < v6 );
        }
      }
    }
    return 1i64;
  }
  else
  {
    f->error = VORBIS_invalid_stream;
    return 0i64;
  }
}

float __fastcall float32_unpack(unsigned int x)
{
  double v1; // xmm0_8
  float v2; // xmm0_4

  v1 = (double)(x & 0x1FFFFF);
  if ( (x & 0x80000000) != 0 )
    *(_QWORD *)&v1 ^= _xmm;
  v2 = v1;
  return ldexp(v2, ((x >> 21) & 0x3FF) - 788);
}

void __fastcall flush_packet(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 v3; // cl
  int v4; // eax

  while ( f->bytes_in_seg || !f->last_seg && next_segment(f) )
  {
    --f->bytes_in_seg;
    ++f->packet_bytes;
    stream = f->stream;
    if ( stream )
    {
      if ( stream >= f->stream_end )
        goto LABEL_8;
      v3 = *stream;
      f->stream = stream + 1;
    }
    else
    {
      v4 = fgetc(f->f);
      v3 = v4;
      if ( v4 == -1 )
      {
LABEL_8:
        v3 = 0;
        f->eof = 1;
      }
    }
    if ( v3 == -1 )
      return;
  }
}

__int64 __fastcall get32(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 v3; // cl
  int v4; // eax
  unsigned __int8 *v5; // rax
  int v6; // edi
  unsigned __int8 v7; // cl
  int v8; // eax
  int v9; // edi
  unsigned __int8 *v10; // rax
  unsigned __int8 v11; // cl
  int v12; // eax
  int v13; // edi
  unsigned __int8 *v14; // rax
  unsigned __int8 v15; // cl
  int v17; // eax
  unsigned __int8 v18; // cl

  stream = f->stream;
  if ( stream )
  {
    if ( stream < f->stream_end )
    {
      v3 = *stream;
      f->stream = stream + 1;
      goto LABEL_8;
    }
    f->eof = 1;
  }
  else
  {
    v4 = fgetc(f->f);
    v3 = v4;
    if ( v4 != -1 )
      goto LABEL_8;
    f->eof = 1;
  }
  v3 = 0;
LABEL_8:
  v5 = f->stream;
  v6 = v3;
  if ( v5 )
  {
    if ( v5 < f->stream_end )
    {
      v7 = *v5;
      f->stream = v5 + 1;
      goto LABEL_13;
    }
  }
  else
  {
    v8 = fgetc(f->f);
    v7 = v8;
    if ( v8 != -1 )
      goto LABEL_13;
  }
  v7 = 0;
  f->eof = 1;
LABEL_13:
  v9 = (v7 << 8) + v6;
  v10 = f->stream;
  if ( v10 )
  {
    if ( v10 < f->stream_end )
    {
      v11 = *v10;
      f->stream = v10 + 1;
      goto LABEL_18;
    }
  }
  else
  {
    v12 = fgetc(f->f);
    v11 = v12;
    if ( v12 != -1 )
      goto LABEL_18;
  }
  v11 = 0;
  f->eof = 1;
LABEL_18:
  v13 = (v11 << 16) + v9;
  v14 = f->stream;
  if ( v14 )
  {
    if ( v14 < f->stream_end )
    {
      v15 = *v14;
      f->stream = v14 + 1;
      return v13 + (v15 << 24);
    }
    goto LABEL_22;
  }
  v17 = fgetc(f->f);
  v18 = v17;
  if ( v17 == -1 )
  {
LABEL_22:
    v18 = 0;
    f->eof = 1;
  }
  return v13 + (v18 << 24);
}

unsigned __int8 __fastcall get8(stb_vorbis *z)
{
  unsigned __int8 *stream; // rcx
  int v3; // eax

  stream = z->stream;
  if ( !stream )
  {
    v3 = fgetc(z->f);
    if ( v3 != -1 )
      return v3;
LABEL_5:
    LOBYTE(v3) = 0;
    z->eof = 1;
    return v3;
  }
  if ( stream >= z->stream_end )
    goto LABEL_5;
  LOBYTE(v3) = *stream;
  z->stream = stream + 1;
  return v3;
}

__int64 __fastcall get8_packet_raw(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 v4; // cl
  int v5; // eax
  unsigned __int8 v6; // cl

  if ( !f->bytes_in_seg && (f->last_seg || !next_segment(f)) )
    return 0xFFFFFFFFi64;
  --f->bytes_in_seg;
  ++f->packet_bytes;
  stream = f->stream;
  if ( stream )
  {
    if ( stream < f->stream_end )
    {
      v4 = *stream;
      f->stream = stream + 1;
      return v4;
    }
    goto LABEL_9;
  }
  v5 = fgetc(f->f);
  v6 = v5;
  if ( v5 == -1 )
  {
LABEL_9:
    v6 = 0;
    f->eof = 1;
  }
  return v6;
}

__int64 __fastcall get_bits(stb_vorbis *f, int n)
{
  int valid_bits; // eax
  unsigned int bits; // edi
  __int64 result; // rax
  int v7; // eax
  int v8; // ecx
  int v9; // er8
  unsigned int acc; // edx

  valid_bits = f->valid_bits;
  if ( valid_bits >= 0 )
  {
    if ( valid_bits >= n )
    {
LABEL_9:
      v9 = f->valid_bits;
      if ( v9 >= 0 )
      {
        acc = f->acc;
        result = acc & ((1 << n) - 1);
        f->acc = acc >> n;
        f->valid_bits = v9 - n;
        return result;
      }
    }
    else
    {
      if ( n > 24 )
      {
        bits = get_bits(f, 24);
        return bits + (get_bits(f, n - 24) << 24);
      }
      if ( !valid_bits )
        f->acc = 0;
      while ( 1 )
      {
        v7 = get8_packet_raw(f);
        if ( v7 == -1 )
          break;
        v8 = f->valid_bits;
        f->acc += v7 << v8;
        f->valid_bits = v8 + 8;
        if ( v8 + 8 >= n )
          goto LABEL_9;
      }
      f->valid_bits = -1;
    }
  }
  return 0i64;
}

unsigned __int64 __fastcall getn(stb_vorbis *z, unsigned __int8 *data, int n)
{
  unsigned __int8 *stream; // rdx
  __int64 v6; // rdi
  unsigned __int64 result; // rax

  stream = z->stream;
  if ( stream )
  {
    v6 = n;
    if ( &stream[n] <= z->stream_end )
    {
      memmove(data, stream, n);
      z->stream += v6;
      return 1i64;
    }
    else
    {
      result = 0i64;
      z->eof = 1;
    }
  }
  else
  {
    result = fread(data, n, 1ui64, z->f);
    if ( result != 1 )
    {
      z->eof = 1;
      return 0i64;
    }
  }
  return result;
}

__int64 __fastcall ilog(int n)
{
  if ( (unsigned int)n >= 0x4000 )
  {
    if ( (unsigned int)n >= 0x1000000 )
    {
      if ( (unsigned int)n >= 0x20000000 )
      {
        if ( (unsigned int)n >= 0x80000000 )
          return 0i64;
        else
          return (unsigned int)(log2_4[(__int64)n >> 30] + 30);
      }
      else
      {
        return (unsigned int)(log2_4[(__int64)n >> 25] + 25);
      }
    }
    else if ( (unsigned int)n >= 0x80000 )
    {
      return (unsigned int)(log2_4[(__int64)n >> 20] + 20);
    }
    else
    {
      return (unsigned int)(log2_4[(__int64)n >> 15] + 15);
    }
  }
  else if ( (unsigned int)n >= 0x10 )
  {
    if ( (unsigned int)n >= 0x200 )
      return (unsigned int)(log2_4[(__int64)n >> 10] + 10);
    else
      return (unsigned int)(log2_4[(__int64)n >> 5] + 5);
  }
  else
  {
    return (unsigned int)log2_4[n];
  }
}

void __fastcall imdct_step3_inner_r_loop(int lim, float *e, int d0, int k_off, float *A, int k1)
{
  int v6; // ecx
  float *v7; // r8
  float *v8; // rdx
  unsigned __int64 v10; // r9
  float v11; // xmm0_4
  float v12; // xmm4_4
  float v13; // xmm3_4
  float v14; // xmm3_4
  float v15; // xmm4_4
  float *v16; // rax
  float v17; // xmm1_4
  float v18; // xmm0_4
  float v19; // xmm4_4
  float v20; // xmm3_4
  float v21; // xmm3_4
  float v22; // xmm4_4
  float *v23; // rax
  float v24; // xmm1_4
  float v25; // xmm0_4
  float v26; // xmm4_4
  float v27; // xmm3_4
  float v28; // xmm3_4
  float v29; // xmm4_4
  float *v30; // rax
  float v31; // xmm1_4
  float v32; // xmm0_4
  float v33; // xmm3_4
  float v34; // xmm4_4
  float v35; // xmm3_4
  float v36; // xmm4_4

  v6 = lim >> 2;
  v7 = &e[d0];
  v8 = &v7[k_off];
  if ( v6 > 0 )
  {
    v10 = k1;
    do
    {
      v11 = *(v7 - 1);
      v12 = *v7 - *v8;
      v13 = v11 - *(v8 - 1);
      *v7 = *v8 + *v7;
      *(v7 - 1) = v11 + *(v8 - 1);
      *v8 = (float)(v12 * *A) - (float)(v13 * A[1]);
      v14 = v13 * *A;
      v15 = v12 * A[1];
      v16 = &A[v10];
      v17 = *(v8 - 2);
      *(v8 - 1) = v14 + v15;
      v18 = *(v7 - 3);
      v19 = *(v7 - 2) - v17;
      v20 = v18 - *(v8 - 3);
      *(v7 - 2) = v17 + *(v7 - 2);
      *(v7 - 3) = v18 + *(v8 - 3);
      *(v8 - 2) = (float)(v19 * *v16) - (float)(v20 * v16[1]);
      v21 = v20 * *v16;
      v22 = v19 * v16[1];
      v23 = &v16[v10];
      v24 = *(v8 - 4);
      *(v8 - 3) = v21 + v22;
      v25 = *(v7 - 5);
      v26 = *(v7 - 4) - v24;
      v27 = v25 - *(v8 - 5);
      *(v7 - 4) = v24 + *(v7 - 4);
      *(v7 - 5) = v25 + *(v8 - 5);
      *(v8 - 4) = (float)(v26 * *v23) - (float)(v27 * v23[1]);
      v28 = v27 * *v23;
      v29 = v26 * v23[1];
      v30 = &v23[v10];
      v31 = *(v8 - 6);
      *(v8 - 5) = v28 + v29;
      v32 = *(v7 - 7);
      v33 = v32 - *(v8 - 7);
      v34 = *(v7 - 6) - v31;
      *(v7 - 6) = v31 + *(v7 - 6);
      *(v7 - 7) = v32 + *(v8 - 7);
      v7 -= 8;
      --v6;
      *(v8 - 6) = (float)(v34 * *v30) - (float)(v33 * v30[1]);
      v35 = v33 * *v30;
      v36 = v34 * v30[1];
      A = &v30[v10];
      *(v8 - 7) = v35 + v36;
      v8 -= 8;
    }
    while ( v6 > 0 );
  }
}

void __fastcall imdct_step3_inner_s_loop(int n, float *e, int i_off, int k_off, float *A, int a_off, int k0)
{
  float v8; // xmm5_4
  float v9; // xmm6_4
  float v10; // xmm7_4
  float v11; // xmm8_4
  float v12; // xmm9_4
  float v13; // xmm10_4
  float v14; // xmm11_4
  float v15; // xmm12_4
  float *v16; // r8
  float *v17; // rcx
  __int64 v18; // rax
  float v19; // xmm0_4
  float v20; // xmm3_4
  float v21; // xmm1_4
  float v22; // xmm4_4
  float v23; // xmm1_4
  float v24; // xmm0_4
  float v25; // xmm4_4
  float v26; // xmm3_4
  float v27; // xmm1_4
  float v28; // xmm0_4
  float v29; // xmm4_4
  float v30; // xmm3_4
  float v31; // xmm1_4
  float v32; // xmm0_4
  float v33; // xmm3_4
  float v34; // xmm4_4

  v8 = *A;
  v9 = A[1];
  v10 = A[a_off];
  v11 = A[a_off + 1];
  v12 = A[2 * a_off];
  v13 = A[2 * a_off + 1];
  v14 = A[3 * a_off];
  v15 = A[3 * a_off + 1];
  v16 = &e[i_off];
  v17 = &v16[k_off];
  if ( n > 0 )
  {
    v18 = 4i64 * k0;
    do
    {
      v19 = *(v16 - 1);
      v20 = v19 - *(v17 - 1);
      v21 = *v16 - *v17;
      v22 = v21 * v9;
      *v16 = *v17 + *v16;
      *(v16 - 1) = v19 + *(v17 - 1);
      *v17 = (float)(v21 * v8) - (float)(v20 * v9);
      v23 = *(v17 - 2);
      *(v17 - 1) = v22 + (float)(v20 * v8);
      v24 = *(v16 - 3);
      v25 = *(v16 - 2) - v23;
      v26 = v24 - *(v17 - 3);
      *(v16 - 2) = v23 + *(v16 - 2);
      *(v16 - 3) = v24 + *(v17 - 3);
      *(v17 - 2) = (float)(v25 * v10) - (float)(v26 * v11);
      v27 = *(v17 - 4);
      *(v17 - 3) = (float)(v25 * v11) + (float)(v26 * v10);
      v28 = *(v16 - 5);
      v29 = *(v16 - 4) - v27;
      v30 = v28 - *(v17 - 5);
      *(v16 - 4) = v27 + *(v16 - 4);
      *(v16 - 5) = v28 + *(v17 - 5);
      *(v17 - 4) = (float)(v29 * v12) - (float)(v30 * v13);
      v31 = *(v17 - 6);
      *(v17 - 5) = (float)(v29 * v13) + (float)(v30 * v12);
      v32 = *(v16 - 7);
      v33 = v32 - *(v17 - 7);
      v34 = *(v16 - 6) - v31;
      *(v16 - 6) = v31 + *(v16 - 6);
      *(v16 - 7) = v32 + *(v17 - 7);
      *(v17 - 6) = (float)(v34 * v14) - (float)(v33 * v15);
      v16 = (float *)((char *)v16 - v18);
      --n;
      *(v17 - 7) = (float)(v34 * v15) + (float)(v33 * v14);
      v17 = (float *)((char *)v17 - v18);
    }
    while ( n > 0 );
  }
}

void __fastcall imdct_step3_inner_s_loop_ld654(int n, float *e, int i_off, float *A, int base_n)
{
  float v5; // xmm15_4
  float *v6; // r8
  __int64 v7; // rax
  float *i; // rcx
  float v9; // xmm12_4
  float v10; // xmm1_4
  float v11; // xmm8_4
  float v12; // xmm12_4
  float v13; // xmm9_4
  float v14; // xmm3_4
  float v15; // xmm11_4
  float v16; // xmm8_4
  float v17; // xmm2_4
  float v18; // xmm7_4
  float v19; // xmm13_4
  float v20; // xmm5_4
  float v21; // xmm9_4
  float v22; // xmm4_4
  float v23; // xmm1_4
  float v24; // xmm11_4
  float v25; // xmm3_4
  float v26; // xmm14_4
  float v27; // xmm13_4
  float v28; // xmm5_4
  float v29; // xmm0_4
  float v30; // xmm7_4
  float v31; // xmm1_4
  float v32; // xmm3_4
  float v33; // xmm10_4
  float v34; // xmm14_4
  float v35; // xmm3_4
  float v36; // xmm13_4
  float v37; // xmm2_4
  float v38; // xmm4_4
  float v39; // xmm1_4
  float v40; // xmm11_4
  float v41; // xmm6_4
  float v42; // xmm10_4
  float v43; // xmm2_4
  float v44; // xmm5_4
  float v45; // xmm6_4
  float v46; // xmm10_4
  float v47; // xmm0_4
  float v48; // xmm5_4
  float v49; // xmm1_4
  float v50; // xmm9_4
  float v51; // xmm0_4
  float v52; // xmm2_4
  float v53; // xmm1_4
  float v54; // xmm7_4
  float v55; // xmm2_4
  float v56; // xmm0_4
  float v57; // xmm3_4
  float v58; // xmm2_4
  float v59; // xmm1_4
  float v60; // xmm14_4
  float v61; // xmm0_4
  float v62; // xmm2_4
  float v63; // xmm1_4
  float v64; // xmm10_4
  float v65; // xmm0_4
  float v66; // xmm3_4
  float v67; // xmm1_4
  float v68; // xmm0_4
  float v69; // xmm2_4
  float v70; // xmm1_4

  v5 = A[(__int64)base_n >> 3];
  v6 = &e[i_off];
  v7 = 64i64 * n;
  for ( i = &v6[v7 / 0xFFFFFFFFFFFFFFFCui64]; v6 > i; v6 -= 16 )
  {
    v9 = *(v6 - 9);
    v10 = *(v6 - 1) - v9;
    v11 = *(v6 - 8);
    v12 = v9 + *(v6 - 1);
    v13 = *(v6 - 11);
    v14 = *v6 - v11;
    v15 = *(v6 - 10);
    v16 = v11 + *v6;
    v17 = *(v6 - 2);
    v18 = *(v6 - 13);
    v19 = *(v6 - 3) - v13;
    v20 = *(v6 - 4);
    v21 = v13 + *(v6 - 3);
    v22 = *(v6 - 15);
    *(v6 - 9) = v10;
    v23 = v17 - v15;
    *(v6 - 8) = v14;
    v24 = v15 + v17;
    v25 = *(v6 - 12) - v20;
    v26 = v19 + v23;
    v27 = v19 - v23;
    v28 = v20 + *(v6 - 12);
    v29 = *(v6 - 5) - v18;
    v30 = v18 + *(v6 - 5);
    *(v6 - 13) = v25;
    v31 = *(v6 - 14);
    v32 = *(v6 - 6);
    v33 = v31 - v32;
    v34 = v26 * v5;
    *(v6 - 12) = v29;
    v35 = v32 + v31;
    v36 = v27 * v5;
    v37 = *(v6 - 7) - v22;
    v38 = v22 + *(v6 - 7);
    v39 = v24 + v35;
    v40 = v24 - v35;
    v41 = v37 + v33;
    v42 = v33 - v37;
    v43 = v16 - v28;
    v44 = v28 + v16;
    v45 = v41 * v5;
    v46 = v42 * v5;
    v47 = v39 + v44;
    v48 = v44 - v39;
    v49 = v21 - v38;
    v50 = v21 + v38;
    *v6 = v47;
    *(v6 - 2) = v48;
    v51 = v49 + v43;
    v52 = v43 - v49;
    v53 = v12 - v30;
    v54 = v30 + v12;
    *(v6 - 4) = v51;
    *(v6 - 6) = v52;
    *(v6 - 1) = v50 + v54;
    *(v6 - 3) = v54 - v50;
    v55 = *(v6 - 12);
    *(v6 - 5) = v53 - v40;
    v56 = *(v6 - 8);
    *(v6 - 7) = v53 + v40;
    v57 = v56 - v55;
    v58 = v55 + v56;
    v59 = v45 + v34;
    v60 = v34 - v45;
    v61 = v59 + v58;
    v62 = v58 - v59;
    v63 = v36 - v46;
    v64 = v46 + v36;
    *(v6 - 8) = v61;
    *(v6 - 10) = v62;
    v65 = v63 + v57;
    v66 = v57 - v63;
    v67 = *(v6 - 13);
    *(v6 - 12) = v65;
    v68 = *(v6 - 9);
    *(v6 - 14) = v66;
    v69 = v68 - v67;
    v70 = v67 + v68;
    *(v6 - 9) = v64 + v70;
    *(v6 - 11) = v70 - v64;
    *(v6 - 13) = v69 - v60;
    *(v6 - 15) = v69 + v60;
  }
}

void __fastcall imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)
{
  int v5; // ecx
  float *v6; // r8
  float *i; // rdx
  float v9; // xmm0_4
  float v10; // xmm4_4
  float v11; // xmm3_4
  float v12; // xmm1_4
  float v13; // xmm0_4
  float v14; // xmm4_4
  float v15; // xmm3_4
  float v16; // xmm1_4
  float v17; // xmm0_4
  float v18; // xmm4_4
  float v19; // xmm3_4
  float v20; // xmm1_4
  float v21; // xmm0_4
  float v22; // xmm3_4
  float v23; // xmm4_4
  float v24; // xmm4_4
  float v25; // xmm3_4

  v5 = n >> 2;
  v6 = &e[i_off];
  for ( i = &v6[k_off]; v5 > 0; i -= 8 )
  {
    v9 = *(v6 - 1);
    v10 = *v6 - *i;
    v11 = v9 - *(i - 1);
    *v6 = *i + *v6;
    *(v6 - 1) = v9 + *(i - 1);
    *i = (float)(v10 * *A) - (float)(v11 * A[1]);
    v12 = *(i - 2);
    *(i - 1) = (float)(v10 * A[1]) + (float)(v11 * *A);
    v13 = *(v6 - 3);
    v14 = *(v6 - 2) - v12;
    v15 = v13 - *(i - 3);
    *(v6 - 2) = v12 + *(v6 - 2);
    *(v6 - 3) = v13 + *(i - 3);
    *(i - 2) = (float)(v14 * A[8]) - (float)(v15 * A[9]);
    v16 = *(i - 4);
    *(i - 3) = (float)(v14 * A[9]) + (float)(v15 * A[8]);
    v17 = *(v6 - 5);
    v18 = *(v6 - 4) - v16;
    v19 = v17 - *(i - 5);
    *(v6 - 4) = v16 + *(v6 - 4);
    *(v6 - 5) = v17 + *(i - 5);
    *(i - 4) = (float)(v18 * A[16]) - (float)(v19 * A[17]);
    v20 = *(i - 6);
    *(i - 5) = (float)(v18 * A[17]) + (float)(v19 * A[16]);
    v21 = *(v6 - 7);
    v22 = v21 - *(i - 7);
    v23 = *(v6 - 6) - v20;
    *(v6 - 6) = v20 + *(v6 - 6);
    *(v6 - 7) = v21 + *(i - 7);
    *(i - 6) = (float)(v23 * A[24]) - (float)(v22 * A[25]);
    v24 = v23 * A[25];
    v25 = v22 * A[24];
    v6 -= 8;
    A += 32;
    --v5;
    *(i - 7) = v24 + v25;
  }
}

__int64 __fastcall init_blocksize(stb_vorbis *f, int b, int n)
{
  __int64 v3; // rbp
  char *alloc_buffer; // rdx
  int v5; // er15
  float *v6; // rdi
  int v7; // er12
  int v10; // er13
  signed int v11; // esi
  __int64 setup_offset; // rax
  float *v13; // rcx
  char *v14; // rdx
  __int64 v15; // rax
  float *v16; // rcx
  char *v17; // r8
  signed int v18; // ecx
  __int64 v19; // rax
  float *v20; // rdx
  float *v21; // r8
  float *v22; // rax
  unsigned __int16 *v23; // rax

  v3 = b;
  alloc_buffer = f->alloc.alloc_buffer;
  v5 = n >> 2;
  v6 = 0i64;
  v7 = n >> 3;
  v10 = 4 * (n >> 1);
  v11 = (v10 + 3) & 0xFFFFFFFC;
  f->setup_memory_required += v11;
  if ( alloc_buffer )
  {
    setup_offset = f->setup_offset;
    v13 = (float *)&alloc_buffer[setup_offset];
    if ( (int)setup_offset + v11 <= f->temp_offset )
    {
      f->setup_offset = setup_offset + v11;
      goto LABEL_7;
    }
  }
  else if ( v11 )
  {
    v13 = (float *)malloc(v11);
    goto LABEL_7;
  }
  v13 = 0i64;
LABEL_7:
  f->A[v3] = v13;
  f->setup_memory_required += v11;
  v14 = f->alloc.alloc_buffer;
  if ( v14 )
  {
    v15 = f->setup_offset;
    v16 = (float *)&v14[v15];
    if ( (int)v15 + v11 <= f->temp_offset )
    {
      f->setup_offset = v15 + v11;
      goto LABEL_13;
    }
  }
  else if ( v11 )
  {
    v16 = (float *)malloc(v11);
    goto LABEL_13;
  }
  v16 = 0i64;
LABEL_13:
  f->B[v3] = v16;
  v17 = f->alloc.alloc_buffer;
  v18 = (4 * v5 + 3) & 0xFFFFFFFC;
  f->setup_memory_required += v18;
  if ( v17 )
  {
    v19 = f->setup_offset;
    if ( (int)v19 + v18 <= f->temp_offset )
    {
      f->setup_offset = v19 + v18;
      v6 = (float *)&v17[v19];
    }
  }
  else if ( v18 )
  {
    v6 = (float *)malloc(v18);
  }
  v20 = f->A[v3];
  f->C[v3] = v6;
  if ( v20
    && (v21 = f->B[v3]) != 0i64
    && v6
    && (compute_twiddle_factors(n, v20, v21, v6), v22 = (float *)setup_malloc(f, v10), (f->window[v3] = v22) != 0i64)
    && (compute_window(n, v22), v23 = (unsigned __int16 *)setup_malloc(f, 2 * v7), (f->bit_reverse[v3] = v23) != 0i64) )
  {
    compute_bitreverse(n, v23);
    return 1i64;
  }
  else
  {
    f->error = VORBIS_outofmem;
    return 0i64;
  }
}

void __fastcall inverse_mdct(float *buffer, int n, stb_vorbis *f, int blocktype)
{
  int temp_offset; // eax
  int v5; // esi
  int v7; // er10
  int v8; // edi
  char *alloc_buffer; // rdx
  int v11; // er15
  signed int v12; // ecx
  int *p_base_n; // r12
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  signed __int64 v16; // rcx
  void *v17; // rsp
  void *v18; // rsp
  float *A; // r13
  float *v20; // rdx
  float *v21; // rax
  float *v22; // r9
  float *v23; // rcx
  float v24; // xmm2_4
  float v25; // xmm0_4
  float v26; // xmm2_4
  float v27; // xmm0_4
  float *v28; // r8
  float v29; // xmm1_4
  float v30; // xmm0_4
  float v31; // xmm0_4
  float v32; // xmm1_4
  float v33; // xmm0_4
  float v34; // xmm0_4
  float *v35; // r11
  __int64 v36; // r8
  float *v37; // r14
  float *v38; // rcx
  float *v39; // rdx
  float *v40; // r10
  char *v41; // rax
  float v42; // xmm1_4
  float v43; // xmm3_4
  float v44; // xmm2_4
  float v45; // xmm1_4
  float v46; // xmm3_4
  float v47; // xmm2_4
  float v48; // xmm1_4
  float v49; // xmm3_4
  float v50; // xmm2_4
  float v51; // xmm1_4
  float v52; // xmm3_4
  float v53; // xmm2_4
  float v54; // xmm1_4
  float v55; // xmm3_4
  float v56; // xmm2_4
  float v57; // xmm1_4
  float v58; // xmm3_4
  float v59; // xmm2_4
  float v60; // xmm1_4
  float v61; // xmm3_4
  float v62; // xmm2_4
  float v63; // xmm1_4
  float v64; // xmm3_4
  float v65; // xmm2_4
  float v66; // xmm2_4
  float v67; // xmm3_4
  float *v68; // rcx
  float *v69; // r9
  float *v70; // r10
  float *v71; // r8
  float *v72; // rdx
  signed __int64 v73; // r11
  float v74; // xmm1_4
  float v75; // xmm3_4
  float v76; // xmm2_4
  float v77; // xmm2_4
  float v78; // xmm3_4
  float v79; // xmm0_4
  float v80; // xmm0_4
  float v81; // xmm2_4
  float v82; // xmm3_4
  int v83; // eax
  int v84; // er14
  int v85; // er9
  int v86; // er11
  int v87; // er11
  int v88; // er10
  int v89; // er11
  int v90; // er11
  int v91; // er11
  int v92; // ecx
  int v93; // eax
  int v94; // er8
  int v95; // edx
  __int64 v96; // rax
  int v97; // edi
  int v98; // er10
  int v99; // er14
  int v100; // edi
  __int64 v101; // rsi
  int v102; // er12
  int v103; // er10
  int v104; // er11
  int v105; // eax
  int v106; // er15
  int v107; // edx
  __int64 v108; // r8
  int v109; // er12
  int v110; // eax
  float *v111; // rsi
  int v112; // edi
  int a_off; // er13
  int v114; // er9
  int v115; // esi
  __int64 v116; // r15
  __int64 v117; // r13
  __int64 v118; // rcx
  unsigned __int16 *v119; // r10
  __int64 v120; // r14
  float *v121; // r8
  float *v122; // r9
  __int64 v123; // rdx
  __int64 v124; // rdx
  __int64 v125; // rdx
  __int64 v126; // rdx
  __int64 v127; // rdx
  __int64 v128; // rdx
  __int64 v129; // rdx
  __int64 v130; // rdx
  float *v131; // rdi
  signed __int64 v132; // r8
  float *v133; // r11
  __int64 v134; // rdx
  __int64 v135; // rdx
  __int64 v136; // rdi
  float *v137; // rcx
  float *v138; // rdx
  float *v139; // r8
  float v140; // xmm3_4
  float v141; // xmm9_4
  float v142; // xmm3_4
  float v143; // xmm1_4
  float v144; // xmm5_4
  float v145; // xmm7_4
  float v146; // xmm1_4
  float v147; // xmm7_4
  float v148; // xmm9_4
  float v149; // xmm2_4
  float v150; // xmm1_4
  float v151; // xmm0_4
  float v152; // xmm8_4
  float v153; // xmm3_4
  float v154; // xmm9_4
  float v155; // xmm5_4
  float v156; // xmm7_4
  float *v157; // rcx
  float *v158; // r9
  __int64 v159; // rax
  __int64 v160; // r14
  __int64 v161; // r11
  float *v162; // rdx
  __int64 v163; // rbx
  float *v164; // r8
  __int64 v165; // r10
  float *v166; // rax
  __int64 v167; // rdi
  float v168; // xmm3_4
  float v169; // xmm0_4
  float v170; // xmm3_4
  float v171; // xmm4_4
  float v172; // xmm5_4
  float v173; // xmm5_4
  float v174; // xmm0_4
  float v175; // xmm4_4
  float v176; // xmm5_4
  float v177; // xmm0_4
  float v178; // xmm4_4
  float v179; // xmm5_4
  float v180; // xmm3_4
  float v181; // xmm4_4
  float v182; // xmm0_4
  float v183; // xmm5_4
  float v184; // xmm0_4
  float v185; // xmm3_4
  float v186; // xmm4_4
  float v187; // xmm5_4
  int base_n; // [rsp+40h] [rbp+0h] BYREF
  int v189; // [rsp+44h] [rbp+4h]
  int d0; // [rsp+48h] [rbp+8h]
  int v191; // [rsp+4Ch] [rbp+Ch]
  int v192; // [rsp+50h] [rbp+10h]
  int lim; // [rsp+54h] [rbp+14h]
  int v194; // [rsp+58h] [rbp+18h]
  __int64 v195; // [rsp+60h] [rbp+20h]
  __int64 v196; // [rsp+68h] [rbp+28h]
  int *v197; // [rsp+70h] [rbp+30h]
  int v198; // [rsp+78h] [rbp+38h]
  int v199; // [rsp+7Ch] [rbp+3Ch]
  __int64 v200; // [rsp+80h] [rbp+40h]
  float *v201; // [rsp+88h] [rbp+48h]
  stb_vorbis *v202; // [rsp+90h] [rbp+50h]
  __int64 v203; // [rsp+98h] [rbp+58h]

  temp_offset = f->temp_offset;
  v5 = n >> 1;
  v7 = n >> 2;
  v8 = n;
  base_n = n;
  alloc_buffer = f->alloc.alloc_buffer;
  v11 = n >> 3;
  v202 = f;
  v199 = v5;
  v191 = v7;
  v194 = temp_offset;
  if ( alloc_buffer )
  {
    v12 = f->temp_offset - ((4 * v5 + 3) & 0xFFFFFFFC);
    if ( v12 >= f->setup_offset )
    {
      p_base_n = (int *)&alloc_buffer[v12];
      f->temp_offset = v12;
    }
    else
    {
      p_base_n = 0i64;
    }
  }
  else
  {
    v14 = 4i64 * v5;
    v15 = v14 + 15;
    if ( v14 + 15 <= v14 )
      v15 = 0xFFFFFFFFFFFFFF0i64;
    v16 = v15 & 0xFFFFFFFFFFFFFFF0ui64;
    v17 = alloca(v16);
    v7 = v191;
    v18 = alloca(v16);
    p_base_n = &base_n;
  }
  v203 = blocktype;
  v197 = p_base_n;
  A = f->A[blocktype];
  v20 = A;
  v201 = A;
  v21 = buffer;
  v22 = (float *)&p_base_n[v5 - 2];
  v200 = v5;
  v23 = &buffer[v5];
  if ( buffer != v23 )
  {
    do
    {
      v22[1] = (float)(*v20 * *v21) - (float)(v20[1] * v21[2]);
      v24 = *v20;
      v25 = v20[1];
      v20 += 2;
      v26 = v24 * v21[2];
      v27 = v25 * *v21;
      v21 += 4;
      *v22 = v26 + v27;
      v22 -= 2;
    }
    while ( v21 != v23 );
  }
  v28 = &buffer[v5 - 3];
  if ( v22 >= (float *)p_base_n )
  {
    if ( (((char *)v22 - (char *)p_base_n + 8) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x20 )
    {
      do
      {
        v22[1] = COERCE_FLOAT(COERCE_UNSIGNED_INT(*v20 * v28[2]) ^ _xmm)
               - COERCE_FLOAT(COERCE_UNSIGNED_INT(v20[1] * *v28) ^ _xmm);
        *(_DWORD *)v22 = COERCE_UNSIGNED_INT((float)(*v20 * *v28) + (float)(v20[1] * v28[2])) ^ _xmm;
        *(v22 - 1) = COERCE_FLOAT(COERCE_UNSIGNED_INT(v20[2] * *(v28 - 2)) ^ _xmm)
                   - COERCE_FLOAT(COERCE_UNSIGNED_INT(*(v28 - 4) * v20[3]) ^ _xmm);
        *((_DWORD *)v22 - 2) = COERCE_UNSIGNED_INT((float)(*(v28 - 2) * v20[3]) + (float)(v20[2] * *(v28 - 4))) ^ _xmm;
        *(v22 - 3) = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(v28 - 6) * v20[4]) ^ _xmm)
                   - COERCE_FLOAT(COERCE_UNSIGNED_INT(*(v28 - 8) * v20[5]) ^ _xmm);
        *((_DWORD *)v22 - 4) = COERCE_UNSIGNED_INT((float)(*(v28 - 6) * v20[5]) + (float)(*(v28 - 8) * v20[4])) ^ _xmm;
        *(v22 - 5) = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(v28 - 10) * v20[6]) ^ _xmm)
                   - COERCE_FLOAT(COERCE_UNSIGNED_INT(*(v28 - 12) * v20[7]) ^ _xmm);
        v29 = *(v28 - 10) * v20[7];
        v30 = *(v28 - 12);
        v28 -= 16;
        v31 = v30 * v20[6];
        v20 += 8;
        *((_DWORD *)v22 - 6) = COERCE_UNSIGNED_INT(v29 + v31) ^ _xmm;
        v22 -= 8;
      }
      while ( v22 >= (float *)p_base_n + 6 );
    }
    for ( ; v22 >= (float *)p_base_n; v22 -= 2 )
    {
      v22[1] = COERCE_FLOAT(COERCE_UNSIGNED_INT(*v20 * v28[2]) ^ _xmm)
             - COERCE_FLOAT(COERCE_UNSIGNED_INT(v20[1] * *v28) ^ _xmm);
      v32 = *v20 * *v28;
      v33 = v20[1];
      v20 += 2;
      v34 = v33 * v28[2];
      v28 -= 4;
      *(_DWORD *)v22 = COERCE_UNSIGNED_INT(v32 + v34) ^ _xmm;
    }
  }
  v35 = (float *)p_base_n;
  v36 = v5 - 8;
  v37 = buffer;
  v38 = &A[v36];
  v39 = (float *)&p_base_n[v7];
  v40 = &buffer[v7];
  if ( v38 >= A )
  {
    if ( ((4 * v36 + 32) & 0xFFFFFFFFFFFFFFE0ui64) >= 0x80 )
    {
      v41 = (char *)((char *)buffer - (char *)p_base_n);
      do
      {
        v42 = v35[1];
        v43 = v39[1] - v42;
        v44 = *v39 - *v35;
        v40[1] = v42 + v39[1];
        *v40 = *v35 + *v39;
        *(float *)((char *)v35 + (_QWORD)v41 + 4) = (float)(v43 * v38[4]) - (float)(v44 * v38[5]);
        *v37 = (float)(v44 * v38[4]) + (float)(v43 * v38[5]);
        v45 = v35[3];
        v46 = v39[3] - v45;
        v47 = v39[2] - v35[2];
        v40[3] = v45 + v39[3];
        v40[2] = v39[2] + v35[2];
        *(float *)((char *)v35 + (_QWORD)v41 + 12) = (float)(v46 * *v38) - (float)(v47 * v38[1]);
        *(float *)((char *)v35 + (_QWORD)v41 + 8) = (float)(v46 * v38[1]) + (float)(v47 * *v38);
        v48 = v35[5];
        v49 = v39[5] - v48;
        v50 = v39[4] - v35[4];
        v40[5] = v48 + v39[5];
        v40[4] = v39[4] + v35[4];
        *(float *)((char *)v35 + (_QWORD)v41 + 20) = (float)(v49 * *(v38 - 4)) - (float)(v50 * *(v38 - 3));
        *(float *)((char *)v35 + (_QWORD)v41 + 16) = (float)(v50 * *(v38 - 4)) + (float)(v49 * *(v38 - 3));
        v51 = v35[7];
        v52 = v39[7] - v51;
        v53 = v39[6] - v35[6];
        v40[7] = v51 + v39[7];
        v40[6] = v39[6] + v35[6];
        *(float *)((char *)v35 + (_QWORD)v41 + 28) = (float)(v52 * *(v38 - 8)) - (float)(v53 * *(v38 - 7));
        *(float *)((char *)v35 + (_QWORD)v41 + 24) = (float)(v53 * *(v38 - 8)) + (float)(v52 * *(v38 - 7));
        v54 = v35[9];
        v55 = v39[9] - v54;
        v56 = v39[8] - v35[8];
        v40[9] = v54 + v39[9];
        v40[8] = v39[8] + v35[8];
        *(float *)((char *)v35 + (_QWORD)v41 + 36) = (float)(v55 * *(v38 - 12)) - (float)(v56 * *(v38 - 11));
        *(float *)((char *)v35 + (_QWORD)v41 + 32) = (float)(v56 * *(v38 - 12)) + (float)(v55 * *(v38 - 11));
        v57 = v35[11];
        v58 = v39[11] - v57;
        v59 = v39[10] - v35[10];
        v40[11] = v57 + v39[11];
        v40[10] = v39[10] + v35[10];
        *(float *)((char *)v35 + (_QWORD)v41 + 44) = (float)(v58 * *(v38 - 16)) - (float)(v59 * *(v38 - 15));
        *(float *)((char *)v35 + (_QWORD)v41 + 40) = (float)(v59 * *(v38 - 16)) + (float)(v58 * *(v38 - 15));
        v60 = v35[13];
        v61 = v39[13] - v60;
        v62 = v39[12] - v35[12];
        v40[13] = v60 + v39[13];
        v40[12] = v39[12] + v35[12];
        *(float *)((char *)v35 + (_QWORD)v41 + 52) = (float)(v61 * *(v38 - 20)) - (float)(v62 * *(v38 - 19));
        *(float *)((char *)v35 + (_QWORD)v41 + 48) = (float)(v62 * *(v38 - 20)) + (float)(v61 * *(v38 - 19));
        v63 = v35[15];
        v64 = v39[15] - v63;
        v65 = v39[14] - v35[14];
        v40[15] = v63 + v39[15];
        v40[14] = v39[14] + v35[14];
        v37 += 16;
        v40 += 16;
        v39 += 16;
        *(float *)((char *)v35 + (_QWORD)v41 + 60) = (float)(v64 * *(v38 - 24)) - (float)(v65 * *(v38 - 23));
        v66 = v65 * *(v38 - 24);
        v67 = v64 * *(v38 - 23);
        v38 -= 32;
        *(float *)((char *)v35 + (_QWORD)v41 + 56) = v66 + v67;
        v35 += 16;
      }
      while ( v38 >= A + 24 );
    }
    if ( v38 >= A )
    {
      v68 = v38 + 5;
      v69 = v35 + 3;
      v70 = v40 + 3;
      v71 = v37 + 3;
      v72 = v39 + 3;
      v73 = (char *)v35 - (char *)v37;
      do
      {
        v74 = *(v69 - 2);
        v75 = *(v72 - 2) - v74;
        v76 = *(v72 - 3) - *(float *)((char *)v71 + v73 - 12);
        *(v70 - 2) = v74 + *(v72 - 2);
        *(v70 - 3) = *(v72 - 3) + *(float *)((char *)v71 + v73 - 12);
        *(v71 - 2) = (float)(v75 * *(v68 - 1)) - (float)(v76 * *v68);
        *(v71 - 3) = (float)(v76 * *(v68 - 1)) + (float)(v75 * *v68);
        v77 = *(v72 - 1) - *(v69 - 1);
        v78 = *v72 - *v69;
        *v70 = *v72 + *v69;
        v79 = *(v72 - 1);
        v72 += 4;
        v80 = v79 + *(v69 - 1);
        v69 += 4;
        *(v70 - 1) = v80;
        v70 += 4;
        *v71 = (float)(v78 * *(v68 - 5)) - (float)(v77 * *(v68 - 4));
        v81 = v77 * *(v68 - 5);
        v82 = v78 * *(v68 - 4);
        v68 -= 8;
        *(v71 - 1) = v81 + v82;
        v71 += 4;
      }
      while ( v68 - 5 >= A );
    }
  }
  v83 = ilog(v8);
  v84 = v5 - 1;
  d0 = v5 - 1;
  v189 = v83 - 1;
  imdct_step3_iter0_loop(v8 >> 4, buffer, v5 - 1, -v11, A);
  imdct_step3_iter0_loop(v86, buffer, v5 - v191 - 1, v85, A);
  lim = v8 >> 5;
  imdct_step3_inner_r_loop(v8 >> 5, buffer, v5 - 1, -v87, A, 16);
  imdct_step3_inner_r_loop(v88, buffer, v5 - v11 - 1, v89, A, 16);
  imdct_step3_inner_r_loop(lim, buffer, v5 - 2 * v11 - 1, v90, A, 16);
  imdct_step3_inner_r_loop(lim, buffer, v5 - 3 * v11 - 1, v91, A, 16);
  v92 = 2;
  v93 = (v189 - 3) >> 1;
  if ( v93 > 2 )
  {
    v94 = 5;
    v95 = __ROL4__(1, 2);
    v96 = (unsigned int)(v93 - 2);
    v192 = 5;
    v196 = v96;
    LODWORD(v195) = v96 + 2;
    do
    {
      v95 = __ROL4__(v95, 1);
      v198 = v95;
      v97 = v8 >> (v94 - 1) >> 1;
      if ( v95 > 0 )
      {
        v98 = d0;
        v99 = __ROL4__(1, v94);
        v100 = -v97;
        v101 = (unsigned int)v95;
        v102 = base_n >> (v94 + 1);
        do
        {
          imdct_step3_inner_r_loop(v102, buffer, v98, v100, A, v99);
          v98 = v104 + v103;
          --v101;
        }
        while ( v101 );
        v95 = v198;
        v94 = v192;
        v96 = v196;
      }
      v8 = base_n;
      ++v94;
      --v96;
      v192 = v94;
      v196 = v96;
    }
    while ( v96 );
    p_base_n = v197;
    v84 = d0;
    v92 = v195;
  }
  v105 = v189 - 6;
  if ( v92 < v189 - 6 )
  {
    v106 = __ROL4__(1, v92);
    v107 = v92 + 6;
    v189 = v92 + 6;
    v108 = (unsigned int)(v105 - v92);
    v196 = v108;
    do
    {
      v109 = v8 >> (v107 - 4);
      v110 = __ROL4__(v106, 3);
      v106 = __ROL4__(v106, 1);
      v111 = A;
      v112 = v8 >> v107;
      if ( v112 > 0 )
      {
        a_off = v110;
        v114 = -(v109 >> 1);
        v195 = 16i64 * v110;
        do
        {
          imdct_step3_inner_s_loop(v106, buffer, v84, v114, v111, a_off, v109);
          v111 = (float *)((char *)v111 + v195);
          v84 -= 8;
          --v112;
        }
        while ( v112 > 0 );
        A = v201;
        v107 = v189;
        v108 = v196;
      }
      v8 = base_n;
      ++v107;
      v84 = d0;
      v196 = --v108;
      v189 = v107;
    }
    while ( v108 );
    p_base_n = v197;
  }
  v115 = base_n;
  imdct_step3_inner_s_loop_ld654(lim, buffer, d0, A, base_n);
  v116 = (__int64)v202;
  v117 = v203;
  v118 = v191 - 4;
  v119 = v202->bit_reverse[v203];
  v120 = v199 - 4;
  v121 = (float *)&p_base_n[v118];
  v122 = (float *)&p_base_n[v120];
  if ( v121 >= (float *)p_base_n )
  {
    if ( ((4 * v118 + 16) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x40 )
    {
      do
      {
        v123 = *v119;
        v122[3] = buffer[v123];
        v122[2] = buffer[(unsigned int)(v123 + 1)];
        v121[3] = buffer[(unsigned int)(v123 + 2)];
        v121[2] = buffer[(unsigned int)(v123 + 3)];
        v124 = v119[1];
        v122[1] = buffer[v124];
        *v122 = buffer[(unsigned int)(v124 + 1)];
        v121[1] = buffer[(unsigned int)(v124 + 2)];
        *v121 = buffer[(unsigned int)(v124 + 3)];
        v125 = v119[2];
        *(v122 - 1) = buffer[v125];
        *(v122 - 2) = buffer[(unsigned int)(v125 + 1)];
        *(v121 - 1) = buffer[(unsigned int)(v125 + 2)];
        *(v121 - 2) = buffer[(unsigned int)(v125 + 3)];
        v126 = v119[3];
        *(v122 - 3) = buffer[v126];
        *(v122 - 4) = buffer[(unsigned int)(v126 + 1)];
        *(v121 - 3) = buffer[(unsigned int)(v126 + 2)];
        *(v121 - 4) = buffer[(unsigned int)(v126 + 3)];
        v127 = v119[4];
        *(v122 - 5) = buffer[v127];
        *(v122 - 6) = buffer[(unsigned int)(v127 + 1)];
        *(v121 - 5) = buffer[(unsigned int)(v127 + 2)];
        *(v121 - 6) = buffer[(unsigned int)(v127 + 3)];
        v128 = v119[5];
        *(v122 - 7) = buffer[v128];
        *(v122 - 8) = buffer[(unsigned int)(v128 + 1)];
        *(v121 - 7) = buffer[(unsigned int)(v128 + 2)];
        *(v121 - 8) = buffer[(unsigned int)(v128 + 3)];
        v129 = v119[6];
        *(v122 - 9) = buffer[v129];
        *(v122 - 10) = buffer[(unsigned int)(v129 + 1)];
        *(v121 - 9) = buffer[(unsigned int)(v129 + 2)];
        *(v121 - 10) = buffer[(unsigned int)(v129 + 3)];
        v130 = v119[7];
        v119 += 8;
        *(v122 - 11) = buffer[v130];
        *(v122 - 12) = buffer[(unsigned int)(v130 + 1)];
        v122 -= 16;
        *(v121 - 11) = buffer[(unsigned int)(v130 + 2)];
        *(v121 - 12) = buffer[(unsigned int)(v130 + 3)];
        v121 -= 16;
      }
      while ( v121 >= (float *)p_base_n + 12 );
    }
    if ( v121 >= (float *)p_base_n )
    {
      v131 = v121 + 2;
      v132 = (char *)v121 - (char *)v122;
      v133 = v122 + 2;
      do
      {
        v134 = *v119;
        v133 -= 4;
        v119 += 2;
        v131 -= 4;
        v133[5] = buffer[v134];
        v133[4] = buffer[(unsigned int)(v134 + 1)];
        v131[5] = buffer[(unsigned int)(v134 + 2)];
        v131[4] = buffer[(unsigned int)(v134 + 3)];
        v135 = *(v119 - 1);
        v133[3] = buffer[v135];
        v133[2] = buffer[(unsigned int)(v135 + 1)];
        v131[3] = buffer[(unsigned int)(v135 + 2)];
        *(float *)((char *)v133 + v132 + 8) = buffer[(unsigned int)(v135 + 3)];
      }
      while ( (char *)v133 + v132 - 8 >= (char *)p_base_n );
    }
  }
  v136 = 4 * v200;
  v137 = (float *)&p_base_n[v200 - 4];
  if ( p_base_n < (int *)v137 )
  {
    v138 = (float *)(p_base_n + 2);
    v139 = (float *)(*(_QWORD *)(v116 + 8 * v117 + 1440) + 12i64);
    do
    {
      v140 = *(v138 - 2);
      v141 = v140 + v137[2];
      v142 = v140 - v137[2];
      v143 = *(v138 - 1) + v137[3];
      v144 = (float)(*(v139 - 3) * v143) + (float)(*(v139 - 2) * v142);
      v145 = (float)(*(v139 - 2) * v143) - (float)(*(v139 - 3) * v142);
      v146 = (float)(*(v138 - 1) - v137[3]) + v145;
      v147 = v145 - (float)(*(v138 - 1) - v137[3]);
      *(v138 - 2) = v141 + v144;
      *(v138 - 1) = v146;
      v137[2] = v141 - v144;
      v148 = *v137;
      v137[3] = v147;
      v149 = *(v139 - 1);
      v150 = v138[1] + v137[1];
      v151 = *v139;
      v152 = v138[1] - v137[1];
      v139 += 4;
      v153 = *v138 - v148;
      v154 = v148 + *v138;
      v155 = (float)(v149 * v150) + (float)(v151 * v153);
      v156 = (float)(v151 * v150) - (float)(v149 * v153);
      *v138 = v154 + v155;
      v138[1] = v152 + v156;
      v138 += 4;
      *v137 = v154 - v155;
      v137[1] = v156 - v152;
      v137 -= 4;
    }
    while ( v138 - 2 < v137 );
  }
  v157 = (float *)&p_base_n[(unsigned __int64)v136 / 4 - 8];
  v158 = &buffer[v120];
  if ( v157 >= (float *)p_base_n )
  {
    v159 = v115 - 4 - v120;
    v160 = v120 - (v115 - 4);
    v161 = -v200;
    v162 = &buffer[v200 + 2];
    v163 = 4 - v136;
    v164 = &v158[v159 + 2];
    v165 = -4 - v136;
    v166 = (float *)(v136 - 32 + *(_QWORD *)(v116 + 8 * v117 + 1424) + 28i64);
    v167 = -2 - v200;
    do
    {
      v168 = v157[7];
      v169 = *(v166 - 1) * v168;
      v170 = v168 * *v166;
      v171 = (float)(v157[6] * *v166) - v169;
      LODWORD(v172) = COERCE_UNSIGNED_INT(*(v166 - 1) * v157[6]) ^ _xmm;
      v162[v167] = v171;
      v173 = v172 - v170;
      LODWORD(v164[v160 + 1]) = LODWORD(v171) ^ _xmm;
      *(v162 - 2) = v173;
      v164[1] = v173;
      v174 = *(v166 - 3);
      v175 = (float)(*(v166 - 2) * v157[4]) - (float)(v174 * v157[5]);
      v176 = COERCE_FLOAT(COERCE_UNSIGNED_INT(v174 * v157[4]) ^ _xmm) - (float)(*(v166 - 2) * v157[5]);
      *(float *)((char *)v162 + v165) = v175;
      LODWORD(v164[v160]) = LODWORD(v175) ^ _xmm;
      *(v162 - 1) = v176;
      *v164 = v176;
      v177 = *(v166 - 5);
      v178 = (float)(*(v166 - 4) * v157[2]) - (float)(v177 * v157[3]);
      v179 = COERCE_FLOAT(COERCE_UNSIGNED_INT(v177 * v157[2]) ^ _xmm) - (float)(*(v166 - 4) * v157[3]);
      v162[v161] = v178;
      LODWORD(v164[v160 - 1]) = LODWORD(v178) ^ _xmm;
      *v162 = v179;
      *(v164 - 1) = v179;
      v180 = *(v166 - 6);
      v181 = v180 * *v157;
      v182 = *(v166 - 7);
      v166 -= 8;
      v183 = v182 * *v157;
      v184 = v182 * v157[1];
      v185 = v180 * v157[1];
      v157 -= 8;
      v186 = v181 - v184;
      v187 = COERCE_FLOAT(LODWORD(v183) ^ _xmm) - v185;
      *(float *)((char *)v162 + v163) = v186;
      *(_DWORD *)v158 = LODWORD(v186) ^ _xmm;
      v158 -= 4;
      v162[1] = v187;
      v162 += 4;
      *(v164 - 2) = v187;
      v164 -= 4;
    }
    while ( v157 >= (float *)p_base_n );
  }
  *(_DWORD *)(v116 + 140) = v194;
}

__int64 __fastcall is_whole_packet_present(stb_vorbis *f, int end_page)
{
  __int64 next_seg; // rcx
  int v4; // er9
  unsigned __int8 *stream; // r8
  int segment_count; // er10
  unsigned __int8 *v7; // r9
  __int64 v8; // rax
  unsigned __int8 *stream_end; // rsi
  __int64 v10; // rdi
  __int64 v11; // r9
  int v12; // er10
  __int64 v13; // r11
  __int64 v14; // rcx

  next_seg = f->next_seg;
  v4 = 1;
  stream = f->stream;
  if ( (_DWORD)next_seg == -1 )
    goto LABEL_12;
  segment_count = f->segment_count;
  if ( (int)next_seg < segment_count )
  {
    v7 = &f->segments[next_seg];
    do
    {
      v8 = *v7;
      stream += v8;
      if ( (_BYTE)v8 != 0xFF )
        break;
      LODWORD(next_seg) = next_seg + 1;
      ++v7;
    }
    while ( (int)next_seg < segment_count );
  }
  if ( (int)next_seg >= segment_count - 1 )
  {
    if ( (_DWORD)next_seg == segment_count )
      LODWORD(next_seg) = -1;
    if ( stream > f->stream_end )
    {
LABEL_32:
      f->error = VORBIS_need_more_data;
      return 0i64;
    }
    v4 = 0;
    if ( (_DWORD)next_seg != -1 )
      return 1i64;
LABEL_12:
    stream_end = f->stream_end;
    while ( stream + 26 < stream_end )
    {
      if ( *(_DWORD *)stream != *(_DWORD *)ogg_page_header || stream[4] )
        goto LABEL_7;
      if ( v4 )
      {
        if ( f->previous_length && (stream[5] & 1) != 0 )
          goto LABEL_7;
      }
      else if ( (stream[5] & 1) == 0 )
      {
        goto LABEL_7;
      }
      v10 = stream[26];
      v11 = (__int64)(stream + 27);
      stream += v10 + 27;
      if ( stream > stream_end )
        goto LABEL_32;
      v12 = 0;
      if ( (_DWORD)v10 )
      {
        v13 = -v11;
        do
        {
          v14 = *(unsigned __int8 *)v11;
          stream += v14;
          if ( (_BYTE)v14 != 0xFF )
            break;
          ++v11;
          ++v12;
        }
        while ( v13 + v11 < v10 );
      }
      if ( v12 < (int)v10 - 1 )
        goto LABEL_7;
      if ( v12 == f->segment_count )
        v12 = -1;
      if ( stream > stream_end )
        goto LABEL_32;
      v4 = 0;
      if ( v12 != -1 )
        return 1i64;
    }
    goto LABEL_32;
  }
LABEL_7:
  f->error = VORBIS_invalid_stream;
  return 0i64;
}

__int64 __fastcall lookup1_values(int entries, int dim)
{
  float v4; // xmm6_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  int v7; // edi
  float v8; // xmm0_4
  float v9; // xmm0_4
  float v10; // xmm0_4
  __int64 result; // rax

  v4 = (float)dim;
  v5 = logf((float)entries);
  v6 = expf(v5 / v4);
  v7 = (int)floorf(v6);
  v8 = (float)v7 + 1.0;
  if ( dim == 2 )
    v9 = v8 * v8;
  else
    v9 = powf(v8, v4);
  v10 = floorf(v9);
  result = (unsigned int)(v7 + 1);
  if ( (int)v10 > entries )
    return (unsigned int)v7;
  return result;
}

int __fastcall maybe_start_packet(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 v3; // cl
  int v4; // eax

  if ( f->next_seg != -1 )
    return start_packet(f);
  stream = f->stream;
  if ( stream )
  {
    if ( stream < f->stream_end )
    {
      v3 = *stream;
      f->stream = stream + 1;
      goto LABEL_9;
    }
    f->eof = 1;
  }
  else
  {
    v4 = fgetc(f->f);
    v3 = v4;
    if ( v4 != -1 )
      goto LABEL_9;
    f->eof = 1;
  }
  v3 = 0;
LABEL_9:
  if ( f->eof )
    return 0;
  if ( v3 != 79 )
  {
    f->error = VORBIS_missing_capture_pattern;
    return 0;
  }
  if ( get8(f) != 103 || get8(f) != 103 || get8(f) != 83 )
  {
    f->error = VORBIS_missing_capture_pattern;
    return 0;
  }
  if ( !start_page_no_capturepattern(f) )
    return 0;
  if ( (f->page_flag & 1) != 0 )
  {
    f->last_seg = 0;
    f->bytes_in_seg = 0;
    f->error = VORBIS_continued_packet_flag_invalid;
    return 0;
  }
  return start_packet(f);
}

__int64 __fastcall next_segment(stb_vorbis *f)
{
  __int64 result; // rax
  __int64 next_seg; // rcx
  int v4; // edx
  int v5; // ecx

  if ( f->last_seg )
    return 0i64;
  if ( f->next_seg != -1 )
    goto LABEL_11;
  f->last_seg_which = f->segment_count - 1;
  result = capture_pattern(f);
  if ( !(_DWORD)result )
  {
    f->error = VORBIS_missing_capture_pattern;
    if ( !f->eof )
    {
      f->error = VORBIS_missing_capture_pattern;
      f->last_seg = 1;
      return result;
    }
    goto LABEL_7;
  }
  if ( !start_page_no_capturepattern(f) )
  {
LABEL_7:
    f->last_seg = 1;
    return 0i64;
  }
  if ( (f->page_flag & 1) != 0 )
  {
LABEL_11:
    next_seg = f->next_seg;
    if ( (unsigned int)next_seg > 0xFE )
      return 0i64;
    result = f->segments[next_seg];
    v4 = next_seg + 1;
    f->next_seg = next_seg + 1;
    if ( (int)result < 255 )
    {
      f->last_seg = 1;
      f->last_seg_which = next_seg;
    }
    f->bytes_in_seg = result;
    v5 = next_seg + 1;
    if ( v4 >= f->segment_count )
      v5 = -1;
    f->next_seg = v5;
  }
  else
  {
    f->error = VORBIS_continued_packet_flag_invalid;
    return 0i64;
  }
  return result;
}

void *__fastcall oggCallBack(void *ptr)
{
  __int32 v2; // er14
  stb_vorbis *v3; // rbp
  int v4; // esi
  int v5; // er12
  int v6; // edi
  _DWORD *v7; // r15
  Framework::GLManager *v8; // r13
  int frame_short_interleaved; // eax
  void *v10; // rdx
  Framework::MemoryManager *p_allocateSound; // rcx
  unsigned __int64 v12; // rdx
  void *v13; // rcx
  unsigned __int64 v14; // rdx
  void *v15; // rcx
  __int64 v17; // [rsp+50h] [rbp+8h]

  EnterCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)ptr + 6) + 8i64));
  v2 = 0;
  v3 = (stb_vorbis *)*((_QWORD *)ptr + 2);
  v4 = 0;
  v17 = *((_QWORD *)ptr + 7);
  v5 = v3->channels << 12;
  v6 = v5;
  v7 = (_DWORD *)**((_QWORD **)ptr + 3);
  LeaveCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)ptr + 6) + 8i64));
  v8 = Framework::GLManager::glm;
  if ( !*v7 )
  {
LABEL_6:
    EnterCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)ptr + 6) + 8i64));
LABEL_7:
    v10 = (void *)*((_QWORD *)ptr + 7);
    p_allocateSound = &v8->allocateSound;
    if ( v10 == *((void **)ptr + 8) )
    {
      Framework::MemoryManager::release(p_allocateSound, v10);
    }
    else
    {
      Framework::MemoryManager::release(p_allocateSound, v10);
      v13 = (void *)*((_QWORD *)ptr + 8);
      if ( v13 )
      {
        operator delete(v13, v12);
        *((_QWORD *)ptr + 8) = 0i64;
      }
    }
    operator delete(v7, 4ui64);
    goto LABEL_15;
  }
  while ( 1 )
  {
    frame_short_interleaved = stb_vorbis_get_frame_short_interleaved(
                                v3,
                                v3->channels,
                                (__int16 *)(v17 + 2i64 * v4),
                                v6 - v4);
    if ( !frame_short_interleaved )
      break;
    v2 += frame_short_interleaved;
    _InterlockedExchange(*((volatile __int32 **)ptr + 4), v2);
    v4 += frame_short_interleaved * v3->channels;
    if ( v4 + v5 > v6 )
      v6 *= 2;
    if ( !*v7 )
      goto LABEL_6;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)ptr + 6) + 8i64));
  if ( !*v7 )
    goto LABEL_7;
  **((_QWORD **)ptr + 3) = 0i64;
  operator delete(v7, 4ui64);
  v15 = (void *)*((_QWORD *)ptr + 8);
  if ( v15 )
  {
    operator delete(v15, v14);
    *((_QWORD *)ptr + 8) = 0i64;
  }
LABEL_15:
  LeaveCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)ptr + 6) + 8i64));
  (**(void (__fastcall ***)(void *, __int64))ptr)(ptr, 1i64);
  vorbis_deinit(v3);
  return 0i64;
}

// attributes: thunk
void __fastcall oggCallBackInfo::onExecuteThread(oggCallBackInfo *this)
{
  oggCallBack(this);
}

__int64 __fastcall point_compare(const void *p, const void *q)
{
  if ( *(_WORD *)p >= *(_WORD *)q )
    return *(_WORD *)p > *(_WORD *)q;
  else
    return 0xFFFFFFFFi64;
}

__int64 __fastcall residue_decode(stb_vorbis *f, Codebook *book, float *target, int offset, int n, int rtype)
{
  int v6; // ebx
  __int64 v8; // rsi
  int step; // ebp
  int i; // edi

  v6 = 0;
  v8 = offset;
  if ( rtype )
  {
    if ( n > 0 )
    {
      while ( (unsigned int)codebook_decode(f, book, &target[(int)v8], n - v6) )
      {
        v6 += book->dimensions;
        LODWORD(v8) = book->dimensions + v8;
        if ( v6 >= n )
          return 1i64;
      }
      return 0i64;
    }
  }
  else
  {
    step = n / book->dimensions;
    if ( step > 0 )
    {
      for ( i = n - offset; (unsigned int)codebook_decode_step(f, book, &target[v8 + v6], i, step); --i )
      {
        if ( ++v6 >= step )
          return 1i64;
      }
      return 0i64;
    }
  }
  return 1i64;
}

__int64 __fastcall set_file_offset(stb_vorbis *f, unsigned int loc)
{
  bool v3; // zf
  unsigned __int8 *stream_start; // r8
  unsigned __int8 *stream_end; // rax
  unsigned __int8 *v6; // rcx
  __int64 result; // rax
  unsigned int v8; // ecx
  int f_start; // edx
  _iobuf *v10; // rcx

  if ( f->push_mode )
    return 0i64;
  v3 = f->stream == 0i64;
  f->eof = 0;
  if ( v3 )
  {
    v8 = loc + f->f_start;
    if ( v8 < loc || loc >= 0x80000000 )
    {
      v8 = 0x7FFFFFFF;
      f->eof = 1;
    }
    if ( !fseek(f->f, v8, 0) )
      return 1i64;
    f_start = f->f_start;
    v10 = f->f;
    f->eof = 1;
    fseek(v10, f_start, 2);
    return 0i64;
  }
  stream_start = f->stream_start;
  stream_end = f->stream_end;
  v6 = &stream_start[loc];
  if ( v6 < stream_end && v6 >= stream_start )
  {
    f->stream = v6;
    return 1i64;
  }
  f->stream = stream_end;
  result = 0i64;
  f->eof = 1;
  return result;
}

char *__fastcall setup_malloc(stb_vorbis *f, int sz)
{
  char *alloc_buffer; // r9
  signed int v3; // edx
  __int64 setup_offset; // rax

  alloc_buffer = f->alloc.alloc_buffer;
  v3 = (sz + 3) & 0xFFFFFFFC;
  f->setup_memory_required += v3;
  if ( alloc_buffer )
  {
    setup_offset = f->setup_offset;
    if ( (int)setup_offset + v3 <= f->temp_offset )
    {
      f->setup_offset = setup_offset + v3;
      return &alloc_buffer[setup_offset];
    }
  }
  else if ( v3 )
  {
    return (char *)malloc(v3);
  }
  return 0i64;
}

char *__fastcall setup_temp_malloc(stb_vorbis *f, int sz)
{
  char *alloc_buffer; // r8
  signed int v3; // edx
  int v4; // eax

  alloc_buffer = f->alloc.alloc_buffer;
  v3 = (sz + 3) & 0xFFFFFFFC;
  if ( !alloc_buffer )
    return (char *)malloc(v3);
  v4 = f->temp_offset - v3;
  if ( v4 < f->setup_offset )
    return 0i64;
  f->temp_offset = v4;
  return &alloc_buffer[v4];
}

void __fastcall skip(stb_vorbis *z, int n)
{
  unsigned __int8 *stream; // rcx
  int v5; // eax

  stream = z->stream;
  if ( stream )
  {
    z->stream = &stream[n];
    if ( &stream[n] >= z->stream_end )
      z->eof = 1;
  }
  else
  {
    v5 = ftell(z->f);
    fseek(z->f, v5 + n, 0);
  }
}

_BOOL8 __fastcall start_decoder(stb_vorbis *f)
{
  int v1; // er13
  stb_vorbis *v2; // rsi
  _BOOL8 result; // rax
  unsigned __int8 page_flag; // al
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned __int8 v7; // al
  unsigned int v8; // edx
  unsigned int v9; // er8
  int segment; // ebx
  int v11; // edx
  int v12; // eax
  __int64 v13; // rbx
  int v14; // eax
  char *v15; // rax
  int v16; // er12
  __int64 v17; // rax
  Codebook *v18; // r14
  int v19; // ebp
  unsigned __int8 v20; // bl
  unsigned __int8 v21; // di
  unsigned __int8 v22; // bl
  int v23; // ebx
  unsigned __int8 v24; // al
  int entries; // edx
  char *v26; // rax
  _BYTE *codeword_lengths; // rdi
  int v28; // ebx
  int v29; // er15
  int v30; // eax
  int v31; // eax
  int v32; // er12
  int v33; // ecx
  char *v34; // rax
  size_t v35; // r8
  unsigned __int8 sparse; // r8
  int v37; // eax
  _BYTE *v38; // rcx
  __int64 v39; // rdx
  unsigned int *v40; // rbx
  char *v41; // rax
  bool v42; // zf
  int v43; // ecx
  char *v44; // rax
  char *v45; // rax
  unsigned int v46; // eax
  int sorted_entries; // edx
  char *v48; // rax
  int v49; // edx
  char *v50; // rax
  int *v51; // rax
  unsigned __int8 v52; // al
  unsigned int v53; // eax
  unsigned int v54; // eax
  unsigned __int8 v55; // al
  int v56; // eax
  char *v57; // rdi
  signed int v58; // ebx
  int v59; // eax
  __int64 v60; // rcx
  int v61; // er15
  int v62; // edx
  int v63; // edx
  char *v64; // rax
  int v65; // ebp
  int v66; // er8
  __int64 v67; // rbx
  int v68; // er11
  int v69; // er10
  int v70; // er9
  unsigned int lookup_values; // ecx
  int v72; // eax
  char *v73; // rax
  signed int v74; // edx
  __int64 v75; // rcx
  int n; // er9
  int v77; // eax
  __int64 v78; // rdx
  void *v79; // rcx
  int v80; // ebx
  char bits; // al
  int v82; // edi
  int v83; // eax
  int v84; // edi
  unsigned __int16 *floor_types; // rbx
  __int64 v86; // r14
  unsigned __int16 v87; // ax
  int v88; // er15
  unsigned __int8 *v89; // rbx
  unsigned __int8 v90; // al
  int v91; // edi
  unsigned __int8 v92; // al
  int v93; // er12
  unsigned __int8 v94; // al
  unsigned __int8 *v95; // r14
  unsigned __int8 v96; // al
  int v97; // ebp
  unsigned __int8 *v98; // rdi
  __int16 v99; // ax
  int v100; // er14
  int v101; // edi
  __int64 v102; // rbp
  int i; // edx
  __int64 v104; // rcx
  __int16 v105; // ax
  int j; // edx
  __int64 v107; // rcx
  int v108; // er8
  unsigned __int8 v109; // bp
  unsigned __int8 v110; // di
  int v111; // er11
  int v112; // er10
  int v113; // edx
  unsigned __int16 *v114; // r9
  int v115; // ecx
  __int64 v116; // rax
  int v117; // ecx
  __int64 v118; // rbx
  char v119; // al
  char v120; // al
  __int64 v121; // rcx
  int v122; // eax
  int v123; // eax
  unsigned __int16 *residue_types; // rbx
  __int64 v125; // rdi
  Residue *v126; // rbp
  unsigned __int16 v127; // ax
  unsigned __int8 v128; // al
  int v129; // er14
  char v130; // bl
  char v131; // r15
  int classifications; // eax
  __int64 v133; // rcx
  char *v134; // rax
  int v135; // ecx
  __int64 v136; // r12
  signed int v137; // er14
  __int64 v138; // r15
  int v139; // er13
  __int64 v140; // rbx
  char *v141; // rax
  int m; // er15
  int v143; // er14
  int dimensions; // ebx
  __int64 v145; // r9
  int v146; // ecx
  int v147; // eax
  char *v148; // rax
  bool v149; // cc
  int v150; // er15
  __int64 v151; // r14
  Mapping *v152; // rdi
  int submaps; // ecx
  unsigned __int16 v154; // ax
  int v155; // ebp
  int channels; // ecx
  __int64 v157; // rbx
  int v158; // eax
  int v159; // eax
  MappingChannel *chan; // rax
  int magnitude; // edx
  int angle; // eax
  int v163; // ebp
  __int64 v164; // rbx
  int k; // edx
  __int64 v166; // rax
  int v167; // ebp
  unsigned __int8 v168; // al
  int v169; // ecx
  int v170; // eax
  int v171; // edi
  unsigned __int16 *p_windowtype; // rbx
  unsigned __int8 v173; // al
  int v174; // edi
  _QWORD *previous_window; // rbx
  int residue_count; // eax
  unsigned __int64 v177; // r9
  Residue *residue_config; // rcx
  __int64 v179; // r8
  signed int v180; // eax
  unsigned int v181; // eax
  int v182; // [rsp+20h] [rbp-4A8h]
  int v183; // [rsp+20h] [rbp-4A8h]
  int v184; // [rsp+20h] [rbp-4A8h]
  __int64 v185; // [rsp+28h] [rbp-4A0h]
  unsigned __int16 *v186; // [rsp+28h] [rbp-4A0h]
  int v187; // [rsp+28h] [rbp-4A0h]
  int v188; // [rsp+30h] [rbp-498h]
  int v189; // [rsp+34h] [rbp-494h]
  __int64 v190; // [rsp+38h] [rbp-490h]
  unsigned __int16 *v191; // [rsp+38h] [rbp-490h]
  __int16 base[504]; // [rsp+50h] [rbp-478h] BYREF
  unsigned __int8 data[4]; // [rsp+440h] [rbp-88h] BYREF
  __int16 v195; // [rsp+444h] [rbp-84h]
  char v196[64]; // [rsp+450h] [rbp-78h]

  v1 = 0;
  v189 = 0;
  v2 = f;
  v188 = 0;
  result = capture_pattern(f);
  if ( !result )
  {
    v2->error = VORBIS_missing_capture_pattern;
    if ( !v2->eof )
    {
      v2->error = VORBIS_missing_capture_pattern;
      return result;
    }
    return 0i64;
  }
  if ( !start_page_no_capturepattern(v2) )
    return 0i64;
  page_flag = v2->page_flag;
  if ( (page_flag & 2) == 0
    || (page_flag & 4) != 0
    || (page_flag & 1) != 0
    || v2->segment_count != 1
    || v2->segments[0] != 30
    || get8(v2) != 1 )
  {
    goto LABEL_6;
  }
  if ( !(unsigned int)getn(v2, data, 6) )
  {
    v2->error = VORBIS_unexpected_eof;
    return 0i64;
  }
  if ( *(_DWORD *)data != *(_DWORD *)&extension::gfxi_detail::_exchange_table_generic_gamepad_buttons.m_exchangedUserDataChange[7][120] )
    goto LABEL_6;
  if ( v195 != *(_WORD *)&extension::gfxi_detail::_exchange_table_generic_gamepad_buttons.m_exchangedUserDataChange[7][124] )
    goto LABEL_6;
  if ( (unsigned int)get32(v2) )
    goto LABEL_6;
  v5 = get8(v2);
  v2->channels = (unsigned __int8)v5;
  if ( !(_BYTE)v5 )
    goto LABEL_6;
  if ( v5 > 0x10 )
  {
    v2->error = VORBIS_too_many_channels;
    return 0i64;
  }
  v6 = get32(v2);
  v2->sample_rate = v6;
  if ( !v6 )
    goto LABEL_6;
  get32(v2);
  get32(v2);
  get32(v2);
  v7 = get8(v2);
  v8 = v7 >> 4;
  v9 = v7 & 0xF;
  v2->blocksize_0 = 1 << v9;
  v2->blocksize_1 = 1 << (v7 >> 4);
  if ( v9 - 6 > 7 || v8 - 6 > 7 || v9 > v8 )
  {
    v2->error = VORBIS_invalid_setup;
    return 0i64;
  }
  if ( (get8(v2) & 1) == 0 )
  {
LABEL_6:
    v2->error = VORBIS_invalid_first_page;
    return 0i64;
  }
  if ( !start_page(v2) || !start_packet(v2) )
    return 0i64;
  do
  {
    segment = next_segment(v2);
    skip(v2, segment);
    v2->bytes_in_seg = 0;
  }
  while ( segment );
  if ( !start_packet(v2) )
    return 0i64;
  if ( v2->push_mode && !(unsigned int)is_whole_packet_present(v2, v11) )
  {
    if ( v2->error == VORBIS_invalid_stream )
      v2->error = VORBIS_invalid_setup;
    return 0i64;
  }
  crc32_init();
  v12 = get8_packet_raw(v2);
  v2->valid_bits = 0;
  if ( v12 != 5 )
    goto LABEL_287;
  v13 = 0i64;
  do
  {
    data[v13++] = get8_packet_raw(v2);
    v2->valid_bits = 0;
  }
  while ( v13 < 6 );
  if ( *(_DWORD *)data != *(_DWORD *)&extension::gfxi_detail::_exchange_table_generic_gamepad_buttons.m_exchangedUserDataChange[7][120]
    || v195 != *(_WORD *)&extension::gfxi_detail::_exchange_table_generic_gamepad_buttons.m_exchangedUserDataChange[7][124] )
  {
LABEL_287:
    v2->error = VORBIS_invalid_setup;
    return 0i64;
  }
  v14 = get_bits(v2, 8) + 1;
  v2->codebook_count = v14;
  v15 = setup_malloc(v2, 2120 * v14);
  v2->codebooks = (Codebook *)v15;
  if ( !v15 )
  {
    v2->error = VORBIS_outofmem;
    return 0i64;
  }
  memset(v15, 0, 2120i64 * v2->codebook_count);
  v16 = 0;
  v182 = 0;
  if ( v2->codebook_count <= 0 )
  {
LABEL_160:
    v80 = 0;
    bits = get_bits(v2, 6);
    v82 = (unsigned __int8)(bits + 1);
    if ( bits != -1 )
    {
      while ( !(unsigned int)get_bits(v2, 16) )
      {
        if ( ++v80 >= v82 )
          goto LABEL_163;
      }
      goto LABEL_159;
    }
LABEL_163:
    v83 = get_bits(v2, 6) + 1;
    v2->floor_count = v83;
    v84 = 0;
    v2->floor_config = (Floor *)setup_malloc(v2, 1596 * v83);
    v183 = 0;
    if ( v2->floor_count > 0 )
    {
      floor_types = v2->floor_types;
      v190 = 0i64;
      v186 = v2->floor_types;
      v86 = 0i64;
      do
      {
        v87 = get_bits(v2, 16);
        *floor_types = v87;
        if ( v87 > 1u )
          goto LABEL_159;
        if ( !v87 )
        {
          v118 = (__int64)&v2->floor_config[v84];
          *(_BYTE *)v118 = get_bits(v2, 8);
          *(_WORD *)(v118 + 2) = get_bits(v2, 16);
          *(_WORD *)(v118 + 4) = get_bits(v2, 16);
          *(_BYTE *)(v118 + 6) = get_bits(v2, 6);
          *(_BYTE *)(v118 + 7) = get_bits(v2, 8);
          v119 = get_bits(v2, 4);
          *(_BYTE *)(v118 + 8) = v119 + 1;
          if ( v119 != -1 )
          {
            do
            {
              v120 = get_bits(v2, 8);
              v121 = v1++;
              *(_BYTE *)(v121 + v118 + 9) = v120;
            }
            while ( v1 < *(unsigned __int8 *)(v118 + 8) );
          }
          v122 = 4;
          if ( !v2->eof )
            v122 = 4;
          goto LABEL_223;
        }
        v88 = -1;
        v89 = &v2->floor_config->floor0.order + v86;
        v90 = get_bits(v2, 5);
        *v89 = v90;
        v91 = 0;
        if ( v90 )
        {
          do
          {
            v92 = get_bits(v2, 4);
            v89[v91 + 1] = v92;
            if ( v92 > v88 )
              v88 = v92;
            ++v91;
          }
          while ( v91 < *v89 );
        }
        v93 = 0;
        if ( v88 >= 0 )
        {
          do
          {
            v89[v93 + 33] = get_bits(v2, 3) + 1;
            v94 = get_bits(v2, 2);
            v89[v93 + 49] = v94;
            v95 = &v89[v93];
            if ( v94 )
            {
              v96 = get_bits(v2, 8);
              v89[v93 + 65] = v96;
              if ( v96 >= v2->codebook_count )
                goto LABEL_159;
            }
            v97 = 0;
            if ( 1 << v95[49] > 0 )
            {
              v98 = &v89[16 * v93 + 82];
              do
              {
                v99 = get_bits(v2, 8) - 1;
                *(_WORD *)v98 = v99;
                if ( v99 >= v2->codebook_count )
                  goto LABEL_159;
                ++v97;
                v98 += 2;
              }
              while ( v97 < 1 << v95[49] );
            }
          }
          while ( ++v93 <= v88 );
        }
        v89[1588] = get_bits(v2, 2) + 1;
        v89[1589] = get_bits(v2, 4);
        v100 = 0;
        *((_WORD *)v89 + 169) = 0;
        *((_WORD *)v89 + 170) = 1 << v89[1589];
        *((_DWORD *)v89 + 398) = 2;
        if ( *v89 )
        {
          do
          {
            v101 = 0;
            v102 = v89[v100 + 1];
            if ( v89[v102 + 33] )
            {
              do
              {
                ++v101;
                *(_WORD *)&v89[2 * (*((_DWORD *)v89 + 398))++ + 338] = get_bits(v2, v89[1589]);
              }
              while ( v101 < v89[v102 + 33] );
            }
            ++v100;
          }
          while ( v100 < *v89 );
        }
        for ( i = 0; i < *((_DWORD *)v89 + 398); base[2 * v104] = v105 )
        {
          v104 = i;
          v105 = *(_WORD *)&v89[2 * i + 338];
          base[2 * i + 1] = i;
          ++i;
        }
        qsort(base, *((int *)v89 + 398), 4ui64, (int (__fastcall *)(const void *, const void *))point_compare);
        for ( j = 0; j < *((_DWORD *)v89 + 398); v89[v107 + 838] = base[2 * v107 + 1] )
          v107 = j++;
        v108 = 2;
        if ( *((int *)v89 + 398) > 2 )
        {
          do
          {
            v109 = 0;
            v110 = 0;
            v111 = -1;
            v112 = 0x10000;
            v113 = 0;
            if ( v108 > 0 )
            {
              v114 = (unsigned __int16 *)(v89 + 338);
              do
              {
                v115 = *v114;
                if ( v115 > v111 && (unsigned __int16)v115 < *(_WORD *)&v89[2 * v108 + 338] )
                {
                  v109 = v113;
                  v111 = *v114;
                }
                if ( v115 < v112 && (unsigned __int16)v115 > *(_WORD *)&v89[2 * v108 + 338] )
                {
                  v110 = v113;
                  v112 = *v114;
                }
                ++v113;
                ++v114;
              }
              while ( v113 < v108 );
            }
            v116 = v108++;
            v89[2 * v116 + 1088] = v109;
            v89[2 * v116 + 1089] = v110;
          }
          while ( v108 < *((_DWORD *)v89 + 398) );
          v2 = f;
        }
        v117 = v188;
        if ( *((_DWORD *)v89 + 398) > v188 )
          v117 = *((_DWORD *)v89 + 398);
        v84 = v183 + 1;
        floor_types = v186 + 1;
        v188 = v117;
        v86 = v190 + 1596;
        v183 = v84;
        ++v186;
        v190 += 1596i64;
      }
      while ( v84 < v2->floor_count );
    }
    v123 = get_bits(v2, 6);
    v2->residue_count = v123 + 1;
    v2->residue_config = (Residue *)setup_malloc(v2, 32 * (v123 + 1));
    v187 = 0;
    if ( v2->residue_count <= 0 )
    {
LABEL_235:
      v147 = get_bits(v2, 6) + 1;
      v2->mapping_count = v147;
      v148 = setup_malloc(v2, 48 * v147);
      v149 = v2->mapping_count <= 0;
      v150 = 0;
      v2->mapping = (Mapping *)v148;
      if ( v149 )
      {
LABEL_265:
        v170 = get_bits(v2, 6) + 1;
        v171 = 0;
        v2->mode_count = v170;
        if ( v170 <= 0 )
        {
LABEL_271:
          flush_packet(v2);
          v149 = v2->channels <= 0;
          v174 = 0;
          v2->previous_length = 0;
          if ( !v149 )
          {
            previous_window = v2->previous_window;
            do
            {
              *(previous_window - 32) = setup_malloc(v2, 4 * v2->blocksize_1);
              *previous_window = setup_malloc(v2, (unsigned __int64)(4i64 * v2->blocksize_1) >> 1);
              previous_window[17] = setup_malloc(v2, 2 * v188);
              ++previous_window;
              ++v174;
            }
            while ( v174 < v2->channels );
          }
          if ( !(unsigned int)init_blocksize(v2, 0, v2->blocksize_0)
            || !(unsigned int)init_blocksize(v2, 1, v2->blocksize_1) )
          {
            return 0i64;
          }
          v2->blocksize[0] = v2->blocksize_0;
          v2->blocksize[1] = v2->blocksize_1;
          residue_count = v2->residue_count;
          v177 = (unsigned __int64)(4i64 * v2->blocksize_1) >> 1;
          if ( residue_count > 0 )
          {
            residue_config = v2->residue_config;
            v179 = (unsigned int)residue_count;
            do
            {
              v180 = (residue_config->end - residue_config->begin) / residue_config->part_size;
              ++residue_config;
              if ( v180 > v1 )
                v1 = v180;
              --v179;
            }
            while ( v179 );
          }
          v2->first_decode = 1;
          v181 = 8 * v2->channels * (v1 + 1);
          if ( (unsigned int)v177 > v181 )
            v181 = v177;
          v42 = v2->alloc.alloc_buffer == 0i64;
          v2->temp_memory_required = v181;
          if ( v42 || v2->setup_offset + (unsigned __int64)v181 + 1896 <= (unsigned int)v2->temp_offset )
          {
            v2->first_audio_page_offset = stb_vorbis_get_file_offset(v2);
            return 1i64;
          }
LABEL_285:
          v43 = 3;
LABEL_220:
          v42 = v2->eof == 0;
          goto LABEL_221;
        }
        p_windowtype = &v2->mode_config[0].windowtype;
        while ( 1 )
        {
          *((_BYTE *)p_windowtype - 2) = get_bits(v2, 1);
          *p_windowtype = get_bits(v2, 16);
          p_windowtype[1] = get_bits(v2, 16);
          v173 = get_bits(v2, 8);
          v42 = *p_windowtype == 0;
          *((_BYTE *)p_windowtype - 1) = v173;
          if ( !v42 || p_windowtype[1] || v173 >= v2->mapping_count )
            break;
          ++v171;
          p_windowtype += 3;
          if ( v171 >= v2->mode_count )
            goto LABEL_271;
        }
      }
      else
      {
        v151 = 0i64;
        while ( 1 )
        {
          v152 = &v2->mapping[v151];
          if ( (unsigned int)get_bits(v2, 16) )
            break;
          v152->chan = (MappingChannel *)setup_malloc(v2, 3 * v2->channels);
          if ( (unsigned int)get_bits(v2, 1) )
            v152->submaps = get_bits(v2, 4);
          else
            v152->submaps = 1;
          submaps = v189;
          if ( v152->submaps > v189 )
            submaps = v152->submaps;
          v189 = submaps;
          if ( (unsigned int)get_bits(v2, 1) )
          {
            v154 = get_bits(v2, 8) + 1;
            v155 = 0;
            v152->coupling_steps = v154;
            if ( v154 )
            {
              channels = v2->channels;
              v157 = 0i64;
              do
              {
                v158 = ilog(channels);
                v152->chan[v157].magnitude = get_bits(v2, v158 - 1);
                v159 = ilog(v2->channels);
                v152->chan[v157].angle = get_bits(v2, v159 - 1);
                chan = v152->chan;
                channels = v2->channels;
                magnitude = chan[v157].magnitude;
                if ( magnitude >= channels )
                  goto LABEL_219;
                angle = chan[v157].angle;
                if ( angle >= channels || (_BYTE)magnitude == (_BYTE)angle )
                  goto LABEL_219;
                ++v155;
                ++v157;
              }
              while ( v155 < v152->coupling_steps );
            }
          }
          else
          {
            v152->coupling_steps = 0;
          }
          if ( (unsigned int)get_bits(v2, 2) )
            break;
          if ( v152->submaps <= 1u )
          {
            for ( k = 0; k < v2->channels; v152->chan[v166].mux = 0 )
              v166 = k++;
          }
          else
          {
            v163 = 0;
            if ( v2->channels > 0 )
            {
              do
              {
                v164 = v163;
                v152->chan[v164].mux = get_bits(v2, 4);
                if ( v152->chan[v164].mux >= v152->submaps )
                  goto LABEL_219;
              }
              while ( ++v163 < v2->channels );
            }
          }
          v167 = 0;
          if ( v152->submaps )
          {
            do
            {
              get_bits(v2, 8);
              v152->submap_floor[v167] = get_bits(v2, 8);
              v168 = get_bits(v2, 8);
              v169 = v152->submap_floor[v167];
              v152->submap_residue[v167] = v168;
              if ( v169 >= v2->floor_count || v168 >= v2->residue_count )
                goto LABEL_219;
            }
            while ( ++v167 < v152->submaps );
          }
          ++v150;
          ++v151;
          if ( v150 >= v2->mapping_count )
            goto LABEL_265;
        }
      }
    }
    else
    {
      residue_types = v2->residue_types;
      v125 = 0i64;
      v191 = v2->residue_types;
      while ( 1 )
      {
        v126 = v2->residue_config;
        v127 = get_bits(v2, 16);
        *residue_types = v127;
        if ( v127 > 2u )
          break;
        v126[v125].begin = get_bits(v2, 24);
        v126[v125].end = get_bits(v2, 24);
        v126[v125].part_size = get_bits(v2, 24) + 1;
        v126[v125].classifications = get_bits(v2, 6) + 1;
        v128 = get_bits(v2, 8);
        v42 = v126[v125].classifications == 0;
        v129 = 0;
        v126[v125].classbook = v128;
        if ( !v42 )
        {
          do
          {
            v130 = 0;
            v131 = get_bits(v2, 3);
            if ( (unsigned int)get_bits(v2, 1) )
              v130 = get_bits(v2, 5);
            classifications = v126[v125].classifications;
            v133 = v129++;
            v196[v133] = v131 + 8 * v130;
          }
          while ( v129 < classifications );
        }
        v134 = setup_malloc(v2, 16 * (unsigned int)v126[v125].classifications);
        v42 = v126[v125].classifications == 0;
        v135 = 0;
        v184 = 0;
        v126[v125].residue_books = (__int16 (*)[8])v134;
        if ( !v42 )
        {
          do
          {
            v136 = v135;
            v137 = 0;
            v138 = 0i64;
            v139 = (unsigned __int8)v196[v135];
            do
            {
              if ( _bittest(&v139, v137) )
              {
                v140 = v138 + 8 * v136;
                (*v126[v125].residue_books)[v140] = get_bits(v2, 8);
                if ( (*v126[v125].residue_books)[v140] >= v2->codebook_count )
                  goto LABEL_219;
              }
              else
              {
                v126[v125].residue_books[v136][v138] = -1;
              }
              ++v137;
              ++v138;
            }
            while ( v137 < 8 );
            v1 = 0;
            v135 = v184 + 1;
            v184 = v135;
          }
          while ( v135 < v126[v125].classifications );
        }
        v141 = setup_malloc(v2, 8 * v2->codebooks[v126[v125].classbook].entries);
        v126[v125].classdata = (unsigned __int8 **)v141;
        if ( !v141 )
          goto LABEL_285;
        memset(v141, 0, 8i64 * v2->codebooks[v126[v125].classbook].entries);
        for ( m = 0; m < v2->codebooks[v126[v125].classbook].entries; ++m )
        {
          v143 = m;
          dimensions = v2->codebooks[v126[v125].classbook].dimensions;
          v126[v125].classdata[m] = (unsigned __int8 *)setup_malloc(v2, dimensions);
          v145 = dimensions - 1;
          if ( dimensions - 1 >= 0 )
          {
            v146 = v126[v125].classifications;
            do
            {
              v126[v125].classdata[m][v145] = v143 % v146;
              v146 = v126[v125].classifications;
              --v145;
              v143 /= v146;
            }
            while ( v145 >= 0 );
          }
        }
        ++v125;
        residue_types = v191 + 1;
        ++v187;
        ++v191;
        if ( v187 >= v2->residue_count )
          goto LABEL_235;
      }
    }
LABEL_219:
    v43 = 20;
    goto LABEL_220;
  }
  v17 = 0i64;
  v185 = 0i64;
  while ( 1 )
  {
    v18 = &v2->codebooks[v17];
    v19 = 0;
    if ( (unsigned __int8)get_bits(v2, 8) != 66
      || (unsigned __int8)get_bits(v2, 8) != 67
      || (unsigned __int8)get_bits(v2, 8) != 86 )
    {
      goto LABEL_159;
    }
    v20 = get_bits(v2, 8);
    v18->dimensions = v20 + ((unsigned int)get_bits(v2, 8) << 8);
    v21 = get_bits(v2, 8);
    v22 = get_bits(v2, 8);
    v18->entries = v21 + (v22 << 8) + ((unsigned int)get_bits(v2, 8) << 16);
    v23 = get_bits(v2, 1);
    if ( v23 )
      v24 = 0;
    else
      v24 = get_bits(v2, 1);
    entries = v18->entries;
    v18->sparse = v24;
    if ( v24 )
    {
      v26 = setup_temp_malloc(v2, entries);
    }
    else
    {
      v26 = setup_malloc(v2, entries);
      v18->codeword_lengths = (unsigned __int8 *)v26;
    }
    codeword_lengths = v26;
    if ( !v26 )
      goto LABEL_154;
    v42 = v23 == 0;
    v28 = 0;
    if ( v42 )
    {
      if ( v18->entries > 0 )
      {
        do
        {
          if ( !v18->sparse || (unsigned int)get_bits(v2, 1) )
          {
            ++v19;
            codeword_lengths[v28] = get_bits(v2, 5) + 1;
          }
          else
          {
            codeword_lengths[v28] = -1;
          }
          ++v28;
        }
        while ( v28 < v18->entries );
      }
    }
    else
    {
      v29 = get_bits(v2, 5) + 1;
      if ( v18->entries > 0 )
      {
        while ( 1 )
        {
          v30 = ilog(v18->entries - v28);
          v31 = get_bits(v2, v30);
          v32 = v31 + v28;
          if ( v31 + v28 > v18->entries )
            goto LABEL_159;
          memset(&codeword_lengths[v28], v29++, v31);
          v28 = v32;
          if ( v32 >= v18->entries )
          {
            v16 = v182;
            break;
          }
        }
      }
    }
    if ( v18->sparse )
    {
      v33 = v18->entries;
      if ( v19 >= v33 >> 2 )
      {
        if ( v33 > (signed int)v2->setup_temp_memory_required )
          v2->setup_temp_memory_required = v33;
        v34 = setup_malloc(v2, v18->entries);
        v35 = v18->entries;
        v18->codeword_lengths = (unsigned __int8 *)v34;
        memmove(v34, codeword_lengths, v35);
        if ( v2->alloc.alloc_buffer )
          v2->temp_offset += (v18->entries + 3) & 0xFFFFFFFC;
        else
          free(codeword_lengths);
        codeword_lengths = v18->codeword_lengths;
        v18->sparse = 0;
      }
    }
    sparse = v18->sparse;
    if ( !sparse )
    {
      v37 = v18->entries;
      v19 = 0;
      if ( v37 > 0 )
      {
        v38 = codeword_lengths;
        v39 = (unsigned int)v37;
        do
        {
          if ( (unsigned __int8)(*v38 - 11) <= 0xF3u )
            ++v19;
          ++v38;
          --v39;
        }
        while ( v39 );
      }
    }
    v18->sorted_entries = v19;
    v40 = 0i64;
    if ( sparse )
    {
      if ( v19 )
      {
        v44 = setup_malloc(v2, v19);
        v18->codeword_lengths = (unsigned __int8 *)v44;
        if ( !v44
          || (v45 = setup_temp_malloc(v2, 4 * v18->sorted_entries), (v18->codewords = (unsigned int *)v45) == 0i64) )
        {
LABEL_81:
          v42 = v2->eof == 0;
          v43 = 3;
          goto LABEL_221;
        }
        v40 = (unsigned int *)setup_temp_malloc(v2, 4 * v18->sorted_entries);
        if ( !v40 )
        {
          v42 = v2->eof == 0;
          v43 = 3;
          goto LABEL_221;
        }
      }
      v46 = v18->entries + 8 * v18->sorted_entries;
      if ( v46 > v2->setup_temp_memory_required )
        v2->setup_temp_memory_required = v46;
    }
    else
    {
      v41 = setup_malloc(v2, 4 * v18->entries);
      v18->codewords = (unsigned int *)v41;
      if ( !v41 )
        goto LABEL_81;
    }
    if ( !(unsigned int)compute_codewords(v18, codeword_lengths, v18->entries, v40) )
      break;
    sorted_entries = v18->sorted_entries;
    if ( sorted_entries )
    {
      v48 = setup_malloc(v2, 4 * sorted_entries + 4);
      v49 = v18->sorted_entries;
      v18->sorted_codewords = (unsigned int *)v48;
      v50 = setup_malloc(v2, 4 * v49 + 4);
      v18->sorted_values = (int *)v50;
      if ( v50 )
      {
        v51 = (int *)(v50 + 4);
        v18->sorted_values = v51;
        *(v51 - 1) = -1;
      }
      compute_sorted_huffman(v18, codeword_lengths, v40);
    }
    if ( v18->sparse )
    {
      if ( v2->alloc.alloc_buffer )
        v2->temp_offset += (4 * v18->sorted_entries + 3) & 0xFFFFFFFC;
      else
        free(v40);
      if ( v2->alloc.alloc_buffer )
        v2->temp_offset += (4 * v18->sorted_entries + 3) & 0xFFFFFFFC;
      else
        free(v18->codewords);
      if ( v2->alloc.alloc_buffer )
        v2->temp_offset += (v18->entries + 3) & 0xFFFFFFFC;
      else
        free(codeword_lengths);
      v18->codewords = 0i64;
    }
    compute_accelerated_huffman(v18);
    v52 = get_bits(v2, 4);
    v18->lookup_type = v52;
    if ( v52 > 2u )
      goto LABEL_159;
    if ( v52 )
    {
      v53 = get_bits(v2, 32);
      v18->minimum_value = float32_unpack(v53);
      v54 = get_bits(v2, 32);
      v18->delta_value = float32_unpack(v54);
      v18->value_bits = get_bits(v2, 4) + 1;
      v55 = get_bits(v2, 1);
      v42 = v18->lookup_type == 1;
      v18->sequence_p = v55;
      if ( v42 )
        v56 = lookup1_values(v18->entries, v18->dimensions);
      else
        v56 = v18->entries * v18->dimensions;
      v18->lookup_values = v56;
      v57 = setup_temp_malloc(v2, 2 * v56);
      if ( !v57 )
        goto LABEL_154;
      v58 = 0;
      if ( (int)v18->lookup_values > 0 )
      {
        while ( 1 )
        {
          v59 = get_bits(v2, v18->value_bits);
          if ( v59 == -1 )
            break;
          v60 = v58++;
          *(_WORD *)&v57[2 * v60] = v59;
          if ( v58 >= (signed int)v18->lookup_values )
            goto LABEL_113;
        }
        if ( v2->alloc.alloc_buffer )
        {
          v43 = 20;
          v2->temp_offset += (2 * v18->lookup_values + 3) & 0xFFFFFFFC;
          v42 = v2->eof == 0;
          goto LABEL_221;
        }
        v79 = v57;
        goto LABEL_158;
      }
LABEL_113:
      if ( v18->lookup_type == 1 )
      {
        v61 = v18->sparse;
        if ( v18->sparse )
        {
          v62 = v18->sorted_entries;
          if ( v62 )
          {
            v63 = v18->dimensions * v62;
            goto LABEL_118;
          }
        }
        else
        {
          v63 = v18->entries * v18->dimensions;
LABEL_118:
          v64 = setup_malloc(v2, 4 * v63);
          v18->multiplicands = (float *)v64;
          if ( !v64 )
          {
            if ( v2->alloc.alloc_buffer )
            {
              v43 = 3;
              v2->temp_offset += (2 * v18->lookup_values + 3) & 0xFFFFFFFC;
              v42 = v2->eof == 0;
              goto LABEL_221;
            }
            free(v57);
LABEL_154:
            v42 = v2->eof == 0;
            v43 = 3;
            goto LABEL_221;
          }
          if ( v61 )
            v65 = v18->sorted_entries;
          else
            v65 = v18->entries;
          v66 = 0;
          if ( v65 > 0 )
          {
            v67 = 0i64;
            do
            {
              if ( v61 )
                v68 = v18->sorted_values[v67];
              else
                v68 = v66;
              v69 = 1;
              v70 = 0;
              if ( v18->dimensions > 0 )
              {
                lookup_values = v18->lookup_values;
                do
                {
                  v72 = v70 + v66 * v18->dimensions;
                  ++v70;
                  v18->multiplicands[v72] = (float)((float)*(unsigned __int16 *)&v57[2 * (v68 / v69 % lookup_values)]
                                                  * v18->delta_value)
                                          + v18->minimum_value;
                  lookup_values = v18->lookup_values;
                  v69 *= lookup_values;
                }
                while ( v70 < v18->dimensions );
              }
              ++v66;
              ++v67;
            }
            while ( v66 < v65 );
          }
          if ( v2->alloc.alloc_buffer )
            v2->temp_offset += (2 * v18->lookup_values + 3) & 0xFFFFFFFC;
          else
            free(v57);
          v18->lookup_type = 2;
        }
      }
      else
      {
        v73 = setup_malloc(v2, 4 * v18->lookup_values);
        v74 = 0;
        for ( v18->multiplicands = (float *)v73;
              v74 < (signed int)v18->lookup_values;
              v18->multiplicands[v75] = (float)((float)*(unsigned __int16 *)&v57[2 * v75] * v18->delta_value)
                                      + v18->minimum_value )
        {
          v75 = v74++;
        }
        if ( v2->alloc.alloc_buffer )
          v2->temp_offset += (2 * v18->lookup_values + 3) & 0xFFFFFFFC;
        else
          free(v57);
      }
      if ( v18->lookup_type == 2 && v18->sequence_p )
      {
        for ( n = 1; n < (signed int)v18->lookup_values; v18->multiplicands[v78] = v18->multiplicands[v77] )
        {
          v77 = n - 1;
          v78 = n++;
        }
        v18->sequence_p = 0;
      }
    }
    ++v16;
    v17 = v185 + 1;
    v182 = v16;
    ++v185;
    if ( v16 >= v2->codebook_count )
      goto LABEL_160;
  }
  if ( v18->sparse && !v2->alloc.alloc_buffer )
  {
    v79 = v40;
LABEL_158:
    free(v79);
  }
LABEL_159:
  v42 = v2->eof == 0;
  v43 = 20;
LABEL_221:
  v122 = v43;
  if ( v42 )
    v122 = v43;
LABEL_223:
  v2->error = v122;
  return 0i64;
}

__int64 __fastcall start_packet(stb_vorbis *f)
{
  if ( f->next_seg == -1 )
  {
    while ( capture_pattern(f) )
    {
      if ( !start_page_no_capturepattern(f) )
        return 0i64;
      if ( (f->page_flag & 1) != 0 )
      {
        f->error = VORBIS_continued_packet_flag_invalid;
        return 0i64;
      }
      if ( f->next_seg != -1 )
        goto LABEL_6;
    }
    f->error = VORBIS_missing_capture_pattern;
    return 0i64;
  }
  else
  {
LABEL_6:
    f->last_seg = 0;
    *(_QWORD *)&f->valid_bits = 0i64;
    f->bytes_in_seg = 0;
    return 1i64;
  }
}

int __fastcall start_page(stb_vorbis *f)
{
  if ( capture_pattern(f) )
    return start_page_no_capturepattern(f);
  f->error = VORBIS_missing_capture_pattern;
  return 0;
}

__int64 __fastcall start_page_no_capturepattern(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax
  unsigned __int8 *v3; // rax
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // cl
  int v7; // eax
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // esi
  unsigned __int8 *v11; // rax
  unsigned __int8 v12; // cl
  int v13; // eax
  unsigned __int8 *segments; // rdi
  int v15; // ecx
  __int64 i; // rax
  int segment_count; // er9
  int v18; // edx
  __int64 v19; // rcx
  int v20; // eax
  __int128 v21; // [rsp+20h] [rbp-28h]

  stream = f->stream;
  if ( stream )
  {
    if ( stream >= f->stream_end )
    {
      f->eof = 1;
      goto LABEL_4;
    }
    v5 = *stream;
    f->stream = stream + 1;
  }
  else
  {
    v7 = fgetc(f->f);
    v5 = v7;
    if ( v7 == -1 )
    {
      f->eof = 1;
      goto LABEL_4;
    }
  }
  if ( v5 )
  {
    f->error = VORBIS_invalid_stream_structure_version;
    return 0i64;
  }
LABEL_4:
  v3 = f->stream;
  if ( v3 )
  {
    if ( v3 < f->stream_end )
    {
      v4 = *v3;
      f->stream = v3 + 1;
      goto LABEL_14;
    }
  }
  else
  {
    v8 = fgetc(f->f);
    v4 = v8;
    if ( v8 != -1 )
      goto LABEL_14;
  }
  v4 = 0;
  f->eof = 1;
LABEL_14:
  f->page_flag = v4;
  v9 = get32(f);
  v10 = get32(f);
  get32(f);
  f->last_page = get32(f);
  get32(f);
  v11 = f->stream;
  if ( v11 )
  {
    if ( v11 < f->stream_end )
    {
      v12 = *v11;
      f->stream = v11 + 1;
      goto LABEL_19;
    }
  }
  else
  {
    v13 = fgetc(f->f);
    v12 = v13;
    if ( v13 != -1 )
      goto LABEL_19;
  }
  v12 = 0;
  f->eof = 1;
LABEL_19:
  segments = f->segments;
  f->segment_count = v12;
  if ( (unsigned int)getn(f, f->segments, v12) )
  {
    f->end_seg_with_known_loc = -2;
    if ( v9 != -1 || v10 != -1 )
    {
      v15 = f->segment_count - 1;
      for ( i = v15; i >= 0; --i )
      {
        if ( segments[i] != 0xFF )
          break;
        --v15;
      }
      if ( v15 >= 0 )
      {
        f->end_seg_with_known_loc = v15;
        f->known_loc_for_packet = v9;
      }
    }
    if ( f->first_decode )
    {
      segment_count = f->segment_count;
      v18 = 0;
      if ( segment_count > 0 )
      {
        v19 = (unsigned int)segment_count;
        do
        {
          v20 = *segments++;
          v18 += v20;
          --v19;
        }
        while ( v19 );
      }
      LODWORD(v21) = f->first_audio_page_offset;
      *((_QWORD *)&v21 + 1) = (unsigned int)v21;
      DWORD1(v21) = segment_count + v21 + 27 + v18;
      *(_OWORD *)&f->p_first.page_start = v21;
      f->p_first.last_decoded_sample = v9;
    }
    f->next_seg = 0;
    return 1i64;
  }
  else
  {
    f->error = VORBIS_unexpected_eof;
    return 0i64;
  }
}

__int64 __fastcall uint32_compare(const void *p, const void *q)
{
  if ( *(_DWORD *)p >= *(_DWORD *)q )
    return *(_DWORD *)p > *(_DWORD *)q;
  else
    return 0xFFFFFFFFi64;
}

__int64 __fastcall vorbis_decode_initial(
        stb_vorbis *f,
        int *p_left_start,
        int *p_left_end,
        int *p_right_start,
        int *p_right_end,
        int *mode)
{
  int valid_bits; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v12; // cl
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  char acc; // cl
  unsigned __int8 *v18; // rax
  unsigned __int8 v19; // cl
  int v20; // eax
  __int64 result; // rax
  int v22; // eax
  int bits; // eax
  Mode *v24; // r14
  int blocksize_1; // edi
  int v26; // esi
  int v27; // er9
  unsigned __int8 blockflag; // r8
  int v29; // edx
  int blocksize_0; // ecx
  int v31; // ecx

  *(_QWORD *)&f->channel_buffer_start = 0i64;
  if ( f->eof )
    return 0i64;
  while ( 1 )
  {
    if ( !maybe_start_packet(f) )
      return 0i64;
    valid_bits = f->valid_bits;
    if ( valid_bits < 0 )
      break;
    if ( valid_bits < 1 )
    {
      f->acc = 0;
      do
      {
        if ( !f->bytes_in_seg && (f->last_seg || !(unsigned int)next_segment(f)) )
        {
LABEL_32:
          f->valid_bits = -1;
          goto LABEL_33;
        }
        --f->bytes_in_seg;
        ++f->packet_bytes;
        stream = f->stream;
        if ( stream )
        {
          if ( stream < f->stream_end )
          {
            v12 = *stream;
            f->stream = stream + 1;
            goto LABEL_14;
          }
        }
        else
        {
          v13 = fgetc(f->f);
          v12 = v13;
          if ( v13 != -1 )
            goto LABEL_14;
        }
        v12 = 0;
        f->eof = 1;
LABEL_14:
        v14 = v12;
        if ( v12 == -1 )
          goto LABEL_32;
        v15 = f->valid_bits;
        f->acc += v14 << v15;
        f->valid_bits = v15 + 8;
      }
      while ( v15 + 8 < 1 );
    }
    v16 = f->valid_bits;
    if ( v16 < 0 )
      break;
    acc = f->acc;
    f->acc >>= 1;
    f->valid_bits = v16 - 1;
    if ( (acc & 1) == 0 )
      break;
    if ( f->push_mode )
    {
      f->error = VORBIS_bad_packet_type;
      return 0i64;
    }
    while ( f->bytes_in_seg || !f->last_seg && (unsigned int)next_segment(f) )
    {
      --f->bytes_in_seg;
      ++f->packet_bytes;
      v18 = f->stream;
      if ( v18 )
      {
        if ( v18 >= f->stream_end )
          goto LABEL_26;
        v19 = *v18;
        f->stream = v18 + 1;
      }
      else
      {
        v20 = fgetc(f->f);
        v19 = v20;
        if ( v20 == -1 )
        {
LABEL_26:
          v19 = 0;
          f->eof = 1;
        }
      }
      f->valid_bits = 0;
      if ( v19 == -1 )
        goto LABEL_30;
    }
    f->valid_bits = 0;
LABEL_30:
    if ( f->eof )
      return 0i64;
  }
LABEL_33:
  v22 = ilog(f->mode_count - 1);
  bits = get_bits(f, v22);
  if ( bits == -1 || bits >= f->mode_count )
    return 0i64;
  *mode = bits;
  v24 = &f->mode_config[bits];
  if ( v24->blockflag )
  {
    blocksize_1 = f->blocksize_1;
    v26 = get_bits(f, 1);
    v27 = get_bits(f, 1);
  }
  else
  {
    blocksize_1 = f->blocksize_0;
    v27 = 0;
    v26 = 0;
  }
  blockflag = v24->blockflag;
  v29 = blocksize_1 >> 1;
  if ( !v24->blockflag || v26 )
  {
    *p_left_start = 0;
    *p_left_end = v29;
  }
  else
  {
    blocksize_0 = f->blocksize_0;
    *p_left_start = (blocksize_1 - blocksize_0) >> 2;
    *p_left_end = (blocksize_0 + blocksize_1) >> 2;
  }
  if ( !blockflag || v27 )
  {
    result = 1i64;
    *p_right_start = v29;
    *p_right_end = blocksize_1;
  }
  else
  {
    v31 = f->blocksize_0;
    *p_right_start = (3 * blocksize_1 - v31) >> 2;
    *p_right_end = (3 * blocksize_1 + v31) >> 2;
    return 1i64;
  }
  return result;
}

__int64 __fastcall vorbis_decode_packet_rest(
        stb_vorbis *f,
        int *len,
        Mode *m,
        int left_start,
        int left_end,
        int right_start,
        int right_end,
        int *p_left)
{
  int v10; // er12
  int v11; // er15
  Mapping *v12; // r13
  __int64 v13; // r15
  MappingChannel *chan; // rax
  __int64 v15; // rax
  __int64 v16; // rdx
  int valid_bits; // eax
  Floor *v18; // rdx
  unsigned int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  __int16 *v23; // rsi
  int v24; // er14
  __int64 v25; // rdi
  int v26; // eax
  int v27; // eax
  __int16 bits; // ax
  int *v29; // r9
  int v30; // edx
  __int16 *v31; // r8
  unsigned __int8 *partition_class_list; // rcx
  __int64 v33; // r14
  __int64 v34; // r12
  unsigned __int8 v35; // cl
  __int64 v36; // r15
  int v37; // esi
  int v38; // eax
  Codebook *v39; // rdi
  int last_seg; // eax
  unsigned __int8 *stream; // rax
  unsigned __int8 v42; // cl
  int v43; // eax
  int v44; // eax
  int v45; // ecx
  unsigned int acc; // edx
  int v47; // ecx
  bool v48; // sf
  __int64 v49; // r14
  __int64 v50; // r13
  __int64 v51; // rsi
  __int64 v52; // rax
  __int64 v53; // rdx
  int v54; // eax
  Codebook *v55; // rdi
  int v56; // eax
  unsigned __int8 *v57; // rax
  unsigned __int8 v58; // cl
  int v59; // eax
  int v60; // eax
  int v61; // ecx
  unsigned int v62; // er8
  __int64 v63; // rdx
  int v64; // ecx
  unsigned __int64 v65; // rsi
  int v66; // er14
  __int16 *v67; // rdi
  unsigned __int8 *v68; // r13
  __int64 v69; // r15
  __int64 v70; // r12
  int v71; // er11
  int v72; // er9
  int v73; // eax
  int v74; // er11
  __int64 v75; // rcx
  __int64 v76; // rdx
  int v77; // ecx
  __int16 *v78; // rsi
  float **v79; // rax
  __int64 coupling_steps; // r8
  unsigned __int8 *p_angle; // rcx
  __int64 v82; // rdx
  int v83; // edi
  __int64 v84; // r14
  int channels; // esi
  int v86; // er11
  unsigned __int64 v87; // rcx
  int v88; // er10
  int *v89; // r8
  unsigned __int8 *p_mux; // rdx
  float **channel_buffers; // r9
  int v93; // eax
  __int64 v94; // rdi
  __int64 v95; // rsi
  MappingChannel *v96; // rcx
  int v97; // er11
  float *v98; // r8
  float *v99; // r10
  __int64 v100; // rax
  float *v101; // rcx
  signed __int64 v102; // rdx
  unsigned int v103; // eax
  __int64 v104; // r9
  float v105; // xmm0_4
  float v106; // xmm4_4
  float v107; // xmm2_4
  float v108; // xmm3_4
  float v109; // xmm4_4
  float v110; // xmm0_4
  float v111; // xmm2_4
  float v112; // xmm3_4
  float v113; // xmm4_4
  float v114; // xmm0_4
  float v115; // xmm2_4
  float v116; // xmm3_4
  float v117; // xmm4_4
  float v118; // xmm0_4
  float v119; // xmm2_4
  float v120; // xmm3_4
  signed __int64 v121; // r8
  float *v122; // rcx
  __int64 v123; // rdx
  float v124; // xmm0_4
  float v125; // xmm4_4
  float v126; // xmm2_4
  float v127; // xmm3_4
  int v128; // esi
  char *v129; // r14
  float **v130; // rdi
  int v131; // esi
  float **v132; // rdi
  unsigned __int8 *v133; // rax
  unsigned __int8 v134; // cl
  int v135; // eax
  int v136; // er9
  unsigned int current_loc; // er8
  unsigned int v138; // ecx
  int discard_samples_deferred; // eax
  unsigned int v140; // eax
  int v141; // [rsp+40h] [rbp-C0h]
  Floor *v142; // [rsp+48h] [rbp-B8h]
  unsigned __int8 v143; // [rsp+50h] [rbp-B0h]
  __int16 *v145; // [rsp+58h] [rbp-A8h]
  int v146; // [rsp+60h] [rbp-A0h]
  int v147; // [rsp+64h] [rbp-9Ch]
  __int64 v148; // [rsp+68h] [rbp-98h]
  __int64 v149; // [rsp+70h] [rbp-90h]
  int v150; // [rsp+78h] [rbp-88h]
  int v151; // [rsp+7Ch] [rbp-84h]
  int v152; // [rsp+80h] [rbp-80h]
  unsigned __int8 *v154; // [rsp+90h] [rbp-70h]
  Mapping *v155; // [rsp+98h] [rbp-68h]
  int Src[256]; // [rsp+B0h] [rbp-50h] BYREF
  char v158[1024]; // [rsp+4B0h] [rbp+3B0h] BYREF
  float *residue_buffers[32]; // [rsp+8B0h] [rbp+7B0h] BYREF
  unsigned __int8 do_not_decode[256]; // [rsp+9B0h] [rbp+8B0h] BYREF

  memset(Src, 0, sizeof(Src));
  v147 = 0;
  v10 = f->blocksize[m->blockflag];
  v11 = v10 >> 1;
  v152 = v10;
  v151 = v10 >> 1;
  v12 = &f->mapping[m->mapping];
  v155 = v12;
  if ( f->channels > 0 )
  {
    v13 = 0i64;
    v149 = 0i64;
    while ( 1 )
    {
      chan = v12->chan;
      Src[v13] = 0;
      v15 = v12->submap_floor[chan[v13].mux];
      if ( !f->floor_types[v15] )
      {
        f->error = VORBIS_invalid_stream;
        return 0i64;
      }
      v16 = v15;
      valid_bits = f->valid_bits;
      v18 = &f->floor_config[v16];
      v142 = v18;
      if ( valid_bits >= 0 )
      {
        if ( valid_bits >= 1 )
        {
LABEL_10:
          v22 = f->valid_bits;
          if ( v22 >= 0 )
          {
            v19 = f->acc & 1;
            f->acc >>= 1;
            f->valid_bits = v22 - 1;
          }
          else
          {
            v19 = 0;
          }
          v18 = v142;
        }
        else
        {
          f->acc = 0;
          while ( 1 )
          {
            v20 = get8_packet_raw(f);
            if ( v20 == -1 )
              break;
            v21 = f->valid_bits;
            f->acc += v20 << v21;
            f->valid_bits = v21 + 8;
            if ( v21 + 8 >= 1 )
              goto LABEL_10;
          }
          v18 = v142;
          f->valid_bits = -1;
          v19 = 0;
        }
      }
      else
      {
        v19 = 0;
      }
      if ( !v19 )
        goto $error;
      v23 = f->finalY[v13];
      v146 = 2;
      v145 = v23;
      v24 = range_list[v18->floor1.floor1_multiplier - 1];
      v25 = 2i64;
      v148 = 2i64;
      v150 = v24;
      v26 = ilog(v24);
      *v23 = get_bits(f, v26 - 1);
      v27 = ilog(v24);
      bits = get_bits(f, v27 - 1);
      v29 = (int *)v142;
      v23[1] = bits;
      v30 = 0;
      v31 = v23;
      v141 = 0;
      if ( !v142->floor0.order )
        goto LABEL_71;
      partition_class_list = v142->floor1.partition_class_list;
      v154 = v142->floor1.partition_class_list;
      do
      {
        v33 = *partition_class_list;
        LODWORD(v34) = 0;
        v35 = *((_BYTE *)v29 + v33 + 49);
        v36 = *((unsigned __int8 *)v29 + v33 + 33);
        v37 = (1 << v35) - 1;
        v143 = v35;
        if ( v35 )
        {
          v38 = f->valid_bits;
          v39 = &f->codebooks[*((unsigned __int8 *)v29 + v33 + 65)];
          if ( v38 <= 9 )
          {
            if ( !v38 )
              f->acc = 0;
            while ( 1 )
            {
              last_seg = f->last_seg;
              if ( last_seg && !f->bytes_in_seg || !f->bytes_in_seg && (last_seg || !(unsigned int)next_segment(f)) )
                break;
              --f->bytes_in_seg;
              ++f->packet_bytes;
              stream = f->stream;
              if ( stream )
              {
                if ( stream < f->stream_end )
                {
                  v42 = *stream;
                  f->stream = stream + 1;
                  goto LABEL_32;
                }
              }
              else
              {
                v43 = fgetc(f->f);
                v42 = v43;
                if ( v43 != -1 )
                  goto LABEL_32;
              }
              v42 = 0;
              f->eof = 1;
LABEL_32:
              v44 = v42;
              if ( v42 != -1 )
              {
                v45 = f->valid_bits;
                f->acc += v44 << v45;
                f->valid_bits = v45 + 8;
                if ( v45 + 8 <= 24 )
                  continue;
              }
              break;
            }
          }
          acc = f->acc;
          v34 = v39->fast_huffman[acc & 0x3FF];
          if ( (int)v34 < 0 )
          {
            LODWORD(v34) = codebook_decode_scalar_raw(f, v39);
          }
          else
          {
            v47 = v39->codeword_lengths[v34];
            v48 = f->valid_bits - v47 < 0;
            f->valid_bits -= v47;
            f->acc = acc >> v47;
            if ( v48 )
            {
              f->valid_bits = 0;
              LODWORD(v34) = -1;
            }
          }
          v31 = v145;
          v29 = (int *)v142;
          v30 = v141;
          if ( v39->sparse )
            LODWORD(v34) = v39->sorted_values[(int)v34];
          v35 = v143;
          v25 = v148;
        }
        if ( !(_DWORD)v36 )
          goto LABEL_69;
        v49 = 4 * v33;
        v146 += v36;
        v50 = v37;
        v51 = v36;
        do
        {
          v52 = v50 & (int)v34;
          LODWORD(v34) = (int)v34 >> v35;
          v53 = *((__int16 *)&v29[v49 + 20] + v52 + 1);
          if ( (int)v53 < 0 )
          {
            v31[v25] = 0;
          }
          else
          {
            v54 = f->valid_bits;
            v55 = &f->codebooks[v53];
            if ( v54 <= 9 )
            {
              if ( !v54 )
                f->acc = 0;
              while ( 1 )
              {
                v56 = f->last_seg;
                if ( v56 && !f->bytes_in_seg || !f->bytes_in_seg && (v56 || !(unsigned int)next_segment(f)) )
                  break;
                --f->bytes_in_seg;
                ++f->packet_bytes;
                v57 = f->stream;
                if ( v57 )
                {
                  if ( v57 < f->stream_end )
                  {
                    v58 = *v57;
                    f->stream = v57 + 1;
                    goto LABEL_57;
                  }
                }
                else
                {
                  v59 = fgetc(f->f);
                  v58 = v59;
                  if ( v59 != -1 )
                    goto LABEL_57;
                }
                v58 = 0;
                f->eof = 1;
LABEL_57:
                v60 = v58;
                if ( v58 != -1 )
                {
                  v61 = f->valid_bits;
                  f->acc += v60 << v61;
                  f->valid_bits = v61 + 8;
                  if ( v61 + 8 <= 24 )
                    continue;
                }
                break;
              }
            }
            v62 = f->acc;
            v63 = v55->fast_huffman[v62 & 0x3FF];
            if ( (int)v63 < 0 )
            {
              LODWORD(v63) = codebook_decode_scalar_raw(f, v55);
            }
            else
            {
              v64 = v55->codeword_lengths[v63];
              v48 = f->valid_bits - v64 < 0;
              f->valid_bits -= v64;
              f->acc = v62 >> v64;
              if ( v48 )
              {
                f->valid_bits = 0;
                LODWORD(v63) = -1;
              }
            }
            if ( v55->sparse )
              LODWORD(v63) = v55->sorted_values[(int)v63];
            v25 = v148;
            v31 = v145;
            v29 = (int *)v142;
            v35 = v143;
            v145[v148] = v63;
          }
          v148 = ++v25;
          --v51;
        }
        while ( v51 );
        v30 = v141;
LABEL_69:
        ++v30;
        partition_class_list = v154 + 1;
        v141 = v30;
        ++v154;
      }
      while ( v30 < *(unsigned __int8 *)v29 );
      v13 = v149;
LABEL_71:
      if ( f->valid_bits == -1 )
      {
$error:
        Src[v13] = 1;
      }
      else
      {
        v65 = 2i64;
        LOWORD(residue_buffers[0]) = 257;
        v66 = 2;
        if ( v29[398] > 2 )
        {
          v67 = v31 + 2;
          v68 = (unsigned __int8 *)((char *)v29 - (char *)v31);
          while ( 1 )
          {
            v69 = v68[(_QWORD)v67 + 1088];
            v70 = v68[(_QWORD)v67 + 1089];
            v71 = v31[v69];
            v72 = *((unsigned __int16 *)v29 + v69 + 169);
            v73 = (int)((*(unsigned __int16 *)&v68[(_QWORD)v67 + 338] - v72) * abs32(v31[v70] - v71))
                / (v142->floor1.Xlist[v70] - v72);
            if ( v31[v70] - v71 >= 0 )
              v74 = v73 + v71;
            else
              v74 = v71 - v73;
            v75 = (unsigned int)*v67;
            v76 = (unsigned int)(2 * (v150 - v74));
            if ( v150 - v74 >= v74 )
              v76 = (unsigned int)(2 * v74);
            if ( !*v67 )
              break;
            *((_BYTE *)residue_buffers + v70) = 1;
            *((_BYTE *)residue_buffers + v69) = 1;
            *((_BYTE *)residue_buffers + v65) = 1;
            if ( (int)v75 >= (int)v76 )
            {
              if ( v150 - v74 <= v74 )
                *v67 = v150 - v75 - 1;
              else
                *v67 = v75;
              goto LABEL_90;
            }
            if ( (v75 & 1) != 0 )
            {
              LOWORD(v74) = v74 - (((int)v75 + 1) >> 1);
LABEL_89:
              *v67 = v74;
              goto LABEL_90;
            }
            *v67 = v74 + ((int)v75 >> 1);
LABEL_90:
            v29 = (int *)v142;
            ++v66;
            v31 = v145;
            ++v65;
            ++v67;
            if ( v66 >= v142->floor1.values )
              goto LABEL_91;
          }
          if ( v65 >= 0x100 )
          {
            _report_rangecheckfailure(v75, v76);
            __debugbreak();
          }
          *((_BYTE *)residue_buffers + v65) = 0;
          goto LABEL_89;
        }
LABEL_91:
        v77 = 0;
        if ( v29[398] > 0 )
        {
          v78 = v145;
          v79 = residue_buffers;
          do
          {
            if ( !*(_BYTE *)v79 )
              *v78 = -1;
            ++v77;
            v79 = (float **)((char *)v79 + 1);
            ++v78;
          }
          while ( v77 < v29[398] );
        }
        v13 = v149;
      }
      ++v13;
      v12 = v155;
      ++v147;
      v149 = v13;
      if ( v147 >= f->channels )
      {
        v11 = v151;
        v10 = v152;
        break;
      }
    }
  }
  memmove(v158, Src, 4i64 * f->channels);
  if ( v12->coupling_steps )
  {
    coupling_steps = v12->coupling_steps;
    p_angle = &v12->chan->angle;
    do
    {
      v82 = *(p_angle - 1);
      if ( !Src[v82] || !Src[*p_angle] )
      {
        Src[*p_angle] = 0;
        Src[v82] = 0;
      }
      p_angle += 3;
      --coupling_steps;
    }
    while ( coupling_steps );
  }
  v83 = 0;
  if ( v12->submaps )
  {
    v84 = 0i64;
    do
    {
      channels = f->channels;
      v86 = 0;
      v87 = 0i64;
      v88 = 0;
      if ( channels > 0 )
      {
        v89 = Src;
        p_mux = &v12->chan->mux;
        channel_buffers = f->channel_buffers;
        do
        {
          if ( *p_mux == v83 )
          {
            if ( *v89 )
            {
              do_not_decode[v87] = 1;
              residue_buffers[v87] = 0i64;
            }
            else
            {
              if ( v87 >= 0x100 )
              {
                _report_rangecheckfailure(v87, p_mux);
                JUMPOUT(0x1400400BDi64);
              }
              residue_buffers[v87] = *channel_buffers;
              do_not_decode[v87] = 0;
            }
            ++v86;
            ++v87;
          }
          ++v88;
          ++channel_buffers;
          p_mux += 3;
          ++v89;
        }
        while ( v88 < channels );
      }
      decode_residue(f, residue_buffers, v86, v11, v12->submap_residue[v84], do_not_decode);
      ++v83;
      ++v84;
    }
    while ( v83 < v12->submaps );
  }
  v93 = v12->coupling_steps - 1;
  v94 = v93;
  if ( v93 >= 0 )
  {
    v95 = v93;
    while ( 1 )
    {
      v96 = v12->chan;
      v97 = 0;
      v98 = f->channel_buffers[v96[v95].magnitude];
      v99 = f->channel_buffers[v96[v95].angle];
      v100 = 0i64;
      if ( v11 >= 4 )
      {
        v101 = v99 + 1;
        v102 = (char *)v98 - (char *)v99;
        v103 = ((unsigned int)(v11 - 4) >> 2) + 1;
        v104 = v103;
        v97 = 4 * v103;
        v100 = 4i64 * v103;
        do
        {
          v105 = *(float *)((char *)v101 + v102 - 4);
          v106 = *(v101 - 1);
          if ( v105 <= 0.0 )
          {
            v107 = *(float *)((char *)v101 + v102 - 4);
            if ( v106 > 0.0 )
            {
              v108 = v106 + v105;
              goto LABEL_131;
            }
            v107 = v105 - v106;
          }
          else if ( v106 <= 0.0 )
          {
            v107 = v106 + v105;
          }
          else
          {
            v107 = *(float *)((char *)v101 + v102 - 4);
            v105 = v105 - v106;
          }
          v108 = v105;
LABEL_131:
          *(float *)((char *)v101 + v102 - 4) = v107;
          v109 = *v101;
          *(v101 - 1) = v108;
          v110 = *(float *)((char *)v101 + v102);
          v111 = v110;
          if ( v110 <= 0.0 )
          {
            if ( v109 > 0.0 )
            {
              v112 = v110 + v109;
              goto LABEL_139;
            }
            v111 = v110 - v109;
          }
          else if ( v109 <= 0.0 )
          {
            v111 = v110 + v109;
          }
          else
          {
            v110 = v110 - v109;
          }
          v112 = v110;
LABEL_139:
          *(float *)((char *)v101 + v102) = v111;
          v113 = v101[1];
          *v101 = v112;
          v114 = *(float *)((char *)v101 + v102 + 4);
          if ( v114 <= 0.0 )
          {
            v115 = *(float *)((char *)v101 + v102 + 4);
            if ( v113 > 0.0 )
            {
              v116 = v113 + v114;
              goto LABEL_147;
            }
            v115 = v114 - v113;
          }
          else if ( v113 <= 0.0 )
          {
            v115 = v113 + v114;
          }
          else
          {
            v115 = *(float *)((char *)v101 + v102 + 4);
            v114 = v114 - v113;
          }
          v116 = v114;
LABEL_147:
          *(float *)((char *)v101 + v102 + 4) = v115;
          v117 = v101[2];
          v101[1] = v116;
          v118 = *(float *)((char *)v101 + v102 + 8);
          if ( v118 > 0.0 )
          {
            if ( v117 <= 0.0 )
            {
              v119 = v117 + v118;
            }
            else
            {
              v119 = *(float *)((char *)v101 + v102 + 8);
              v118 = v118 - v117;
            }
            goto LABEL_154;
          }
          v119 = *(float *)((char *)v101 + v102 + 8);
          if ( v117 <= 0.0 )
          {
            v119 = v118 - v117;
LABEL_154:
            v120 = v118;
            goto LABEL_155;
          }
          v120 = v117 + v118;
LABEL_155:
          *(float *)((char *)v101 + v102 + 8) = v119;
          v101[2] = v120;
          v101 += 4;
          --v104;
        }
        while ( v104 );
      }
      if ( v97 < v11 )
        break;
LABEL_167:
      --v95;
      if ( --v94 < 0 )
        goto LABEL_168;
    }
    v121 = (char *)v98 - (char *)v99;
    v122 = &v99[v100];
    v123 = (unsigned int)(v11 - v97);
    while ( 1 )
    {
      v124 = *(float *)((char *)v122 + v121);
      v125 = *v122;
      v126 = v124;
      if ( v124 > 0.0 )
        break;
      if ( v125 <= 0.0 )
      {
        v126 = v124 - v125;
LABEL_165:
        v127 = v124;
        goto LABEL_166;
      }
      v127 = v124 + v125;
LABEL_166:
      *(float *)((char *)v122 + v121) = v126;
      *v122++ = v127;
      if ( !--v123 )
        goto LABEL_167;
    }
    if ( v125 <= 0.0 )
      v126 = v124 + v125;
    else
      v124 = v124 - v125;
    goto LABEL_165;
  }
LABEL_168:
  v128 = 0;
  if ( f->channels > 0 )
  {
    v129 = v158;
    v130 = f->channel_buffers;
    do
    {
      if ( *(_DWORD *)v129 )
        memset(*v130, 0, 4i64 * v11);
      else
        do_floor(f, v12, v128, v10, *v130, (__int16 *)v130[49]);
      ++v128;
      ++v130;
      v129 += 4;
    }
    while ( v128 < f->channels );
  }
  v131 = 0;
  if ( f->channels > 0 )
  {
    v132 = f->channel_buffers;
    do
    {
      inverse_mdct(*v132, v10, f, m->blockflag);
      ++v131;
      ++v132;
    }
    while ( v131 < f->channels );
  }
  while ( f->bytes_in_seg || !f->last_seg && (unsigned int)next_segment(f) )
  {
    --f->bytes_in_seg;
    ++f->packet_bytes;
    v133 = f->stream;
    if ( v133 )
    {
      if ( v133 >= f->stream_end )
        goto LABEL_184;
      v134 = *v133;
      f->stream = v133 + 1;
    }
    else
    {
      v135 = fgetc(f->f);
      v134 = v135;
      if ( v135 == -1 )
      {
LABEL_184:
        v134 = 0;
        f->eof = 1;
      }
    }
    if ( v134 == -1 )
      break;
  }
  if ( f->first_decode )
  {
    f->current_loc_valid = 1;
    f->first_decode = 0;
    f->current_loc = -v11;
    f->discard_samples_deferred = v10 - right_end;
    goto LABEL_188;
  }
  discard_samples_deferred = f->discard_samples_deferred;
  if ( discard_samples_deferred )
  {
    v136 = discard_samples_deferred + left_start;
    *p_left = discard_samples_deferred + left_start;
    f->discard_samples_deferred = 0;
  }
  else
  {
LABEL_188:
    v136 = left_start;
  }
  if ( f->last_seg_which == f->end_seg_with_known_loc )
  {
    if ( f->current_loc_valid )
    {
      if ( (f->page_flag & 4) != 0 )
      {
        current_loc = f->current_loc;
        v138 = right_end + f->known_loc_for_packet - v10;
        if ( v138 < current_loc + right_end )
        {
          if ( v138 >= current_loc )
            *len = v138 - current_loc;
          else
            *len = 0;
          *len += v136;
          f->current_loc += *len;
          return 1i64;
        }
      }
    }
    v140 = f->known_loc_for_packet - v11;
    f->current_loc_valid = 1;
    f->current_loc = v136 + v140;
  }
  if ( f->current_loc_valid )
    f->current_loc += right_start - v136;
  *len = right_end;
  return 1i64;
}

void __fastcall vorbis_deinit(stb_vorbis *p)
{
  int v2; // ebp
  int v3; // er15
  __int64 v4; // r12
  Residue *v5; // rdi
  int v6; // er14
  __int64 v7; // rsi
  int v8; // esi
  __int64 v9; // r14
  Codebook *v10; // rdi
  int *sorted_values; // rax
  int *v12; // rcx
  int v13; // edi
  __int64 v14; // rsi
  void **previous_window; // rdi
  void **B; // rdi
  __int64 v17; // rsi

  v2 = 0;
  v3 = 0;
  if ( p->residue_count > 0 )
  {
    v4 = 0i64;
    do
    {
      v5 = &p->residue_config[v4];
      if ( v5->classdata )
      {
        v6 = 0;
        if ( p->codebooks[v5->classbook].entries > 0 )
        {
          v7 = 0i64;
          do
          {
            if ( !p->alloc.alloc_buffer )
              free(v5->classdata[v7]);
            ++v6;
            ++v7;
          }
          while ( v6 < p->codebooks[v5->classbook].entries );
        }
        if ( p->alloc.alloc_buffer )
          goto LABEL_13;
        free(v5->classdata);
      }
      if ( !p->alloc.alloc_buffer )
        free(v5->residue_books);
LABEL_13:
      ++v3;
      ++v4;
    }
    while ( v3 < p->residue_count );
  }
  if ( p->codebooks )
  {
    v8 = 0;
    if ( p->codebook_count > 0 )
    {
      v9 = 0i64;
      do
      {
        v10 = &p->codebooks[v9];
        if ( !p->alloc.alloc_buffer )
        {
          free(v10->codeword_lengths);
          if ( !p->alloc.alloc_buffer )
          {
            free(v10->multiplicands);
            if ( !p->alloc.alloc_buffer )
            {
              free(v10->codewords);
              if ( !p->alloc.alloc_buffer )
                free(v10->sorted_codewords);
            }
          }
        }
        sorted_values = v10->sorted_values;
        v12 = sorted_values - 1;
        if ( !sorted_values )
          v12 = 0i64;
        if ( !p->alloc.alloc_buffer )
          free(v12);
        ++v8;
        ++v9;
      }
      while ( v8 < p->codebook_count );
    }
    if ( !p->alloc.alloc_buffer )
      free(p->codebooks);
  }
  if ( !p->alloc.alloc_buffer )
  {
    free(p->floor_config);
    if ( !p->alloc.alloc_buffer )
      free(p->residue_config);
  }
  v13 = 0;
  if ( p->mapping_count > 0 )
  {
    v14 = 0i64;
    do
    {
      if ( !p->alloc.alloc_buffer )
        free(p->mapping[v14].chan);
      ++v13;
      ++v14;
    }
    while ( v13 < p->mapping_count );
  }
  if ( !p->alloc.alloc_buffer )
    free(p->mapping);
  if ( p->channels > 0 )
  {
    previous_window = (void **)p->previous_window;
    do
    {
      if ( !p->alloc.alloc_buffer )
      {
        free(*(previous_window - 32));
        if ( !p->alloc.alloc_buffer )
        {
          free(*previous_window);
          if ( !p->alloc.alloc_buffer )
            free(previous_window[17]);
        }
      }
      ++v2;
      ++previous_window;
    }
    while ( v2 < p->channels );
  }
  B = (void **)p->B;
  v17 = 2i64;
  do
  {
    if ( !p->alloc.alloc_buffer )
    {
      free(*(B - 2));
      if ( !p->alloc.alloc_buffer )
      {
        free(*B);
        if ( !p->alloc.alloc_buffer )
        {
          free(B[2]);
          if ( !p->alloc.alloc_buffer )
          {
            free(B[4]);
            if ( !p->alloc.alloc_buffer )
              free(B[6]);
          }
        }
      }
    }
    ++B;
    --v17;
  }
  while ( v17 );
  if ( p->close_on_free )
    fclose(p->f);
  free(p);
}

__int64 __fastcall vorbis_find_page(stb_vorbis *f, unsigned int *end, unsigned int *last)
{
  unsigned int v5; // er12
  unsigned __int8 *stream; // rax
  unsigned __int8 v7; // cl
  unsigned int v8; // er15
  int v9; // eax
  int v10; // esi
  __int64 v11; // rdi
  unsigned __int8 *v12; // rax
  unsigned __int8 v13; // cl
  int v14; // eax
  char *v15; // rdi
  __int64 v16; // rsi
  unsigned __int8 *v17; // rax
  unsigned __int8 v18; // cl
  int v19; // eax
  __int64 v20; // rcx
  int v21; // er14
  unsigned __int64 v22; // rax
  unsigned int v23; // edi
  char *v24; // r9
  __int64 v25; // r10
  __int64 v26; // rcx
  unsigned int v27; // edx
  __int64 v28; // rsi
  __int64 v29; // rbp
  unsigned __int8 *v30; // rax
  unsigned __int8 v31; // cl
  int v32; // eax
  unsigned __int8 *v33; // rax
  unsigned __int8 v34; // dl
  int v35; // eax
  int v38; // [rsp+28h] [rbp-60h] BYREF
  char v39[22]; // [rsp+2Ch] [rbp-5Ch] BYREF
  unsigned __int8 v40; // [rsp+42h] [rbp-46h]

  if ( f->eof )
    return 0i64;
  v5 = 0;
  while ( 1 )
  {
    stream = f->stream;
    if ( !stream )
      break;
    if ( stream < f->stream_end )
    {
      v7 = *stream;
      f->stream = stream + 1;
      goto LABEL_7;
    }
    f->eof = 1;
LABEL_58:
    if ( f->eof )
      return 0i64;
  }
  v9 = fgetc(f->f);
  v7 = v9;
  if ( v9 == -1 )
  {
    f->eof = 1;
    goto LABEL_58;
  }
LABEL_7:
  if ( v7 != 79 )
    goto LABEL_58;
  if ( f->push_mode )
  {
    v8 = 0;
  }
  else if ( f->stream )
  {
    v8 = LODWORD(f->stream) - LODWORD(f->stream_start);
  }
  else
  {
    v8 = ftell(f->f) - f->f_start;
  }
  if ( v8 - 25 > f->stream_len )
    return 0i64;
  v10 = 1;
  v11 = 1i64;
  while ( 2 )
  {
    v12 = f->stream;
    if ( !v12 )
    {
      v14 = fgetc(f->f);
      v13 = v14;
      if ( v14 != -1 )
        goto LABEL_22;
LABEL_21:
      v13 = 0;
      f->eof = 1;
      goto LABEL_22;
    }
    if ( v12 >= f->stream_end )
      goto LABEL_21;
    v13 = *v12;
    f->stream = v12 + 1;
LABEL_22:
    if ( v13 == ogg_page_header[v11] )
    {
      ++v10;
      if ( ++v11 < 4 )
        continue;
    }
    break;
  }
  if ( f->eof )
    return 0i64;
  if ( v10 != 4 )
    goto $invalid;
  v15 = v39;
  v38 = *(_DWORD *)ogg_page_header;
  v16 = 23i64;
  while ( 2 )
  {
    v17 = f->stream;
    if ( v17 )
    {
      if ( v17 < f->stream_end )
      {
        v18 = *v17;
        f->stream = v17 + 1;
        goto LABEL_32;
      }
LABEL_31:
      v18 = 0;
      f->eof = 1;
    }
    else
    {
      v19 = fgetc(f->f);
      v18 = v19;
      if ( v19 == -1 )
        goto LABEL_31;
    }
LABEL_32:
    *v15++ = v18;
    if ( --v16 )
      continue;
    break;
  }
  if ( f->eof )
    return 0i64;
  if ( v39[0] )
  {
$invalid:
    set_file_offset(f, v8);
    goto LABEL_58;
  }
  v20 = 22i64;
  v21 = (unsigned __int8)v39[18]
      + ((unsigned __int8)v39[21] << 24)
      + ((unsigned __int8)v39[20] << 16)
      + ((unsigned __int8)v39[19] << 8);
  v22 = 22i64;
  do
  {
    if ( v22 >= 0x1B )
    {
      _report_rangecheckfailure(v20, end);
      JUMPOUT(0x1400424E6i64);
    }
    v39[v22 - 4] = 0;
    v20 = (unsigned int)(v20 + 1);
    ++v22;
  }
  while ( (unsigned int)v20 < 0x1A );
  v23 = 0;
  v24 = (char *)&v38 + 1;
  v25 = 9i64;
  do
  {
    v26 = (unsigned __int8)*(v24 - 1);
    v24 += 3;
    v27 = (((v23 << 8) ^ crc_table[((unsigned __int64)v23 >> 24) ^ v26]) << 8) ^ crc_table[(unsigned __int8)*(v24 - 3) ^ ((unsigned __int64)((v23 << 8) ^ crc_table[((unsigned __int64)v23 >> 24) ^ v26]) >> 24)];
    v23 = (v27 << 8) ^ crc_table[((unsigned __int64)v27 >> 24) ^ (unsigned __int8)*(v24 - 2)];
    --v25;
  }
  while ( v25 );
  LODWORD(v28) = 0;
  if ( !v40 )
    goto LABEL_56;
  v29 = v40;
  do
  {
    v30 = f->stream;
    if ( v30 )
    {
      if ( v30 < f->stream_end )
      {
        v31 = *v30;
        f->stream = v30 + 1;
        goto LABEL_47;
      }
    }
    else
    {
      v32 = fgetc(f->f);
      v31 = v32;
      if ( v32 != -1 )
        goto LABEL_47;
    }
    v31 = 0;
    f->eof = 1;
LABEL_47:
    v28 = v31 + (unsigned int)v28;
    v23 = (v23 << 8) ^ crc_table[v31 ^ ((unsigned __int64)v23 >> 24)];
    --v29;
  }
  while ( v29 );
  if ( !(_DWORD)v28 )
  {
LABEL_56:
    if ( v23 != v21 )
      goto $invalid;
    if ( end )
    {
      if ( !f->push_mode )
      {
        if ( f->stream )
          v5 = LODWORD(f->stream) - LODWORD(f->stream_start);
        else
          v5 = ftell(f->f) - f->f_start;
      }
      *end = v5;
    }
    if ( last )
      *last = ((unsigned __int8)v39[1] >> 2) & 1;
    set_file_offset(f, v8 - 1);
    return 1i64;
  }
  if ( !f->eof )
  {
    while ( 1 )
    {
      v33 = f->stream;
      if ( v33 )
      {
        if ( v33 >= f->stream_end )
          goto LABEL_54;
        v34 = *v33;
        f->stream = v33 + 1;
      }
      else
      {
        v35 = fgetc(f->f);
        v34 = v35;
        if ( v35 == -1 )
        {
LABEL_54:
          v34 = 0;
          f->eof = 1;
        }
      }
      v23 = (v23 << 8) ^ crc_table[v34 ^ ((unsigned __int64)v23 >> 24)];
      if ( !--v28 )
        goto LABEL_56;
    }
  }
  return 0i64;
}

__int64 __fastcall vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
{
  int v4; // er13
  int v5; // er14
  int v6; // er11
  int previous_length; // eax
  int v9; // edi
  int v10; // er12
  float **channel_buffers; // r14
  __int64 v12; // r15
  __int64 v13; // rsi
  float *v14; // rdx
  float *v15; // r9
  float *v16; // r8
  __int64 v17; // rbx
  __int64 v18; // rbp
  __int64 v19; // rax
  char *v20; // rcx
  char *v21; // rdx
  unsigned __int64 v22; // rax
  float v23; // xmm2_4
  float *v24; // rdx
  float *v25; // r8
  __int64 v26; // r9
  __int64 v27; // rbx
  __int64 v28; // rax
  float v29; // xmm1_4
  int v30; // ebp
  __int64 v31; // rbx
  float *v32; // rdx
  int v33; // er8
  char *v34; // r9
  float *v36; // [rsp+60h] [rbp+8h]

  v4 = right;
  v5 = left;
  v6 = len;
  previous_length = f->previous_length;
  v9 = 0;
  if ( previous_length )
  {
    if ( 2 * previous_length == f->blocksize_0 )
      v36 = f->window[0];
    else
      v36 = 2 * previous_length == f->blocksize_1 ? f->window[1] : 0i64;
    v10 = 0;
    if ( f->channels > 0 )
    {
      channel_buffers = f->channel_buffers;
      v12 = f->previous_length;
      do
      {
        v13 = 0i64;
        if ( v12 >= 4 )
        {
          v14 = channel_buffers[32];
          v15 = &v36[v12 - 2];
          v16 = &(*channel_buffers)[left + 1];
          v17 = (char *)&v14[-left] - (char *)*channel_buffers;
          v18 = (char *)&v36[-left] - (char *)*channel_buffers;
          v19 = 4 * (2i64 - left) - (_QWORD)*channel_buffers;
          v20 = (char *)v14 + v19;
          v21 = (char *)v36 + v19;
          v22 = ((unsigned __int64)(v12 - 4) >> 2) + 1;
          v13 = 4 * v22;
          do
          {
            *(v16 - 1) = (float)(*(float *)((char *)v16 + v17 - 4) * v15[1])
                       + (float)(*(float *)((char *)v16 + v18 - 4) * *(v16 - 1));
            *v16 = (float)(*(float *)((char *)v16 + v17) * *v15) + (float)(*(float *)((char *)v16 + v18) * *v16);
            v16[1] = (float)(*(float *)((char *)v16 + v17 + 4) * *(v15 - 1))
                   + (float)(*(float *)((char *)v16 + v18 + 4) * v16[1]);
            v23 = *(float *)&v20[(_QWORD)v16] * *(v15 - 2);
            v15 -= 4;
            v16[2] = v23 + (float)(*(float *)((char *)v16 + (_QWORD)v21) * v16[2]);
            v16 += 4;
            --v22;
          }
          while ( v22 );
        }
        if ( v13 < v12 )
        {
          v24 = &(*channel_buffers)[left + v13];
          v25 = &v36[v12 - v13 - 1];
          v26 = (char *)&channel_buffers[32][-left] - (char *)*channel_buffers;
          v27 = (char *)&v36[-left] - (char *)*channel_buffers;
          v28 = v12 - v13;
          do
          {
            v29 = *(float *)((char *)v24 + v26) * *v25--;
            *v24 = v29 + (float)(*(float *)((char *)v24 + v27) * *v24);
            ++v24;
            --v28;
          }
          while ( v28 );
        }
        ++v10;
        ++channel_buffers;
      }
      while ( v10 < f->channels );
      v6 = len;
      v4 = right;
      v5 = left;
    }
  }
  v30 = f->previous_length;
  f->previous_length = v6 - v4;
  if ( f->channels > 0 )
  {
    v31 = 0i64;
    do
    {
      if ( v4 < v6 )
      {
        v32 = f->previous_window[v31];
        v33 = v4;
        v34 = (char *)f->channel_buffers[v31] + 4i64 * v4 - (_QWORD)v32;
        do
        {
          ++v33;
          *v32 = *(float *)((char *)v32 + (_QWORD)v34);
          ++v32;
        }
        while ( v33 < v6 );
      }
      ++v9;
      ++v31;
    }
    while ( v9 < f->channels );
  }
  if ( !v30 )
    return 0i64;
  if ( v6 >= v4 )
    v6 = v4;
  f->samples_output += v6 - v5;
  return (unsigned int)(v6 - v5);
}

void __fastcall vorbis_pump_first_frame(stb_vorbis *f)
{
  int v2; // edi
  int v3; // [rsp+20h] [rbp-38h]
  int right; // [rsp+40h] [rbp-18h] BYREF
  int v5[5]; // [rsp+44h] [rbp-14h] BYREF
  int left_start; // [rsp+68h] [rbp+10h] BYREF
  int len; // [rsp+70h] [rbp+18h] BYREF
  int right_end; // [rsp+78h] [rbp+20h] BYREF

  len = 0;
  if ( (unsigned int)vorbis_decode_initial(f, &left_start, v5, &right, &right_end, &len) )
  {
    v2 = right;
    if ( (unsigned int)vorbis_decode_packet_rest(
                         f,
                         &len,
                         &f->mode_config[len],
                         left_start,
                         v3,
                         right,
                         right_end,
                         &left_start) )
      vorbis_finish_frame(f, len, left_start, v2);
  }
}

__int64 __fastcall stb_vorbis_decode_memory_plus(
        unsigned __int8 *mem,
        int len,
        int *channels,
        int *sample,
        int **threadState,
        int *loadCount,
        AgPointer<AgSharedInstance<AgMutex> > *pThreadMutex,
        __int16 **output)
{
  stb_vorbis *v11; // rax
  stb_vorbis *v12; // r14
  unsigned __int64 v13; // r8
  int v14; // er15
  __int16 *v16; // rax
  __int16 *v17; // r13
  char *v18; // rsi
  int error[6]; // [rsp+30h] [rbp-58h] BYREF

  if ( mem && (v11 = stb_vorbis_open_memory(mem, len, error, (_stb_vorbis_alloc *)sample), (v12 = v11) != 0i64) )
  {
    v14 = stb_vorbis_stream_length_in_samples(v11);
    *channels = v12->channels;
    *sample = v12->sample_rate;
    if ( v14 > 0 )
    {
      v16 = (__int16 *)Framework::MemoryManager::allocate(
                         &Framework::GLManager::glm->allocateSound,
                         2i64 * v14 * v12->channels,
                         v13);
      v17 = v16;
      if ( v16 )
      {
        *output = v16;
        v18 = (char *)operator new(0x70ui64);
        *(_QWORD *)v18 = &AgSimpleThreadHost::`vftable';
        *((_DWORD *)v18 + 2) = 0;
        *(_QWORD *)v18 = &oggCallBackInfo::`vftable';
        *((_DWORD *)v18 + 3) = 1;
        *((_QWORD *)v18 + 5) = 0i64;
        *((_QWORD *)v18 + 6) = 0i64;
        AgThread::AgThread((AgThread *)(v18 + 72), NotRunning);
        *((_QWORD *)v18 + 3) = threadState;
        *((_QWORD *)v18 + 4) = loadCount;
        *((_QWORD *)v18 + 2) = v12;
        *((_QWORD *)v18 + 7) = v17;
        *((_QWORD *)v18 + 8) = mem;
        AgPointer<AgSharedInstance<AgMutex>>::operator=(
          (AgPointer<AgSharedInstance<AgMutex> > *)(v18 + 40),
          pThreadMutex);
        AgThread::startDetached((AgThread *)(v18 + 72), (AgIThreadHost *)v18, 0x100000ui64, -1, "OggRead");
        AgPointer<AgSharedInstance<AgMutex>>::~AgPointer<AgSharedInstance<AgMutex>>(pThreadMutex);
        return (unsigned int)v14;
      }
      else
      {
        vorbis_deinit(v12);
        if ( !v12->alloc.alloc_buffer )
          free(v12);
        AgPointer<AgSharedInstance<AgMutex>>::~AgPointer<AgSharedInstance<AgMutex>>(pThreadMutex);
        return 4294967294i64;
      }
    }
    else
    {
      vorbis_deinit(v12);
      if ( !v12->alloc.alloc_buffer )
        free(v12);
      AgPointer<AgSharedInstance<AgMutex>>::~AgPointer<AgSharedInstance<AgMutex>>(pThreadMutex);
      return 4294967294i64;
    }
  }
  else
  {
    AgPointer<AgSharedInstance<AgMutex>>::~AgPointer<AgSharedInstance<AgMutex>>(pThreadMutex);
    return 0xFFFFFFFFi64;
  }
}

__int64 __fastcall stb_vorbis_get_file_offset(stb_vorbis *f)
{
  unsigned __int8 *stream; // rax

  if ( f->push_mode )
    return 0i64;
  stream = f->stream;
  if ( stream )
    return (unsigned int)((_DWORD)stream - LODWORD(f->stream_start));
  else
    return ftell(f->f) - f->f_start;
}

__int64 __fastcall stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)
{
  __int64 result; // rax
  int v6; // edi
  int v7; // esi
  int v8; // er9
  __int64 v9; // rsi
  float **outputs; // r8
  __int64 v11; // rdx
  int p_right_end; // [rsp+20h] [rbp-48h]
  int p_right_start; // [rsp+40h] [rbp-28h] BYREF
  int p_left_end[3]; // [rsp+44h] [rbp-24h] BYREF
  int len; // [rsp+70h] [rbp+8h] BYREF
  int *p_left_start; // [rsp+78h] [rbp+10h] BYREF
  int left_end; // [rsp+88h] [rbp+20h] BYREF

  p_left_start = channels;
  if ( f->push_mode )
  {
    f->error = VORBIS_invalid_api_mixing;
    return 0i64;
  }
  else
  {
    v6 = 0;
    len = 0;
    if ( (unsigned int)vorbis_decode_initial(f, (int *)&p_left_start, p_left_end, &p_right_start, &left_end, &len)
      && (v7 = p_right_start,
          (unsigned int)vorbis_decode_packet_rest(
                          f,
                          &len,
                          &f->mode_config[len],
                          (int)p_left_start,
                          p_right_end,
                          p_right_start,
                          left_end,
                          (int *)&p_left_start)) )
    {
      v8 = v7;
      v9 = (int)p_left_start;
      LODWORD(result) = vorbis_finish_frame(f, len, (int)p_left_start, v8);
      if ( f->channels > 0 )
      {
        outputs = f->outputs;
        do
        {
          v11 = (__int64)*(outputs - 16);
          ++outputs;
          ++v6;
          *(outputs - 1) = (float *)(4 * v9 + v11);
        }
        while ( v6 < f->channels );
      }
      f->channel_buffer_start = v9;
      f->channel_buffer_end = v9 + result;
      if ( output )
        *output = f->outputs;
      return (unsigned int)result;
    }
    else
    {
      *(_QWORD *)&f->channel_buffer_start = 0i64;
      return 0i64;
    }
  }
}

__int64 __fastcall stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int *num_c, __int16 *buffer, int num_shorts)
{
  int v6; // edi
  int samples; // ebx
  int v9; // er8
  int frame_float; // eax
  int data; // [rsp+20h] [rbp-48h]
  int len; // [rsp+28h] [rbp-40h]
  float **output[5]; // [rsp+40h] [rbp-28h] BYREF
  __int16 *buffera; // [rsp+80h] [rbp+18h] BYREF

  buffera = buffer;
  v6 = (int)num_c;
  if ( (_DWORD)num_c == 1 )
  {
    samples = stb_vorbis_get_frame_float(f, num_c, output);
    if ( samples > num_shorts )
      samples = num_shorts;
    if ( samples )
      convert_samples_short(1, &buffera, v9, f->channels, output[0], len, samples);
  }
  else
  {
    frame_float = stb_vorbis_get_frame_float(f, num_c, output);
    samples = frame_float;
    if ( frame_float )
    {
      if ( v6 * frame_float > num_shorts )
        samples = num_shorts / v6;
      convert_channels_short_interleaved(v6, buffer, f->channels, output[0], data, samples);
    }
  }
  return (unsigned int)samples;
}

stb_vorbis *__fastcall stb_vorbis_open_memory(unsigned __int8 *data, int len, int *error, _stb_vorbis_alloc *alloc)
{
  __int64 v5; // rdi
  stb_vorbis *v7; // rbx
  stb_vorbis *v8; // rdx
  stb_vorbis *p_f; // rcx
  __int64 v10; // rax
  __int128 v11; // xmm0
  stb_vorbis f; // [rsp+20h] [rbp-798h] BYREF

  v5 = len;
  memset(&f, 0, sizeof(f));
  f.page_crc_tests = -1;
  *(_QWORD *)&f.eof = 0i64;
  f.codebooks = 0i64;
  f.close_on_free = 0;
  f.f = 0i64;
  f.stream_end = &data[v5];
  f.stream = data;
  f.stream_start = data;
  f.stream_len = v5;
  f.push_mode = 0;
  if ( !start_decoder(&f) )
    goto LABEL_10;
  f.setup_memory_required += 1896;
  if ( f.alloc.alloc_buffer )
  {
    v7 = (stb_vorbis *)&f.alloc.alloc_buffer[f.setup_offset];
    if ( f.setup_offset + 1896 > f.temp_offset )
      goto LABEL_10;
    f.setup_offset += 1896;
  }
  else
  {
    v7 = (stb_vorbis *)malloc(0x768ui64);
  }
  if ( v7 )
  {
    v8 = v7;
    p_f = &f;
    v10 = 14i64;
    do
    {
      v8 = (stb_vorbis *)((char *)v8 + 128);
      v11 = *(_OWORD *)&p_f->sample_rate;
      p_f = (stb_vorbis *)((char *)p_f + 128);
      *(_OWORD *)&v8[-1].last_seg_which = v11;
      *(_OWORD *)&v8[-1].end_seg_with_known_loc = *(_OWORD *)&p_f[-1].end_seg_with_known_loc;
      *(_OWORD *)&v8[-1].page_crc_tests = *(_OWORD *)&p_f[-1].page_crc_tests;
      *(_OWORD *)&v8[-1].scan[0].bytes_done = *(_OWORD *)&p_f[-1].scan[0].bytes_done;
      *(_OWORD *)&v8[-1].scan[1].crc_so_far = *(_OWORD *)&p_f[-1].scan[1].crc_so_far;
      *(_OWORD *)&v8[-1].scan[2].bytes_left = *(_OWORD *)&p_f[-1].scan[2].bytes_left;
      *(_OWORD *)&v8[-1].scan[3].goal_crc = *(_OWORD *)&p_f[-1].scan[3].goal_crc;
      *(_OWORD *)&v8[-1].scan[3].sample_loc = *(_OWORD *)&p_f[-1].scan[3].sample_loc;
      --v10;
    }
    while ( v10 );
    *(_OWORD *)&v8->sample_rate = *(_OWORD *)&p_f->sample_rate;
    *(_OWORD *)&v8->setup_temp_memory_required = *(_OWORD *)&p_f->setup_temp_memory_required;
    *(_OWORD *)&v8->f_start = *(_OWORD *)&p_f->f_start;
    *(_OWORD *)&v8->stream_start = *(_OWORD *)&p_f->stream_start;
    *(_OWORD *)&v8->stream_len = *(_OWORD *)&p_f->stream_len;
    *(_OWORD *)&v8->p_first.page_end = *(_OWORD *)&p_f->p_first.page_end;
    *(_QWORD *)&v8->p_last.page_start = *(_QWORD *)&p_f->p_last.page_start;
    vorbis_pump_first_frame(v7);
    return v7;
  }
LABEL_10:
  if ( error )
    *error = f.error;
  vorbis_deinit(&f);
  return 0i64;
}

__int64 __fastcall stb_vorbis_stream_length_in_samples(stb_vorbis *f)
{
  __int64 result; // rax
  unsigned int v3; // er14
  unsigned int stream_len; // esi
  unsigned int first_audio_page_offset; // esi
  unsigned int file_offset; // edi
  unsigned int v7; // ebp
  int v8; // eax
  unsigned int last; // [rsp+20h] [rbp-38h] BYREF
  unsigned int end; // [rsp+24h] [rbp-34h] BYREF
  unsigned __int8 data[8]; // [rsp+28h] [rbp-30h] BYREF

  if ( f->push_mode )
  {
    f->error = VORBIS_invalid_api_mixing;
    return 0i64;
  }
  else
  {
    if ( !f->total_samples )
    {
      if ( f->stream )
        v3 = LODWORD(f->stream) - LODWORD(f->stream_start);
      else
        v3 = ftell(f->f) - f->f_start;
      stream_len = f->stream_len;
      if ( stream_len < 0x10000
        || (first_audio_page_offset = stream_len - 0x10000, first_audio_page_offset < f->first_audio_page_offset) )
      {
        first_audio_page_offset = f->first_audio_page_offset;
      }
      set_file_offset(f, first_audio_page_offset);
      if ( (unsigned int)vorbis_find_page(f, &end, &last) )
      {
        file_offset = stb_vorbis_get_file_offset(f);
        while ( !last )
        {
          set_file_offset(f, end);
          if ( !(unsigned int)vorbis_find_page(f, &end, &last) )
            break;
          first_audio_page_offset = file_offset + 1;
          if ( f->push_mode )
            file_offset = 0;
          else
            file_offset = f->stream ? LODWORD(f->stream) - LODWORD(f->stream_start) : ftell(f->f) - f->f_start;
        }
        set_file_offset(f, file_offset);
        getn(f, data, 6);
        v7 = get32(f);
        v8 = get32(f);
        if ( v7 == -1 && v8 == -1 )
        {
          f->error = VORBIS_cant_find_last_page;
          f->total_samples = -1;
        }
        else
        {
          f->p_last.page_start = file_offset;
          if ( v8 )
            v7 = -2;
          f->p_last.page_end = end;
          f->total_samples = v7;
          f->p_last.last_decoded_sample = v7;
          f->p_last.first_decoded_sample = -1;
          f->p_last.after_previous_page_start = first_audio_page_offset;
        }
      }
      else
      {
        f->error = VORBIS_cant_find_last_page;
        f->total_samples = -1;
      }
      set_file_offset(f, v3);
    }
    result = f->total_samples;
    if ( (_DWORD)result == -1 )
      return 0i64;
  }
  return result;
}

