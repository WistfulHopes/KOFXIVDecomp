#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/globalheapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/fixmemory.h"
#include "dev/silverware/git/sdk/input/agsdlmappingparser.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/matrix4unaligned.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/quat_aos.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/kof/master/development/source/baseproject/jni/game/check/operationmapper.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/kof/master/development/source/ps4project/baseproject/extension/bilinkable.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_refcount.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memory.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_memoryheap.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_stats.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_timer.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_sse.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/input/imetargetpad.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_types.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/input/imesystem.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/variableheapmemorybase.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector2unaligned.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_sysalloc.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_functions.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_threads.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_types.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/physicalheapmemory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/deque"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/jobmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector3unaligned.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/util/resourcemanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/boolinvec.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vectormath_aos.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/heapmh/heapmh_sysallocmalloc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/mat_aos.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pccontrolsmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/kof/master/development/source/ps4project/toolkit/geommath/vector4unaligned.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/vecidx_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/sdk/util/ageventdispatcher.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/kof/master/development/source/ps4project/baseproject/pcutil/pcdummy.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/quat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/floatinvec.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_vec64.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_array.h"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_allocator.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/kof/master/development/source/middleware/autodesk/scaleform/gfx_sdk/src/kernel/sf_atomic.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/internal/internal_math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/kof/master/development/source/baseproject/jni/framework/libcommon.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/scalar_cpp/vec_aos.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/kof/master/development/source/baseproject/jni/framework/ag/3rdparty/vectormath/cpp/mat_aos.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/debug/logging.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/memory/heapmemory.h"
#include "dev/kof/master/development/source/baseproject/jni/framework/thread/mutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/kof/master/development/source/baseproject/jni/game/check/operationmapper.cpp"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/bitset"

AgSingleton<AgInputManager> * AgSingleton<AgInputManager>::ms_instance; // 0x140ACAB00
std::piecewise_construct_t std::piecewise_construct; // 0x140888AA2
void Fw::ImeTargetKB::Update(); // 0x14002E970
bool Fw::ImeTargetKB::Show(Fw::cImeOption & option); // 0x14002ECB0
void Fw::ImeTargetKB::Abort(); // 0x14002EE00
void Fw::ImeTargetKB::onTypedText(const AgTypingInputEvent & e); // 0x14002EE90
void Fw::ImeTargetKB::onEditedText(const AgEditedInputEvent & e); // 0x14002F060//decompilation failure at 140ACAB00!
//decompilation failure at 140888AA2!
AgDelegate1<AgControllerRemovedEvent const &,void> *__fastcall std::_Uninitialized_move_al_unchecked1<AgDelegate1<AgControllerAddedEvent const &,void> *,AgDelegate1<AgControllerAddedEvent const &,void> *,std::allocator<AgDelegate1<AgControllerAddedEvent const &,void>>>(
        AgDelegate1<AgControllerRemovedEvent const &,void> *_First,
        AgDelegate1<AgControllerRemovedEvent const &,void> *_Last,
        AgDelegate1<AgControllerRemovedEvent const &,void> *_Dest,
        std::_Wrap_alloc<std::allocator<AgDelegate1<AgControllerRemovedEvent const &,void> > > *_Al)
{
  for ( ; _First != _Last; ++_First )
  {
    if ( _Dest )
    {
      _Dest->m_Closure.m_pthis = 0i64;
      _Dest->m_Closure.m_pFunction = 0i64;
      *_Dest = *_First;
    }
    ++_Dest;
  }
  return _Dest;
}

void __fastcall AgScopedLock<AgMutex>::~AgScopedLock<AgMutex>(AgScopedLock<AgMutex> *this)
{
  if ( this->m_locked )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)this->m_lockable);
    this->m_locked = 0;
  }
}

void __fastcall ActorWeapon::ActionFlagCheck(_SETJMP_FLOAT128 *JumpBuffer)
{
  ;
}

void __fastcall Fw::ImeTargetKB::Abort(Fw::ImeTargetKB *this)
{
  AgDelegate1<AgControllerAddedEvent const &,void> v1; // [rsp+20h] [rbp-18h] BYREF

  Fw::ImeTarget::m_IMEKeyboard.m_Status = 3;
  v1.m_Closure.m_pthis = (detail::GenericClass *)&Fw::ImeTarget::m_IMEKeyboard;
  UserGameOperation::Instance()->m_keyboardLocked = 0;
  v1.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *))Fw::ImeTargetKB::onTypedText;
  AgEventDispatcherBase<AgEditedInputEvent>::unbind(
    (AgEventDispatcherBase<AgControllerAddedEvent> *)&AgSingleton<AgInputManager>::ms_instance[68],
    &v1);
  v1.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *))Fw::ImeTargetKB::onEditedText;
  v1.m_Closure.m_pthis = (detail::GenericClass *)&Fw::ImeTarget::m_IMEKeyboard;
  AgEventDispatcherBase<AgEditedInputEvent>::unbind(
    (AgEventDispatcherBase<AgControllerAddedEvent> *)&AgSingleton<AgInputManager>::ms_instance[84],
    &v1);
  AgInputManager::stopTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
}

char __fastcall Fw::ImeTargetKB::Show(Fw::ImeTargetKB *this, Fw::cImeOption *option)
{
  unsigned __int64 maxTextLength; // rcx
  AgSingleton<AgInputManager> *v4; // rbx
  AgSingleton<AgInputManager> *v5; // rbx
  AgDelegate1<AgTypingInputEvent const &,void> _Val; // [rsp+28h] [rbp-30h] BYREF
  int v8; // [rsp+38h] [rbp-20h]
  AgSingleton<AgInputManager> *v9; // [rsp+40h] [rbp-18h]

  strcpy_s(Fw::ImeTarget::m_IMEKeyboard.m_prevText, 0x100ui64, option->input);
  memset(Fw::ImeTarget::m_IMEKeyboard.m_textBuffer, 0, sizeof(Fw::ImeTarget::m_IMEKeyboard.m_textBuffer));
  Fw::ImeTarget::m_IMEKeyboard.m_textLength = 0i64;
  maxTextLength = 255i64;
  if ( (unsigned __int64)option->maxTextLength < 0xFF )
    maxTextLength = option->maxTextLength;
  Fw::ImeTarget::m_IMEKeyboard.m_maxTextLength = maxTextLength;
  Fw::ImeTarget::m_IMEKeyboard.m_Status = 1;
  v4 = AgSingleton<AgInputManager>::ms_instance + 68;
  _Val.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *))Fw::ImeTargetKB::onTypedText;
  _Val.m_Closure.m_pthis = (detail::GenericClass *)&Fw::ImeTarget::m_IMEKeyboard;
  v9 = AgSingleton<AgInputManager>::ms_instance + 68;
  EnterCriticalSection((LPCRITICAL_SECTION)&AgSingleton<AgInputManager>::ms_instance[68]);
  v8 = 1;
  std::vector<AgDelegate1<AgEditedInputEvent const &,void>>::push_back(
    (std::vector<AgDelegate1<AgTypingInputEvent const &,void>> *)&v4[5],
    &_Val);
  LeaveCriticalSection((LPCRITICAL_SECTION)v4);
  v5 = AgSingleton<AgInputManager>::ms_instance + 84;
  _Val.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *))Fw::ImeTargetKB::onEditedText;
  _Val.m_Closure.m_pthis = (detail::GenericClass *)&Fw::ImeTarget::m_IMEKeyboard;
  v9 = AgSingleton<AgInputManager>::ms_instance + 84;
  EnterCriticalSection((LPCRITICAL_SECTION)&AgSingleton<AgInputManager>::ms_instance[84]);
  v8 = 1;
  std::vector<AgDelegate1<AgEditedInputEvent const &,void>>::push_back(
    (std::vector<AgDelegate1<AgTypingInputEvent const &,void>> *)&v5[5],
    &_Val);
  LeaveCriticalSection((LPCRITICAL_SECTION)v5);
  AgInputManager::startTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
  UserGameOperation::Instance()->m_keyboardLocked = 1;
  *(_WORD *)&Fw::ImeTarget::m_IMEKeyboard.m_EnterStatus = 1;
  *(_QWORD *)&Fw::ImeTarget::m_IMEKeyboard.m_inputLength = 0i64;
  Fw::ImeTarget::m_IMEKeyboard.m_overflowed = 0;
  return 1;
}

bool __fastcall UserGameOperation::Test(
        int userIndex,
        GameOperations::GameOpSpec op,
        UserGameOperation::TestPolicy testPolicy)
{
  UserGameOperation *v6; // rax

  v6 = UserGameOperation::Instance();
  return UserGameOperation::test(v6, userIndex, op, testPolicy, 0, 0i64);
}

void __fastcall Fw::ImeTargetKB::Update(Fw::ImeTargetKB *this)
{
  UserGameOperation *v1; // rax
  __int64 v2; // rbx
  std::bitset<16> *v3; // r8
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int128 v6; // xmm1
  __int64 v7; // rax
  char v8; // di
  UserGameOperation *v9; // rax
  std::bitset<16> *v10; // r8
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int128 v13; // xmm1
  __int64 v14; // rdx
  signed __int64 v15; // r8
  __int64 v16; // rdx
  signed __int64 v17; // r8
  __int64 v18; // rax
  UserGameOperation *v19; // rax
  int v20[2]; // [rsp+20h] [rbp-50h] BYREF
  __int128 v21; // [rsp+28h] [rbp-48h] BYREF
  __int128 v22; // [rsp+38h] [rbp-38h] BYREF
  __int128 v23; // [rsp+48h] [rbp-28h]
  __int128 v24; // [rsp+58h] [rbp-18h]
  __int64 v25; // [rsp+80h] [rbp+10h]

  if ( Fw::ImeTarget::m_IMEKeyboard.m_Status == 1 )
  {
    v1 = UserGameOperation::Instance();
    v2 = 3i64;
    if ( v1 == (UserGameOperation *)-2464i64 )
    {
LABEL_11:
      v8 = 0;
    }
    else
    {
      v3 = &v1->m_ButtonConfig[5];
      v20[0] = 0xFFFF;
      v4 = 0i64;
      while ( *(int *)((char *)&v20[v4] + (char *)&v1->m_ButtonConfig[5] - (char *)v20) == v20[v4] )
      {
        if ( --v4 < 0 )
          goto LABEL_6;
      }
      v14 = 0i64;
      v20[0] = v3->_Array[0] & v1->m_anyUserSlot.m_pressedEventChannels._Array[0];
      v15 = (char *)v3 - (char *)v20;
      while ( v20[v14] == *(int *)((char *)&v20[v14] + v15) )
      {
        if ( --v14 < 0 )
          goto LABEL_26;
      }
LABEL_6:
      v5 = 3i64;
      v6 = *(_OWORD *)&v1->m_KeyboardButtonConfig[5]._Array[2];
      v21 = *(_OWORD *)v1->m_KeyboardButtonConfig[5]._Array;
      v22 = v6;
      do
      {
        *((_QWORD *)&v21 + v5) &= *(__int64 *)((char *)&v25 + 8 * v5 + (char *)&v1->m_anyUserSlot - ((char *)&v22 + 8));
        --v5;
      }
      while ( v5 >= 0 );
      v7 = 3i64;
      v23 = v21;
      v24 = v22;
      while ( !*((_QWORD *)&v23 + v7) )
      {
        if ( --v7 < 0 )
          goto LABEL_11;
      }
LABEL_26:
      v8 = 1;
    }
    v9 = UserGameOperation::Instance();
    if ( v9 == (UserGameOperation *)-2464i64 )
    {
LABEL_21:
      if ( !v8 )
      {
        Fw::ImeTarget::m_IMEKeyboard.m_EnterStatus = 0;
        return;
      }
    }
    else
    {
      v10 = &v9->m_ButtonConfig[4];
      v20[0] = 0xFFFF;
      v11 = 0i64;
      while ( *(int *)((char *)&v20[v11] + (char *)&v9->m_ButtonConfig[4] - (char *)v20) == v20[v11] )
      {
        if ( --v11 < 0 )
          goto LABEL_16;
      }
      v16 = 0i64;
      v20[0] = v10->_Array[0] & v9->m_anyUserSlot.m_pressedEventChannels._Array[0];
      v17 = (char *)v10 - (char *)v20;
      while ( v20[v16] == *(int *)((char *)&v20[v16] + v17) )
      {
        if ( --v16 < 0 )
          goto LABEL_30;
      }
LABEL_16:
      v12 = 3i64;
      v13 = *(_OWORD *)&v9->m_KeyboardButtonConfig[4]._Array[2];
      v21 = *(_OWORD *)v9->m_KeyboardButtonConfig[4]._Array;
      v22 = v13;
      do
      {
        *((_QWORD *)&v21 + v12) &= *(__int64 *)((char *)&v25 + 8 * v12 + (char *)&v9->m_anyUserSlot - ((char *)&v22 + 8));
        --v12;
      }
      while ( v12 >= 0 );
      v23 = v21;
      v24 = v22;
      while ( !*((_QWORD *)&v23 + v2) )
      {
        if ( --v2 < 0 )
          goto LABEL_21;
      }
    }
LABEL_30:
    if ( !Fw::ImeTarget::m_IMEKeyboard.m_EnterStatus )
    {
      if ( Fw::ImeTarget::m_IMEKeyboard.m_EnteringInput )
      {
        Fw::ImeTarget::m_IMEKeyboard.m_EnteringInput = 0;
        v18 = -1i64;
        do
          ++v18;
        while ( Fw::ImeTarget::m_IMEKeyboard.m_textBuffer[v18] );
        Fw::ImeTarget::m_IMEKeyboard.m_inputLength = v18;
        Fw::ImeTarget::m_IMEKeyboard.m_currentInputLength = 0;
      }
      else
      {
        Fw::ImeTarget::m_IMEKeyboard.m_Status = 2;
        v19 = UserGameOperation::Instance();
        *(_QWORD *)&v21 = &Fw::ImeTarget::m_IMEKeyboard;
        v19->m_keyboardLocked = 0;
        *((_QWORD *)&v21 + 1) = Fw::ImeTargetKB::onTypedText;
        AgEventDispatcherBase<AgEditedInputEvent>::unbind(
          (AgEventDispatcherBase<AgControllerAddedEvent> *)&AgSingleton<AgInputManager>::ms_instance[68],
          (AgDelegate1<AgControllerAddedEvent const &,void> *)&v21);
        *((_QWORD *)&v21 + 1) = Fw::ImeTargetKB::onEditedText;
        *(_QWORD *)&v21 = &Fw::ImeTarget::m_IMEKeyboard;
        AgEventDispatcherBase<AgEditedInputEvent>::unbind(
          (AgEventDispatcherBase<AgControllerAddedEvent> *)&AgSingleton<AgInputManager>::ms_instance[84],
          (AgDelegate1<AgControllerAddedEvent const &,void> *)&v21);
        AgInputManager::stopTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
        if ( v8 )
          strcpy_s(Fw::ImeTarget::m_IMEKeyboard.m_textBuffer, 0x100ui64, Fw::ImeTarget::m_IMEKeyboard.m_prevText);
        if ( Fw::ImeTarget::m_IMEKeyboard.m_overflowed )
        {
          Fw::ImeTarget::m_IMEKeyboard.m_overflowed = 0;
          AgInputManager::startTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
        }
      }
    }
  }
}

void __fastcall std::vector<AgDelegate1<AgTypingInputEvent const &,void>>::_Reallocate(
        std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>> *this,
        unsigned __int64 _Count,
        __int64 a3,
        std::_Wrap_alloc<std::allocator<AgDelegate1<AgControllerRemovedEvent const &,void> > > *a4)
{
  AgDelegate1<AgControllerRemovedEvent const &,void> *v6; // rbx
  unsigned __int64 v7; // rcx
  void (__fastcall *v8)(detail::GenericClass *); // rax
  signed __int64 v9; // r14

  if ( _Count )
  {
    if ( _Count > 0xFFFFFFFFFFFFFFFi64 )
      std::_Xbad_alloc();
    v7 = 16 * _Count;
    if ( 16 * _Count < 0x1000 )
    {
      v6 = (AgDelegate1<AgControllerRemovedEvent const &,void> *)operator new(v7);
    }
    else
    {
      if ( v7 + 39 <= v7 )
        std::_Xbad_alloc();
      v8 = (void (__fastcall *)(detail::GenericClass *))operator new(v7 + 39);
      v6 = (AgDelegate1<AgControllerRemovedEvent const &,void> *)(((unsigned __int64)v8 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
      v6[-1].m_Closure.m_pFunction = v8;
    }
  }
  else
  {
    v6 = 0i64;
  }
  std::_Uninitialized_move_al_unchecked1<AgDelegate1<AgControllerAddedEvent const &,void> *,AgDelegate1<AgControllerAddedEvent const &,void> *,std::allocator<AgDelegate1<AgControllerAddedEvent const &,void>>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v6,
    a4);
  v9 = (char *)this->_Mypair._Myval2._Mylast - (char *)this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  this->_Mypair._Myval2._Myend = &v6[_Count];
  this->_Mypair._Myval2._Mylast = (AgDelegate1<AgControllerRemovedEvent const &,void> *)((char *)v6
                                                                                       + (v9 & 0xFFFFFFFFFFFFFFF0ui64));
  this->_Mypair._Myval2._Myfirst = v6;
}

void __fastcall std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>>::_Reserve(
        std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>> *this,
        unsigned __int64 _Count)
{
  AgDelegate1<AgControllerRemovedEvent const &,void> *Myend; // r9
  AgDelegate1<AgControllerRemovedEvent const &,void> *Mylast; // rdx
  AgDelegate1<AgControllerRemovedEvent const &,void> *Myfirst; // rcx
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rcx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( !(Myend - Mylast) )
  {
    Myfirst = this->_Mypair._Myval2._Myfirst;
    v6 = Mylast - Myfirst;
    if ( v6 == 0xFFFFFFFFFFFFFFFi64 )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + 1;
    v8 = Myend - Myfirst;
    v9 = 0i64;
    if ( 0xFFFFFFFFFFFFFFFi64 - (v8 >> 1) >= v8 )
      v9 = v8 + (v8 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgDelegate1<AgTypingInputEvent const &,void>>::_Reallocate(
      this,
      v7,
      (__int64)this,
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgControllerRemovedEvent const &,void> > > *)v8);
  }
}

void __fastcall std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
        std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *this,
        AgDelegate1<AgUserUpdatedEvent const &,void> *_Ptr,
        unsigned __int64 _Count)
{
  void (__fastcall *m_pFunction)(detail::GenericClass *); // rax
  char *v4; // rdx

  if ( _Count > 0xFFFFFFFFFFFFFFFi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 16 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    m_pFunction = _Ptr[-1].m_Closure.m_pFunction;
    if ( (AgDelegate1<AgUserUpdatedEvent const &,void> *)m_pFunction >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)m_pFunction);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = (AgDelegate1<AgUserUpdatedEvent const &,void> *)m_pFunction;
  }
  operator delete(_Ptr);
}

void __fastcall Fw::ImeTargetKB::onEditedText(Fw::ImeTargetKB *this, const AgEditedInputEvent *e)
{
  const char *CString; // rax
  unsigned __int64 v5; // rdi
  const char *v6; // r11
  __int64 v7; // r9
  unsigned int v8; // er8
  const char *v9; // rdx
  __int64 v10; // rax
  char v11; // cl
  char *m_textBuffer; // rbx
  int v13; // edx
  __int64 v14; // r14
  char *v15; // r8
  __int64 v16; // rax
  char v17; // cl
  unsigned int i; // edx
  unsigned __int64 v19; // rax
  char v20; // cl

  if ( this->m_Status == 1 && AgString::getLength(&e->string) )
  {
    this->m_EnteringInput = 1;
    CString = AgString::getCString(&e->string);
    v5 = 0i64;
    v6 = CString;
    v7 = 0i64;
    v8 = 0;
    if ( *CString )
    {
      v9 = CString;
      do
      {
        if ( v8 >= 0x100 )
          break;
        v10 = v7 + 1;
        v11 = *v9 & 0xC0;
        ++v8;
        ++v9;
        if ( v11 == (char)0x80 )
          v10 = v7;
        v7 = v10;
      }
      while ( *v9 );
    }
    m_textBuffer = this->m_textBuffer;
    v13 = 0;
    v14 = 0i64;
    if ( this->m_textBuffer[0] )
    {
      v15 = this->m_textBuffer;
      do
      {
        if ( v13 >= (unsigned __int64)this->m_inputLength )
          break;
        v16 = v14 + 1;
        v17 = *v15 & 0xC0;
        ++v13;
        ++v15;
        if ( v17 == (char)0x80 )
          v16 = v14;
        v14 = v16;
      }
      while ( *v15 );
    }
    if ( v14 + v7 > this->m_maxTextLength )
    {
      if ( !this->m_overflowed )
      {
        this->m_overflowed = 1;
        AgInputManager::stopTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
      }
    }
    else
    {
      strcpy_s(&this->m_textBuffer[this->m_inputLength], 255i64 - this->m_inputLength, v6);
      for ( i = 0; *m_textBuffer; v5 = v19 )
      {
        if ( i >= 0x100 )
          break;
        v19 = v5 + 1;
        v20 = *m_textBuffer & 0xC0;
        ++i;
        ++m_textBuffer;
        if ( v20 == (char)0x80 )
          v19 = v5;
      }
      this->m_textLength = v5;
      this->m_currentInputLength = v5 - v14;
    }
  }
}

void __fastcall Fw::ImeTargetKB::onTypedText(Fw::ImeTargetKB *this, const AgTypingInputEvent *e)
{
  bool v4; // bl
  unsigned __int64 m_textLength; // r10
  __int64 v6; // rdx
  int v7; // er9
  char *m_textBuffer; // rcx
  bool i; // zf
  __int64 Length; // r11
  __int64 v12; // r8
  unsigned int v13; // er9
  char *v14; // r10
  char v15; // cl
  __int64 v16; // rax
  __int64 v17; // r14
  const char *CString; // rax
  __int64 v19; // rax
  AgString s2; // [rsp+28h] [rbp-20h] BYREF

  if ( this->m_Status == 1 )
  {
    AgString::AgString(&s2, 8);
    v4 = operator==(&e->string, &s2);
    AgString::~AgString(&s2);
    if ( v4 )
    {
      m_textLength = this->m_textLength;
      if ( m_textLength )
      {
        v6 = 0i64;
        v7 = 0;
        m_textBuffer = this->m_textBuffer;
        for ( i = this->m_textBuffer[0] == 0; !i; i = *m_textBuffer == 0 )
        {
          if ( (*m_textBuffer & 0xC0) != 0x80 && ++v6 == m_textLength )
          {
            this->m_textBuffer[v7] = 0;
            if ( --this->m_currentInputLength < 0 )
            {
              this->m_currentInputLength = 0;
              this->m_inputLength = v7;
            }
            if ( this->m_inputLength < 0 )
              this->m_inputLength = 0;
            if ( this->m_overflowed )
            {
              this->m_overflowed = 0;
              this->m_inputLength = v7;
              this->m_currentInputLength = 0;
              AgInputManager::startTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
            }
            break;
          }
          ++v7;
          ++m_textBuffer;
        }
        --this->m_textLength;
      }
    }
    else if ( *AgString::getCString(&e->string) >= 0 )
    {
      Length = AgString::getLength(&e->string);
      v12 = 0i64;
      v13 = 0;
      if ( this->m_textBuffer[0] )
      {
        v14 = this->m_textBuffer;
        do
        {
          if ( v13 >= 0x100 )
            break;
          v15 = *v14 & 0xC0;
          ++v13;
          ++v14;
          v16 = v12 + 1;
          if ( v15 == (char)0x80 )
            v16 = v12;
          v12 = v16;
        }
        while ( *v14 );
      }
      v17 = Length;
      if ( Length + v12 <= this->m_maxTextLength )
      {
        CString = AgString::getCString(&e->string);
        strcat_s(this->m_textBuffer, 0x100ui64, CString);
        this->m_textLength += v17;
        v19 = -1i64;
        do
          ++v19;
        while ( this->m_textBuffer[v19] );
        this->m_inputLength = v19;
      }
    }
  }
}

void __fastcall std::vector<AgDelegate1<AgEditedInputEvent const &,void>>::push_back(
        std::vector<AgDelegate1<AgTypingInputEvent const &,void>> *this,
        const AgDelegate1<AgTypingInputEvent const &,void> *_Val)
{
  AgDelegate1<AgTypingInputEvent const &,void> *Mylast; // rax
  const AgDelegate1<AgTypingInputEvent const &,void> *v3; // rdi
  AgDelegate1<AgTypingInputEvent const &,void> *Myfirst; // rcx
  signed __int64 v6; // rdi
  AgDelegate1<AgTypingInputEvent const &,void> *v7; // rcx

  Mylast = this->_Mypair._Myval2._Mylast;
  v3 = _Val;
  if ( _Val >= Mylast || (Myfirst = this->_Mypair._Myval2._Myfirst, Myfirst > _Val) )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>>::_Reserve(
        (std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>> *)this,
        (unsigned __int64)_Val);
    v7 = this->_Mypair._Myval2._Mylast;
    if ( v7 )
      goto LABEL_10;
  }
  else
  {
    v6 = (char *)_Val - (char *)Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>>::_Reserve(
        (std::vector<AgDelegate1<AgControllerRemovedEvent const &,void>> *)this,
        (unsigned __int64)_Val);
    v7 = this->_Mypair._Myval2._Mylast;
    if ( v7 )
    {
      v3 = (AgDelegate1<AgTypingInputEvent const &,void> *)((char *)this->_Mypair._Myval2._Myfirst
                                                          + (v6 & 0xFFFFFFFFFFFFFFF0ui64));
LABEL_10:
      v7->m_Closure.m_pthis = 0i64;
      v7->m_Closure.m_pFunction = 0i64;
      v7->m_Closure.m_pFunction = v3->m_Closure.m_pFunction;
      v7->m_Closure.m_pthis = v3->m_Closure.m_pthis;
    }
  }
  ++this->_Mypair._Myval2._Mylast;
}

void __fastcall AgEventDispatcherBase<AgEditedInputEvent>::unbind(
        AgEventDispatcherBase<AgControllerAddedEvent> *this,
        AgDelegate1<AgControllerAddedEvent const &,void> *f)
{
  AgDelegate1<AgControllerAddedEvent const &,void> *Myfirst; // rax
  AgDelegate1<AgControllerAddedEvent const &,void> *Mylast; // r8
  AgDelegate1<AgControllerAddedEvent const &,void> *i; // rax

  EnterCriticalSection((LPCRITICAL_SECTION)this);
  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  Mylast = this->m_bindings._Mypair._Myval2._Mylast;
  if ( Myfirst != Mylast )
  {
    while ( f->m_Closure.m_pthis != Myfirst->m_Closure.m_pthis
         || f->m_Closure.m_pFunction != Myfirst->m_Closure.m_pFunction )
    {
      if ( ++Myfirst == Mylast )
        goto LABEL_9;
    }
    for ( i = Myfirst + 1; i != Mylast; ++i )
    {
      i[-1].m_Closure.m_pFunction = i->m_Closure.m_pFunction;
      i[-1].m_Closure.m_pthis = i->m_Closure.m_pthis;
    }
    --this->m_bindings._Mypair._Myval2._Mylast;
  }
LABEL_9:
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
}

