#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "dev/silverware/git/src/platforms/shared/audio/xaudio2/agaudiochanneldataxaudio2.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/silverware/git/src/audio/agaudiosourcedata.h"
#include "dev/silverware/git/sdk/audio/agaudiomanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/array"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "program files (x86)/microsoft directx sdk (june 2010)/include/xma2defs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/silverware/git/src/audio/agwavutils.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "dev/silverware/git/sdk/agcurve.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agendian.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/src/platforms/shared/audio/xaudio2/agaudiomanagerxaudio2.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/windows kits/8.1/include/um/propidl.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "program files (x86)/microsoft directx sdk (june 2010)/include/xaudio2.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "dev/silverware/git/sdk/audio/agaudioeffects.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "dev/silverware/git/sdk/audio/agaudiochannel.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/src/3rdparty/libvorbis-1.3.5/include/vorbis/vorbisfile.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/8.1/include/shared/winerror.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/silverware/git/src/audio/agaudiochanneldata.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/silverware/git/src/platforms/shared/audio/xaudio2/agaudiosourcedataxaudio2.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/windows kits/8.1/include/um/oleauto.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/silverware/git/sdk/agvector3.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/audio/agaudiotypes.h"

enum AgAudioStreamIndex
{
	AgAudioStreamIndex_FrontLeft = 0,
	AgAudioStreamIndex_FrontRight = 1,
	AgAudioStreamIndex_FrontCenter = 2,
	AgAudioStreamIndex_LowFrequency = 3,
	AgAudioStreamIndex_BackLeft = 4,
	AgAudioStreamIndex_BackRight = 5,
	AgAudioStreamIndex_BackCenter = 6,
	AgAudioStreamIndex_SideLeft = 7,
	AgAudioStreamIndex_SideRight = 8,
	AgAudioStreamIndex_Count = 9,
};
unsigned long long oggReadFunc(void * ptr, unsigned long long size, unsigned long long nmemb, void * datasource); // 0x14068B2E0
long oggSeekFunc(void * datasource, long long offset, long whence); // 0x14068B310
long oggTellFunc(void * datasource); // 0x14068B370
class std::array<int,9>
{
	class _Myt;
	typedef long value_type;
	typedef unsigned long long size_type;
	typedef long long difference_type;
	typedef long *pointer;
	typedef const long const_pointer;
	typedef long reference;
	typedef const long const_reference;
	class iterator;
	class const_iterator;
	class reverse_iterator;
	class const_reverse_iterator;
public:
	void assign(const long &);
	void fill(const long &);
	std::_Array_const_iterator<int,9> begin();
	std::_Array_iterator<int,9> begin();
	std::_Array_const_iterator<int,9> end();
	std::_Array_iterator<int,9> end();
	std::reverse_iterator<std::_Array_const_iterator<int,9> > rbegin();
	std::reverse_iterator<std::_Array_iterator<int,9> > rbegin();
	std::reverse_iterator<std::_Array_const_iterator<int,9> > rend();
	std::reverse_iterator<std::_Array_iterator<int,9> > rend();
	std::_Array_const_iterator<int,9> cbegin();
	std::_Array_const_iterator<int,9> cend();
	std::reverse_iterator<std::_Array_const_iterator<int,9> > crbegin();
	std::reverse_iterator<std::_Array_const_iterator<int,9> > crend();
	unsigned long long size();
	unsigned long long max_size();
	bool empty();
	const long & at(unsigned long long);
	long & at(unsigned long long);
	const long & operator[](unsigned long long);
	long & operator[](unsigned long long);
	static void _Bad_subscript();
	const long & front();
	long & front();
	const long & back();
	long & back();
	const long * data();
	long * data();
	void _Xran();
	long _Elems[9]; // 0x0
	void swap(std::array<int,9> &);
};
std::array<int,9> fillOggStreamConfiguration(unsigned long numOggStreams); // 0x14068B170
std::array<int,9> fillSpeakerConfiguration(unsigned long channelMask); // 0x14068B230
AgAudioChannelXAudio2::AgAudioChannelXAudio2(const long is3D, AgAudioSourceType type); // 0x14068A540
AgXAudio2OGGData::AgXAudio2OGGData(); // 0x14068A570
void AgAudioChannelXAudio2::updateVolume(AgAudioManagerXAudio2 & audioManager); // 0x14068BAE0
class AgAudioChannelXAudio2::updateVolume::__l12::<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1>
{
public:
	void operator()(AgAudioStreamIndex, AgSpeakerIndex, float);
	<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1>(AgAudioChannelXAudio2::updateVolume::__l12::<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1> &);
	<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1>();
	<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1>(const std::array<int,9> &, float[8] &, const float * &);
private:
	const std::array<int,9> & speakerConfigurationIds; // 0x0
	float[8] & finalVolumes; // 0x8
	const float * & rawVolume; // 0x10
public:
	AgAudioChannelXAudio2::updateVolume::__l12::<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1> & operator=(const AgAudioChannelXAudio2::updateVolume::__l12::<lambda_68a237d4c4db58cdd2bdd9f9830a4ee1> &);
};
ov_callbacks agOggCallbacks; // 0x140A29450
void AgAudioChannelXAudio2::updatePitch(); // 0x14068BA50
void AgAudioChannelXAudio2::updatePlayCount(); // 0x14068BAC0
void AgAudioChannelXAudio2::updateElapsedTime(); // 0x14068B930
void AgAudioChannelXAudio2::_play(AgAudioManagerXAudio2 & audioManager); // 0x14068A6B0
class AgPointer<AgAudioSourceXAudio2>
{
public:
	AgPointer<AgAudioSourceXAudio2>(const AgReference<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2>(AgPointer<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2>(const AgPointer<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2>(AgAudioSourceXAudio2 *);
	AgPointer<AgAudioSourceXAudio2>();
	~AgPointer<AgAudioSourceXAudio2>();
	AgPointer<AgAudioSourceXAudio2> & operator=(AgPointer<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2> & operator=(const AgReference<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2> & operator=(const AgPointer<AgAudioSourceXAudio2> &);
	AgPointer<AgAudioSourceXAudio2> & operator=(AgAudioSourceXAudio2 *);
	bool operator<(const AgPointer<AgAudioSourceXAudio2> &);
	AgAudioSourceXAudio2 * operator->();
	AgAudioSourceXAudio2 & operator*();
	bool operator==(const AgPointer<AgAudioSourceXAudio2> &);
	bool operator==(AgAudioSourceXAudio2 *);
	bool operator!=(const AgPointer<AgAudioSourceXAudio2> &);
	bool operator!=(AgAudioSourceXAudio2 *);
	AgAudioSourceXAudio2 * getObject();
	void swap(AgPointer<AgAudioSourceXAudio2> &);
private:
	AgReferenceCount * m_ref; // 0x0
	AgAudioSourceXAudio2 * m_ptr; // 0x8
};
class AgAudioChannelXAudio2::_play::__l40::<lambda_ae226d07bdc95a9c1964496a87815e1f>
{
public:
	unsigned long long operator()(AgAudioStreamIndex, AgAudioStreamIndex);
	<lambda_ae226d07bdc95a9c1964496a87815e1f>(AgAudioChannelXAudio2::_play::__l40::<lambda_ae226d07bdc95a9c1964496a87815e1f> &);
	<lambda_ae226d07bdc95a9c1964496a87815e1f>();
	<lambda_ae226d07bdc95a9c1964496a87815e1f>(unsigned long &, const std::array<int,9> &, const std::array<int,9> &);
private:
	unsigned long & srcChannels; // 0x0
	const std::array<int,9> & speakerConfigurationIds; // 0x8
	const std::array<int,9> & oggStreamConfigurationIds; // 0x10
public:
	AgAudioChannelXAudio2::_play::__l40::<lambda_ae226d07bdc95a9c1964496a87815e1f> & operator=(const AgAudioChannelXAudio2::_play::__l40::<lambda_ae226d07bdc95a9c1964496a87815e1f> &);
};
void AgAudioChannelXAudio2::_pause(); // 0x14068A630
void AgAudioChannelXAudio2::_resume(); // 0x14068AEC0
void AgAudioChannelXAudio2::_stop(); // 0x14068AF30
void AgAudioChannelXAudio2::_update(); // 0x14068B0D0
void AgAudioChannelData::OnStreamEnd(); // 0x14068A620
void AgAudioChannelData::OnBufferEnd(void * __formal); // 0x14068A5F0
void AgAudioChannelData::streamBuffer(unsigned long bufsQueued); // 0x14068B4E0
void AgAudioChannelData::streamRuntimeBuffers(); // 0x14068B860
void AgAudioChannelData::recalculateLoopingPoints(bool fromStart); // 0x14068B380//decompilation failure at 140A29450!
void __fastcall AgAudioChannelXAudio2::AgAudioChannelXAudio2(
        AgAudioChannelXAudio2 *this,
        const int is3D,
        AgAudioSourceType type)
{
  AgAudioChannel::AgAudioChannel(this, is3D, type);
  this->__vftable = (AgAudioChannelXAudio2_vtbl *)&AgAudioChannelXAudio2::`vftable';
}

void __fastcall AgXAudio2OGGData::AgXAudio2OGGData(AgXAudio2OGGData *this)
{
  InitializeCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgAudioChannelData::OnBufferEnd(AgAudioChannelData *this, void *__formal)
{
  if ( this->m_type == AgAudioSourceType_Stream
    && (!LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
     || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0) )
  {
    AgAudioManagerXAudio2::addStreamJob((AgAudioManagerXAudio2 *)AgSingleton<AgAudioManager>::ms_instance, this);
  }
}

void __fastcall AgAudioChannelData::OnStreamEnd(AgAudioChannelData *this)
{
  this->m_stopped = 1;
}

void __fastcall AgAudioChannelXAudio2::_pause(AgAudioChannelXAudio2 *this)
{
  AgAudioChannelData *m_internalData; // rax
  IXAudio2SourceVoice *m_sourceVoice; // rcx

  if ( !LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
    || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0 )
  {
    if ( AgSingleton<AgAudioManager>::ms_instance[43].__vftable )
    {
      if ( AgSingleton<AgAudioManager>::ms_instance[44].__vftable )
      {
        m_internalData = this->m_internalData;
        m_sourceVoice = m_internalData->m_sourceVoice;
        if ( m_sourceVoice )
        {
          if ( (m_internalData->m_internalState & 3) == 1 )
          {
            m_sourceVoice->Stop(m_sourceVoice, 0, 0);
            this->m_internalData->m_internalState |= 2u;
          }
        }
      }
    }
  }
}

void __fastcall AgAudioChannelXAudio2::_play(AgAudioChannelXAudio2 *this, AgAudioManagerXAudio2 *audioManager)
{
  AgAudioChannelData *m_internalData; // r12
  unsigned __int8 m_internalState; // al
  int Type; // eax
  AgAudioSourceXAudio2 *m_ptr; // rcx
  const AgPath *Path; // rax
  AgPointer<AgFile> *v9; // rax
  AgPointer<AgStream> *v10; // rax
  AgPointer<AgStream> *v11; // rax
  AgReferenceCount *v12; // rax
  AgXAudio2OGGData *v13; // rax
  AgXAudio2OGGData *v14; // rcx
  tWAVEFORMATEX *v15; // rbx
  AgAudioChannelData *v16; // rcx
  AgXAudio2OGGData *m_oggData; // rdx
  IXAudio2 *v18; // rax
  unsigned int nChannels; // edi
  unsigned __int64 v20; // rbx
  std::array<int,9> *v21; // rax
  __m128i v22; // xmm6
  int v23; // er14
  std::array<int,9> *v24; // rax
  void *v25; // rsi
  int v26; // er9
  int v27; // ecx
  int v28; // edx
  int v29; // edx
  int v30; // er8
  int v31; // er11
  int v32; // er10
  int v33; // er10
  unsigned __int64 v34; // rdx
  IXAudio2 *XAudio2; // r14
  AgAudioSourceXAudio2 *v36; // rbx
  IXAudio2_vtbl *v37; // rsi
  tWAVEFORMATEX *WaveFormat; // rax
  IXAudio2 *v39; // rdi
  IXAudio2_vtbl *v40; // rbx
  tWAVEFORMATEX *v41; // rax
  AgAudioChannelData *v42; // rdx
  unsigned int m_playCount; // eax
  int v44; // [rsp+48h] [rbp-C0h]
  AgPointer<AgFile> result; // [rsp+50h] [rbp-B8h] BYREF
  AgPointer<AgStream> v46; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v47; // [rsp+70h] [rbp-98h] BYREF
  unsigned __int8 *Data; // [rsp+78h] [rbp-90h]
  __int64 v49; // [rsp+80h] [rbp-88h]
  __int64 v50; // [rsp+88h] [rbp-80h]
  __int64 v51; // [rsp+90h] [rbp-78h]
  int v52; // [rsp+98h] [rbp-70h]
  __int64 v53; // [rsp+A0h] [rbp-68h]
  AgPointer<AgPlayer> v54; // [rsp+A8h] [rbp-60h] BYREF
  AgPointer<AgPlayer> v55; // [rsp+B8h] [rbp-50h] BYREF
  ov_callbacks v56; // [rsp+C8h] [rbp-40h] BYREF
  std::array<int,9> v57; // [rsp+E8h] [rbp-20h] BYREF
  std::array<int,9> v58; // [rsp+110h] [rbp+8h] BYREF
  __int128 v59; // [rsp+138h] [rbp+30h]
  __int128 v60; // [rsp+148h] [rbp+40h]
  __m128i v61; // [rsp+160h] [rbp+58h]
  __int128 v62; // [rsp+170h] [rbp+68h]

  v53 = -2i64;
  if ( (!audioManager->m_criticalError || audioManager->m_deviceChangedTimestamp == 0.0)
    && audioManager->m_xaudio2
    && audioManager->m_masterVoice )
  {
    m_internalData = this->m_internalData;
    m_internalState = m_internalData->m_internalState;
    if ( (m_internalState & 2) != 0 )
    {
      AgAudioChannelXAudio2::_resume(this);
    }
    else if ( (m_internalState & 3) == 0 )
    {
      v47 = 0i64;
      Data = 0i64;
      v49 = 0i64;
      v50 = 0i64;
      v51 = 0i64;
      v52 = 0;
      m_internalData->m_stopped = 0;
      if ( !this->m_internalData->m_sourceVoice )
      {
        Type = AgAudioSource::getType(m_internalData->m_source.m_ptr);
        m_ptr = (AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr;
        if ( Type == 1 )
        {
          if ( (unsigned int)AgAudioSource::isRuntime(m_ptr) )
          {
            if ( !audioManager->m_criticalError || audioManager->m_deviceChangedTimestamp == 0.0 )
            {
              XAudio2 = AgAudioManagerXAudio2::getXAudio2(audioManager);
              v36 = (AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr;
              v37 = XAudio2->__vftable;
              AgAudioSourceXAudio2::_fetchCallbacks(v36);
              WaveFormat = AgAudioSourceXAudio2::getWaveFormat(v36);
              ((void (__fastcall *)(IXAudio2 *, IXAudio2SourceVoice **, tWAVEFORMATEX *))v37->CreateSourceVoice)(
                XAudio2,
                &this->m_internalData->m_sourceVoice,
                WaveFormat);
              AgAudioChannelData::streamBuffer(this->m_internalData, 0);
            }
          }
          else
          {
            Path = AgAudioSourceXAudio2::getPath((AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr);
            v9 = AgFile::open(&result, Path, 1u, 1);
            AgPointer<AgAudioChannel>::operator=(&this->m_internalData->m_file, v9);
            AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&result);
            AgPointer<AgFile>::operator<AgStream> AgPointer<AgStream>(&this->m_internalData->m_file, &v46);
            result.m_ref = (AgReferenceCount *)&v54;
            AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
              &v54,
              (const AgPointer<AgPlayer> *)&v46);
            if ( !AgWavUtils::startsWith(v10, 0x46464952u) )
            {
              result.m_ref = (AgReferenceCount *)&v55;
              AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
                &v55,
                (const AgPointer<AgPlayer> *)&v46);
              if ( AgWavUtils::startsWith(v11, 0x5367674Fu) )
              {
                v12 = (AgReferenceCount *)operator new(0x30378ui64);
                result.m_ref = v12;
                if ( v12 )
                {
                  AgXAudio2OGGData::AgXAudio2OGGData((AgXAudio2OGGData *)v12);
                  v14 = v13;
                }
                else
                {
                  v14 = 0i64;
                }
                this->m_internalData->m_oggData = v14;
                this->m_internalData->m_oggData->m_currentOggBuffer = 0;
                v46.m_ptr->setPosition(v46.m_ptr, 0i64);
                v56 = agOggCallbacks;
                if ( (int)ov_open_callbacks(
                            this->m_internalData,
                            &this->m_internalData->m_oggData->m_vf,
                            0i64,
                            0i64,
                            &v56) < 0 )
                  AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_internalData->m_file, 0i64);
                v15 = AgAudioSourceXAudio2::getWaveFormat((AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr);
                v16 = this->m_internalData;
                m_oggData = v16->m_oggData;
                if ( m_oggData && v16->m_elapsedTime != 0.0 )
                  ov_time_seek(&m_oggData->m_vf);
                this->m_internalData->m_totalTime = AgAudioSource::getTotalTime(m_internalData->m_source.m_ptr);
                AgAudioChannelData::recalculateLoopingPoints(this->m_internalData, 1);
                if ( !audioManager->m_criticalError || audioManager->m_deviceChangedTimestamp == 0.0 )
                {
                  v18 = AgAudioManagerXAudio2::getXAudio2(audioManager);
                  ((void (__fastcall *)(IXAudio2 *, IXAudio2SourceVoice **, tWAVEFORMATEX *, _QWORD, _DWORD, AgAudioChannelData *, _QWORD, _QWORD))v18->CreateSourceVoice)(
                    v18,
                    &this->m_internalData->m_sourceVoice,
                    v15,
                    0i64,
                    LODWORD(FLOAT_2_0),
                    this->m_internalData,
                    0i64,
                    0i64);
                  nChannels = v15->nChannels;
                  if ( nChannels > 2 )
                  {
                    LODWORD(result.m_ref) = audioManager->m_numChannels;
                    v20 = nChannels * LODWORD(result.m_ref);
                    v21 = fillSpeakerConfiguration(&v57, audioManager->m_channelMask);
                    v61 = *(__m128i *)v21->_Elems;
                    v22 = v61;
                    v62 = *(_OWORD *)&v21->_Elems[4];
                    v23 = v21->_Elems[8];
                    v24 = fillOggStreamConfiguration(&v58, nChannels);
                    v59 = *(_OWORD *)v24->_Elems;
                    v60 = *(_OWORD *)&v24->_Elems[4];
                    v44 = v24->_Elems[8];
                    v25 = operator new[](saturated_mul(v20, 4ui64));
                    memset(v25, 0, 4 * v20);
                    v26 = _mm_cvtsi128_si32(v22);
                    if ( v26 != -1 )
                      *((_DWORD *)v25 + (unsigned int)v59 + nChannels * v26) = 1065353216;
                    v27 = v61.m128i_i32[1];
                    if ( v61.m128i_i32[1] != -1 )
                      *((_DWORD *)v25 + DWORD1(v59) + nChannels * v61.m128i_i32[1]) = 1065353216;
                    v28 = DWORD2(v59);
                    if ( DWORD2(v59) != -1 )
                    {
                      if ( v61.m128i_i32[2] == -1 )
                      {
                        *((_DWORD *)v25 + DWORD2(v59) + nChannels * v27) = 1062836634;
                        *((_DWORD *)v25 + v28 + nChannels * v26) = 1062836634;
                      }
                      else
                      {
                        *((_DWORD *)v25 + DWORD2(v59) + nChannels * v61.m128i_i32[2]) = 1065353216;
                      }
                    }
                    v29 = DWORD1(v62);
                    v30 = v62;
                    if ( (_DWORD)v60 != -1 )
                    {
                      v31 = DWORD1(v60);
                      if ( DWORD1(v60) != -1 )
                      {
                        if ( (_DWORD)v62 == -1 )
                          *((_DWORD *)v25 + (unsigned int)v60 + nChannels * v26) = 1060320051;
                        else
                          *((_DWORD *)v25 + (unsigned int)v60 + nChannels * (_DWORD)v62) = 1065353216;
                        if ( v29 == -1 )
                          *((_DWORD *)v25 + v31 + nChannels * v27) = 1060320051;
                        else
                          *((_DWORD *)v25 + v31 + nChannels * v29) = 1065353216;
                      }
                    }
                    v32 = HIDWORD(v59);
                    if ( HIDWORD(v59) != -1 )
                    {
                      if ( v61.m128i_i32[3] == -1 )
                      {
                        *((_DWORD *)v25 + HIDWORD(v59) + nChannels * v27) = 1048576000;
                        *((_DWORD *)v25 + v32 + nChannels * v26) = 1048576000;
                      }
                      else
                      {
                        *((_DWORD *)v25 + HIDWORD(v59) + nChannels * v61.m128i_i32[3]) = 1065353216;
                      }
                    }
                    v33 = DWORD2(v60);
                    if ( DWORD2(v60) != -1 )
                    {
                      if ( DWORD2(v62) == -1 )
                      {
                        if ( v30 == -1 )
                          *((_DWORD *)v25 + DWORD2(v60) + nChannels * v26) = 1059481190;
                        else
                          *((_DWORD *)v25 + DWORD2(v60) + nChannels * v30) = 1062836634;
                        if ( v29 == -1 )
                          *((_DWORD *)v25 + v33 + nChannels * v27) = 1059481190;
                        else
                          *((_DWORD *)v25 + v33 + nChannels * v29) = 1062836634;
                      }
                      else
                      {
                        *((_DWORD *)v25 + DWORD2(v60) + nChannels * DWORD2(v62)) = 1065353216;
                      }
                    }
                    if ( HIDWORD(v60) != -1 && v44 != -1 )
                    {
                      if ( HIDWORD(v62) == -1 )
                      {
                        if ( v30 == -1 )
                          *((_DWORD *)v25 + HIDWORD(v60) + nChannels * v26) = 1059481190;
                        else
                          *((_DWORD *)v25 + HIDWORD(v60) + nChannels * v30) = 1062836634;
                      }
                      else
                      {
                        *((_DWORD *)v25 + HIDWORD(v60) + nChannels * HIDWORD(v62)) = 1065353216;
                      }
                      if ( v23 == -1 )
                      {
                        if ( v29 == -1 )
                          *((_DWORD *)v25 + v44 + nChannels * v27) = 1059481190;
                        else
                          *((_DWORD *)v25 + v44 + nChannels * v29) = 1062836634;
                      }
                      else
                      {
                        *((_DWORD *)v25 + v44 + nChannels * v23) = 1065353216;
                      }
                    }
                    this->m_internalData->m_sourceVoice->SetOutputMatrix(
                      this->m_internalData->m_sourceVoice,
                      0i64,
                      nChannels,
                      (unsigned int)result.m_ref,
                      (const float *)v25,
                      0);
                    operator delete(v25, v34);
                  }
                  AgAudioChannelData::streamBuffer(this->m_internalData, 0);
                }
              }
            }
            AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&v46);
          }
        }
        else
        {
          HIDWORD(v47) = AgAudioSourceXAudio2::getChunkSize(m_ptr);
          Data = AgAudioSourceXAudio2::getData((AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr);
          LODWORD(v47) = 64;
          if ( !audioManager->m_criticalError || audioManager->m_deviceChangedTimestamp == 0.0 )
          {
            v39 = AgAudioManagerXAudio2::getXAudio2(audioManager);
            v40 = v39->__vftable;
            v41 = AgAudioSourceXAudio2::getWaveFormat((AgAudioSourceXAudio2 *)m_internalData->m_source.m_ptr);
            ((void (__fastcall *)(IXAudio2 *, IXAudio2SourceVoice **, tWAVEFORMATEX *, _QWORD, _DWORD, AgAudioChannelData *, _QWORD, _QWORD))v40->CreateSourceVoice)(
              v39,
              &this->m_internalData->m_sourceVoice,
              v41,
              0i64,
              LODWORD(FLOAT_2_0),
              this->m_internalData,
              0i64,
              0i64);
          }
        }
      }
      v42 = this->m_internalData;
      if ( v42->m_sourceVoice )
      {
        AgAudioChannel::addAllEffects(this, v42);
        AgAudioChannelXAudio2::updateVolume(this, audioManager);
        AgAudioChannelXAudio2::updatePitch(this);
        AgAudioChannel::updateAllEffects(this, this->m_internalData);
        if ( !(unsigned int)AgAudioSource::getType(m_internalData->m_source.m_ptr) )
        {
          m_playCount = this->m_internalData->m_playCount;
          if ( m_playCount )
          {
            if ( m_playCount > 1 )
              LODWORD(v51) = m_playCount - 1;
          }
          else
          {
            LODWORD(v51) = 255;
          }
        }
        if ( !audioManager->m_criticalError || audioManager->m_deviceChangedTimestamp == 0.0 )
        {
          if ( Data )
            this->m_internalData->m_sourceVoice->SubmitSourceBuffer(
              this->m_internalData->m_sourceVoice,
              (const XAUDIO2_BUFFER *)&v47,
              0i64);
          if ( this->m_internalData->m_sourceVoice->Start(this->m_internalData->m_sourceVoice, 0, 0) >= 0 )
          {
            this->m_internalData->m_internalState |= 1u;
            this->m_internalData->m_dirtyFlags &= ~0x40u;
          }
        }
      }
    }
  }
}

void __fastcall AgAudioChannelXAudio2::_resume(AgAudioChannelXAudio2 *this)
{
  AgAudioChannelData *m_internalData; // rax
  IXAudio2SourceVoice *m_sourceVoice; // rcx

  if ( !LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
    || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0 )
  {
    if ( AgSingleton<AgAudioManager>::ms_instance[43].__vftable )
    {
      if ( AgSingleton<AgAudioManager>::ms_instance[44].__vftable )
      {
        m_internalData = this->m_internalData;
        m_sourceVoice = m_internalData->m_sourceVoice;
        if ( m_sourceVoice )
        {
          if ( (m_internalData->m_internalState & 2) != 0 )
          {
            m_sourceVoice->Start(m_sourceVoice, 0, 0);
            this->m_internalData->m_internalState &= ~2u;
          }
        }
      }
    }
  }
}

void __fastcall AgAudioChannelXAudio2::_stop(AgAudioChannelXAudio2 *this)
{
  AgAudioManagerXAudio2 *v2; // rdi
  AgAudioChannelData *m_internalData; // rdx
  _RTL_CRITICAL_SECTION *m_oggData; // rcx
  _RTL_CRITICAL_SECTION *v5; // rsi

  v2 = (AgAudioManagerXAudio2 *)AgSingleton<AgAudioManager>::ms_instance;
  if ( !LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
    || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0 )
  {
    if ( AgSingleton<AgAudioManager>::ms_instance[43].__vftable )
    {
      if ( AgSingleton<AgAudioManager>::ms_instance[44].__vftable )
      {
        m_internalData = this->m_internalData;
        if ( (m_internalData->m_internalState & 3) != 0 )
        {
          if ( m_internalData->m_sourceVoice )
          {
            AgAudioChannel::removeAllEffects(this, m_internalData);
            if ( !v2->m_criticalError || v2->m_deviceChangedTimestamp == 0.0 )
              this->m_internalData->m_sourceVoice->Stop(this->m_internalData->m_sourceVoice, 0, 0);
            AgAudioManagerXAudio2::cancelStreamJob(v2, this->m_internalData);
            m_oggData = (_RTL_CRITICAL_SECTION *)this->m_internalData->m_oggData;
            if ( m_oggData )
            {
              EnterCriticalSection(m_oggData);
              ov_clear(&this->m_internalData->m_oggData->m_vf);
              LeaveCriticalSection((LPCRITICAL_SECTION)this->m_internalData->m_oggData);
              v5 = (_RTL_CRITICAL_SECTION *)this->m_internalData->m_oggData;
              if ( v5 )
              {
                DeleteCriticalSection(v5);
                operator delete(v5, 0x30378ui64);
              }
              this->m_internalData->m_oggData = 0i64;
            }
            if ( !v2->m_criticalError || v2->m_deviceChangedTimestamp == 0.0 )
              this->m_internalData->m_sourceVoice->DestroyVoice(this->m_internalData->m_sourceVoice);
          }
          this->m_internalData->m_internalState &= 0xFCu;
        }
      }
    }
  }
  AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_internalData->m_file, 0i64);
  this->m_internalData->m_sourceVoice = 0i64;
}

void __fastcall AgAudioChannelXAudio2::_update(AgAudioChannelXAudio2 *this)
{
  AgAudioChannelData *m_internalData; // rcx

  if ( (!LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
     || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0)
    && AgSingleton<AgAudioManager>::ms_instance[43].__vftable
    && AgSingleton<AgAudioManager>::ms_instance[44].__vftable
    && (m_internalData = this->m_internalData, m_internalData->m_sourceVoice) )
  {
    if ( (m_internalData->m_internalState & 3) != 0 )
    {
      AgAudioChannelData::streamRuntimeBuffers(m_internalData);
      if ( this->m_internalData->m_stopped )
        AgAudioChannelXAudio2::_stop(this);
    }
  }
  else
  {
    AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_internalData->m_file, 0i64);
    this->m_internalData->m_sourceVoice = 0i64;
  }
}

std::array<int,9> *__fastcall fillOggStreamConfiguration(std::array<int,9> *result, unsigned int numOggStreams)
{
  std::array<int,9> *v2; // r8
  __int64 v3; // r9
  __int64 v4; // r10
  int v5; // eax
  int v6; // eax
  int v7; // eax

  v2 = result;
  v3 = 0i64;
  v4 = 9i64;
  if ( result > &result[1] )
    v4 = 0i64;
  if ( v4 )
  {
    do
    {
      ++v3;
      result->_Elems[0] = -1;
      result = (std::array<int,9> *)((char *)result + 4);
    }
    while ( v3 != v4 );
  }
  v2->_Elems[0] = 0;
  v5 = 1;
  if ( numOggStreams == 3 || numOggStreams >= 5 )
  {
    v2->_Elems[2] = 1;
    v5 = 2;
  }
  v2->_Elems[1] = v5;
  v6 = v5 + 1;
  if ( numOggStreams >= 7 )
  {
    v2->_Elems[7] = v6;
    v7 = v6 + 1;
    v2->_Elems[8] = v7;
    v6 = v7 + 1;
  }
  if ( numOggStreams - 4 <= 2 || numOggStreams == 8 )
    v2->_Elems[4] = v6++;
  if ( numOggStreams - 4 <= 2 || numOggStreams == 8 )
    v2->_Elems[5] = v6++;
  if ( numOggStreams == 7 )
  {
    v2->_Elems[6] = v6;
    v2->_Elems[3] = v6 + 1;
    return v2;
  }
  else
  {
    if ( numOggStreams >= 6 )
      v2->_Elems[3] = v6;
    return v2;
  }
}

std::array<int,9> *__fastcall fillSpeakerConfiguration(std::array<int,9> *result, unsigned int channelMask)
{
  std::array<int,9> *v2; // r8
  __int64 v3; // r9
  __int64 v4; // r10
  unsigned int v5; // eax

  v2 = result;
  v3 = 0i64;
  v4 = 9i64;
  if ( result > &result[1] )
    v4 = 0i64;
  if ( v4 )
  {
    do
    {
      ++v3;
      v2->_Elems[0] = -1;
      v2 = (std::array<int,9> *)((char *)v2 + 4);
    }
    while ( v3 != v4 );
  }
  v5 = channelMask & 1;
  if ( (channelMask & 1) != 0 )
    result->_Elems[0] = 0;
  if ( (channelMask & 2) != 0 )
    result->_Elems[1] = v5++;
  if ( (channelMask & 4) != 0 )
    result->_Elems[2] = v5++;
  if ( (channelMask & 8) != 0 )
    result->_Elems[3] = v5++;
  if ( (channelMask & 0x10) != 0 )
    result->_Elems[4] = v5++;
  if ( (channelMask & 0x20) != 0 )
    result->_Elems[5] = v5++;
  if ( (channelMask & 0x100) != 0 )
    result->_Elems[6] = v5++;
  if ( (channelMask & 0x200) != 0 )
    result->_Elems[7] = v5++;
  if ( (channelMask & 0x400) != 0 )
    result->_Elems[8] = v5;
  return result;
}

unsigned __int64 __fastcall oggReadFunc(void *ptr, unsigned __int64 size, unsigned __int64 nmemb, void *datasource)
{
  return (*(unsigned int (__fastcall **)(_QWORD, void *, _QWORD))(**((_QWORD **)datasource + 26) + 16i64))(
           *((_QWORD *)datasource + 26),
           ptr,
           (unsigned int)(size * nmemb));
}

__int64 __fastcall oggSeekFunc(void *datasource, __int64 offset, int whence)
{
  __int64 v3; // rbx

  v3 = offset;
  if ( whence == 1 )
  {
    v3 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)datasource + 26) + 48i64))(*((_QWORD *)datasource + 26))
       + offset;
  }
  else if ( whence == 2 )
  {
    v3 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)datasource + 26) + 32i64))(*((_QWORD *)datasource + 26))
       - offset;
  }
  (*(void (__fastcall **)(_QWORD, __int64))(**((_QWORD **)datasource + 26) + 40i64))(*((_QWORD *)datasource + 26), v3);
  return 0i64;
}

__int64 __fastcall oggTellFunc(void *datasource)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)datasource + 26) + 48i64))(*((_QWORD *)datasource + 26));
}

void __fastcall AgAudioChannelData::recalculateLoopingPoints(AgAudioChannelData *this, bool fromStart)
{
  int v4; // eax
  _RTL_CRITICAL_SECTION *m_oggData; // rbx
  tWAVEFORMATEX *WaveFormat; // rax
  std::pair<int,int> result; // [rsp+50h] [rbp+8h] BYREF

  if ( this->m_oggData )
  {
    Scaleform::Render::PNG::LibPNGInput::GetSize(this->m_source.m_ptr, &result);
    v4 = result.second != -1;
    this->m_loop = v4;
    if ( v4 )
    {
      if ( fromStart )
      {
        m_oggData = (_RTL_CRITICAL_SECTION *)this->m_oggData;
        EnterCriticalSection(m_oggData);
        result.first = ov_pcm_tell(&this->m_oggData->m_vf);
        LeaveCriticalSection(m_oggData);
      }
      WaveFormat = AgAudioSourceXAudio2::getWaveFormat((AgAudioSourceXAudio2 *)this->m_source.m_ptr);
      this->m_bytesLeftForLoop = WaveFormat->nBlockAlign * (result.second - result.first);
    }
    else
    {
      this->m_bytesLeftForLoop = 0;
    }
  }
}

__int64 __fastcall AgWavUtils::startsWith(AgPointer<AgStream> *stream, unsigned int fourcc)
{
  unsigned int v4; // edi
  int v6; // [rsp+50h] [rbp+18h] BYREF

  stream->m_ptr->setPosition(stream->m_ptr, 0i64);
  v4 = 0;
  v6 = 0;
  if ( stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v6, 4u) == 4 )
  {
    LOBYTE(v4) = v6 == fourcc;
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)stream);
    return v4;
  }
  else
  {
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)stream);
    return 0i64;
  }
}

void __fastcall AgAudioChannelData::streamBuffer(AgAudioChannelData *this, unsigned int bufsQueued)
{
  AgAudioSource *m_ptr; // rcx
  _RTL_CRITICAL_SECTION *m_oggData; // rax
  unsigned __int64 v6; // rdi
  AgXAudio2OGGData *v7; // r14
  unsigned int m_playCount; // er15
  char v9; // r12
  unsigned __int64 m_bytesLeftForLoop; // rsi
  int v11; // eax
  int v12; // eax
  tWAVEFORMATEX *WaveFormat; // rax
  unsigned __int64 v14; // rsi
  int first; // ecx
  int v16; // eax
  int v17; // eax
  _RTL_CRITICAL_SECTION *lpCriticalSection; // [rsp+48h] [rbp-49h]
  std::pair<int,int> v19; // [rsp+58h] [rbp-39h] BYREF
  int v20; // [rsp+60h] [rbp-31h]
  AgXAudio2OGGData *v21; // [rsp+68h] [rbp-29h]
  unsigned __int64 v22; // [rsp+70h] [rbp-21h] BYREF
  unsigned __int8 *v23; // [rsp+78h] [rbp-19h]
  __int64 v24; // [rsp+80h] [rbp-11h]
  __int64 v25; // [rsp+88h] [rbp-9h]
  __int64 v26; // [rsp+90h] [rbp-1h]
  int v27; // [rsp+98h] [rbp+7h]
  int v28; // [rsp+F8h] [rbp+67h] BYREF
  std::pair<int,int> result; // [rsp+108h] [rbp+77h] BYREF
  AgSingleton<AgAudioManager> *i; // [rsp+110h] [rbp+7Fh]

  if ( !this->m_stopped )
  {
    m_ptr = this->m_source.m_ptr;
    if ( m_ptr )
    {
      if ( (unsigned int)AgAudioSource::getType(m_ptr) == 1 )
      {
        m_oggData = (_RTL_CRITICAL_SECTION *)this->m_oggData;
        lpCriticalSection = m_oggData;
        if ( m_oggData )
        {
          v6 = 0i64;
          v21 = this->m_oggData;
          EnterCriticalSection(m_oggData);
          v20 = 1;
          for ( i = AgSingleton<AgAudioManager>::ms_instance; bufsQueued < 3; v6 = 0i64 )
          {
            ++bufsQueued;
            v7 = this->m_oggData;
            m_playCount = this->m_playCount;
            v9 = 0;
            m_bytesLeftForLoop = 0x10000i64;
            if ( this->m_loop && (unsigned __int64)this->m_bytesLeftForLoop < 0x10000 )
              m_bytesLeftForLoop = this->m_bytesLeftForLoop;
            v28 = 0;
            while ( v6 < m_bytesLeftForLoop )
            {
              v11 = ov_read(
                      (int)v7 + 40,
                      (int)v6 + (v7->m_currentOggBuffer << 16) + (int)v7 + 884,
                      (int)m_bytesLeftForLoop - (int)v6,
                      0,
                      2,
                      1,
                      (__int64)&v28);
              v6 += v11;
              if ( this->m_loop && (this->m_bytesLeftForLoop -= v11, this->m_bytesLeftForLoop <= 0) || !v11 )
              {
                if ( m_playCount == 1 )
                {
                  v9 = 1;
                }
                else
                {
                  if ( this->m_oggData )
                  {
                    Scaleform::Render::PNG::LibPNGInput::GetSize(this->m_source.m_ptr, &result);
                    v12 = result.second != -1;
                    this->m_loop = v12;
                    if ( v12 )
                    {
                      WaveFormat = AgAudioSourceXAudio2::getWaveFormat((AgAudioSourceXAudio2 *)this->m_source.m_ptr);
                      this->m_bytesLeftForLoop = WaveFormat->nBlockAlign * (result.second - result.first);
                    }
                    else
                    {
                      this->m_bytesLeftForLoop = 0;
                    }
                  }
                  v14 = 0x10000i64;
                  if ( this->m_loop && (unsigned __int64)this->m_bytesLeftForLoop < 0x10000 )
                    v14 = this->m_bytesLeftForLoop;
                  first = Scaleform::Render::PNG::LibPNGInput::GetSize(this->m_source.m_ptr, &v19)->first;
                  if ( first == -1 )
                    first = 0;
                  ov_pcm_seek(&v7->m_vf, first);
                  do
                  {
                    if ( v6 >= v14 )
                      break;
                    v16 = ov_read(
                            (int)v7 + 40,
                            (int)v6 + (v7->m_currentOggBuffer << 16) + (int)v7 + 884,
                            (int)v14 - (int)v6,
                            0,
                            2,
                            1,
                            (__int64)&v28);
                    v6 += v16;
                    if ( this->m_loop )
                    {
                      this->m_bytesLeftForLoop -= v16;
                      if ( this->m_bytesLeftForLoop <= 0 )
                        break;
                    }
                  }
                  while ( v16 );
                }
                break;
              }
            }
            v22 = 0i64;
            v23 = 0i64;
            v24 = 0i64;
            v25 = 0i64;
            v26 = 0i64;
            v27 = 0;
            v23 = v7->m_buffer[(unsigned __int64)v7->m_currentOggBuffer];
            v17 = 0;
            if ( v9 )
              v17 = 64;
            v22 = __PAIR64__(v6, v17);
            if ( !LODWORD(i[46].__vftable) || *(double *)&i[47].__vftable == 0.0 )
              this->m_sourceVoice->SubmitSourceBuffer(this->m_sourceVoice, (const XAUDIO2_BUFFER *)&v22, 0i64);
            v7->m_currentOggBuffer = (v7->m_currentOggBuffer + 1) % 3;
            if ( v9 )
              break;
          }
          LeaveCriticalSection(lpCriticalSection);
        }
      }
    }
  }
}

void __fastcall AgAudioChannelData::streamRuntimeBuffers(AgAudioChannelData *this)
{
  AgAudioSource *m_ptr; // rcx
  std::pair<AgPointer<AgStream>,AgXAudio2RuntimeData *> *v3; // rax
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rdi
  AgStream *v7; // rcx
  AgSingleton<AgAudioManager> *v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11[7]; // [rsp+20h] [rbp-38h] BYREF

  m_ptr = this->m_source.m_ptr;
  if ( m_ptr )
  {
    if ( (unsigned int)AgAudioSource::isRuntime(m_ptr) )
    {
      v3 = AgAudioSourceXAudio2::_pumpRuntimeStream((AgAudioSourceXAudio2 *)this->m_source.m_ptr);
      v6 = (__int64)v3;
      if ( v3 )
      {
        v7 = v3->first.m_ptr;
        memset(&v11[2], 0, 28);
        v8 = AgSingleton<AgAudioManager>::ms_instance;
        v9 = ((__int64 (__fastcall *)(AgStream *, AgStream_vtbl *, __int64, __int64, _QWORD, _QWORD))v7->getResidentData)(
               v7,
               v7->__vftable,
               v4,
               v5,
               0i64,
               0i64);
        v10 = *(_QWORD *)(v6 + 8);
        v11[1] = v9;
        HIDWORD(v11[0]) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 32i64))(v10);
        *(__int64 *)((char *)&v11[4] + 4) = v6;
        if ( !LODWORD(v8[46].__vftable) || *(double *)&v8[47].__vftable == 0.0 )
          this->m_sourceVoice->SubmitSourceBuffer(this->m_sourceVoice, (const XAUDIO2_BUFFER *)v11, 0i64);
      }
    }
  }
}

void __fastcall AgAudioChannelXAudio2::updateElapsedTime(AgAudioChannelXAudio2 *this)
{
  AgAudioChannelData *m_internalData; // rcx
  _RTL_CRITICAL_SECTION *m_oggData; // rdi
  AgXAudio2OGGData *v4; // rcx

  if ( (this->m_internalData->m_internalState & 1) != 0
    && (!LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
     || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0) )
  {
    if ( AgSingleton<AgAudioManager>::ms_instance[43].__vftable )
    {
      if ( AgSingleton<AgAudioManager>::ms_instance[44].__vftable )
      {
        m_internalData = this->m_internalData;
        if ( m_internalData->m_sourceVoice )
        {
          if ( (unsigned int)AgAudioSource::getType(m_internalData->m_source.m_ptr) )
          {
            m_oggData = (_RTL_CRITICAL_SECTION *)this->m_internalData->m_oggData;
            EnterCriticalSection(m_oggData);
            v4 = this->m_internalData->m_oggData;
            if ( v4 )
              ov_time_seek(&v4->m_vf);
            AgAudioChannelData::recalculateLoopingPoints(this->m_internalData, 1);
            LeaveCriticalSection(m_oggData);
          }
          this->m_internalData->m_sourceVoice->FlushSourceBuffers(this->m_internalData->m_sourceVoice);
        }
      }
    }
  }
  this->m_internalData->m_dirtyFlags &= ~0x40u;
}

void __fastcall AgAudioChannelXAudio2::updatePitch(AgAudioChannelXAudio2 *this)
{
  AgAudioChannelData *m_internalData; // rdx
  IXAudio2SourceVoice *m_sourceVoice; // rcx

  if ( !LODWORD(AgSingleton<AgAudioManager>::ms_instance[46].__vftable)
    || *(double *)&AgSingleton<AgAudioManager>::ms_instance[47].__vftable == 0.0 )
  {
    if ( AgSingleton<AgAudioManager>::ms_instance[43].__vftable )
    {
      if ( AgSingleton<AgAudioManager>::ms_instance[44].__vftable )
      {
        m_internalData = this->m_internalData;
        m_sourceVoice = m_internalData->m_sourceVoice;
        if ( m_sourceVoice )
          ((void (__fastcall *)(IXAudio2SourceVoice *, AgAudioChannelData *, _QWORD))m_sourceVoice->SetFrequencyRatio)(
            m_sourceVoice,
            m_internalData,
            0i64);
      }
    }
  }
  this->m_internalData->m_dirtyFlags &= ~2u;
}

void __fastcall AgAudioChannelXAudio2::updatePlayCount(AgAudioChannelXAudio2 *this)
{
  this->m_internalData->m_dirtyFlags &= ~0x20u;
}

void __fastcall AgAudioChannelXAudio2::updateVolume(AgAudioChannelXAudio2 *this, AgAudioManagerXAudio2 *audioManager)
{
  double v2; // xmm0_8
  AgAudioChannelData *m_internalData; // rax
  AgAudioChannelData *v6; // rdx
  unsigned int NumChannels; // esi
  AgAudioChannelData *v8; // rcx
  std::array<int,9> *v9; // rax
  __int128 v10; // xmm0
  __int128 v11; // xmm1
  __int128 *v12; // rax
  std::array<int,9> *v13; // rax
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm1
  __m128i v17; // xmm2
  int v18; // eax
  __int64 v19; // rcx
  float v20; // xmm0_4
  int *v21; // rax
  int *v22; // rax
  int *v23; // rax
  int *v24; // rax
  int *v25; // rax
  int *v26; // rax
  int *v27; // rax
  int *v28; // rax
  int *v29; // rax
  int *v30; // rax
  int *v31; // rax
  int *v32; // rax
  IXAudio2SourceVoice *m_sourceVoice; // rcx
  IXAudio2SourceVoice_vtbl *v34; // rax
  int v35; // [rsp+38h] [rbp-C8h] BYREF
  float v36; // [rsp+3Ch] [rbp-C4h] BYREF
  int v37; // [rsp+40h] [rbp-C0h] BYREF
  float v38; // [rsp+44h] [rbp-BCh] BYREF
  int v39; // [rsp+48h] [rbp-B8h] BYREF
  float v40; // [rsp+4Ch] [rbp-B4h] BYREF
  int v41; // [rsp+50h] [rbp-B0h] BYREF
  float v42; // [rsp+54h] [rbp-ACh] BYREF
  int v43; // [rsp+58h] [rbp-A8h] BYREF
  float v44; // [rsp+5Ch] [rbp-A4h] BYREF
  int v45; // [rsp+60h] [rbp-A0h] BYREF
  float v46; // [rsp+64h] [rbp-9Ch] BYREF
  int v47; // [rsp+68h] [rbp-98h] BYREF
  float v48; // [rsp+6Ch] [rbp-94h] BYREF
  int v49; // [rsp+70h] [rbp-90h] BYREF
  float v50; // [rsp+74h] [rbp-8Ch] BYREF
  int v51; // [rsp+78h] [rbp-88h] BYREF
  float v52; // [rsp+7Ch] [rbp-84h] BYREF
  int v53; // [rsp+80h] [rbp-80h] BYREF
  float v54; // [rsp+84h] [rbp-7Ch] BYREF
  int v55; // [rsp+88h] [rbp-78h] BYREF
  float v56; // [rsp+8Ch] [rbp-74h] BYREF
  int v57; // [rsp+90h] [rbp-70h] BYREF
  float v58; // [rsp+94h] [rbp-6Ch] BYREF
  std::array<int,9> result; // [rsp+98h] [rbp-68h] BYREF
  std::array<int,9> v60; // [rsp+C0h] [rbp-40h] BYREF
  __m128i v61; // [rsp+E8h] [rbp-18h]
  __int128 v62; // [rsp+F8h] [rbp-8h]
  int v63; // [rsp+108h] [rbp+8h]
  AgVolumeArray m_channelVolume; // [rsp+110h] [rbp+10h] BYREF
  __int128 v65[2]; // [rsp+130h] [rbp+30h] BYREF
  int v66; // [rsp+150h] [rbp+50h]
  __int128 v67[2]; // [rsp+158h] [rbp+58h] BYREF
  int v68; // [rsp+178h] [rbp+78h]
  int v69; // [rsp+180h] [rbp+80h] BYREF
  __int64 v70; // [rsp+184h] [rbp+84h]
  __int64 v71; // [rsp+18Ch] [rbp+8Ch]
  __int64 v72; // [rsp+194h] [rbp+94h]
  int v73; // [rsp+19Ch] [rbp+9Ch]

  if ( !audioManager->m_criticalError || (HIDWORD(v2) = 0, audioManager->m_deviceChangedTimestamp == 0.0) )
  {
    if ( audioManager->m_xaudio2 )
    {
      if ( audioManager->m_masterVoice )
      {
        m_internalData = this->m_internalData;
        if ( m_internalData->m_sourceVoice )
        {
          if ( m_internalData->m_type )
            *(float *)&v2 = AgAudioManager::getGlobalStreamVolume(audioManager);
          else
            *(float *)&v2 = AgAudioManager::getGlobalSampleVolume(audioManager);
          v6 = this->m_internalData;
          if ( (v6->m_dirtyFlags & 0x80u) == 0 )
          {
            ((void (__fastcall *)(IXAudio2SourceVoice *, AgAudioChannelData *, _QWORD))v6->m_sourceVoice->SetVolume)(
              v6->m_sourceVoice,
              v6,
              0i64);
          }
          else
          {
            NumChannels = AgAudioSource::getNumChannels(v6->m_source.m_ptr);
            m_channelVolume = this->m_internalData->m_channelVolume;
            AgVolumeArray::applyVolume(&m_channelVolume, v2);
            v8 = this->m_internalData;
            if ( v8->m_oggData )
            {
              v70 = 0i64;
              v71 = 0i64;
              v72 = 0i64;
              v73 = 0;
              v69 = 0;
              if ( NumChannels == 1 )
              {
                v9 = fillSpeakerConfiguration(&result, audioManager->m_channelMask);
                v10 = *(_OWORD *)v9->_Elems;
                v11 = *(_OWORD *)&v9->_Elems[4];
                v66 = v9->_Elems[8];
                v12 = v65;
                v65[0] = v10;
                v65[1] = v11;
              }
              else
              {
                v13 = fillOggStreamConfiguration(&v60, NumChannels);
                v14 = *(_OWORD *)v13->_Elems;
                v15 = *(_OWORD *)&v13->_Elems[4];
                v68 = v13->_Elems[8];
                v12 = v67;
                v67[0] = v14;
                v67[1] = v15;
              }
              v16 = v12[1];
              v17 = (__m128i)*v12;
              v63 = *((_DWORD *)v12 + 8);
              v18 = _mm_cvtsi128_si32(v17);
              v61 = v17;
              v61.m128i_i32[0] = v18;
              v62 = v16;
              if ( v18 != -1 )
              {
                v19 = v18;
                v35 = 1065353216;
                v20 = *((float *)&v69 + v18) + m_channelVolume.m_volumes[0];
                v21 = &v35;
                v36 = v20;
                if ( v20 <= 1.0 )
                  v21 = (int *)&v36;
                *(&v69 + v19) = *v21;
              }
              if ( v61.m128i_i32[2] != -1 )
              {
                v37 = 1065353216;
                v22 = &v37;
                v38 = m_channelVolume.m_volumes[2] + *((float *)&v69 + v61.m128i_i32[2]);
                if ( v38 <= 1.0 )
                  v22 = (int *)&v38;
                *(&v69 + v61.m128i_i32[2]) = *v22;
              }
              if ( v61.m128i_i32[1] != -1 )
              {
                v39 = 1065353216;
                v23 = &v39;
                v40 = m_channelVolume.m_volumes[1] + *((float *)&v69 + v61.m128i_i32[1]);
                if ( v40 <= 1.0 )
                  v23 = (int *)&v40;
                *(&v69 + v61.m128i_i32[1]) = *v23;
              }
              if ( HIDWORD(v62) != -1 )
              {
                v41 = 1065353216;
                v24 = &v41;
                v42 = m_channelVolume.m_volumes[6] + *((float *)&v69 + SHIDWORD(v62));
                if ( v42 <= 1.0 )
                  v24 = (int *)&v42;
                *(&v69 + SHIDWORD(v62)) = *v24;
              }
              if ( v63 != -1 )
              {
                v43 = 1065353216;
                v25 = &v43;
                v44 = m_channelVolume.m_volumes[7] + *((float *)&v69 + v63);
                if ( v44 <= 1.0 )
                  v25 = (int *)&v44;
                *(&v69 + v63) = *v25;
              }
              if ( (_DWORD)v62 != -1 )
              {
                v45 = 1065353216;
                v26 = &v45;
                v46 = m_channelVolume.m_volumes[4] + *((float *)&v69 + (int)v62);
                if ( v46 <= 1.0 )
                  v26 = (int *)&v46;
                *(&v69 + (int)v62) = *v26;
              }
              if ( DWORD1(v62) != -1 )
              {
                v47 = 1065353216;
                v27 = &v47;
                v48 = m_channelVolume.m_volumes[5] + *((float *)&v69 + SDWORD1(v62));
                if ( v48 <= 1.0 )
                  v27 = (int *)&v48;
                *(&v69 + SDWORD1(v62)) = *v27;
              }
              if ( v61.m128i_i32[3] != -1 )
              {
                v49 = 1065353216;
                v28 = &v49;
                v50 = m_channelVolume.m_volumes[3] + *((float *)&v69 + v61.m128i_i32[3]);
                if ( v50 <= 1.0 )
                  v28 = (int *)&v50;
                *(&v69 + v61.m128i_i32[3]) = *v28;
              }
              if ( v61.m128i_i32[2] == -1 )
              {
                if ( v61.m128i_i32[0] != -1 )
                {
                  v51 = 1065353216;
                  v29 = &v51;
                  v52 = (float)(m_channelVolume.m_volumes[2] * 0.85000002) + *((float *)&v69 + v61.m128i_i32[0]);
                  if ( v52 <= 1.0 )
                    v29 = (int *)&v52;
                  *(&v69 + v61.m128i_i32[0]) = *v29;
                }
                if ( v61.m128i_i32[1] != -1 )
                {
                  v53 = 1065353216;
                  v30 = &v53;
                  v54 = (float)(m_channelVolume.m_volumes[2] * 0.85000002) + *((float *)&v69 + v61.m128i_i32[1]);
                  if ( v54 <= 1.0 )
                    v30 = (int *)&v54;
                  *(&v69 + v61.m128i_i32[1]) = *v30;
                }
              }
              if ( v61.m128i_i32[3] == -1 )
              {
                if ( v61.m128i_i32[0] != -1 )
                {
                  v55 = 1065353216;
                  v31 = &v55;
                  v56 = (float)(m_channelVolume.m_volumes[3] * 0.25) + *((float *)&v69 + v61.m128i_i32[0]);
                  if ( v56 <= 1.0 )
                    v31 = (int *)&v56;
                  *(&v69 + v61.m128i_i32[0]) = *v31;
                }
                if ( v61.m128i_i32[1] != -1 )
                {
                  v57 = 1065353216;
                  v32 = &v57;
                  v58 = (float)(m_channelVolume.m_volumes[3] * 0.25) + *((float *)&v69 + v61.m128i_i32[1]);
                  if ( v58 <= 1.0 )
                    v32 = (int *)&v58;
                  *(&v69 + v61.m128i_i32[1]) = *v32;
                }
              }
              m_sourceVoice = this->m_internalData->m_sourceVoice;
              v34 = m_sourceVoice->__vftable;
              if ( NumChannels == 1 )
                v34->SetOutputMatrix(m_sourceVoice, 0i64, 1u, audioManager->m_numChannels, (const float *)&v69, 0);
              else
                v34->SetChannelVolumes(m_sourceVoice, NumChannels, (const float *)&v69, 0);
            }
            else
            {
              v8->m_sourceVoice->SetChannelVolumes(v8->m_sourceVoice, NumChannels, m_channelVolume.m_volumes, 0);
            }
          }
        }
      }
    }
  }
  this->m_internalData->m_dirtyFlags &= 0x62u;
}

