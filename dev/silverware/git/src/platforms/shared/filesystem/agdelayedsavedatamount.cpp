#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/silverware/git/src/platforms/shared/filesystem/agvirtualmount.h"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "dev/silverware/git/sdk/util/ageventdispatcher.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/silverware/git/sdk/system/agsystemmanager.h"
#include "dev/silverware/git/sdk/system/agsystemconfig.h"
#include "dev/silverware/git/sdk/util/agjsondata.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "dev/silverware/git/sdk/memory/agbuffer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/memory/agbufferstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/silverware/git/src/platforms/shared/filesystem/agdelayedsavedatamount.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"

AgDelayedSaveDataMount::AgDelayedSaveDataMount(const AgString & mountPoint, AgPointer<AgMount> target, const AgPath & path, AgPointer<AgUser> user); // 0x14069D1E0
AgMountErrorEvent::AgMountErrorEvent(AgMountErrorEvent & __that); // 0x14069D350
AgMountErrorEvent::AgMountErrorEvent(const AgMountErrorEvent & __that); // 0x14069D3E0
AgDelayedSaveDataMount::~AgDelayedSaveDataMount(); // 0x14069D4F0
void AgDelayedSaveDataMount::mount(); // 0x14069DA40
void AgDelayedSaveDataMount::retry(const AgMountErrorEvent & e); // 0x14069E1A0
long AgDelayedSaveDataMount::removeDirectory(const AgPath & path); // 0x14069E070
void AgDelayedSaveDataMount::onExecuteThread(); // 0x14069DAA0
void AgDelayedSaveDataMount::onJoinThread(); // 0x14069DBA0
long AgDelayedSaveDataMount::getThreadIsRunning(); // 0x140047560
void AgDelayedSaveDataMount::update(); // 0x14069E260
class AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >
{
public:
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >(const AgReference<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >(AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >(const AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >(AgBufferStream<AgBuffer<AgAllocator<1> > > *);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >();
	~AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > >();
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > & operator=(AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > & operator=(const AgReference<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > & operator=(const AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > & operator=(AgBufferStream<AgBuffer<AgAllocator<1> > > *);
	bool operator<(const AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	AgBufferStream<AgBuffer<AgAllocator<1> > > * operator->();
	AgBufferStream<AgBuffer<AgAllocator<1> > > & operator*();
	bool operator==(const AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	bool operator==(AgBufferStream<AgBuffer<AgAllocator<1> > > *);
	bool operator!=(const AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
	bool operator!=(AgBufferStream<AgBuffer<AgAllocator<1> > > *);
	AgBufferStream<AgBuffer<AgAllocator<1> > > * getObject();
	void swap(AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > &);
private:
	AgReferenceCount * m_ref; // 0x0
	AgBufferStream<AgBuffer<AgAllocator<1> > > * m_ptr; // 0x8
public:
	AgPointer<AgStream> operator class AgPointer<class AgStream>();
};
typedef long long AgPointerOffset;
typedef AgBufferStream<AgBuffer<AgAllocator<1> > > AgBufferSystemStream;
typedef AgBuffer<AgAllocator<1> > AgBufferSystem;
void AgDelayedSaveDataMount::readSaveData(); // 0x14069DD70
void AgDelayedSaveDataMount::writeSaveData(); // 0x14069E560void __fastcall AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        AgPointer<AgPlayer> *this,
        const AgPointer<AgPlayer> *rhs)
{
  AgReferenceCount *m_ref; // rsi
  int m_strongCount; // ebx

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  m_ref = rhs->m_ref;
  if ( rhs->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          return;
      }
      if ( m_strongCount != -1 )
      {
        this->m_ref = rhs->m_ref;
        this->m_ptr = rhs->m_ptr;
      }
    }
  }
}

AgPointer<AgStream> *__fastcall AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>::operator<AgStream> AgPointer<AgStream>(
        AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > *this,
        AgPointer<AgStream> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)this);
  return result;
}

void __fastcall std::_Destroy_range<std::allocator<AgMountErrorEvent>,AgMountErrorEvent *>(
        AgMountErrorEvent *_First,
        AgMountErrorEvent *_Last,
        std::_Wrap_alloc<std::allocator<AgMountErrorEvent> > *_Al)
{
  AgMountErrorEvent *v4; // rbx
  unsigned __int64 v5; // rdx

  if ( _First != _Last )
  {
    v4 = _First;
    do
    {
      AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&v4->data);
      AgString::~AgString(&v4->path.m_path, v5);
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)v4++);
    }
    while ( v4 != _Last );
  }
}

AgMountErrorEvent *__fastcall std::_Uninitialized_move_al_unchecked1<AgMountErrorEvent *,AgMountErrorEvent *,std::allocator<AgMountErrorEvent>>(
        AgMountErrorEvent *_First,
        AgMountErrorEvent *_Last,
        AgMountErrorEvent *_Dest,
        std::_Wrap_alloc<std::allocator<AgMountErrorEvent> > *_Al)
{
  while ( _First != _Last )
  {
    if ( _Dest )
      AgMountErrorEvent::AgMountErrorEvent(_Dest, _First);
    ++_Dest;
    ++_First;
  }
  return _Dest;
}

void __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::AgBufferStream<AgBuffer<AgAllocator<1>>>(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        const AgBufferStream<AgBuffer<AgAllocator<1> > > *stream)
{
  this->m_refCount = 0i64;
  this->__vftable = (AgBufferStream<AgBuffer<AgAllocator<1> > >_vtbl *)&AgStream::`vftable';
  this->__vftable = (AgBufferStream<AgBuffer<AgAllocator<1> > >_vtbl *)&AgBufferStream<AgBuffer<AgAllocator<1>>>::`vftable';
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)&this->m_buffer,
    (const AgPointer<AgPlayer> *)&stream->m_buffer);
  this->m_bufferOffset = stream->m_bufferOffset;
  this->m_bufferSize = stream->m_bufferSize;
  this->m_bufferPosition = stream->m_bufferPosition;
}

void __fastcall AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        AgPointer<AgBuffer<AgAllocator<1> > > *this,
        AgBuffer<AgAllocator<1> > *t)
{
  AgReferenceCount *v4; // rax
  int v5; // ecx
  AgReferenceCount *m_refCount; // rsi

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      v5 = 1;
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = t;
      }
      else
      {
        v4 = 0i64;
      }
      t->m_refCount = v4;
    }
    m_refCount = t->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(t->m_refCount);
    this->m_ref = m_refCount;
    this->m_ptr = t;
  }
}

void __fastcall AgPointer<AgStream>::AgPointer<AgStream>(AgPointer<AgStream> *this, AgStream *t)
{
  AgReferenceCount *v4; // rax
  int v5; // ecx
  AgReferenceCount *m_refCount; // rsi

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      v5 = 1;
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = t;
      }
      else
      {
        v4 = 0i64;
      }
      t->m_refCount = v4;
    }
    m_refCount = t->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(t->m_refCount);
    this->m_ref = m_refCount;
    this->m_ptr = t;
  }
}

void __fastcall AgDelayedSaveDataMount::AgDelayedSaveDataMount(
        AgDelayedSaveDataMount *this,
        const AgString *mountPoint,
        AgPointer<AgMount> *target,
        const AgPath *path,
        AgPointer<AgUser> *user)
{
  AgPointer<AgUser> *v9; // rax
  AgController *v10; // rbx
  AgThread *v11; // rax
  AgController *v12; // rax
  AgPointer<AgPlayer> v13; // [rsp+38h] [rbp-40h] BYREF

  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(&v13, (const AgPointer<AgPlayer> *)user);
  AgVirtualMount::AgVirtualMount(this, mountPoint, v9);
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgIThreadHost::`vftable';
  this->AgVirtualMount::AgMount::__vftable = (AgDelayedSaveDataMount_vtbl *)&AgDelayedSaveDataMount::`vftable'{for `AgVirtualMount'};
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgDelayedSaveDataMount::`vftable'{for `AgIThreadHost'};
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)&this->m_target,
    (const AgPointer<AgPlayer> *)target);
  AgString::AgString(&this->m_path.m_path, &path->m_path);
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
  this->m_condition.m_conditionVariable.m_mutex = &this->m_condition.m_mutex;
  InitializeConditionVariable((PCONDITION_VARIABLE)&this->m_condition.m_conditionVariable.m_data);
  v10 = 0i64;
  this->m_workerThread.m_ref = 0i64;
  this->m_workerThread.m_ptr = 0i64;
  this->m_running = 1;
  this->m_shouldRead = 0;
  this->m_writeBuffer.m_ref = 0i64;
  this->m_writeBuffer.m_ptr = 0i64;
  v11 = (AgThread *)operator new(0x28ui64);
  if ( v11 )
  {
    AgThread::AgThread(v11, &this->AgIThreadHost, 0x4000ui64, -1, "AgDelayedSaveDataMount");
    v10 = v12;
  }
  AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_workerThread, v10);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)target);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)user);
}

void __fastcall AgMountErrorEvent::AgMountErrorEvent(AgMountErrorEvent *this, AgMountErrorEvent *__that)
{
  this->mount.m_ref = __that->mount.m_ref;
  this->mount.m_ptr = __that->mount.m_ptr;
  __that->mount.m_ref = 0i64;
  __that->mount.m_ptr = 0i64;
  AgString::AgString(&this->path.m_path, &__that->path.m_path);
  this->operation = __that->operation;
  this->expectedSize = __that->expectedSize;
  this->errorData = __that->errorData;
  this->data = __that->data;
  __that->data.m_ref = 0i64;
  __that->data.m_ptr = 0i64;
}

void __fastcall AgMountErrorEvent::AgMountErrorEvent(AgMountErrorEvent *this, const AgMountErrorEvent *__that)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)this,
    (const AgPointer<AgPlayer> *)__that);
  AgString::AgString(&this->path.m_path, &__that->path.m_path);
  this->operation = __that->operation;
  this->expectedSize = __that->expectedSize;
  this->errorData = __that->errorData;
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)&this->data,
    (const AgPointer<AgPlayer> *)&__that->data);
}

void __fastcall AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>::~AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>(
        AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > *this)
{
  AgBufferStream<AgBuffer<AgAllocator<1> > > *m_ptr; // rdi
  AgReferenceCount *m_ref; // rbx
  int v3; // esi

  m_ptr = this->m_ptr;
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( this->m_ref )
  {
    this->m_ref = 0i64;
    v3 = 0;
    if ( !(unsigned int)AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !(unsigned int)AgAtomicDecrement(&m_ref->m_weakCount) )
        v3 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgBufferStream<AgBuffer<AgAllocator<1> > > *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v3 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgDelayedSaveDataMount::~AgDelayedSaveDataMount(AgDelayedSaveDataMount *this)
{
  unsigned __int64 v2; // rdx

  AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&this->m_writeBuffer);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->m_workerThread);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
  AgString::~AgString(&this->m_path.m_path, v2);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->m_target);
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgIThreadHost::`vftable';
  AgVirtualMount::~AgVirtualMount(this);
}

void __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::operator delete(void *p)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool.m_lock);
  *(_QWORD *)p = AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool.m_free;
  AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool.m_free = (unsigned __int8 *)p;
  --AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool.m_used;
  LeaveCriticalSection((LPCRITICAL_SECTION)&AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool.m_lock);
}

void __fastcall std::vector<AgMountErrorEvent>::_Reallocate(
        std::vector<AgMountErrorEvent> *this,
        unsigned __int64 _Count)
{
  AgMountErrorEvent *v4; // r14
  AgMountErrorEvent *Mylast; // rsi
  AgMountErrorEvent *Myfirst; // rbx
  signed __int64 v7; // r15
  unsigned __int64 v8; // rdx

  v4 = std::allocator<AgMountErrorEvent>::allocate((std::allocator<AgMountErrorEvent> *)this, _Count);
  std::_Uninitialized_move_al_unchecked1<AgMountErrorEvent *,AgMountErrorEvent *,std::allocator<AgMountErrorEvent>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    (std::_Wrap_alloc<std::allocator<AgMountErrorEvent> > *)this);
  Mylast = this->_Mypair._Myval2._Mylast;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v7 = Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( ; Myfirst != Mylast; ++Myfirst )
    {
      AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&Myfirst->data);
      AgString::~AgString(&Myfirst->path.m_path, v8);
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    }
    std::allocator<AgMountErrorEvent>::deallocate(
      (std::allocator<AgMountErrorEvent> *)this,
      this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v7];
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<AgMountErrorEvent>::_Reserve(std::vector<AgMountErrorEvent> *this, unsigned __int64 _Count)
{
  AgMountErrorEvent *Myend; // rcx
  AgMountErrorEvent *Mylast; // r9
  signed __int64 v6; // rdx
  unsigned __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( Myend - Mylast < _Count )
  {
    v6 = Mylast - this->_Mypair._Myval2._Myfirst;
    if ( 0x333333333333333i64 - v6 < _Count )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + _Count;
    v8 = (unsigned __int128)(((char *)Myend - (char *)this->_Mypair._Myval2._Myfirst) * (__int128)0x6666666666666667i64) >> 64;
    v9 = 0i64;
    v10 = ((unsigned __int64)v8 >> 63) + (v8 >> 5);
    if ( 0x333333333333333i64 - (v10 >> 1) >= v10 )
      v9 = v10 + (v10 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgMountErrorEvent>::_Reallocate(this, v7);
  }
}

AgMountErrorEvent *__fastcall std::allocator<AgMountErrorEvent>::allocate(
        std::allocator<AgMountErrorEvent> *this,
        unsigned __int64 _Count)
{
  AgMountErrorEvent *result; // rax
  unsigned __int64 v3; // rcx
  AgBuffer<AgAllocator<1> > *v4; // rax
  AgBuffer<AgAllocator<1> > *v5; // rcx

  if ( !_Count )
    return 0i64;
  if ( _Count > 0x333333333333333i64 )
    std::_Xbad_alloc();
  v3 = 80 * _Count;
  if ( 80 * _Count < 0x1000 )
  {
    result = (AgMountErrorEvent *)operator new(v3);
    if ( !result )
      invalid_parameter_noinfo_noreturn();
  }
  else
  {
    if ( v3 + 39 <= v3 )
      std::_Xbad_alloc();
    v4 = (AgBuffer<AgAllocator<1> > *)operator new(v3 + 39);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    result = (AgMountErrorEvent *)(((unsigned __int64)&v4->m_alignment + 7) & 0xFFFFFFFFFFFFFFE0ui64);
    result[-1].data.m_ptr = v5;
  }
  return result;
}

AgPointer<AgStream> *__fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::clone(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        AgPointer<AgStream> *result)
{
  AgStream *v4; // rdi
  AgBufferStream<AgBuffer<AgAllocator<1> > > *v5; // rax
  AgStream *v6; // rax

  v4 = 0i64;
  v5 = (AgBufferStream<AgBuffer<AgAllocator<1> > > *)AgMemoryPoolImpl<AgMutex,AgMutex>::_alloc(&AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool);
  if ( v5 )
  {
    AgBufferStream<AgBuffer<AgAllocator<1>>>::AgBufferStream<AgBuffer<AgAllocator<1>>>(v5, this);
    v4 = v6;
  }
  AgPointer<AgStream>::AgPointer<AgStream>(result, v4);
  return result;
}

AgPointer<AgBuffer<AgAllocator<1> > > *__fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::getBuffer(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        AgPointer<AgBuffer<AgAllocator<1> > > *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)&this->m_buffer);
  return result;
}

AgStringRef *__fastcall AgMemoryStream::getName(AgBufferStream<AgBuffer<AgAllocator<1> > > *this, AgStringRef *result)
{
  AgStringRef::AgStringRef(result, "Memory");
  return result;
}

Concurrency::details::ScheduleGroupSegmentBase *__fastcall Scaleform::SwitchFormatter::GetSize(
        Concurrency::details::ContextBase *this)
{
  return this->m_pSegment;
}

AgBuffer<AgAllocator<1> > *__fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::getResidentData(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this)
{
  AgBuffer<AgAllocator<1> > *result; // rax

  result = this->m_buffer.m_ptr;
  if ( result )
    return (AgBuffer<AgAllocator<1> > *)&result->m_data[this->m_bufferOffset];
  return result;
}

_BOOL8 __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::getResidentType(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this)
{
  return this->m_buffer.m_ptr != 0i64;
}

__int64 __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::getSize(AgBufferStream<AgBuffer<AgAllocator<1> > > *this)
{
  AgBuffer<AgAllocator<1> > *m_ptr; // rax
  __int64 result; // rax
  unsigned __int64 m_bufferSize; // rcx

  m_ptr = this->m_buffer.m_ptr;
  if ( m_ptr )
    m_ptr = (AgBuffer<AgAllocator<1> > *)m_ptr->m_size;
  result = (__int64)m_ptr - this->m_bufferOffset;
  if ( result < 0 )
    return 0i64;
  m_bufferSize = this->m_bufferSize;
  if ( m_bufferSize != -1i64 && m_bufferSize >= result )
    return m_bufferSize;
  return result;
}

__int64 __fastcall Scaleform::Render::StrokerAA::GetMeshVertexCount(AgDelayedSaveDataMount *this)
{
  return LODWORD(this->m_mountPoint.m_text);
}

__int64 __fastcall AgUser::isSignedIn(Concurrency::details::ThreadInternalContext *this)
{
  return 1i64;
}

void __fastcall AgDelayedSaveDataMount::mount(AgDelayedSaveDataMount *this)
{
  AgCondition *p_m_condition; // rbx

  this->m_shouldRead = 1;
  p_m_condition = &this->m_condition;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
  WakeAllConditionVariable((PCONDITION_VARIABLE)&p_m_condition->m_conditionVariable.m_data);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_condition);
}

void __fastcall AgDelayedSaveDataMount::onExecuteThread(AgDelayedSaveDataMount *this)
{
  _RTL_CRITICAL_SECTION *v2; // rsi
  _RTL_CRITICAL_SECTION *v3; // rcx

  if ( LODWORD(this->m_mountPoint.m_text) )
  {
    v2 = (_RTL_CRITICAL_SECTION *)&this[-1].m_stateChanged.AgVirtualMount::AgMount::m_mutex.m_data.m_criticalSection.data[32];
    do
    {
      EnterCriticalSection(v2);
      while ( LODWORD(this->m_mountPoint.m_text) )
      {
        if ( HIDWORD(this->m_mountPoint.m_text) )
          break;
        if ( *(_QWORD *)&this->m_stateChanged.AgVirtualMount::AgMount::m_mutex.m_data.m_criticalSection.data[8] )
          break;
        EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex.m_data.m_criticalSection.data[24]);
        LeaveCriticalSection(v2);
        SleepConditionVariableCS(
          (PCONDITION_VARIABLE)&this->m_user,
          *(PCRITICAL_SECTION *)&this->m_modified,
          0xFFFFFFFF);
        LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_mutex.m_data.m_criticalSection.data[24]);
        EnterCriticalSection(v2);
      }
      v3 = v2;
      if ( LODWORD(this->m_mountPoint.m_text) )
      {
        if ( !HIDWORD(this->m_mountPoint.m_text) )
        {
          LeaveCriticalSection(v2);
          LODWORD(this[-1].m_finishedWriting.m_conditionVariable.m_mutex) = 0;
          AgDelayedSaveDataMount::writeSaveData((AgDelayedSaveDataMount *)((char *)this - 336));
          continue;
        }
        LeaveCriticalSection(v2);
        AgDelayedSaveDataMount::readSaveData((AgDelayedSaveDataMount *)((char *)this - 336));
        EnterCriticalSection(v2);
        v3 = v2;
        HIDWORD(this->m_mountPoint.m_text) = 0;
      }
      LeaveCriticalSection(v3);
    }
    while ( LODWORD(this->m_mountPoint.m_text) );
  }
}

void __fastcall AgDelayedSaveDataMount::onJoinThread(AgDelayedSaveDataMount *this)
{
  unsigned __int8 *v1; // rbx

  LODWORD(this->m_mountPoint.m_text) = 0;
  v1 = &this->m_mutex.m_data.m_criticalSection.data[24];
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex.m_data.m_criticalSection.data[24]);
  WakeAllConditionVariable((PCONDITION_VARIABLE)v1 + 6);
  LeaveCriticalSection((LPCRITICAL_SECTION)v1);
}

void __fastcall std::vector<AgMountErrorEvent>::push_back(
        std::vector<AgMountErrorEvent> *this,
        const AgMountErrorEvent *_Val)
{
  AgMountErrorEvent *Mylast; // rcx
  signed __int64 v5; // rdi
  AgMountErrorEvent *v6; // rcx
  AgMountErrorEvent *v7; // rcx

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || this->_Mypair._Myval2._Myfirst > _Val )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgMountErrorEvent>::_Reserve(this, 1ui64);
    v7 = this->_Mypair._Myval2._Mylast;
    if ( v7 )
      AgMountErrorEvent::AgMountErrorEvent(v7, _Val);
  }
  else
  {
    v5 = _Val - this->_Mypair._Myval2._Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgMountErrorEvent>::_Reserve(this, 1ui64);
    v6 = this->_Mypair._Myval2._Mylast;
    if ( v6 )
      AgMountErrorEvent::AgMountErrorEvent(v6, &this->_Mypair._Myval2._Myfirst[v5]);
  }
  ++this->_Mypair._Myval2._Mylast;
}

__int64 __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::read(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        unsigned __int8 *buffer,
        unsigned int size)
{
  __int64 v3; // rsi
  unsigned __int64 m_bufferPosition; // rbp
  unsigned __int64 v7; // rax

  v3 = size;
  if ( !buffer || !this->m_buffer.m_ptr )
    return 0i64;
  m_bufferPosition = this->m_bufferPosition;
  v7 = ((__int64 (*)(void))this->getSize)();
  if ( v3 + m_bufferPosition >= v7 )
    LODWORD(v3) = v7 - m_bufferPosition;
  memmove(buffer, &this->m_buffer.m_ptr->m_data[this->m_bufferOffset + m_bufferPosition], (unsigned int)v3);
  this->m_bufferPosition += (unsigned int)v3;
  return (unsigned int)v3;
}

void __fastcall AgDelayedSaveDataMount::readSaveData(AgDelayedSaveDataMount *this)
{
  AgBuffer<AgAllocator<1> > *v2; // rax
  unsigned int v3; // esi
  AgBuffer<AgAllocator<1> > *v4; // rax
  volatile int *v5; // rbx
  _DWORD *v6; // rax
  int v7; // eax
  volatile int *v8; // r14
  unsigned __int8 *v9; // rax
  unsigned __int8 *v10; // rsi
  int v11; // ebx
  AgPointer<AgStream> *v12; // rax
  AgFile *v13; // rsi
  volatile int *v14; // rbx
  int v15; // er14
  volatile int *value[2]; // [rsp+28h] [rbp-48h] BYREF
  void *p; // [rsp+38h] [rbp-38h] BYREF
  AgFile *v18; // [rsp+40h] [rbp-30h]
  int v19; // [rsp+48h] [rbp-28h]
  AgCondition *p_m_condition; // [rsp+50h] [rbp-20h]
  AgPointer<AgStream> v21; // [rsp+58h] [rbp-18h] BYREF

  ((void (__fastcall *)(AgMount *, void **, AgPath *, __int64, __int64))this->m_target.m_ptr->open)(
    this->m_target.m_ptr,
    &p,
    &this->m_path,
    1i64,
    -2i64);
  if ( (unsigned int)AgFile::waitOpen(v18) )
  {
    v3 = v18->getSize(v18);
    v4 = (AgBuffer<AgAllocator<1> > *)operator new(0x30ui64);
    v5 = (volatile int *)v4;
    if ( v4 )
    {
      v4->m_refCount = 0i64;
      v4->__vftable = (AgBuffer<AgAllocator<1> >_vtbl *)&AgBuffer<AgAllocator<1>>::`vftable';
      v4->m_data = 0i64;
      v4->m_size = 0i64;
      v4->m_alignment = 0i64;
      v4->m_flags = 7;
      AgBuffer<AgAllocator<1>>::reset(v4, v3);
    }
    else
    {
      v5 = 0i64;
    }
    *(_OWORD *)value = 0i64;
    if ( v5 )
    {
      if ( *((_QWORD *)v5 + 1) )
      {
        v7 = 0;
      }
      else
      {
        v6 = AgReferenceCount::operator new(0x10ui64);
        if ( v6 )
        {
          *v6 = 1;
          v6[1] = 1;
          *((_QWORD *)v6 + 1) = v5;
        }
        else
        {
          v6 = 0i64;
        }
        *((_QWORD *)v5 + 1) = v6;
        v7 = 1;
      }
      v8 = (volatile int *)*((_QWORD *)v5 + 1);
      if ( !v7 )
        AgReferenceCount::incRef(*((AgReferenceCount **)v5 + 1));
      value[0] = v8;
      value[1] = v5;
    }
    else
    {
      v5 = value[1];
      v8 = value[0];
    }
    if ( v18->read(v18, (unsigned __int8 *)*((_QWORD *)v5 + 2), v3) )
    {
      v9 = AgMemoryPoolImpl<AgMutex,AgMutex>::_alloc(&AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool);
      v10 = v9;
      if ( v9 )
      {
        *((_QWORD *)v9 + 1) = 0i64;
        *(_QWORD *)v9 = &AgStream::`vftable';
        *(_QWORD *)v9 = &AgBufferStream<AgBuffer<AgAllocator<1>>>::`vftable';
        *((_QWORD *)v9 + 2) = 0i64;
        *((_QWORD *)v9 + 3) = 0i64;
        if ( v8 )
        {
          v11 = *v8;
          if ( *v8 )
          {
            while ( (unsigned int)AgAtomicCompareExchange(value[0], v11, v11 + 1) != v11 )
            {
              v11 = *value[0];
              if ( !*value[0] )
                goto LABEL_29;
            }
            if ( v11 != -1 )
            {
              *((volatile int **)v10 + 2) = value[0];
              *((volatile int **)v10 + 3) = value[1];
            }
          }
        }
LABEL_29:
        *((_QWORD *)v10 + 4) = 0i64;
        *((_QWORD *)v10 + 5) = -1i64;
        *((_QWORD *)v10 + 6) = 0i64;
      }
      else
      {
        v10 = 0i64;
      }
      AgPointer<AgStream>::AgPointer<AgStream>(&v21, (AgStream *)v10);
      AgVirtualMount::deserialize(this, v12);
    }
    AgMount::setMounted(this, 1);
    AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>((AgPointer<AgBuffer<AgAllocator<1> > > *)value);
  }
  else
  {
    v2 = (AgBuffer<AgAllocator<1> > *)operator new(0x30ui64);
    if ( v2 )
    {
      v2->m_refCount = 0i64;
      v2->__vftable = (AgBuffer<AgAllocator<1> >_vtbl *)&AgBuffer<AgAllocator<1>>::`vftable';
      v2->m_alignment = 0i64;
      v2->m_flags = 7;
      v2->m_data = 0i64;
      v2->m_size = 0i64;
    }
    else
    {
      v2 = 0i64;
    }
    AgPointer<AgBuffer<AgAllocator<1>>>::operator=(&this->m_writeBuffer, v2);
    v19 = 0;
    p_m_condition = &this->m_condition;
    EnterCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
    v19 = 1;
    WakeAllConditionVariable((PCONDITION_VARIABLE)&this->m_condition.m_conditionVariable.m_data);
    LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
    v19 = 0;
  }
  v13 = v18;
  v18 = 0i64;
  v14 = (volatile int *)p;
  if ( p )
  {
    p = 0i64;
    v15 = 0;
    if ( !(unsigned int)AgAtomicDecrement(v14) )
    {
      if ( !(unsigned int)AgAtomicDecrement(v14 + 1) )
        v15 = 1;
      *((_QWORD *)v14 + 1) = 0i64;
      if ( v13 )
        ((void (__fastcall *)(AgFile *, __int64))v13->~AgStream)(v13, 1i64);
      if ( v15 )
        AgReferenceCount::operator delete((void *)v14);
    }
  }
}

__int64 __fastcall AgDelayedSaveDataMount::removeDirectory(AgDelayedSaveDataMount *this, const AgPath *path)
{
  AgPath *Relative; // rax
  bool v5; // bl
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  AgString s2; // [rsp+28h] [rbp-30h] BYREF
  AgPath result; // [rsp+38h] [rbp-20h] BYREF

  AgString::AgString(&s2, "/", -1);
  AgPath::clean((AgPath *)&s2);
  Relative = AgPath::getRelative((AgPath *)path, &result);
  v5 = operator==(&Relative->m_path, &s2);
  AgString::~AgString(&result.m_path, v6);
  AgString::~AgString(&s2, v7);
  if ( !v5 )
    return AgUser::isSignedIn((Concurrency::details::ThreadInternalContext *)this);
  this->m_target.m_ptr->remove(this->m_target.m_ptr, &this->m_path);
  return 1i64;
}

void __fastcall AgBuffer<AgAllocator<1>>::resize(AgBuffer<AgAllocator<1> > *this, unsigned __int64 size)
{
  unsigned __int8 *m_data; // rsi
  unsigned __int64 m_alignment; // r8
  AgAllocator<1> *p_m_allocator; // rcx
  unsigned __int8 *v7; // rax
  size_t m_size; // r8

  m_data = this->m_data;
  if ( size )
  {
    m_alignment = this->m_alignment;
    p_m_allocator = &this->m_allocator;
    if ( m_alignment )
      v7 = (unsigned __int8 *)AgAllocator<1>::allocate(p_m_allocator, size, m_alignment);
    else
      v7 = (unsigned __int8 *)AgAllocator<1>::allocate(p_m_allocator, size);
  }
  else
  {
    v7 = 0i64;
  }
  this->m_data = v7;
  if ( m_data )
  {
    m_size = this->m_size;
    if ( size < m_size )
      m_size = size;
    memmove(v7, m_data, m_size);
    AgAllocator<1>::deallocate(&this->m_allocator, m_data);
  }
  this->m_size = size;
}

void __fastcall AgDelayedSaveDataMount::retry(AgDelayedSaveDataMount *this, const AgMountErrorEvent *e)
{
  if ( e->operation == AgMountOperation_Write && !this->m_writeBuffer.m_ptr )
  {
    AgPointer<AgBuffer<AgAllocator<1>>>::operator=(&this->m_writeBuffer, &e->data);
    AgCondition::signalAll(&this->m_condition);
  }
}

void __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::setPosition(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        unsigned __int64 value)
{
  AgBuffer<AgAllocator<1> > *m_ptr; // rax
  unsigned __int64 m_size; // rax

  m_ptr = this->m_buffer.m_ptr;
  if ( m_ptr )
  {
    m_size = m_ptr->m_size;
    if ( m_size < value )
      value = m_size;
    this->m_bufferPosition = value;
  }
  else
  {
    if ( value )
      value = (unsigned __int64)this->m_buffer.m_ptr;
    this->m_bufferPosition = value;
  }
}

void __fastcall AgCondition::signalAll(AgCondition *this)
{
  EnterCriticalSection((LPCRITICAL_SECTION)this);
  WakeAllConditionVariable((PCONDITION_VARIABLE)&this->m_conditionVariable.m_data);
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgDelayedSaveDataMount::update(AgDelayedSaveDataMount *this)
{
  int v2; // er15
  AgBufferStream<AgBuffer<AgAllocator<1> > > *m_ptr; // rbx
  AgBuffer<AgAllocator<1> > *v4; // rax
  int m_strongCount; // edi
  AgReferenceCount *m_ref; // rsi
  AgReferenceCount *v7; // rax
  AgReferenceCount *m_refCount; // rdi
  AgPointer<AgStream> *v9; // rax
  AgPointer<AgBuffer<AgAllocator<1> > > *Buffer; // rax
  char v11; // [rsp+20h] [rbp-60h]
  AgPointer<AgBufferStream<AgBuffer<AgAllocator<1> > > > v12; // [rsp+30h] [rbp-50h] BYREF
  AgPointer<AgBuffer<AgAllocator<1> > > v13; // [rsp+40h] [rbp-40h] BYREF
  int v14; // [rsp+50h] [rbp-30h]
  LPCRITICAL_SECTION lpCriticalSection; // [rsp+58h] [rbp-28h]
  AgPointer<AgStream> result; // [rsp+60h] [rbp-20h] BYREF
  AgPointer<AgBuffer<AgAllocator<1> > > v17; // [rsp+70h] [rbp-10h] BYREF

  v11 = 0;
  lpCriticalSection = (LPCRITICAL_SECTION)&this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  v2 = 1;
  v14 = 1;
  if ( this->m_modified && !this->m_writeBuffer.m_ptr )
  {
    m_ptr = (AgBufferStream<AgBuffer<AgAllocator<1> > > *)AgMemoryPoolImpl<AgMutex,AgMutex>::_alloc(&AgBufferStream<AgBuffer<AgAllocator<1>>>::s_pool);
    if ( m_ptr )
    {
      v4 = (AgBuffer<AgAllocator<1> > *)operator new(0x30ui64);
      if ( v4 )
      {
        v4->m_refCount = 0i64;
        v4->__vftable = (AgBuffer<AgAllocator<1> >_vtbl *)&AgBuffer<AgAllocator<1>>::`vftable';
        v4->m_alignment = 0i64;
        v4->m_flags = 7;
        v4->m_data = 0i64;
        v4->m_size = 0i64;
      }
      else
      {
        v4 = 0i64;
      }
      AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(&v13, v4);
      v11 = 1;
      m_ptr->m_refCount = 0i64;
      m_ptr->__vftable = (AgBufferStream<AgBuffer<AgAllocator<1> > >_vtbl *)&AgStream::`vftable';
      m_ptr->__vftable = (AgBufferStream<AgBuffer<AgAllocator<1> > >_vtbl *)&AgBufferStream<AgBuffer<AgAllocator<1>>>::`vftable';
      m_ptr->m_buffer.m_ref = 0i64;
      m_ptr->m_buffer.m_ptr = 0i64;
      if ( v13.m_ref )
      {
        m_strongCount = v13.m_ref->m_strongCount;
        if ( v13.m_ref->m_strongCount )
        {
          while ( 1 )
          {
            m_ref = v13.m_ref;
            if ( (unsigned int)AgAtomicCompareExchange(&v13.m_ref->m_strongCount, m_strongCount, m_strongCount + 1) == m_strongCount )
              break;
            m_strongCount = m_ref->m_strongCount;
            if ( !m_ref->m_strongCount )
              goto LABEL_14;
          }
          if ( m_strongCount != -1 )
          {
            m_ptr->m_buffer.m_ref = m_ref;
            m_ptr->m_buffer.m_ptr = v13.m_ptr;
          }
        }
      }
LABEL_14:
      m_ptr->m_bufferOffset = 0i64;
      m_ptr->m_bufferSize = -1i64;
      m_ptr->m_bufferPosition = 0i64;
    }
    else
    {
      m_ptr = 0i64;
    }
    v12 = 0i64;
    if ( m_ptr )
    {
      if ( m_ptr->m_refCount )
      {
        v2 = 0;
      }
      else
      {
        v7 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
        if ( v7 )
        {
          v7->m_strongCount = 1;
          v7->m_weakCount = 1;
          v7->m_data = m_ptr;
        }
        else
        {
          v7 = 0i64;
        }
        m_ptr->m_refCount = v7;
      }
      m_refCount = m_ptr->m_refCount;
      if ( !v2 )
        AgReferenceCount::incRef(m_ptr->m_refCount);
      v12.m_ref = m_refCount;
      v12.m_ptr = m_ptr;
    }
    else
    {
      m_ptr = v12.m_ptr;
    }
    if ( (v11 & 1) != 0 )
      AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&v13);
    v9 = AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>::operator<AgStream> AgPointer<AgStream>(&v12, &result);
    AgVirtualMount::serialize(this, v9);
    Buffer = AgBufferStream<AgBuffer<AgAllocator<1>>>::getBuffer(m_ptr, &v17);
    AgPointer<AgBuffer<AgAllocator<1>>>::operator=(&this->m_writeBuffer, Buffer);
    AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&v17);
    AgCondition::signalAll(&this->m_condition);
    AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>::~AgPointer<AgBufferStream<AgBuffer<AgAllocator<1>>>>(&v12);
  }
  LeaveCriticalSection(lpCriticalSection);
}

__int64 __fastcall AgBufferStream<AgBuffer<AgAllocator<1>>>::write(
        AgBufferStream<AgBuffer<AgAllocator<1> > > *this,
        const unsigned __int8 *buffer,
        unsigned int size)
{
  unsigned int v4; // esi
  unsigned __int64 m_bufferPosition; // rbp
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rax
  AgBuffer<AgAllocator<1> > *m_ptr; // rcx
  unsigned __int64 m_size; // rdx

  v4 = size;
  if ( !this->m_buffer.m_ptr )
    return 0i64;
  m_bufferPosition = this->m_bufferPosition;
  v8 = size + m_bufferPosition;
  v9 = this->getSize(this);
  if ( v8 >= v9 )
  {
    m_ptr = this->m_buffer.m_ptr;
    if ( (m_ptr->m_flags & 4) != 0
      && (!m_ptr ? (m_size = 0i64) : (m_size = m_ptr->m_size), v8 + this->m_bufferOffset >= m_size) )
    {
      AgBuffer<AgAllocator<1>>::resize(m_ptr, v8 + this->m_bufferOffset);
    }
    else
    {
      v4 = v9 - m_bufferPosition;
    }
  }
  memmove(&this->m_buffer.m_ptr->m_data[this->m_bufferOffset + m_bufferPosition], buffer, v4);
  this->m_bufferPosition += v4;
  return v4;
}

void __fastcall AgDelayedSaveDataMount::writeSaveData(AgDelayedSaveDataMount *this)
{
  AgPointer<AgMount> *v2; // rax
  AgReferenceCount *m_ref; // rdi
  int m_strongCount; // ebx
  AgBuffer<AgAllocator<1> > *m_ptr; // rsi
  AgMount *v6; // rbx
  AgPath *Parent; // rax
  unsigned __int64 v8; // rdx
  AgMount *v9; // rbx
  AgPath *v10; // rax
  unsigned __int64 v11; // rdx
  AgStringRef *v12; // rax
  AgStringRef *v13; // rax
  AgMountError v14; // ebx
  AgSingleton<AgFileSystem> *v15; // rbx
  _RTL_CRITICAL_SECTION *v16; // rdi
  unsigned __int64 v17; // rdx
  AgPointer<AgMount> *v18; // rax
  unsigned __int64 v19; // rdx
  AgFile *v20; // rdi
  volatile int *v21; // rbx
  int v22; // er14
  unsigned __int64 v23; // rdx
  AgReferenceCount *v24; // rbx
  int v25; // edi
  AgPointer<AgBuffer<AgAllocator<1> > > rhs_8; // [rsp+28h] [rbp-E0h] BYREF
  volatile int *value; // [rsp+38h] [rbp-D0h] BYREF
  AgFile *v28; // [rsp+40h] [rbp-C8h]
  AgString v29; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v30; // [rsp+58h] [rbp-B0h]
  AgSingleton<AgFileSystem> *v31; // [rsp+60h] [rbp-A8h]
  AgString v32; // [rsp+68h] [rbp-A0h] BYREF
  AgMountErrorEvent v33; // [rsp+78h] [rbp-90h] BYREF
  __int64 v34; // [rsp+C8h] [rbp-40h]
  AgPointer<AgMount> v35; // [rsp+D0h] [rbp-38h] BYREF
  AgPath result; // [rsp+E0h] [rbp-28h] BYREF
  AgPath v37; // [rsp+F0h] [rbp-18h] BYREF
  AgStringRef v38; // [rsp+108h] [rbp+0h] BYREF
  AgStringRef v39; // [rsp+118h] [rbp+10h] BYREF
  AgPointer<AgMount> v40; // [rsp+128h] [rbp+20h] BYREF
  AgStringRef v41; // [rsp+138h] [rbp+30h] BYREF
  AgStringRef v42; // [rsp+148h] [rbp+40h] BYREF

  v34 = -2i64;
  AgPointer<AgMount>::AgPointer<AgMount>(&v35, this);
  AgFileSystem::onWriteBegin((AgFileSystem *)AgSingleton<AgFileSystem>::ms_instance, v2);
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  rhs_8 = 0i64;
  m_ref = this->m_writeBuffer.m_ref;
  if ( !m_ref )
    goto LABEL_8;
  m_strongCount = m_ref->m_strongCount;
  if ( !m_ref->m_strongCount )
    goto LABEL_8;
  while ( (unsigned int)AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( !m_ref->m_strongCount )
      goto LABEL_8;
  }
  if ( m_strongCount != -1 )
  {
    rhs_8.m_ref = this->m_writeBuffer.m_ref;
    m_ptr = this->m_writeBuffer.m_ptr;
    rhs_8.m_ptr = m_ptr;
  }
  else
  {
LABEL_8:
    m_ptr = rhs_8.m_ptr;
  }
  AgPointer<AgBuffer<AgAllocator<1>>>::operator=(&this->m_writeBuffer, 0i64);
  LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  v6 = this->m_target.m_ptr;
  Parent = AgPath::getParent(&this->m_path, &result);
  LOBYTE(v6) = v6->directoryExists(v6, Parent) == 0;
  AgString::~AgString(&result.m_path, v8);
  if ( (_BYTE)v6 )
  {
    v9 = this->m_target.m_ptr;
    v10 = AgPath::getParent(&this->m_path, &v37);
    v9->createDirectory(v9, v10, 1);
    AgString::~AgString(&v37.m_path, v11);
  }
  AgString::AgString(&v29, &this->m_path.m_path);
  AgString::AgString(&v32, &this->m_path.m_path);
  AgStringRef::AgStringRef(&v41, ".bak");
  v38 = *v12;
  AgPath::setExtension((AgPath *)&v32, &v38);
  AgStringRef::AgStringRef(&v42, ".tmp");
  v39 = *v13;
  AgPath::setExtension((AgPath *)&v29, &v39);
  v14 = AgMountError_NotOwned;
  this->m_target.m_ptr->open(this->m_target.m_ptr, (AgPointer<AgFile> *)&value, (const AgPath *)&v29, 2u);
  if ( !(unsigned int)AgFile::waitOpen(v28) )
    goto LABEL_17;
  if ( v28->write(v28, m_ptr->m_data, m_ptr->m_size) != m_ptr->m_size )
  {
    v14 = AgMountError_NoFreeSpace;
LABEL_17:
    v33.mount = 0i64;
    AgString::AgString(&v33.path.m_path);
    v33.errorData.error = AgMountError_None;
    memset(&v33.errorData.systemError, 0, 24);
    AgPointer<AgMount>::operator=(&v33.mount, this);
    AgString::operator=(&v33.path.m_path, &this->m_path.m_path);
    v33.operation = AgMountOperation_Write;
    v33.expectedSize = m_ptr->m_size;
    v33.errorData.error = v14;
    v33.errorData.systemError = 0i64;
    AgPointer<AgBuffer<AgAllocator<1>>>::operator=(&v33.data, &rhs_8);
    v15 = AgSingleton<AgFileSystem>::ms_instance;
    LODWORD(v30) = 0;
    v16 = (_RTL_CRITICAL_SECTION *)&AgSingleton<AgFileSystem>::ms_instance[48];
    v31 = AgSingleton<AgFileSystem>::ms_instance + 48;
    EnterCriticalSection((LPCRITICAL_SECTION)&AgSingleton<AgFileSystem>::ms_instance[48]);
    LODWORD(v30) = 1;
    std::vector<AgMountErrorEvent>::push_back((std::vector<AgMountErrorEvent> *)&v15[53], &v33);
    LeaveCriticalSection(v16);
    LODWORD(v30) = 0;
    AgPointer<AgBuffer<AgAllocator<1>>>::~AgPointer<AgBuffer<AgAllocator<1>>>(&v33.data);
    AgString::~AgString(&v33.path.m_path, v17);
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&v33);
    goto LABEL_20;
  }
  v28->close(v28);
  if ( this->m_target.m_ptr->exists(this->m_target.m_ptr, &this->m_path)
    && !this->m_target.m_ptr->move(this->m_target.m_ptr, &this->m_path, (const AgPath *)&v32, 1)
    || !this->m_target.m_ptr->move(this->m_target.m_ptr, (const AgPath *)&v29, &this->m_path, 1) )
  {
    goto LABEL_17;
  }
  if ( !this->m_mounted )
    AgMount::setMounted(this, 1);
LABEL_20:
  AgPointer<AgMount>::AgPointer<AgMount>(&v40, this);
  AgFileSystem::onWriteEnd((AgFileSystem *)AgSingleton<AgFileSystem>::ms_instance, v18);
  v20 = v28;
  v28 = 0i64;
  v21 = value;
  if ( value )
  {
    value = 0i64;
    v22 = 0;
    if ( (unsigned int)AgAtomicDecrement(v21) )
    {
      m_ptr = rhs_8.m_ptr;
    }
    else
    {
      if ( (unsigned int)AgAtomicDecrement(v21 + 1) )
        m_ptr = rhs_8.m_ptr;
      else
        v22 = 1;
      *((_QWORD *)v21 + 1) = 0i64;
      if ( v20 )
        ((void (__fastcall *)(AgFile *, __int64))v20->~AgStream)(v20, 1i64);
      if ( v22 )
        AgReferenceCount::operator delete((void *)v21);
    }
  }
  AgString::~AgString(&v32, v19);
  AgString::~AgString(&v29, v23);
  rhs_8.m_ptr = 0i64;
  v24 = rhs_8.m_ref;
  if ( rhs_8.m_ref )
  {
    rhs_8.m_ref = 0i64;
    v25 = 0;
    if ( !(unsigned int)AgAtomicDecrement(&v24->m_strongCount) )
    {
      if ( !(unsigned int)AgAtomicDecrement(&v24->m_weakCount) )
        v25 = 1;
      v24->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgBuffer<AgAllocator<1> > *, __int64))m_ptr->~AgBuffer<AgAllocator<1> >)(m_ptr, 1i64);
      if ( v25 )
        AgReferenceCount::operator delete(v24);
    }
  }
}

