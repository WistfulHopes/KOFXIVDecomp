#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/microsoft directx sdk (june 2010)/include/d3d10.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/silverware/git/sdk/input/agcontrolleraxiscomponent.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlwinverapi.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlsimpcoll.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/tchar.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "program files (x86)/microsoft directx sdk (june 2010)/include/d3d11sdklayers.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/silverware/git/sdk/util/ageventdispatcher.h"
#include "program files (x86)/windows kits/8.1/include/um/winnt.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlcomcli.h"
#include "program files (x86)/windows kits/8.1/include/shared/basetsd.h"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/silverware/git/sdk/system/agsystemconfig.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlcore.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_stdinc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/windows kits/8.1/include/um/oleauto.h"
#include "dev/silverware/git/sdk/util/agjsondata.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "dev/silverware/git/sdk/system/agwindowconfig.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/agdisplay.h"
#include "dev/silverware/git/sdk/agvector4.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/mbstring.h"
#include "dev/silverware/git/src/platforms/shared/input/agsdlinputmanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "program files (x86)/windows kits/8.1/include/um/winuser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agvector3.h"
#include "program files (x86)/windows kits/8.1/include/um/combaseapi.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/statreg.h"
#include "dev/silverware/git/src/platforms/shared/input/agstandardgamepadcontroller.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/input/agcontrollerrumblecomponent.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/windows kits/8.1/include/um/unknwnbase.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atltransactionmanager.h"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_endian.h"
#include "dev/silverware/git/sdk/input/agcontrollerbuttoncomponent.h"
#include "dev/silverware/git/sdk/input/agcontrollercomponent.h"
#include "dev/silverware/git/src/platforms/pc/input/agpcinputmanager.h"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_rect.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/silverware/git/sdk/input/aginputmanager.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/input/agcontroller.h"
#include "program files (x86)/windows kits/8.1/include/um/winbase.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlbase.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atldef.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/silverware/git/src/platforms/shared/input/agstandardmousecontroller.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlchecked.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlexcept.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atltrace.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlconv.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/atlmfc/include/atlalloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "program files (x86)/windows kits/8.1/include/um/winsock2.h"
#include "program files (x86)/windows kits/8.1/include/um/propidl.h"
#include "dev/silverware/git/src/platforms/pc/agdisplayplatformdatapc.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "program files (x86)/windows kits/8.1/include/shared/stralign.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/microsoft directx sdk (june 2010)/include/d3d11.h"
#include "dev/silverware/git/src/platforms/pc/system/agpcsystemmanager.h"
#include "dev/silverware/git/sdk/system/agsystemmanager.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/silverware/git/src/platforms/shared/input/agstandardkeyboardcontroller.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "dev/silverware/git/src/platforms/shared/input/agstandardtouchcontroller.h"
#include "dev/silverware/git/sdk/input/agcontrollertouchcomponent.h"
#include "dev/silverware/git/sdk/aghash.h"
#include "dev/silverware/git/sdk/agstringutils.h"
#include "program files (x86)/windows kits/8.1/include/shared/winerror.h"
#include "program files (x86)/windows kits/8.1/include/shared/guiddef.h"
#include "program files (x86)/windows kits/8.1/include/um/shlwapi.h"
#include "dev/silverware/git/sdk/agrectangle.h"

long globalGetLogConsole(); // 0x140688AD0
class ThreadHost :
	AgIThreadHost
{
public:
	ThreadHost(ThreadHost &);
	ThreadHost(const ThreadHost &);
	ThreadHost();
	virtual void onExecuteThread();
	virtual void onJoinThread();
	virtual long getThreadIsRunning();
private:
	volatile long m_running; // 0x8
public:
	virtual ~ThreadHost();
	ThreadHost & operator=(ThreadHost &);
	ThreadHost & operator=(const ThreadHost &);
};
void ThreadHost::onExecuteThread(); // 0x140688B20
void ThreadHost::onJoinThread(); // 0x140688B80
long ThreadHost::getThreadIsRunning(); // 0x140030600
AgPCSystemManager::AgPCSystemManager(); // 0x1406876B0
ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>(); // 0x140687820
ATL::CComPtr<IDXGIAdapter>::~CComPtr<IDXGIAdapter>(); // 0x140687850
ATL::CComPtr<IDXGIDevice>::~CComPtr<IDXGIDevice>(); // 0x140687880
AgEditedInputEvent::~AgEditedInputEvent(); // 0x1406878C0
AgPCSystemManager::~AgPCSystemManager(); // 0x1406878E0
ThreadHost::~ThreadHost(); // 0x1406879B0
long AgPCSystemManager::onSingletonInit(); // 0x140688BF0
long AgPCSystemManager::onSingletonExit(); // 0x140688BD0
void AgPCSystemManager::createWindow(const AgWindowConfig & config); // 0x1406883D0
void AgPCSystemManager::destroyWindow(); // 0x140688810
long AgPCSystemManager::waitForWindow(); // 0x140689B10
long AgPCSystemManager::createWindow(); // 0x1406882D0
void AgPCSystemManager::createDisplay(); // 0x140687EC0
void AgPCSystemManager::setWindowProperties(unsigned long width, unsigned long height, long vsync, AgWindowMode mode); // 0x1406896A0
void AgPCSystemManager::updateProperties(); // 0x140689710
long AgPCSystemManager::updateWindowProperties(long fullscreen); // 0x140689940
void AgPCSystemManager::processWindowMessage(); // 0x140688DF0
long AgPCSystemManager::run(); // 0x1406894E0
void AgPCSystemManager::handleWindowClose(); // 0x140688AE0
long AgPCSystemManager::createWindowSDL(); // 0x140688460
void AgPCSystemManager::processCommandArguments(); // 0x140688D30
long AgPCSystemManager::isRunningVistaOrLater(); // 0x140688B10
long _validateOSVersion(unsigned long versionMajor, unsigned long versionMinor); // 0x140687D90
void AgPCSystemManager::onShutdown(); // 0x140688BB0
unsigned long long AgPCSystemManager::getVideoMemorySize(); // 0x140688940
class ATL::CComPtr<ID3D11Device> :
	ATL::CComPtrBase<ID3D11Device>
{
public:
	CComPtr<ID3D11Device>(ATL::CComPtr<ID3D11Device> &);
	CComPtr<ID3D11Device>(const ATL::CComPtr<ID3D11Device> &);
	CComPtr<ID3D11Device>(ID3D11Device *);
	CComPtr<ID3D11Device>();
	ID3D11Device * operator=(ATL::CComPtr<ID3D11Device> &);
	ID3D11Device * operator=(const ATL::CComPtr<ID3D11Device> &);
	ID3D11Device * operator=(ID3D11Device *);
	~CComPtr<ID3D11Device>();
};
class ATL::CComPtr<IDXGIDevice> :
	ATL::CComPtrBase<IDXGIDevice>
{
public:
	CComPtr<IDXGIDevice>(ATL::CComPtr<IDXGIDevice> &);
	CComPtr<IDXGIDevice>(const ATL::CComPtr<IDXGIDevice> &);
	CComPtr<IDXGIDevice>(IDXGIDevice *);
	CComPtr<IDXGIDevice>();
	IDXGIDevice * operator=(ATL::CComPtr<IDXGIDevice> &);
	IDXGIDevice * operator=(const ATL::CComPtr<IDXGIDevice> &);
	IDXGIDevice * operator=(IDXGIDevice *);
	~CComPtr<IDXGIDevice>();
};
class ATL::CComPtr<IDXGIAdapter> :
	ATL::CComPtrBase<IDXGIAdapter>
{
public:
	CComPtr<IDXGIAdapter>(ATL::CComPtr<IDXGIAdapter> &);
	CComPtr<IDXGIAdapter>(const ATL::CComPtr<IDXGIAdapter> &);
	CComPtr<IDXGIAdapter>(IDXGIAdapter *);
	CComPtr<IDXGIAdapter>();
	IDXGIAdapter * operator=(ATL::CComPtr<IDXGIAdapter> &);
	IDXGIAdapter * operator=(const ATL::CComPtr<IDXGIAdapter> &);
	IDXGIAdapter * operator=(IDXGIAdapter *);
	~CComPtr<IDXGIAdapter>();
};
long gs_logOutput; // 0x140A94098
long gs_logConsole; // 0x140A9409C
long gs_DontSetFocus; // 0x140A940A0
std::piecewise_construct_t std::piecewise_construct; // 0x14086C8A2
AgSingleton<AgSteamworks> * AgSingleton<AgSteamworks>::ms_instance; // 0x140A94090
AgSingleton<AgHttp> * AgSingleton<AgHttp>::ms_instance; // 0x140A94080
AgSingleton<AgMicroTransaction> * AgSingleton<AgMicroTransaction>::ms_instance; // 0x140A94088
bool ATL::CAtlBaseModule::m_bInitFailed; // 0x140A94078
typedef long INT32;//decompilation failure at 140A94098!
//decompilation failure at 140A9409C!
//decompilation failure at 140A940A0!
//decompilation failure at 14086C8A2!
//decompilation failure at 140A94090!
//decompilation failure at 140A94080!
//decompilation failure at 140A94088!
//decompilation failure at 140A94078!
void __fastcall std::_Destroy_range<std::allocator<AgEditedInputEvent>,AgEditedInputEvent *>(
        AgEditedInputEvent *_First,
        AgEditedInputEvent *_Last,
        std::_Wrap_alloc<std::allocator<AgEditedInputEvent> > *_Al)
{
  AgEditedInputEvent *v4; // rdi

  if ( _First != _Last )
  {
    v4 = _First;
    do
    {
      AgString::~AgString(&v4->string, (unsigned __int64)_Last);
      ++v4;
    }
    while ( v4 != _Last );
  }
}

AgEditedInputEvent *__fastcall std::_Uninitialized_move_al_unchecked1<AgEditedInputEvent *,AgEditedInputEvent *,std::allocator<AgEditedInputEvent>>(
        AgEditedInputEvent *_First,
        AgEditedInputEvent *_Last,
        AgEditedInputEvent *_Dest,
        std::_Wrap_alloc<std::allocator<AgEditedInputEvent> > *_Al)
{
  while ( _First != _Last )
  {
    if ( _Dest )
    {
      AgString::AgString(&_Dest->string, &_First->string);
      _Dest->start = _First->start;
      _Dest->length = _First->length;
    }
    ++_Dest;
    ++_First;
  }
  return _Dest;
}

void __fastcall AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        AgPointer<AgPlayer> *this,
        const AgPointer<AgPlayer> *rhs)
{
  AgReferenceCount *m_ref; // rsi
  int m_strongCount; // ebx

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  m_ref = rhs->m_ref;
  if ( rhs->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          return;
      }
      if ( m_strongCount != -1 )
      {
        this->m_ref = rhs->m_ref;
        this->m_ptr = rhs->m_ptr;
      }
    }
  }
}

void __fastcall AgDisplayPlatformData::AgDisplayPlatformData(AgDisplayPlatformData *this)
{
  this->m_windowHandle = 0i64;
  this->m_direct3d9 = 0i64;
  this->m_direct3dDevice9 = 0i64;
  memset(&this->m_direct3dCaps, 0, 0x170ui64);
  this->m_defaultDepth = 0i64;
  this->m_sdlWindow = 0i64;
  this->m_sdlGlContext = 0i64;
  this->m_sdlLoadContexts = 0i64;
  this->m_sdlLoadContextCount = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  this->m_loadingMutex = 0i64;
}

void __fastcall AgPCSystemManager::AgPCSystemManager(AgPCSystemManager *this)
{
  AgSystemManager::AgSystemManager(this);
  this->__vftable = (AgPCSystemManager_vtbl *)&AgPCSystemManager::`vftable';
  *(_QWORD *)&this->m_activated = 0i64;
  this->m_windowCreated = 0;
  this->m_windowHandle = 0i64;
  this->m_sdlWindow = 0i64;
  this->m_display.m_ref = 0i64;
  this->m_display.m_ptr = 0i64;
  this->m_windowProcSem.m_data.m_aborted = 0;
  this->m_windowProcSem.m_data.m_sem = 0i64;
  this->m_windowProcSem.m_data.m_sem = CreateSemaphoreA(0i64, 0, 0x7FFFFFFF, 0i64);
  this->m_windowCreateSem.m_data.m_aborted = 0;
  this->m_windowCreateSem.m_data.m_sem = 0i64;
  this->m_windowCreateSem.m_data.m_sem = CreateSemaphoreA(0i64, 0, 0x7FFFFFFF, 0i64);
  *(_QWORD *)&this->m_windowProperties.width = 0i64;
  *(_QWORD *)&this->m_windowProperties.mode = 2i64;
  this->m_windowProperties.vsync = 1;
  AgString::AgString(&this->m_windowProperties.title);
  *(_QWORD *)&this->m_pendingWindowProperties.width = 0i64;
  *(_QWORD *)&this->m_pendingWindowProperties.mode = 2i64;
  this->m_pendingWindowProperties.vsync = 1;
  AgString::AgString(&this->m_pendingWindowProperties.title);
  this->m_videoMemorySize = 0i64;
  *(_QWORD *)&this->m_windowProperties.height = 0i64;
  this->m_windowProperties.width = 0;
  this->m_windowProperties.vsync = 0;
  this->m_pendingWindowProperties.width = 0;
  this->m_pendingWindowProperties.height = this->m_windowProperties.height;
  this->m_pendingWindowProperties.mode = this->m_windowProperties.mode;
  this->m_pendingWindowProperties.multisample = this->m_windowProperties.multisample;
  this->m_pendingWindowProperties.vsync = this->m_windowProperties.vsync;
  AgString::operator=(&this->m_pendingWindowProperties.title, &this->m_windowProperties.title);
}

void __fastcall AgSingleton<AgSteamworks>::~AgSingleton<AgSteamworks>(AgSingleton<AgSteamworks> *this)
{
  this->__vftable = (AgSingleton<AgSteamworks>_vtbl *)&AgSingleton<AgSteamworks>::`vftable';
}

void __fastcall ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>(ATL::CComPtr<ID3D11Device> *this)
{
  ID3D11Device *p; // rcx

  p = this->p;
  if ( p )
    p->Release(p);
}

void __fastcall ATL::CComPtr<IDXGIAdapter>::~CComPtr<IDXGIAdapter>(ATL::CComPtr<IDXGIAdapter> *this)
{
  IDXGIAdapter *p; // rcx

  p = this->p;
  if ( p )
    p->Release(p);
}

void __fastcall ATL::CComPtr<IDXGIDevice>::~CComPtr<IDXGIDevice>(ATL::CComPtr<IDXGIDevice> *this)
{
  IDXGIDevice *p; // rcx

  p = this->p;
  if ( p )
    p->Release(p);
}

void __fastcall ATL::CComPtrBase<IDXGIAdapter>::~CComPtrBase<IDXGIAdapter>(ATL::CComPtrBase<IDXGIDevice> *this)
{
  IDXGIDevice *p; // rcx

  p = this->p;
  if ( p )
    p->Release(p);
}

void __fastcall AgEditedInputEvent::~AgEditedInputEvent(AgEditedInputEvent *this, unsigned __int64 a2)
{
  AgString::~AgString(&this->string, a2);
}

void __fastcall AgPCSystemManager::~AgPCSystemManager(AgPCSystemManager *this, unsigned __int64 a2)
{
  AgSingleton<AgSteamworks> *v3; // rdi
  unsigned __int64 v4; // rdx
  void *m_sem; // rcx
  void *v6; // rcx

  this->__vftable = (AgPCSystemManager_vtbl *)&AgPCSystemManager::`vftable';
  v3 = AgSingleton<AgSteamworks>::ms_instance;
  if ( AgSingleton<AgSteamworks>::ms_instance )
  {
    AgSingleton<AgSteamworks>::ms_instance->onSingletonExit(AgSingleton<AgSteamworks>::ms_instance);
    AgSingleton<AgSteamworks>::ms_instance = 0i64;
    ((void (__fastcall *)(AgSingleton<AgSteamworks> *, __int64))v3->~AgSingleton<AgSteamworks>)(v3, 1i64);
  }
  AgString::~AgString(&this->m_pendingWindowProperties.title, a2);
  AgString::~AgString(&this->m_windowProperties.title, v4);
  m_sem = this->m_windowCreateSem.m_data.m_sem;
  if ( m_sem )
    CloseHandle(m_sem);
  v6 = this->m_windowProcSem.m_data.m_sem;
  if ( v6 )
    CloseHandle(v6);
  AgPointer<AgDisplay>::~AgPointer<AgDisplay>(&this->m_display);
  AgSystemManager::~AgSystemManager(this);
}

void __fastcall ThreadHost::~ThreadHost(ThreadHost *this)
{
  this->__vftable = (ThreadHost_vtbl *)&AgIThreadHost::`vftable';
}

void __fastcall AgAsyncEventDispatcher<AgEditedInputEvent>::operator()(
        AgAsyncEventDispatcher<AgEditedInputEvent> *this,
        AgEditedInputEvent *argument)
{
  AgMutex *p_m_queueMutex; // rdi

  p_m_queueMutex = &this->m_queueMutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  std::vector<AgEditedInputEvent>::push_back(&this->m_eventQueue, argument);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_queueMutex);
}

void __fastcall AgAsyncEventDispatcher<AgTypingInputEvent>::operator()(
        AgAsyncEventDispatcher<AgTypingInputEvent> *this,
        AgTypingInputEvent *argument)
{
  AgMutex *p_m_queueMutex; // rdi

  p_m_queueMutex = &this->m_queueMutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  std::vector<AgTypingInputEvent>::push_back(&this->m_eventQueue, argument);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_queueMutex);
}

// attributes: thunk
BOOL __stdcall ATL::_AtlInitializeCriticalSectionEx(
        LPCRITICAL_SECTION lpCriticalSection,
        DWORD dwSpinCount,
        DWORD Flags)
{
  return InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
}

void __fastcall std::vector<AgEditedInputEvent>::_Reallocate(
        std::vector<AgEditedInputEvent> *this,
        unsigned __int64 _Count)
{
  AgEditedInputEvent *v4; // r14
  AgEditedInputEvent *Mylast; // rsi
  AgEditedInputEvent *Myfirst; // rbx
  signed __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // r15

  v4 = (AgEditedInputEvent *)std::allocator<AgArchive::DirectoryEntry>::allocate(
                               (std::allocator<AgJsonNode> *)this,
                               _Count);
  std::_Uninitialized_move_al_unchecked1<AgEditedInputEvent *,AgEditedInputEvent *,std::allocator<AgEditedInputEvent>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    (std::_Wrap_alloc<std::allocator<AgEditedInputEvent> > *)this);
  Mylast = this->_Mypair._Myval2._Mylast;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v7 = (char *)Mylast - (char *)this->_Mypair._Myval2._Myfirst;
  v8 = (unsigned __int128)(v7 * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v9 = v7 / 24;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( ; Myfirst != Mylast; ++Myfirst )
      AgString::~AgString(&Myfirst->string, v8);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)this,
      (AgJsonNode *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v9];
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<AgEditedInputEvent>::_Reserve(
        std::vector<AgEditedInputEvent> *this,
        unsigned __int64 _Count)
{
  AgEditedInputEvent *Myend; // rcx
  AgEditedInputEvent *Mylast; // r9
  signed __int64 v6; // rdx
  unsigned __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( Myend - Mylast < _Count )
  {
    v6 = Mylast - this->_Mypair._Myval2._Myfirst;
    if ( 0xAAAAAAAAAAAAAAAi64 - v6 < _Count )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + _Count;
    v8 = (unsigned __int128)(((char *)Myend - (char *)this->_Mypair._Myval2._Myfirst) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
    v9 = 0i64;
    v10 = ((unsigned __int64)v8 >> 63) + (v8 >> 2);
    if ( 0xAAAAAAAAAAAAAAAi64 - (v10 >> 1) >= v10 )
      v9 = v10 + (v10 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgEditedInputEvent>::_Reallocate(this, v7);
  }
}

_BOOL8 __fastcall validateOSVersion(unsigned int versionMajor, unsigned int versionMinor)
{
  ULONGLONG v4; // rax
  DWORDLONG v5; // rax
  _OSVERSIONINFOEXW VersionInformation; // [rsp+20h] [rbp-138h] BYREF

  memset(&VersionInformation, 0, sizeof(VersionInformation));
  VersionInformation.dwOSVersionInfoSize = 284;
  VersionInformation.dwMajorVersion = versionMajor;
  VersionInformation.dwMinorVersion = versionMinor;
  v4 = VerSetConditionMask(0i64, 2u, 3u);
  v5 = VerSetConditionMask(v4, 1u, 3u);
  return VerifyVersionInfoW(&VersionInformation, 3u, v5);
}

AgJsonNode *__fastcall std::allocator<AgArchive::DirectoryEntry>::allocate(
        std::allocator<AgJsonNode> *this,
        unsigned __int64 _Count)
{
  AgJsonNode *result; // rax
  unsigned __int64 v3; // rcx
  AgJsonNodeData *v4; // rax
  AgJsonNodeData *v5; // rcx

  if ( !_Count )
    return 0i64;
  if ( _Count > 0xAAAAAAAAAAAAAAAi64 )
    std::_Xbad_alloc();
  v3 = 24 * _Count;
  if ( 24 * _Count < 0x1000 )
  {
    result = (AgJsonNode *)operator new(v3);
    if ( !result )
      invalid_parameter_noinfo_noreturn();
  }
  else
  {
    if ( v3 + 39 <= v3 )
      std::_Xbad_alloc();
    v4 = (AgJsonNodeData *)operator new(v3 + 39);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    result = (AgJsonNode *)(((unsigned __int64)&v4[1].m_refCount + 7) & 0xFFFFFFFFFFFFFFE0ui64);
    result[-1].m_data.m_ptr = v5;
  }
  return result;
}

void __fastcall AgPCSystemManager::createDisplay(AgPCSystemManager *this)
{
  AgReferenceCount *v2; // rax
  AgDisplayPlatformData *v3; // rax
  AgDisplayPlatformData *v4; // rsi
  unsigned __int64 m_numGlLoadingContexts; // rcx
  unsigned __int64 v6; // rax
  __int64 i; // rdi
  unsigned __int64 m_sdlLoadContextCount; // r14
  __int64 v9; // rax
  bool v10; // cf
  unsigned __int64 v11; // rax
  AgReferenceCount *v12; // rax
  void **p_m_data; // rdi
  AgReferenceCount *v14; // rax
  Concurrency::details::ThreadInternalContext *Log; // rax
  AgPointer<AgDisplay> *v16; // rax
  AgDisplay *m_ptr; // rcx
  AgPointer<AgStandardKeyboardController> *Keyboard; // rax
  AgPointer<AgStandardMouseController> *Mouse; // rax
  int height; // [rsp+30h] [rbp-40h] BYREF
  int width[3]; // [rsp+34h] [rbp-3Ch] BYREF
  AgPointer<AgStandardKeyboardController> result; // [rsp+40h] [rbp-30h] BYREF
  AgPointer<AgPlayer> v23; // [rsp+50h] [rbp-20h] BYREF
  __int64 v24; // [rsp+60h] [rbp-10h]

  v24 = -2i64;
  if ( this->m_display.m_ptr )
  {
    AgTrace("[SilverWare] Display already exists!");
  }
  else
  {
    v2 = (AgReferenceCount *)operator new(0x1E0ui64);
    v23.m_ref = v2;
    if ( v2 )
    {
      AgDisplayPlatformData::AgDisplayPlatformData((AgDisplayPlatformData *)v2);
      v4 = v3;
    }
    else
    {
      v4 = 0i64;
    }
    AgTrace("[SilverWare] Initializing with GL (SDL)");
    SDL_GL_SetAttribute_0(22i64);
    this->m_sdlGlContext = (void *)SDL_GL_CreateContext_0(this->m_sdlWindow);
    m_numGlLoadingContexts = AgSystemManager::getSystemConfig()->m_numGlLoadingContexts;
    this->m_sdlLoadContextCount = m_numGlLoadingContexts;
    if ( (_DWORD)m_numGlLoadingContexts )
    {
      v6 = 8 * m_numGlLoadingContexts;
      if ( !is_mul_ok(m_numGlLoadingContexts, 8ui64) )
        v6 = -1i64;
      this->m_sdlLoadContexts = (void **)operator new[](v6);
      for ( i = 0i64; (unsigned int)i < this->m_sdlLoadContextCount; i = (unsigned int)(i + 1) )
        this->m_sdlLoadContexts[i] = (void *)SDL_GL_CreateContext_0(this->m_sdlWindow);
    }
    else
    {
      this->m_sdlLoadContexts = 0i64;
    }
    SDL_GL_MakeCurrent_0(this->m_sdlWindow, this->m_sdlGlContext);
    glewInit();
    if ( this->m_windowProperties.multisample )
      glEnable(0x809Du);
    SDL_GL_MakeCurrent_0(0i64, 0i64);
    v4->m_sdlGlContext = this->m_sdlGlContext;
    v4->m_sdlLoadContexts = this->m_sdlLoadContexts;
    v4->m_sdlLoadContextCount = this->m_sdlLoadContextCount;
    m_sdlLoadContextCount = this->m_sdlLoadContextCount;
    v23.m_ref = (AgReferenceCount *)m_sdlLoadContextCount;
    v9 = 40 * m_sdlLoadContextCount;
    if ( !is_mul_ok(m_sdlLoadContextCount, 0x28ui64) )
      v9 = -1i64;
    v10 = __CFADD__(v9, 8i64);
    v11 = v9 + 8;
    if ( v10 )
      v11 = -1i64;
    v12 = (AgReferenceCount *)operator new[](v11);
    result.m_ref = v12;
    if ( v12 )
    {
      *(_QWORD *)&v12->m_strongCount = m_sdlLoadContextCount;
      p_m_data = &v12->m_data;
      `eh vector constructor iterator'(
        &v12->m_data,
        0x28ui64,
        (unsigned int)m_sdlLoadContextCount,
        (void (__fastcall *)(void *))AgMutex::`default constructor closure',
        (void (__fastcall *)(void *))AgMutex::~AgMutex);
    }
    else
    {
      p_m_data = 0i64;
    }
    v4->m_loadingMutex = (AgMutex *)p_m_data;
    v4->m_sdlWindow = this->m_sdlWindow;
    v4->m_windowHandle = this->m_windowHandle;
    if ( this->m_windowProperties.mode == AgWindowMode_Fullscreen )
    {
      width[0] = this->m_windowProperties.width;
      height = this->m_windowProperties.height;
    }
    else
    {
      SDL_GetWindowSize_0(this->m_sdlWindow, width, &height);
    }
    if ( (int)SDL_GL_SetSwapInterval_0(this->m_windowProperties.vsync == 1) < 0 )
      AgTrace(
        "createDisplay: failed setting SDL_GL_SetSwapInterval(%d)\n",
        (unsigned int)this->m_windowProperties.vsync);
    AgTrace("[SilverWare] Creating display...");
    v14 = (AgReferenceCount *)operator new(0x70ui64);
    result.m_ref = v14;
    if ( v14 )
      AgDisplay::AgDisplay((AgDisplay *)v14, v4);
    AgPointer<AgDisplay>::operator=(&this->m_display, (AgDisplay *)v14);
    AgTrace("[SilverWare] Initializing...");
    AgDisplay::initialize(this->m_display.m_ptr);
    result.m_ref = (AgReferenceCount *)__PAIR64__(height, width[0]);
    LODWORD(result.m_ptr) = 0;
    Log = (Concurrency::details::ThreadInternalContext *)Scaleform::GFx::Stream::GetLog(this->m_display.m_ptr);
    AgUser::isSignedIn(Log);
    AgTrace("[SilverWare] Created display (w=%i, h=%i)", (unsigned int)width[0], (unsigned int)height);
    AgDisplay::onSizeChanged(this->m_display.m_ptr, width[0], height);
    AgDisplay::onModeChanged(this->m_display.m_ptr, this->m_windowProperties.mode);
    AgTrace("[SilverWare] Registering display");
    result.m_ref = (AgReferenceCount *)&v23;
    AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
      &v23,
      (const AgPointer<AgPlayer> *)&this->m_display);
    AgDisplayManager::registerDisplay((AgDisplayManager *)AgSingleton<AgDisplayManager>::ms_instance, v16);
    if ( this->m_activated != 1 )
    {
      if ( AgDebugChannelData::isEnabled(this->m_channel.m_data)
        && AgDebugChannelData::getVerbosity(this->m_channel.m_data) >= AgLogVerbosity_Info )
      {
        AgDebugChannel<1>::log(
          &this->m_channel,
          AgLogVerbosity_Info,
          "AgPCSystemManager.onWindowActivate() switched window activation");
      }
      this->m_activated = 1;
    }
    this->m_focused = 1;
    AgSystemManager::onActivated(this);
    m_ptr = this->m_display.m_ptr;
    if ( m_ptr )
      AgDisplay::onFocusChanged(m_ptr, 1);
    if ( AgSingleton<AgInputManager>::ms_instance )
    {
      Keyboard = AgPCInputManager::getKeyboard((AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance, &result);
      Keyboard->m_ptr->clear(Keyboard->m_ptr);
      AgPointer<AgStandardKeyboardController>::~AgPointer<AgStandardKeyboardController>(&result);
      Mouse = AgPCInputManager::getMouse(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                (AgPointer<AgStandardMouseController> *)&result);
      Mouse->m_ptr->clear(Mouse->m_ptr);
      AgPointer<AgStandardMouseController>::~AgPointer<AgStandardMouseController>((AgPointer<AgStandardMouseController> *)&result);
    }
  }
}

int __fastcall AgPCSystemManager::createWindow(AgPCSystemManager *this)
{
  int result; // eax
  int v3; // edi
  int height; // [rsp+20h] [rbp-18h]

  if ( AgDebugChannelData::isEnabled(this->m_channel.m_data)
    && AgDebugChannelData::getVerbosity(this->m_channel.m_data) >= AgLogVerbosity_Info )
  {
    AgDebugChannel<1>::log(&this->m_channel, AgLogVerbosity_Info, "AgPCSystemManager.createWindow()");
  }
  this->m_windowProperties.width = this->m_pendingWindowProperties.width;
  this->m_windowProperties.height = this->m_pendingWindowProperties.height;
  this->m_windowProperties.mode = this->m_pendingWindowProperties.mode;
  this->m_windowProperties.multisample = this->m_pendingWindowProperties.multisample;
  this->m_windowProperties.vsync = this->m_pendingWindowProperties.vsync;
  AgString::operator=(&this->m_windowProperties.title, &this->m_pendingWindowProperties.title);
  height = this->m_windowProperties.height;
  AgTrace(
    "Window Properties: %i %i %i %i",
    (unsigned int)this->m_windowProperties.vsync,
    (unsigned int)this->m_windowProperties.mode,
    (unsigned int)this->m_windowProperties.width,
    height);
  result = AgPCSystemManager::createWindowSDL(this);
  v3 = result;
  if ( !this->m_windowProcSem.m_data.m_aborted )
  {
    ReleaseSemaphore(this->m_windowProcSem.m_data.m_sem, 1, 0i64);
    result = v3;
  }
  this->m_windowCreated = 1;
  return result;
}

void __fastcall AgPCSystemManager::createWindow(AgPCSystemManager *this, const AgWindowConfig *config)
{
  this->m_pendingWindowProperties.width = config->width;
  this->m_pendingWindowProperties.height = config->height;
  this->m_pendingWindowProperties.mode = config->mode;
  this->m_pendingWindowProperties.multisample = config->multisample;
  this->m_pendingWindowProperties.vsync = config->vsync;
  AgString::operator=(&this->m_pendingWindowProperties.title, &config->title);
  if ( !this->m_windowCreateSem.m_data.m_aborted )
    ReleaseSemaphore(this->m_windowCreateSem.m_data.m_sem, 1, 0i64);
  if ( !this->m_windowProcSem.m_data.m_aborted )
    WaitForSingleObjectEx(this->m_windowProcSem.m_data.m_sem, 0xFFFFFFFF, 1);
}

__int64 __fastcall AgPCSystemManager::createWindowSDL(AgPCSystemManager *this)
{
  __int64 Window_0; // rdi
  __int64 Context_0; // rbp
  AgMultisampleType v5; // ebx
  AgWindowMode mode; // ecx
  __int32 v7; // ecx
  AgRectangle *ScreenSize; // rdi
  AgRectangle *v9; // rbx
  char *CString; // rax
  struct SDL_Window *v11; // rax
  AgRectangle *v12; // rdi
  AgRectangle *v13; // rbx
  char *v14; // rax
  struct SDL_Window *v15; // rax
  char *v16; // rax
  struct SDL_Window *v17; // rax
  struct SDL_Window *m_sdlWindow; // rcx
  HICON IconW; // rax
  AgRectangle result; // [rsp+30h] [rbp-58h] BYREF
  AgRectangle v21; // [rsp+40h] [rbp-48h] BYREF
  __int16 v22; // [rsp+50h] [rbp-38h] BYREF
  char v23; // [rsp+52h] [rbp-36h]
  HWND__ *v24; // [rsp+58h] [rbp-30h]
  GLint params; // [rsp+98h] [rbp+10h] BYREF
  char v26; // [rsp+A0h] [rbp+18h] BYREF

  if ( (int)SDL_Init_0(32i64) < 0 )
    return 0i64;
  SDL_GL_SetAttribute_0(17i64);
  SDL_GL_SetAttribute_0(18i64);
  SDL_GL_SetAttribute_0(21i64);
  SDL_GL_SetAttribute_0(5i64);
  if ( this->m_windowProperties.multisample )
  {
    if ( !*(_QWORD *)__glewTexImage2DMultisample || !*(_QWORD *)__glewRenderbufferStorageMultisampleEXT )
    {
      gs_maxSupportedMSAALevel = AgMultisampleType_None;
      goto LABEL_18;
    }
    Window_0 = SDL_CreateWindow_0(&pnewText, 0i64, 0i64, 1i64, 1, 10);
    Context_0 = SDL_GL_CreateContext_0(Window_0);
    SDL_GL_MakeCurrent_0(Window_0, Context_0);
    v5 = AgMultisampleType_None;
    params = 0;
    glGetIntegerv(0x8D57u, &params);
    if ( params >= 2 )
    {
      if ( params < 4 )
      {
        gs_maxSupportedMSAALevel = AgMultisampleType_2x;
LABEL_13:
        if ( this->m_windowProperties.multisample > AgDisplay::getMaxMultisampleType() )
          this->m_windowProperties.multisample = AgDisplay::getMaxMultisampleType();
        SDL_GL_DeleteContext_0(Context_0);
        SDL_DestroyWindow_0(Window_0);
        if ( this->m_windowProperties.multisample )
        {
          SDL_GL_SetAttribute_0(13i64);
          AgRenderTypeConverter::getNumMSAASamples(this->m_windowProperties.multisample);
          SDL_GL_SetAttribute_0(14i64);
        }
        goto LABEL_18;
      }
      if ( params < 8 )
      {
        gs_maxSupportedMSAALevel = AgMultisampleType_4x;
        goto LABEL_13;
      }
      LOBYTE(v5) = params >= 16;
      v5 += 3;
    }
    gs_maxSupportedMSAALevel = v5;
    goto LABEL_13;
  }
LABEL_18:
  mode = this->m_windowProperties.mode;
  if ( mode )
  {
    v7 = mode - 1;
    if ( v7 )
    {
      if ( v7 != 1 )
        goto LABEL_27;
      ScreenSize = AgDisplay::getScreenSize(&result);
      v9 = AgDisplay::getScreenSize(&v21);
      CString = AgString::getCString(&this->m_windowProperties.title);
      v11 = (struct SDL_Window *)SDL_CreateWindow_0(
                                   CString,
                                   805240832i64,
                                   805240832i64,
                                   (unsigned int)v9->m_width,
                                   ScreenSize->m_height,
                                   6);
      this->m_sdlWindow = v11;
      if ( v11 )
      {
        SDL_SetWindowFullscreen_0(v11, 4097i64);
        goto LABEL_27;
      }
      return 0i64;
    }
    v12 = AgDisplay::getScreenSize(&v21);
    v13 = AgDisplay::getScreenSize(&result);
    v14 = AgString::getCString(&this->m_windowProperties.title);
    v15 = (struct SDL_Window *)SDL_CreateWindow_0(
                                 v14,
                                 805240832i64,
                                 805240832i64,
                                 (unsigned int)v13->m_width,
                                 v12->m_height,
                                 6);
    this->m_sdlWindow = v15;
    if ( !v15 )
      return 0i64;
    SDL_SetWindowFullscreen_0(v15, 1i64);
  }
  else
  {
    v16 = AgString::getCString(&this->m_windowProperties.title);
    v17 = (struct SDL_Window *)SDL_CreateWindow_0(
                                 v16,
                                 805240832i64,
                                 805240832i64,
                                 (unsigned int)this->m_windowProperties.width,
                                 this->m_windowProperties.height,
                                 6);
    this->m_sdlWindow = v17;
    if ( !v17 )
      return 0i64;
    SDL_SetWindowFullscreen_0(v17, 0i64);
    SDL_SetWindowSize_0(
      this->m_sdlWindow,
      (unsigned int)this->m_windowProperties.width,
      (unsigned int)this->m_windowProperties.height);
    SDL_GL_GetDrawableSize_0(this->m_sdlWindow, &v26, &params);
  }
LABEL_27:
  m_sdlWindow = this->m_sdlWindow;
  v22 = 2;
  v23 = 5;
  if ( !(unsigned int)SDL_GetWindowWMInfo_0(m_sdlWindow, &v22) )
    return 0i64;
  this->m_windowHandle = v24;
  IconW = LoadIconW(gs_hInstance, L"WIN_ICON");
  if ( !IconW )
  {
    IconW = LoadIconW(gs_hInstance, (LPCWSTR)0x65);
    if ( !IconW )
      IconW = LoadIconW(0i64, (LPCWSTR)0x7F05);
  }
  SendMessageW(this->m_windowHandle, 0x80u, 0i64, (LPARAM)IconW);
  return 1i64;
}

void __fastcall AgPCSystemManager::destroyWindow(AgPCSystemManager *this)
{
  unsigned __int64 v2; // rdx
  __int64 i; // rdi

  if ( this->m_windowCreated )
  {
    SDL_GL_DeleteContext_0(this->m_sdlGlContext);
    this->m_sdlGlContext = 0i64;
    for ( i = 0i64; (unsigned int)i < this->m_sdlLoadContextCount; i = (unsigned int)(i + 1) )
      SDL_GL_DeleteContext_0(this->m_sdlLoadContexts[i]);
    operator delete(this->m_sdlLoadContexts, v2);
    this->m_sdlLoadContexts = 0i64;
    this->m_sdlLoadContextCount = 0;
    SDL_DestroyWindow_0(this->m_sdlWindow);
  }
}

AgPointer<AgStandardKeyboardController> *__fastcall AgPCInputManager::getKeyboard(
        AgPCInputManager *this,
        AgPointer<AgStandardKeyboardController> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)&this->m_keyboard);
  return result;
}

AgPointer<AgStandardMouseController> *__fastcall AgPCInputManager::getMouse(
        AgPCInputManager *this,
        AgPointer<AgStandardMouseController> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)&this->m_mouse);
  return result;
}

__int64 __fastcall AgSimpleThreadHost::getThreadIsStopping(
        Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy> *this)
{
  return this->m_executionResourceTlsIndex;
}

unsigned __int64 __fastcall AgPCSystemManager::getVideoMemorySize(AgPCSystemManager *this)
{
  unsigned __int64 result; // rax
  HMODULE LibraryW; // rax
  HMODULE v4; // rbx
  FARPROC ProcAddress; // rax
  __int64 v6; // [rsp+50h] [rbp-168h] BYREF
  __int64 v7; // [rsp+58h] [rbp-160h] BYREF
  __int64 v8[2]; // [rsp+60h] [rbp-158h] BYREF
  __int64 v9[38]; // [rsp+70h] [rbp-148h] BYREF

  v8[1] = -2i64;
  result = this->m_videoMemorySize;
  if ( !result )
  {
    LibraryW = LoadLibraryW(L"d3d11.dll");
    v4 = LibraryW;
    if ( LibraryW )
    {
      ProcAddress = GetProcAddress(LibraryW, "D3D11CreateDevice");
      if ( ProcAddress )
      {
        v8[0] = 0i64;
        if ( ((int (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _QWORD, _DWORD, int, __int64 *, _QWORD, _QWORD))ProcAddress)(
               0i64,
               1i64,
               0i64,
               0i64,
               0i64,
               0,
               7,
               v8,
               0i64,
               0i64) >= 0 )
        {
          v7 = 0i64;
          (**(void (__fastcall ***)(__int64, GUID *, __int64 *))v8[0])(
            v8[0],
            &GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c,
            &v7);
          v6 = 0i64;
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v7 + 56i64))(v7, &v6);
          memset(v9, 0, sizeof(v9));
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v6 + 64i64))(v6, v9);
          this->m_videoMemorySize = (unsigned __int64)(v9[34] + v9[35] + v9[36]) >> 20;
          if ( v6 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16i64))(v6);
          if ( v7 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
        }
        if ( v8[0] )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v8[0] + 16i64))(v8[0]);
      }
      FreeLibrary(v4);
    }
    return this->m_videoMemorySize;
  }
  return result;
}

__int64 __fastcall globalGetLogConsole()
{
  return (unsigned int)gs_logConsole;
}

void __fastcall AgPCSystemManager::handleWindowClose(AgPCSystemManager *this)
{
  AgProgram *Instance; // rax

  this->onShutdown(this);
  if ( AgProgram::getInstance() )
  {
    Instance = AgProgram::getInstance();
    AgProgram::onShutdown(Instance);
  }
}

_BOOL8 __fastcall AgPCSystemManager::isRunningVistaOrLater()
{
  return validateOSVersion(6u, 0);
}

void __fastcall ThreadHost::onExecuteThread(ThreadHost *this)
{
  AgSingleton<AgSystemManager> *v2; // rcx

  AgMain((__int64)this);
  this->m_running = 0;
  v2 = AgSingleton<AgSystemManager>::ms_instance;
  if ( AgSingleton<AgSystemManager>::ms_instance )
  {
    LOBYTE(AgSingleton<AgSystemManager>::ms_instance[97].__vftable) = 0;
    if ( !LODWORD(v2[119].__vftable) )
    {
      LODWORD(v2[119].__vftable) = 1;
      ReleaseSemaphore(v2[120].__vftable, 1000, 0i64);
    }
  }
}

void __fastcall ThreadHost::onJoinThread(ThreadHost *this)
{
  AgProgram *Instance; // rax

  if ( AgProgram::getInstance() )
  {
    Instance = AgProgram::getInstance();
    Instance->onJoinThread(Instance);
  }
}

void __fastcall AgPCSystemManager::onShutdown(AgPCSystemManager *this)
{
  AgSystemManager::onShutdown(this);
  PostQuitMessage(0);
}

int __fastcall AgPCSystemManager::onSingletonExit(AgPCSystemManager *this)
{
  AgPCSystemManager::destroyWindow(this);
  return AgSystemManager::onSingletonExit(this);
}

int __fastcall AgPCSystemManager::onSingletonInit(AgPCSystemManager *this)
{
  AgDisplayManager *v2; // rax
  AgSingleton<AgDisplayManager> *v3; // rax
  AgSingleton<AgDisplayManager> *v4; // rbx
  AgHttp *v5; // rax
  AgSingleton<AgHttp> *v6; // rax
  AgSingleton<AgHttp> *v7; // rbx
  AgMicroTransaction *v8; // rax
  AgSingleton<AgMicroTransaction> *v9; // rax
  AgSingleton<AgMicroTransaction> *v10; // rbx
  AgSingleton<AgSteamworks> *v11; // rbx
  int v12; // eax

  if ( !AgSingleton<AgDisplayManager>::ms_instance )
  {
    v2 = (AgDisplayManager *)operator new(0x10ui64);
    if ( v2 )
    {
      AgDisplayManager::AgDisplayManager(v2);
      v4 = v3;
    }
    else
    {
      v4 = 0i64;
    }
    v4->onSingletonInit(v4);
    AgSingleton<AgDisplayManager>::ms_instance = v4;
  }
  if ( !AgSingleton<AgHttp>::ms_instance )
  {
    v5 = (AgHttp *)operator new(0x10ui64);
    if ( v5 )
    {
      AgHttp::AgHttp(v5);
      v7 = v6;
    }
    else
    {
      v7 = 0i64;
    }
    v7->onSingletonInit(v7);
    AgSingleton<AgHttp>::ms_instance = v7;
  }
  if ( !AgSingleton<AgMicroTransaction>::ms_instance )
  {
    v8 = (AgMicroTransaction *)operator new(8ui64);
    if ( v8 )
    {
      AgMicroTransaction::AgMicroTransaction(v8);
      v10 = v9;
    }
    else
    {
      v10 = 0i64;
    }
    v10->onSingletonInit(v10);
    AgSingleton<AgMicroTransaction>::ms_instance = v10;
  }
  if ( AgSingleton<AgSteamworks>::ms_instance )
    return 0;
  v11 = (AgSingleton<AgSteamworks> *)operator new(8ui64);
  if ( v11 )
  {
    v11->__vftable = (AgSingleton<AgSteamworks>_vtbl *)&AgSingleton<AgSteamworks>::`vftable';
    v11->__vftable = (AgSingleton<AgSteamworks>_vtbl *)&AgSteamworks::`vftable';
  }
  else
  {
    v11 = 0i64;
  }
  v12 = v11->onSingletonInit(v11);
  AgSingleton<AgSteamworks>::ms_instance = v11;
  if ( !v12 )
    return 0;
  else
    return AgSystemManager::onSingletonInit(this);
}

void AgPCSystemManager::processCommandArguments(void)
{
  AgString *i; // rbx
  bool v1; // al
  int v2; // ecx
  AgStringRef s1; // [rsp+20h] [rbp-38h] BYREF
  AgStringRef s2; // [rsp+30h] [rbp-28h] BYREF
  AgStringRef v5; // [rsp+40h] [rbp-18h] BYREF

  for ( i = AgSystemManager::ms_commandArguments._Mypair._Myval2._Myfirst;
        i != AgSystemManager::ms_commandArguments._Mypair._Myval2._Mylast;
        ++i )
  {
    AgStringRef::AgStringRef(&s1, i);
    AgStringRef::AgStringRef(&s2, "-log");
    if ( operator==(&s1, &s2) )
    {
      gs_logOutput = 1;
    }
    else
    {
      AgStringRef::AgStringRef(&v5, "-console");
      v1 = operator==(&s1, &v5);
      v2 = gs_logConsole;
      if ( v1 )
        v2 = 1;
      gs_logConsole = v2;
    }
  }
}

void __fastcall AgPCSystemManager::processWindowMessage(AgPCSystemManager *this)
{
  AgDisplay *v2; // rcx
  AgPCInputManager *v3; // rcx
  AgPointer<AgStandardKeyboardController> *Keyboard; // rax
  AgPointer<AgStandardMouseController> *Mouse; // rax
  AgDisplay *v6; // rcx
  AgDisplay *m_ptr; // rcx
  AgDisplay *v8; // rcx
  AgDisplay *v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  AgEditedInputEvent result; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v13; // [rsp+40h] [rbp-C0h]
  SDL_MouseMotionEvent param; // [rsp+50h] [rbp-B0h] BYREF
  int v15; // [rsp+15Ch] [rbp+5Ch]
  int v16; // [rsp+160h] [rbp+60h]

  v13 = -2i64;
  if ( this->m_sdlWindow || AgPCSystemManager::waitForWindow(this) )
  {
    AgInputManager::updateTextInput((AgInputManager *)AgSingleton<AgInputManager>::ms_instance);
    if ( (unsigned int)SDL_WaitEvent_0(&param) )
    {
      if ( param.type > 0x401 )
      {
        if ( param.type > 0x606 )
        {
          if ( param.type == 1619 )
          {
            if ( AgSingleton<AgInputManager>::ms_instance )
              AgSDLInputManager::addSDLController(
                (AgSDLInputManager *)AgSingleton<AgInputManager>::ms_instance,
                param.windowID);
          }
          else if ( param.type == 1620 && AgSingleton<AgInputManager>::ms_instance )
          {
            AgSDLInputManager::removeSDLController(
              (AgSDLInputManager *)AgSingleton<AgInputManager>::ms_instance,
              param.windowID);
          }
        }
        else
        {
          switch ( param.type )
          {
            case 0x606u:
              if ( AgSingleton<AgInputManager>::ms_instance )
                AgSDLInputManager::removeSDLJoystick(
                  (AgSDLInputManager *)AgSingleton<AgInputManager>::ms_instance,
                  param.windowID);
              break;
            case 0x402u:
              if ( AgSingleton<AgInputManager>::ms_instance )
              {
                switch ( LOBYTE(param.state) )
                {
                  case 1u:
                    AgPCInputManager::handleMouseButtonUp(
                      (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                      AgMouseButton_Left);
                    break;
                  case 2u:
                    AgPCInputManager::handleMouseButtonUp(
                      (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                      AgMouseButton_Middle);
                    break;
                  case 3u:
                    AgPCInputManager::handleMouseButtonUp(
                      (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                      AgMouseButton_Right);
                    break;
                  case 4u:
                    AgPCInputManager::handleMouseButtonUp(
                      (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                      AgMouseButton_4);
                    break;
                  case 5u:
                    AgPCInputManager::handleMouseButtonUp(
                      (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                      AgMouseButton_5);
                    break;
                }
              }
              break;
            case 0x403u:
              if ( AgSingleton<AgInputManager>::ms_instance )
              {
                *(float *)&result.string.m_length = (float)(int)param.state;
                *((float *)&result.string.m_length + 1) = (float)param.x;
                AgPCInputManager::handleScrollChanged(
                  (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                  (const AgVector2 *)&result);
              }
              break;
            default:
              if ( param.type == 1541 && AgSingleton<AgInputManager>::ms_instance )
                AgSDLInputManager::addSDLJoystick(
                  (AgSDLInputManager *)AgSingleton<AgInputManager>::ms_instance,
                  param.windowID);
              break;
          }
        }
      }
      else if ( param.type == 1025 )
      {
        if ( AgSingleton<AgInputManager>::ms_instance )
        {
          switch ( LOBYTE(param.state) )
          {
            case 1u:
              AgPCInputManager::handleMouseButtonDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                AgMouseButton_Left);
              break;
            case 2u:
              AgPCInputManager::handleMouseButtonDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                AgMouseButton_Middle);
              break;
            case 3u:
              AgPCInputManager::handleMouseButtonDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                AgMouseButton_Right);
              break;
            case 4u:
              AgPCInputManager::handleMouseButtonDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                AgMouseButton_4);
              break;
            case 5u:
              AgPCInputManager::handleMouseButtonDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                AgMouseButton_5);
              break;
          }
        }
      }
      else if ( param.type > 0x302 )
      {
        if ( param.type == 771 )
        {
          AgString::AgString(&result.string);
          AgString::operator=(&result.string, (const char *)&param.which);
          AgAsyncEventDispatcher<AgTypingInputEvent>::operator()(
            (AgAsyncEventDispatcher<AgTypingInputEvent> *)&AgSingleton<AgInputManager>::ms_instance[68],
            (AgTypingInputEvent *)&result);
          AgString::~AgString(&result.string, v11);
        }
        else if ( param.type == 1024 && AgSingleton<AgInputManager>::ms_instance )
        {
          AgPCInputManager::processSDLMouse((AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance, &param);
        }
      }
      else
      {
        switch ( param.type )
        {
          case 0x302u:
            AgString::AgString(&result.string);
            AgString::operator=(&result.string, (const char *)&param.which);
            result.start = v15;
            result.length = v16;
            AgAsyncEventDispatcher<AgEditedInputEvent>::operator()(
              (AgAsyncEventDispatcher<AgEditedInputEvent> *)&AgSingleton<AgInputManager>::ms_instance[84],
              &result);
            AgString::~AgString(&result.string, v10);
            break;
          case 0x200u:
            switch ( LOBYTE(param.which) )
            {
              case 7:
                m_ptr = this->m_display.m_ptr;
                if ( m_ptr )
                  AgDisplay::onMinimized(m_ptr, 1);
                break;
              case 8:
                v9 = this->m_display.m_ptr;
                if ( v9 )
                  AgDisplay::onMinimized(v9, 0);
                break;
              case 9:
                v8 = this->m_display.m_ptr;
                if ( v8 )
                {
                  AgDisplay::onMinimized(v8, 0);
                  AgPCSystemManager::updateWindowProperties(
                    this,
                    this->m_pendingWindowProperties.mode == AgWindowMode_Fullscreen);
                }
                break;
              case 0xC:
                this->m_focused = 1;
                AgSystemManager::onActivated(this);
                v2 = this->m_display.m_ptr;
                if ( v2 )
                  AgDisplay::onFocusChanged(v2, 1);
                v3 = (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance;
                if ( AgSingleton<AgInputManager>::ms_instance )
                  goto LABEL_20;
                break;
              case 0xD:
                this->m_focused = 0;
                AgSystemManager::onSuspending(this);
                v6 = this->m_display.m_ptr;
                if ( v6 )
                  AgDisplay::onFocusChanged(v6, 0);
                v3 = (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance;
                if ( AgSingleton<AgInputManager>::ms_instance )
                {
LABEL_20:
                  Keyboard = AgPCInputManager::getKeyboard(v3, (AgPointer<AgStandardKeyboardController> *)&result);
                  Keyboard->m_ptr->clear(Keyboard->m_ptr);
                  AgPointer<AgStandardKeyboardController>::~AgPointer<AgStandardKeyboardController>((AgPointer<AgStandardKeyboardController> *)&result);
                  Mouse = AgPCInputManager::getMouse(
                            (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                            (AgPointer<AgStandardMouseController> *)&result);
                  Mouse->m_ptr->clear(Mouse->m_ptr);
                  AgPointer<AgStandardMouseController>::~AgPointer<AgStandardMouseController>((AgPointer<AgStandardMouseController> *)&result);
                }
                break;
              case 0xE:
                AgPCSystemManager::handleWindowClose(this);
                break;
              default:
                return;
            }
            break;
          case 0x300u:
            if ( AgSingleton<AgInputManager>::ms_instance )
            {
              result.string = *(AgString *)&param.state;
              AgPCInputManager::handleKeyDown(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                (SDL_Keysym *)&result);
            }
            break;
          case 0x301u:
            if ( AgSingleton<AgInputManager>::ms_instance )
            {
              result.string = *(AgString *)&param.state;
              AgPCInputManager::handleKeyUp(
                (AgPCInputManager *)AgSingleton<AgInputManager>::ms_instance,
                (SDL_Keysym *)&result);
            }
            break;
        }
      }
    }
  }
}

void __fastcall std::vector<AgEditedInputEvent>::push_back(
        std::vector<AgEditedInputEvent> *this,
        AgEditedInputEvent *_Val)
{
  AgEditedInputEvent *Mylast; // rcx
  signed __int64 v5; // rsi
  AgEditedInputEvent *v6; // rdi
  AgEditedInputEvent *v7; // rsi
  AgEditedInputEvent *v8; // rdi

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || this->_Mypair._Myval2._Myfirst > _Val )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgEditedInputEvent>::_Reserve(this, 1ui64);
    v8 = this->_Mypair._Myval2._Mylast;
    if ( v8 )
    {
      AgString::AgString(&v8->string, &_Val->string);
      v8->start = _Val->start;
      v8->length = _Val->length;
    }
  }
  else
  {
    v5 = _Val - this->_Mypair._Myval2._Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgEditedInputEvent>::_Reserve(this, 1ui64);
    v6 = this->_Mypair._Myval2._Mylast;
    v7 = &this->_Mypair._Myval2._Myfirst[v5];
    if ( v6 )
    {
      AgString::AgString(&v6->string, &v7->string);
      v6->start = v7->start;
      v6->length = v7->length;
    }
  }
  ++this->_Mypair._Myval2._Mylast;
}

void __fastcall std::vector<AgTypingInputEvent>::push_back(
        std::vector<AgTypingInputEvent> *this,
        AgTypingInputEvent *_Val)
{
  AgTypingInputEvent *Mylast; // rax
  AgTypingInputEvent *Myfirst; // rcx
  signed __int64 v6; // rdi
  AgTypingInputEvent *v7; // rcx
  AgString *v8; // rdi
  AgTypingInputEvent *v9; // rcx

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || (Myfirst = this->_Mypair._Myval2._Myfirst, Myfirst > _Val) )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgTypingInputEvent>::_Reserve(this, 1ui64);
    v9 = this->_Mypair._Myval2._Mylast;
    if ( v9 )
      AgString::AgString(&v9->string, &_Val->string);
  }
  else
  {
    v6 = (char *)_Val - (char *)Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgTypingInputEvent>::_Reserve(this, 1ui64);
    v7 = this->_Mypair._Myval2._Mylast;
    v8 = (AgString *)((char *)&this->_Mypair._Myval2._Myfirst->string + (v6 & 0xFFFFFFFFFFFFFFF0ui64));
    if ( v7 )
      AgString::AgString(&v7->string, v8);
  }
  ++this->_Mypair._Myval2._Mylast;
}

__int64 __fastcall AgPCSystemManager::run(AgPCSystemManager *this)
{
  AgThread *v2; // rax
  AgThread *v3; // rax
  AgThread *v4; // rbx
  AgReferenceCount *v5; // rax
  int v6; // eax
  AgReferenceCount *m_refCount; // rdi
  int v8; // esi
  AgIThreadHost host; // [rsp+58h] [rbp-30h] BYREF
  int v11; // [rsp+60h] [rbp-28h]

  host.__vftable = (AgIThreadHost_vtbl *)&ThreadHost::`vftable';
  v11 = 1;
  v2 = (AgThread *)operator new(0x28ui64);
  if ( v2 )
  {
    AgThread::AgThread(v2, &host, 0x100000ui64, -1, "AgThread");
    v4 = v3;
  }
  else
  {
    v4 = 0i64;
  }
  if ( v4 )
  {
    if ( v4->m_refCount )
    {
      v6 = 0;
    }
    else
    {
      v5 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      if ( v5 )
      {
        v5->m_strongCount = 1;
        v5->m_weakCount = 1;
        v5->m_data = v4;
      }
      else
      {
        v5 = 0i64;
      }
      v4->m_refCount = v5;
      v6 = 1;
    }
    m_refCount = v4->m_refCount;
    if ( !v6 )
      AgReferenceCount::incRef(v4->m_refCount);
  }
  else
  {
    v4 = 0i64;
    m_refCount = 0i64;
  }
  while ( this->m_running )
    AgPCSystemManager::processWindowMessage(this);
  AgThread::join(v4);
  if ( m_refCount )
  {
    v8 = 0;
    if ( !(unsigned int)AgAtomicDecrement(&m_refCount->m_strongCount) )
    {
      if ( !(unsigned int)AgAtomicDecrement(&m_refCount->m_weakCount) )
        v8 = 1;
      m_refCount->m_data = 0i64;
      if ( v4 )
        ((void (__fastcall *)(AgThread *, __int64))v4->~AgThread)(v4, 1i64);
      if ( v8 )
        AgReferenceCount::operator delete(m_refCount);
    }
  }
  return 0i64;
}

void __fastcall AgPCSystemManager::setWindowProperties(
        AgPCSystemManager *this,
        unsigned int width,
        unsigned int height,
        int vsync,
        AgWindowMode mode)
{
  this->m_pendingWindowProperties.mode = mode;
  this->m_pendingWindowProperties.width = width;
  this->m_pendingWindowProperties.height = height;
  this->m_pendingWindowProperties.vsync = vsync;
  if ( AgSingleton<AgSystemManager>::ms_instance )
    AgPCSystemManager::updateProperties((AgPCSystemManager *)AgSingleton<AgSystemManager>::ms_instance);
  if ( !this->m_windowProcSem.m_data.m_aborted )
    WaitForSingleObjectEx(this->m_windowProcSem.m_data.m_sem, 0xFFFFFFFF, 1);
}

void __fastcall AgPCSystemManager::updateProperties(AgPCSystemManager *this)
{
  unsigned int v2; // er14
  int v3; // ebp
  AgWindowMode mode; // ecx
  int v5; // er15
  __int32 v6; // ecx
  __int64 v7; // rdx
  AgDisplay *m_ptr; // rdi
  unsigned int v9; // ebx
  int CurrentScreen; // eax
  int vsync; // eax
  AgDisplay *v12; // rcx
  AgDisplayMode result; // [rsp+28h] [rbp-40h] BYREF
  AgDisplayMode v14; // [rsp+34h] [rbp-34h] BYREF
  AgPointer<AgDisplay> v15; // [rsp+40h] [rbp-28h] BYREF

  if ( this->m_pendingWindowProperties.mode == AgWindowMode_BorderlessWindowed )
  {
    AgDisplayManager::getDisplayByIndex((AgDisplayManager *)AgSingleton<AgDisplayManager>::ms_instance, &v15, 0);
    this->m_pendingWindowProperties.width = AgDisplay::getNativeMode(v15.m_ptr, &result)->m_width;
    this->m_pendingWindowProperties.height = AgDisplay::getNativeMode(v15.m_ptr, &v14)->m_height;
    AgPointer<AgDisplay>::~AgPointer<AgDisplay>(&v15);
  }
  v2 = 0;
  if ( this->m_pendingWindowProperties.width != this->m_windowProperties.width
    || (v3 = 0, this->m_pendingWindowProperties.height != this->m_windowProperties.height) )
  {
    v3 = 1;
  }
  mode = this->m_pendingWindowProperties.mode;
  if ( mode == this->m_windowProperties.mode && !v3 )
  {
    v5 = 0;
    goto LABEL_18;
  }
  v5 = 1;
  if ( mode )
  {
    v6 = mode - 1;
    if ( v6 )
    {
      if ( v6 != 1 )
        goto LABEL_16;
      v7 = 4113i64;
    }
    else
    {
      v7 = 1i64;
    }
  }
  else
  {
    v7 = 0i64;
  }
  SDL_SetWindowFullscreen_0(this->m_sdlWindow, v7);
LABEL_16:
  if ( v3 )
    SDL_SetWindowSize_0(
      this->m_sdlWindow,
      (unsigned int)this->m_pendingWindowProperties.width,
      (unsigned int)this->m_pendingWindowProperties.height);
LABEL_18:
  m_ptr = this->m_display.m_ptr;
  v9 = AgDisplay::getCurrentScreen(m_ptr) | 0x2FFF0000;
  CurrentScreen = AgDisplay::getCurrentScreen(m_ptr);
  SDL_SetWindowPosition_0(this->m_sdlWindow, CurrentScreen | 0x2FFF0000u, v9);
  vsync = this->m_pendingWindowProperties.vsync;
  if ( vsync != this->m_windowProperties.vsync )
  {
    LOBYTE(v2) = vsync == 1;
    SDL_GL_SetSwapInterval_0(v2);
  }
  if ( v3 | v5 )
  {
    v12 = this->m_display.m_ptr;
    if ( v12 )
    {
      if ( v3 )
        AgDisplay::onSizeChanged(v12, this->m_pendingWindowProperties.width, this->m_pendingWindowProperties.height);
      if ( v5 )
        AgDisplay::onModeChanged(this->m_display.m_ptr, this->m_pendingWindowProperties.mode);
      AgSystemManager::onDisplayChanged(this);
    }
  }
  this->m_windowProperties.width = this->m_pendingWindowProperties.width;
  this->m_windowProperties.height = this->m_pendingWindowProperties.height;
  this->m_windowProperties.mode = this->m_pendingWindowProperties.mode;
  this->m_windowProperties.multisample = this->m_pendingWindowProperties.multisample;
  this->m_windowProperties.vsync = this->m_pendingWindowProperties.vsync;
  AgString::operator=(&this->m_windowProperties.title, &this->m_pendingWindowProperties.title);
  if ( !this->m_windowProcSem.m_data.m_aborted )
    ReleaseSemaphore(this->m_windowProcSem.m_data.m_sem, 1, 0i64);
}

__int64 __fastcall AgPCSystemManager::updateWindowProperties(AgPCSystemManager *this, int fullscreen)
{
  AgWindowMode mode; // ebx
  HWND__ *m_windowHandle; // rcx
  DWORD v6; // er14
  LONG_PTR v7; // r8
  UINT uFlags; // ebp
  int height; // er8
  int v10; // ebx
  int v11; // er15
  AgRectangle *ScreenSize; // rbx
  AgRectangle *v13; // rax
  AgRectangle *v15; // rbx
  AgRectangle *v16; // rax
  int cy; // ecx
  int v18; // er9
  int v19; // er8
  int m_width; // eax
  AgRectangle result; // [rsp+40h] [rbp-58h] BYREF
  AgRectangle v22; // [rsp+50h] [rbp-48h] BYREF
  AgRectangle v23; // [rsp+60h] [rbp-38h] BYREF

  mode = this->m_pendingWindowProperties.mode;
  m_windowHandle = this->m_windowHandle;
  v6 = 382337024;
  if ( mode )
    v6 = -1778384896;
  SetWindowLongPtrW(m_windowHandle, -16, v6);
  v7 = 262400i64;
  if ( mode )
    v7 = 0x40000i64;
  SetWindowLongPtrW(this->m_windowHandle, -20, v7);
  uFlags = 0;
  if ( this->m_pendingWindowProperties.mode != this->m_windowProperties.mode )
    uFlags = 32;
  AgDisplay::getScreenSize(&result);
  height = this->m_pendingWindowProperties.height;
  v10 = (result.m_width - this->m_pendingWindowProperties.width) / 2;
  v11 = (result.m_height - height) / 2;
  if ( fullscreen )
  {
    ScreenSize = AgDisplay::getScreenSize(&v23);
    v13 = AgDisplay::getScreenSize(&v22);
    SetWindowPos(this->m_windowHandle, 0i64, 0, 0, v13->m_width, ScreenSize->m_height, uFlags);
    return 1i64;
  }
  else
  {
    if ( this->m_pendingWindowProperties.mode == AgWindowMode_BorderlessWindowed )
    {
      v15 = AgDisplay::getScreenSize(&v22);
      v16 = AgDisplay::getScreenSize(&v23);
      cy = v15->m_height;
      v18 = 0;
      v19 = 0;
      m_width = v16->m_width;
    }
    else
    {
      v23.m_width = this->m_pendingWindowProperties.width;
      v23.m_height = height;
      *(_QWORD *)&v23.m_left = 0i64;
      AdjustWindowRectEx((LPRECT)&v23, v6, 0, 0);
      v18 = v11;
      cy = v23.m_height - v23.m_top;
      v19 = v10;
      m_width = v23.m_width - v23.m_left;
    }
    SetWindowPos(this->m_windowHandle, (HWND)0xFFFFFFFFFFFFFFFEi64, v19, v18, m_width, cy, uFlags);
    return 0i64;
  }
}

int __fastcall AgPCSystemManager::waitForWindow(AgPCSystemManager *this)
{
  if ( !this->m_windowCreateSem.m_data.m_aborted )
    WaitForSingleObjectEx(this->m_windowCreateSem.m_data.m_sem, 0xFFFFFFFF, 1);
  if ( this->m_windowCreateSem.m_data.m_aborted )
    return 0;
  else
    return AgPCSystemManager::createWindow(this);
}

