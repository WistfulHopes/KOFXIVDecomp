#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/system/agsystemmanager.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "dev/silverware/git/sdk/system/agsystemconfig.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_stdinc.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/silverware/git/sdk/util/agjsondata.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/silverware/git/sdk/agvertexdeclaration.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agrectangle.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_endian.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/silverware/git/src/platforms/pc/sdl/include/sdl_rect.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/silverware/git/sdk/agdisplay.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/silverware/git/sdk/agvector3.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "dev/silverware/git/sdk/agvector4.h"
#include "dev/silverware/git/sdk/agvector2.h"
#include "dev/silverware/git/sdk/agmath.h"

AgPointer<AgDisplay> AgDisplay::ms_lockedDisplay; // 0x140A8FEB0
void(*??ms_lockedDisplay$initializer$@AgDisplay@@0P6AXXZEA@@3P6AXXZEA)(); // 0x1407406C0
typedef unsigned short Uint16;
typedef unsigned long long Uint64;
typedef unsigned long Uint32;
AgDisplay::AgDisplay(AgDisplayPlatformData * platformData); // 0x140668D10
AgDisplay::~AgDisplay(); // 0x140668E10
void AgDisplay::initialize(); // 0x1406690F0
AgDisplayPlatformImplementation * AgDisplay::getPlatformImplementation(); // 0x140487310
void AgDisplay::onSizeChanged(long width, long height); // 0x140669190
void AgDisplay::onModeChanged(AgWindowMode mode); // 0x140669180
void AgDisplay::onMinimized(long minimized); // 0x140669170
long AgDisplay::isMinimized(); // 0x140669100
void AgDisplay::use(); // 0x140669270
void AgDisplay::lock(); // 0x140669110
void AgDisplay::unlock(); // 0x140669210
void AgDisplay::flush(); // 0x140669000
unsigned long AgDisplay::getWidth(); // 0x14017D8E0
unsigned long AgDisplay::getHeight(); // 0x1400B8230
long AgDisplay::getVsyncEnabled(); // 0x1403DD110
AgWindowMode AgDisplay::getWindowMode(); // 0x14035A420
void AgDisplay::setCursor(long show, long locked); // 0x1406691F0
void AgDisplay::onFocusChanged(long focus); // 0x140669140
bool AgDisplay_compareModes(AgDisplayMode mode1, AgDisplayMode mode2); // 0x140668F60
void AgDisplay::_updateModes(); // 0x140668F80
unsigned long AgDisplay::getNumModes(); // 0x1406690A0
AgDisplayMode AgDisplay::getMode(unsigned long mode); // 0x140669050
AgDisplayMode AgDisplay::getNativeMode(); // 0x140669080
long AgDisplay::getCurrentScreen(); // 0x140669010
AgRectangle AgDisplay::getCurrentScreenBounds(); // 0x140669020
AgRectangle AgDisplay::getScreenSize(); // 0x1406690D0
AgMultisampleType AgDisplay::getMaxMultisampleType(); // 0x140669040//decompilation failure at 140A8FEB0!
//decompilation failure at 1407406C0!
void __fastcall std::_Guess_median_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Mid,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  signed __int64 v7; // rdx
  __int64 v8; // rax
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  AgDisplayMode *v11; // rbp

  v7 = _Last - _First;
  if ( v7 <= 40 )
  {
    std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(_First, _Mid, _Last, _Pred);
  }
  else
  {
    v8 = (v7 + 1) / 8;
    v9 = 24 * v8;
    v10 = 12 * v8;
    v11 = &_First[v8];
    std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(_First, v11, &_First[2 * v8], _Pred);
    std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
      &_Mid[v10 / 0xFFFFFFFFFFFFFFF4ui64],
      _Mid,
      &_Mid[v10 / 0xC],
      _Pred);
    std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
      &_Last[v9 / 0xFFFFFFFFFFFFFFF4ui64],
      &_Last[v10 / 0xFFFFFFFFFFFFFFF4ui64],
      _Last,
      _Pred);
    std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
      v11,
      _Mid,
      &_Last[v10 / 0xFFFFFFFFFFFFFFF4ui64],
      _Pred);
  }
}

void __fastcall std::_Insertion_sort_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  AgDisplayMode *v4; // rbx
  AgDisplayMode *i; // rdi
  unsigned int m_refreshRate; // er15
  unsigned int v9; // eax
  AgDisplayMode *v10; // rsi
  AgDisplayMode *v11; // rbx
  int v12; // eax
  __int64 v13; // xmm0_8
  __int64 v14; // [rsp+20h] [rbp-48h] BYREF
  unsigned int v15; // [rsp+28h] [rbp-40h]
  __int64 v16; // [rsp+30h] [rbp-38h] BYREF
  unsigned int j; // [rsp+38h] [rbp-30h]
  __int64 v18; // [rsp+40h] [rbp-28h] BYREF
  unsigned int v19; // [rsp+48h] [rbp-20h]
  __int64 v20; // [rsp+50h] [rbp-18h] BYREF
  unsigned int v21; // [rsp+58h] [rbp-10h]
  __int64 v22; // [rsp+90h] [rbp+28h]

  if ( _First != _Last )
  {
    v4 = _First + 1;
    for ( i = _First + 1; i != _Last; ++i )
    {
      m_refreshRate = i->m_refreshRate;
      v9 = _First->m_refreshRate;
      v10 = i;
      v22 = *(_QWORD *)&i->m_width;
      v18 = *(_QWORD *)&_First->m_width;
      v20 = *(_QWORD *)&i->m_width;
      v19 = v9;
      v21 = m_refreshRate;
      if ( (*_Pred)((AgDisplayMode *)&v20, (AgDisplayMode *)&v18) )
      {
        memmove(v4, _First, (char *)i - (char *)_First);
        *(_QWORD *)&_First->m_width = v22;
        _First->m_refreshRate = m_refreshRate;
      }
      else
      {
        v11 = i - 1;
        v12 = i[-1].m_refreshRate;
        v14 = *(_QWORD *)&i[-1].m_width;
        v16 = v22;
        v15 = v12;
        for ( j = m_refreshRate; (*_Pred)((AgDisplayMode *)&v16, (AgDisplayMode *)&v14); j = m_refreshRate )
        {
          *(_QWORD *)&v10->m_width = *(_QWORD *)&v11->m_width;
          v10->m_refreshRate = v11->m_refreshRate;
          v10 = v11;
          v13 = *(_QWORD *)&v11[-1].m_width;
          --v11;
          v14 = v13;
          v16 = v22;
          v15 = v11->m_refreshRate;
        }
        v4 = _First + 1;
        *(_QWORD *)&v10->m_width = v22;
        v10->m_refreshRate = m_refreshRate;
      }
    }
  }
}

void __fastcall std::_Make_heap_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  __int64 v3; // rdx
  __int64 v5; // r12
  __int64 v6; // r14
  __int64 v7; // r8
  __int64 v8; // r15
  AgDisplayMode *v9; // rax
  __int64 v10; // xmm1_8
  __int64 v11; // rdi
  __int64 v12; // rbx
  unsigned int m_refreshRate; // er13
  AgDisplayMode *v14; // rcx
  int v15; // eax
  __int64 v16; // xmm0_8
  int v17; // eax
  __int64 v18; // rax
  AgDisplayMode *v19; // rdx
  __int64 v20; // rax
  AgDisplayMode *v21; // rdx
  __int64 v22; // rbx
  AgDisplayMode *v23; // rbp
  int v24; // eax
  AgDisplayMode *v25; // rcx
  __int64 v26; // rax
  AgDisplayMode *v27; // [rsp+20h] [rbp-98h]
  __int64 v28; // [rsp+30h] [rbp-88h] BYREF
  int v29; // [rsp+38h] [rbp-80h]
  __int64 v30; // [rsp+40h] [rbp-78h] BYREF
  int v31; // [rsp+48h] [rbp-70h]
  __int64 v32; // [rsp+50h] [rbp-68h] BYREF
  unsigned int v33; // [rsp+58h] [rbp-60h]
  __int64 v34; // [rsp+60h] [rbp-58h] BYREF
  int v35; // [rsp+68h] [rbp-50h]
  __int64 v36; // [rsp+C0h] [rbp+8h]
  __int64 v37; // [rsp+C8h] [rbp+10h]
  __int64 v39; // [rsp+D8h] [rbp+20h]

  v3 = (unsigned __int128)(((char *)_Last - (char *)_First) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
  v5 = ((unsigned __int64)v3 >> 63) + (v3 >> 1);
  v37 = v5;
  if ( v5 >= 2 )
  {
    v6 = v5 / 2;
    if ( v5 / 2 > 0 )
    {
      v7 = v5 - 1;
      v8 = (v5 - 1) / 2;
      v39 = v5 - 1;
      v9 = &_First[v6];
      do
      {
        v10 = *(_QWORD *)&v9[-1].m_width;
        --v6;
        v36 = v10;
        v27 = v9 - 1;
        v11 = v6;
        v12 = v6;
        m_refreshRate = v9[-1].m_refreshRate;
        if ( v6 < v8 )
        {
          do
          {
            v12 = 2 * v12 + 2;
            v14 = &_First[v12];
            v15 = v14[-1].m_refreshRate;
            v28 = *(_QWORD *)&v14[-1].m_width;
            v16 = *(_QWORD *)&v14->m_width;
            v29 = v15;
            v17 = v14->m_refreshRate;
            v30 = v16;
            v31 = v17;
            if ( (*_Pred)((AgDisplayMode *)&v30, (AgDisplayMode *)&v28) )
              --v12;
            v18 = v11;
            v11 = v12;
            v19 = &_First[v18];
            *(_QWORD *)&v19->m_width = *(_QWORD *)&_First[v12].m_width;
            v19->m_refreshRate = _First[v12].m_refreshRate;
          }
          while ( v12 < v8 );
          v5 = v37;
          v7 = v39;
        }
        if ( v12 == v8 && (v5 & 1) == 0 )
        {
          v20 = v11;
          v11 = v7;
          v21 = &_First[v20];
          *(_QWORD *)&v21->m_width = *(_QWORD *)&_First[v5 - 1].m_width;
          v21->m_refreshRate = _First[v5 - 1].m_refreshRate;
        }
        v22 = (v11 - 1) / 2;
        if ( v6 < v11 )
        {
          do
          {
            v32 = v10;
            v23 = &_First[v22];
            v24 = v23->m_refreshRate;
            v34 = *(_QWORD *)&v23->m_width;
            v33 = m_refreshRate;
            v35 = v24;
            if ( !(*_Pred)((AgDisplayMode *)&v34, (AgDisplayMode *)&v32) )
              break;
            v10 = v36;
            v25 = &_First[v11];
            *(_QWORD *)&v25->m_width = *(_QWORD *)&v23->m_width;
            v11 = v22;
            v25->m_refreshRate = v23->m_refreshRate;
            v22 = (v22 - 1) / 2;
          }
          while ( v6 < v11 );
          v5 = v37;
        }
        v26 = v11;
        *(_QWORD *)&_First[v26].m_width = v36;
        v7 = v5 - 1;
        _First[v26].m_refreshRate = m_refreshRate;
        v9 = v27;
      }
      while ( v6 > 0 );
    }
  }
}

void __fastcall std::_Med3_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Mid,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  unsigned int m_refreshRate; // eax
  __int64 v7; // xmm0_8
  unsigned int v10; // eax
  __int64 v11; // xmm1_8
  unsigned int v12; // ecx
  unsigned int v13; // eax
  __int64 v14; // xmm0_8
  unsigned int v15; // eax
  int v16; // ecx
  __int64 v17; // xmm1_8
  __int64 v18; // xmm0_8
  unsigned int v19; // eax
  __int64 v20; // xmm1_8
  unsigned int v21; // ecx
  __int64 v22; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v23; // [rsp+28h] [rbp-18h]
  __int64 v24; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v25; // [rsp+38h] [rbp-8h]

  m_refreshRate = _First->m_refreshRate;
  v22 = *(_QWORD *)&_First->m_width;
  v7 = *(_QWORD *)&_Mid->m_width;
  v23 = m_refreshRate;
  v10 = _Mid->m_refreshRate;
  v24 = v7;
  v25 = v10;
  if ( (*_Pred)((AgDisplayMode *)&v24, (AgDisplayMode *)&v22) )
  {
    v11 = *(_QWORD *)&_Mid->m_width;
    v12 = _Mid->m_refreshRate;
    *(_QWORD *)&_Mid->m_width = *(_QWORD *)&_First->m_width;
    _Mid->m_refreshRate = _First->m_refreshRate;
    *(_QWORD *)&_First->m_width = v11;
    _First->m_refreshRate = v12;
  }
  v13 = _Mid->m_refreshRate;
  v24 = *(_QWORD *)&_Mid->m_width;
  v14 = *(_QWORD *)&_Last->m_width;
  v25 = v13;
  v15 = _Last->m_refreshRate;
  v22 = v14;
  v23 = v15;
  if ( (*_Pred)((AgDisplayMode *)&v22, (AgDisplayMode *)&v24) )
  {
    v16 = _Last->m_refreshRate;
    v17 = *(_QWORD *)&_Last->m_width;
    *(_QWORD *)&_Last->m_width = *(_QWORD *)&_Mid->m_width;
    _Last->m_refreshRate = _Mid->m_refreshRate;
    *(_QWORD *)&_Mid->m_width = v17;
    _Mid->m_refreshRate = v16;
    v18 = *(_QWORD *)&_First->m_width;
    v19 = _First->m_refreshRate;
    v23 = v16;
    v24 = v18;
    v25 = v19;
    v22 = v17;
    if ( (*_Pred)((AgDisplayMode *)&v22, (AgDisplayMode *)&v24) )
    {
      v20 = *(_QWORD *)&_Mid->m_width;
      v21 = _Mid->m_refreshRate;
      *(_QWORD *)&_Mid->m_width = *(_QWORD *)&_First->m_width;
      _Mid->m_refreshRate = _First->m_refreshRate;
      *(_QWORD *)&_First->m_width = v20;
      _First->m_refreshRate = v21;
    }
  }
}

std::pair<AgDisplayMode *,AgDisplayMode *> *__fastcall std::_Partition_by_median_guess_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        std::pair<AgDisplayMode *,AgDisplayMode *> *result,
        AgDisplayMode *_First,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  AgDisplayMode *v4; // rsi
  AgDisplayMode *v5; // r13
  AgDisplayMode *v7; // rbx
  AgDisplayMode *v8; // r14
  AgDisplayMode *v9; // rdi
  int m_refreshRate; // eax
  __int64 v11; // xmm0_8
  int v12; // eax
  int v13; // eax
  __int64 v14; // xmm0_8
  int v15; // eax
  int v16; // eax
  __int64 v17; // xmm0_8
  int v18; // eax
  int v19; // eax
  __int64 v20; // xmm0_8
  int v21; // eax
  AgDisplayMode *v22; // rdi
  AgDisplayMode *v23; // r15
  AgDisplayMode *v24; // rsi
  int v25; // eax
  __int64 v26; // xmm0_8
  int v27; // eax
  int v28; // eax
  __int64 v29; // xmm0_8
  int v30; // eax
  AgDisplayMode *v31; // rax
  __int64 v32; // xmm1_8
  unsigned int v33; // ecx
  bool v34; // zf
  AgDisplayMode *v35; // rsi
  int v36; // eax
  __int64 v37; // xmm0_8
  int v38; // eax
  int v39; // eax
  __int64 v40; // xmm0_8
  int v41; // eax
  __int64 v42; // xmm1_8
  unsigned int v43; // ecx
  __int64 v44; // xmm1_8
  unsigned int v45; // ecx
  AgDisplayMode *v46; // r8
  AgDisplayMode *v47; // rdx
  __int64 v48; // xmm1_8
  unsigned int v49; // ecx
  __int64 v50; // xmm1_8
  unsigned int v51; // ecx
  __int64 v52; // xmm0_8
  __int64 v53; // xmm1_8
  unsigned int v54; // ecx
  __int64 v55; // xmm1_8
  unsigned int v56; // ecx
  std::pair<AgDisplayMode *,AgDisplayMode *> *v57; // rax
  __int64 v58; // [rsp+20h] [rbp-59h] BYREF
  int v59; // [rsp+28h] [rbp-51h]
  __int64 v60; // [rsp+30h] [rbp-49h] BYREF
  int v61; // [rsp+38h] [rbp-41h]
  __int64 v62; // [rsp+40h] [rbp-39h] BYREF
  int v63; // [rsp+48h] [rbp-31h]
  __int64 v64; // [rsp+50h] [rbp-29h] BYREF
  int v65; // [rsp+58h] [rbp-21h]
  __int64 v66; // [rsp+60h] [rbp-19h] BYREF
  int v67; // [rsp+68h] [rbp-11h]
  __int64 v68; // [rsp+70h] [rbp-9h] BYREF
  int v69; // [rsp+78h] [rbp-1h]
  __int64 v70; // [rsp+80h] [rbp+7h] BYREF
  int v71; // [rsp+88h] [rbp+Fh]
  __int64 v72; // [rsp+90h] [rbp+17h] BYREF
  int v73; // [rsp+98h] [rbp+1Fh]

  v4 = _First;
  v5 = _Last;
  v7 = &_First[((char *)_Last - (char *)_First) / 24];
  std::_Guess_median_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(_First, v7, _Last - 1, _Pred);
  v8 = v7 + 1;
  if ( v4 < v7 )
  {
    do
    {
      v9 = v7 - 1;
      m_refreshRate = v7->m_refreshRate;
      v58 = *(_QWORD *)&v7->m_width;
      v11 = *(_QWORD *)&v7[-1].m_width;
      v59 = m_refreshRate;
      v12 = v7[-1].m_refreshRate;
      v60 = v11;
      v61 = v12;
      if ( (*_Pred)((AgDisplayMode *)&v60, (AgDisplayMode *)&v58) )
        break;
      v13 = v9->m_refreshRate;
      v62 = *(_QWORD *)&v9->m_width;
      v14 = *(_QWORD *)&v7->m_width;
      v63 = v13;
      v15 = v7->m_refreshRate;
      v64 = v14;
      v65 = v15;
      if ( (*_Pred)((AgDisplayMode *)&v64, (AgDisplayMode *)&v62) )
        break;
      --v7;
    }
    while ( v4 < v9 );
  }
  for ( ; v8 < v5; ++v8 )
  {
    v16 = v7->m_refreshRate;
    v64 = *(_QWORD *)&v7->m_width;
    v17 = *(_QWORD *)&v8->m_width;
    v65 = v16;
    v18 = v8->m_refreshRate;
    v62 = v17;
    v63 = v18;
    if ( (*_Pred)((AgDisplayMode *)&v62, (AgDisplayMode *)&v64) )
      break;
    v19 = v8->m_refreshRate;
    v60 = *(_QWORD *)&v8->m_width;
    v20 = *(_QWORD *)&v7->m_width;
    v61 = v19;
    v21 = v7->m_refreshRate;
    v58 = v20;
    v59 = v21;
    if ( (*_Pred)((AgDisplayMode *)&v58, (AgDisplayMode *)&v60) )
      break;
  }
  v22 = v8;
  v23 = v7;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v22 < v5 )
      {
        v24 = v8 - 1;
        do
        {
          v25 = v22->m_refreshRate;
          v64 = *(_QWORD *)&v22->m_width;
          v26 = *(_QWORD *)&v7->m_width;
          v65 = v25;
          v27 = v7->m_refreshRate;
          v62 = v26;
          v63 = v27;
          if ( !(*_Pred)((AgDisplayMode *)&v62, (AgDisplayMode *)&v64) )
          {
            v28 = v7->m_refreshRate;
            v60 = *(_QWORD *)&v7->m_width;
            v29 = *(_QWORD *)&v22->m_width;
            v61 = v28;
            v30 = v22->m_refreshRate;
            v58 = v29;
            v59 = v30;
            if ( (*_Pred)((AgDisplayMode *)&v58, (AgDisplayMode *)&v60) )
              break;
            v31 = v8;
            ++v24;
            ++v8;
            if ( v31 != v22 )
            {
              v32 = *(_QWORD *)&v24->m_width;
              v33 = v24->m_refreshRate;
              *(_QWORD *)&v24->m_width = *(_QWORD *)&v22->m_width;
              v24->m_refreshRate = v22->m_refreshRate;
              *(_QWORD *)&v22->m_width = v32;
              v22->m_refreshRate = v33;
            }
          }
          ++v22;
        }
        while ( v22 < v5 );
        v4 = _First;
      }
      v34 = v23 == v4;
      if ( v23 > v4 )
      {
        v35 = v23 - 1;
        do
        {
          v36 = v7->m_refreshRate;
          v66 = *(_QWORD *)&v7->m_width;
          v37 = *(_QWORD *)&v35->m_width;
          v67 = v36;
          v38 = v35->m_refreshRate;
          v68 = v37;
          v69 = v38;
          if ( !(*_Pred)((AgDisplayMode *)&v68, (AgDisplayMode *)&v66) )
          {
            v39 = v35->m_refreshRate;
            v70 = *(_QWORD *)&v35->m_width;
            v40 = *(_QWORD *)&v7->m_width;
            v71 = v39;
            v41 = v7->m_refreshRate;
            v72 = v40;
            v73 = v41;
            if ( (*_Pred)((AgDisplayMode *)&v72, (AgDisplayMode *)&v70) )
              break;
            if ( --v7 != v35 )
            {
              v42 = *(_QWORD *)&v7->m_width;
              v43 = v7->m_refreshRate;
              *(_QWORD *)&v7->m_width = *(_QWORD *)&v35->m_width;
              v7->m_refreshRate = v35->m_refreshRate;
              *(_QWORD *)&v35->m_width = v42;
              v35->m_refreshRate = v43;
            }
          }
          --v23;
          --v35;
        }
        while ( _First < v23 );
        v4 = _First;
        v5 = _Last;
        v34 = v23 == _First;
      }
      if ( v34 )
        break;
      --v23;
      if ( v22 == v5 )
      {
        if ( v23 != --v7 )
        {
          v50 = *(_QWORD *)&v23->m_width;
          v51 = v23->m_refreshRate;
          *(_QWORD *)&v23->m_width = *(_QWORD *)&v7->m_width;
          v23->m_refreshRate = v7->m_refreshRate;
          *(_QWORD *)&v7->m_width = v50;
          v7->m_refreshRate = v51;
        }
        v52 = *(_QWORD *)&v8[-1].m_width;
        --v8;
        v53 = *(_QWORD *)&v7->m_width;
        v54 = v7->m_refreshRate;
        *(_QWORD *)&v7->m_width = v52;
        v7->m_refreshRate = v8->m_refreshRate;
        *(_QWORD *)&v8->m_width = v53;
        v8->m_refreshRate = v54;
      }
      else
      {
        v55 = *(_QWORD *)&v22->m_width;
        v56 = v22->m_refreshRate;
        *(_QWORD *)&v22->m_width = *(_QWORD *)&v23->m_width;
        v22->m_refreshRate = v23->m_refreshRate;
        ++v22;
        *(_QWORD *)&v23->m_width = v55;
        v23->m_refreshRate = v56;
      }
    }
    if ( v22 == v5 )
      break;
    if ( v8 != v22 )
    {
      v44 = *(_QWORD *)&v7->m_width;
      v45 = v7->m_refreshRate;
      *(_QWORD *)&v7->m_width = *(_QWORD *)&v8->m_width;
      v7->m_refreshRate = v8->m_refreshRate;
      *(_QWORD *)&v8->m_width = v44;
      v8->m_refreshRate = v45;
    }
    v46 = v22;
    v47 = v7;
    ++v8;
    ++v7;
    ++v22;
    v48 = *(_QWORD *)&v47->m_width;
    v49 = v47->m_refreshRate;
    *(_QWORD *)&v47->m_width = *(_QWORD *)&v46->m_width;
    v47->m_refreshRate = v46->m_refreshRate;
    *(_QWORD *)&v46->m_width = v48;
    v46->m_refreshRate = v49;
  }
  v57 = result;
  result->first = v7;
  result->second = v8;
  return v57;
}

void __fastcall std::_Pop_heap_hole_by_index<AgDisplayMode *,__int64,AgDisplayMode,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        __int64 _Hole,
        __int64 _Bottom,
        AgDisplayMode *_Val,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // r8
  __int64 v11; // rbp
  unsigned int m_refreshRate; // eax
  __int64 v13; // xmm0_8
  unsigned int v14; // eax
  __int64 v15; // rax
  AgDisplayMode *v16; // rdx
  AgDisplayMode *v17; // rdx
  __int64 v18; // [rsp+30h] [rbp-48h] BYREF
  unsigned int v19; // [rsp+38h] [rbp-40h]
  __int64 v20; // [rsp+40h] [rbp-38h] BYREF
  unsigned int v21; // [rsp+48h] [rbp-30h]

  v6 = _Hole;
  v7 = _Hole;
  v8 = _Hole;
  v11 = (_Bottom - 1) / 2;
  if ( _Hole < v11 )
  {
    do
    {
      v6 = 2 * v6 + 2;
      m_refreshRate = _First[v6 - 1].m_refreshRate;
      v18 = *(_QWORD *)&_First[v6 - 1].m_width;
      v13 = *(_QWORD *)&_First[v6].m_width;
      v19 = m_refreshRate;
      v14 = _First[v6].m_refreshRate;
      v20 = v13;
      v21 = v14;
      if ( ((unsigned __int8 (__fastcall *)(__int64 *, __int64 *, __int64))*_Pred)(&v20, &v18, v8) )
        --v6;
      v15 = v7;
      v7 = v6;
      v16 = &_First[v15];
      *(_QWORD *)&v16->m_width = *(_QWORD *)&_First[v6].m_width;
      v16->m_refreshRate = _First[v6].m_refreshRate;
    }
    while ( v6 < v11 );
    v8 = _Hole;
  }
  if ( v6 == v11 && (_Bottom & 1) == 0 )
  {
    v17 = &_First[v7];
    v7 = _Bottom - 1;
    *(_QWORD *)&v17->m_width = *(_QWORD *)&_First[_Bottom - 1].m_width;
    v17->m_refreshRate = _First[_Bottom - 1].m_refreshRate;
  }
  std::_Push_heap_by_index<AgDisplayMode *,__int64,AgDisplayMode,bool (*)(AgDisplayMode,AgDisplayMode)>(
    _First,
    v7,
    v8,
    _Val,
    _Pred);
}

void __fastcall std::_Push_heap_by_index<AgDisplayMode *,__int64,AgDisplayMode,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        __int64 _Hole,
        __int64 _Top,
        AgDisplayMode *_Val,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  __int64 v5; // rbx
  __int64 i; // rdi
  unsigned int m_refreshRate; // ecx
  AgDisplayMode *v11; // rsi
  int v12; // eax
  __int64 v13; // xmm0_8
  AgDisplayMode *v14; // rcx
  AgDisplayMode *v15; // rcx
  __int64 v16; // [rsp+20h] [rbp-38h] BYREF
  unsigned int v17; // [rsp+28h] [rbp-30h]
  __int64 v18; // [rsp+30h] [rbp-28h] BYREF
  int v19; // [rsp+38h] [rbp-20h]

  v5 = _Hole;
  for ( i = (_Hole - 1) / 2; _Top < v5; i = (i - 1) / 2 )
  {
    m_refreshRate = _Val->m_refreshRate;
    v11 = &_First[i];
    v12 = v11->m_refreshRate;
    v16 = *(_QWORD *)&_Val->m_width;
    v13 = *(_QWORD *)&v11->m_width;
    v17 = m_refreshRate;
    v18 = v13;
    v19 = v12;
    if ( !(*_Pred)((AgDisplayMode *)&v18, (AgDisplayMode *)&v16) )
      break;
    v14 = &_First[v5];
    v5 = i;
    *(_QWORD *)&v14->m_width = *(_QWORD *)&v11->m_width;
    v14->m_refreshRate = v11->m_refreshRate;
  }
  v15 = &_First[v5];
  *(_QWORD *)&v15->m_width = *(_QWORD *)&_Val->m_width;
  v15->m_refreshRate = _Val->m_refreshRate;
}

void __fastcall std::_Sort_heap_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Last,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  unsigned __int64 v6; // rdx
  AgDisplayMode *v7; // rbx
  __int64 v8; // xmm0_8
  AgDisplayMode _Val; // [rsp+30h] [rbp-18h] BYREF

  v6 = (__int64)((unsigned __int128)(((char *)_Last - (char *)_First) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 1;
  if ( (__int64)((v6 >> 63) + v6) >= 2 )
  {
    v7 = _Last - 1;
    do
    {
      v8 = *(_QWORD *)&v7->m_width;
      _Val.m_refreshRate = v7->m_refreshRate;
      *(_QWORD *)&_Val.m_width = v8;
      *(_QWORD *)&v7->m_width = *(_QWORD *)&_First->m_width;
      v7->m_refreshRate = _First->m_refreshRate;
      std::_Pop_heap_hole_by_index<AgDisplayMode *,__int64,AgDisplayMode,bool (*)(AgDisplayMode,AgDisplayMode)>(
        _First,
        0i64,
        v7 - _First,
        &_Val,
        _Pred);
      --v7;
    }
    while ( ((char *)v7 - (char *)_First + 12) / 12 >= 2 );
  }
}

void __fastcall std::_Sort_unchecked1<AgDisplayMode *,__int64,bool (*)(AgDisplayMode,AgDisplayMode)>(
        AgDisplayMode *_First,
        AgDisplayMode *_Last,
        __int64 _Ideal,
        bool (__fastcall **_Pred)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))
{
  AgDisplayMode *first; // rbx
  unsigned __int64 v7; // rdx
  AgDisplayMode *second; // rdi
  __int64 v9; // rdx
  std::pair<AgDisplayMode *,AgDisplayMode *> _Lasta; // [rsp+20h] [rbp-18h] BYREF

  first = _Last;
  v7 = (__int64)((unsigned __int128)(((char *)_Last - (char *)_First) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 1;
  second = _First;
  v9 = (v7 >> 63) + v7;
  if ( v9 <= 32 )
  {
LABEL_7:
    if ( v9 >= 2 )
      std::_Insertion_sort_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(second, first, _Pred);
  }
  else
  {
    while ( _Ideal > 0 )
    {
      std::_Partition_by_median_guess_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(
        &_Lasta,
        second,
        first,
        _Pred);
      _Ideal = _Ideal / 2 / 2 + _Ideal / 2;
      if ( _Lasta.first - second >= first - _Lasta.second )
      {
        std::_Sort_unchecked1<AgDisplayMode *,__int64,bool (*)(AgDisplayMode,AgDisplayMode)>(
          _Lasta.second,
          first,
          _Ideal,
          _Pred);
        first = _Lasta.first;
      }
      else
      {
        std::_Sort_unchecked1<AgDisplayMode *,__int64,bool (*)(AgDisplayMode,AgDisplayMode)>(
          second,
          _Lasta.first,
          _Ideal,
          _Pred);
        second = _Lasta.second;
      }
      v9 = first - second;
      if ( v9 <= 32 )
        goto LABEL_7;
    }
    std::_Make_heap_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(second, first, _Pred);
    std::_Sort_heap_unchecked<AgDisplayMode *,bool (*)(AgDisplayMode,AgDisplayMode)>(second, first, _Pred);
  }
}

void __fastcall AgDisplay::AgDisplay(AgDisplay *this, AgDisplayPlatformData *platformData)
{
  AgDisplayPlatformImplementation *v4; // rdi
  AgDisplayPlatformImplementation *v5; // rax
  AgDisplayPlatformImplementation *v6; // rax

  v4 = 0i64;
  this->m_refCount = 0i64;
  this->m_platformImplementation = 0i64;
  *(_QWORD *)&this->m_width = 0i64;
  *(_QWORD *)&this->m_windowMode = 1i64;
  this->m_constrainAspectRatio = 0;
  *(_QWORD *)&this->m_vsync = 1i64;
  *(_QWORD *)&this->m_showCursor = 1i64;
  this->m_minimized = 0;
  this->m_displayModes._Mypair._Myval2._Myfirst = 0i64;
  this->m_displayModes._Mypair._Myval2._Mylast = 0i64;
  this->m_displayModes._Mypair._Myval2._Myend = 0i64;
  *(_QWORD *)&this->m_nativeMode.m_width = 0i64;
  this->m_nativeMode.m_refreshRate = 0;
  v5 = (AgDisplayPlatformImplementation *)operator new(8ui64);
  if ( v5 )
  {
    AgDisplayPlatformImplementation::AgDisplayPlatformImplementation(v5, platformData);
    v4 = v6;
  }
  this->m_platformImplementation = v4;
}

void __fastcall std::vector<AgDisplayMode>::~vector<AgDisplayMode>(std::vector<AgDisplayMode> *this)
{
  AgDisplayMode *Myfirst; // rcx

  Myfirst = this->_Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<ParticleDataForChild>>::deallocate(
      (std::allocator<AgDisplayMode> *)this,
      Myfirst,
      this->_Mypair._Myval2._Myend - Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgDisplay::~AgDisplay(AgDisplay *this)
{
  AgDisplayPlatformImplementation *m_platformImplementation; // rdi
  AgDisplayMode *Myfirst; // r9

  m_platformImplementation = this->m_platformImplementation;
  if ( m_platformImplementation )
  {
    AgDisplayPlatformImplementation::~AgDisplayPlatformImplementation(this->m_platformImplementation);
    operator delete(m_platformImplementation, 8ui64);
  }
  this->m_platformImplementation = 0i64;
  Myfirst = this->m_displayModes._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<ParticleDataForChild>>::deallocate(
      (std::allocator<AgDisplayMode> *)&this->m_displayModes,
      this->m_displayModes._Mypair._Myval2._Myfirst,
      this->m_displayModes._Mypair._Myval2._Myend - Myfirst);
    this->m_displayModes._Mypair._Myval2._Myfirst = 0i64;
    this->m_displayModes._Mypair._Myval2._Mylast = 0i64;
    this->m_displayModes._Mypair._Myval2._Myend = 0i64;
  }
}

AgPointer<AgDisplay> *__fastcall AgPointer<AgDisplay>::operator=(AgPointer<AgDisplay> *this, AgDisplay *t)
{
  AgDisplay *m_ptr; // rbx
  AgReferenceCount *v4; // rax
  int v5; // ecx
  AgReferenceCount *m_refCount; // rdi
  AgReferenceCount *m_ref; // rcx
  AgDisplay *v8; // rax
  AgPointer<AgDisplay> v10; // [rsp+28h] [rbp-20h] BYREF

  m_ptr = t;
  v10 = 0i64;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      v5 = 1;
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = m_ptr;
      }
      m_ptr->m_refCount = v4;
    }
    m_refCount = m_ptr->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(m_ptr->m_refCount);
    v10.m_ref = m_refCount;
    v10.m_ptr = m_ptr;
  }
  else
  {
    m_ptr = v10.m_ptr;
    m_refCount = v10.m_ref;
  }
  m_ref = this->m_ref;
  v8 = this->m_ptr;
  this->m_ref = m_refCount;
  this->m_ptr = m_ptr;
  v10.m_ref = m_ref;
  v10.m_ptr = v8;
  AgPointer<AgDisplay>::~AgPointer<AgDisplay>(&v10);
  return this;
}

bool __fastcall AgDisplay_compareModes(AgDisplayMode *mode1, AgDisplayMode *mode2)
{
  return mode1->m_width < mode2->m_width || mode1->m_width == mode2->m_width && mode1->m_height < mode2->m_height;
}

void __fastcall AgDisplay::_updateModes(AgDisplay *this)
{
  AgDisplayMode *Myfirst; // rcx
  signed __int64 v3; // r8
  bool (__fastcall *_Pred)(AgDisplayMode, AgDisplayMode); // [rsp+30h] [rbp+8h] BYREF

  AgDisplayPlatformImplementation::getDisplayModes(this->m_platformImplementation, &this->m_displayModes);
  AgDisplayPlatformImplementation::getDisplayNativeMode(this->m_platformImplementation, &this->m_nativeMode);
  Myfirst = this->m_displayModes._Mypair._Myval2._Myfirst;
  v3 = (char *)this->m_displayModes._Mypair._Myval2._Mylast - (char *)Myfirst;
  _Pred = (bool (__fastcall *)(AgDisplayMode, AgDisplayMode))AgDisplay_compareModes;
  std::_Sort_unchecked1<AgDisplayMode *,__int64,bool (*)(AgDisplayMode,AgDisplayMode)>(
    Myfirst,
    this->m_displayModes._Mypair._Myval2._Mylast,
    v3 / 12,
    (bool (__fastcall **)(AgDisplayMode *__struct_ptr, AgDisplayMode *__struct_ptr))&_Pred);
}

void __fastcall std::_Wrap_alloc<std::allocator<ParticleDataForChild>>::deallocate(
        std::allocator<AgDisplayMode> *this,
        AgDisplayMode *_Ptr,
        unsigned __int64 _Count)
{
  AgDisplayMode *v3; // rax
  char *v4; // rdx

  if ( _Count > 0x1555555555555555i64 )
    invalid_parameter_noinfo_noreturn();
  if ( 12 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    v3 = *(AgDisplayMode **)&_Ptr[-1].m_height;
    if ( v3 >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)v3);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = v3;
  }
  operator delete(_Ptr);
}

void __fastcall AgDisplay::flush(AgDisplay *this)
{
  AgDisplayPlatformImplementation::flush(this->m_platformImplementation);
}

// attributes: thunk
int __fastcall AgDisplay::getCurrentScreen(AgDisplay *this)
{
  return AgDisplayPlatformImplementation::getCurrentScreen();
}

AgRectangle *__fastcall AgDisplay::getCurrentScreenBounds(AgDisplay *this, AgRectangle *result)
{
  AgDisplayPlatformImplementation::getCurrentScreenBounds(result);
  return result;
}

__int64 __fastcall AgProgram::getShutdownRequested(AgProgram *this)
{
  return (unsigned int)this->m_shutdownRequested;
}

// attributes: thunk
AgMultisampleType __fastcall AgDisplay::getMaxMultisampleType()
{
  return AgDisplayPlatformImplementation::getMaxMultisampleType();
}

AgDisplayMode *__fastcall AgDisplay::getMode(AgDisplay *this, AgDisplayMode *result, unsigned int mode)
{
  __int64 v3; // r8
  AgDisplayMode *Myfirst; // rax
  __int64 v5; // xmm0_8

  v3 = mode;
  Myfirst = this->m_displayModes._Mypair._Myval2._Myfirst;
  v5 = *(_QWORD *)&Myfirst[v3].m_width;
  LODWORD(Myfirst) = Myfirst[v3].m_refreshRate;
  *(_QWORD *)&result->m_width = v5;
  result->m_refreshRate = (unsigned int)Myfirst;
  return result;
}

AgDisplayMode *__fastcall AgDisplay::getNativeMode(AgDisplay *this, AgDisplayMode *result)
{
  unsigned int m_refreshRate; // eax

  m_refreshRate = this->m_nativeMode.m_refreshRate;
  *(_QWORD *)&result->m_width = *(_QWORD *)&this->m_nativeMode.m_width;
  result->m_refreshRate = m_refreshRate;
  return result;
}

signed __int64 __fastcall AgDisplay::getNumModes(AgDisplay *this)
{
  return this->m_displayModes._Mypair._Myval2._Mylast - this->m_displayModes._Mypair._Myval2._Myfirst;
}

AgDisplayPlatformImplementation *__fastcall Scaleform::GFx::Stream::GetLog(AgDisplay *this)
{
  return this->m_platformImplementation;
}

AgRectangle *__fastcall AgDisplay::getScreenSize(AgRectangle *result)
{
  AgDisplayPlatformImplementation::getScreenSize(result);
  return result;
}

__int64 __fastcall AgDisplay::getVsyncEnabled(AgDisplay *this)
{
  return (unsigned int)this->m_vsync;
}

__int64 __fastcall AgDisplay::getWidth(AgUser *this)
{
  return (unsigned int)this->m_signInBusy;
}

__int64 __fastcall Scaleform::Render::ShapeDataPacked<Scaleform::ArrayDH<unsigned char,2,Scaleform::ArrayDefaultPolicy>>::GetStartingPos(
        AgDisplay *this)
{
  return (unsigned int)this->m_windowMode;
}

// attributes: thunk
void __fastcall AgDisplay::initialize(AgDisplay *this)
{
  AgDisplay::_updateModes(this);
}

__int64 __fastcall AgDisplay::isMinimized(AgDisplay *this)
{
  return (unsigned int)this->m_minimized;
}

void __fastcall AgDisplay::lock(AgDisplay *this)
{
  AgDisplayPlatformImplementation::lock(this->m_platformImplementation);
  AgPointer<AgDisplay>::operator=(&AgDisplay::ms_lockedDisplay, this);
}

void __fastcall AgDisplay::onFocusChanged(AgDisplay *this, int focus)
{
  this->m_focused = focus;
  if ( focus )
    AgDisplayPlatformImplementation::setCursor(this->m_platformImplementation, this->m_showCursor, this->m_lockCursor);
  else
    AgDisplayPlatformImplementation::setCursor(this->m_platformImplementation, 1, 0);
}

void __fastcall AgDisplay::onMinimized(AgDisplay *this, int minimized)
{
  this->m_minimized = minimized;
}

void __fastcall AgDisplay::onModeChanged(AgDisplay *this, AgWindowMode mode)
{
  this->m_windowMode = mode;
}

void __fastcall AgDisplay::onSizeChanged(AgDisplay *this, int width, int height)
{
  float v3; // xmm0_4
  AgRectangle v4; // [rsp+0h] [rbp-18h]

  v3 = (float)width;
  if ( this->m_constrainAspectRatio )
    height = (int)(float)(v3 * this->m_aspect);
  else
    this->m_aspect = (float)height / v3;
  *(_QWORD *)&v4.m_width = __PAIR64__(height, width);
  *(_QWORD *)&v4.m_left = 0i64;
  this->m_width = width;
  this->m_height = height;
  this->m_size = v4;
}

void __fastcall AgDisplay::setCursor(AgDisplay *this, int show, int locked)
{
  bool v3; // zf
  AgDisplayPlatformImplementation *m_platformImplementation; // rcx

  v3 = this->m_focused == 0;
  this->m_showCursor = show;
  this->m_lockCursor = locked;
  m_platformImplementation = this->m_platformImplementation;
  if ( v3 )
  {
    locked = 0;
    show = 1;
  }
  AgDisplayPlatformImplementation::setCursor(m_platformImplementation, show, locked);
}

void __fastcall AgDisplay::unlock(AgDisplay *this)
{
  AgReferenceCount *m_ref; // rax
  AgDisplay *m_ptr; // rdx
  AgPointer<AgDisplay> v4; // [rsp+28h] [rbp-20h] BYREF

  m_ref = AgDisplay::ms_lockedDisplay.m_ref;
  m_ptr = AgDisplay::ms_lockedDisplay.m_ptr;
  AgDisplay::ms_lockedDisplay = 0i64;
  v4.m_ref = m_ref;
  v4.m_ptr = m_ptr;
  AgPointer<AgDisplay>::~AgPointer<AgDisplay>(&v4);
  AgDisplayPlatformImplementation::unlock(this->m_platformImplementation);
}

void __fastcall AgDisplay::use(AgDisplay *this)
{
  AgDisplayPlatformImplementation::use(this->m_platformImplementation);
}

