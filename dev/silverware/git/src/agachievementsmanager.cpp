#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agachievementsmanager.h"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/silverware/git/sdk/3rdparty/steam/isteamhtmlsurface.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/silverware/git/sdk/util/agservicecommand.inl"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api_internal.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steam_api.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "dev/silverware/git/sdk/3rdparty/steam/matchmakingtypes.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "dev/silverware/git/sdk/agqueue.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/silverware/git/sdk/3rdparty/steam/steamclientpublic.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/silverware/git/sdk/agringbuffer.h"
#include "dev/silverware/git/sdk/agmemory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "dev/silverware/git/sdk/util/agworkerpool.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"

AgSingleton<AgWorkerPool> * AgSingleton<AgWorkerPool>::ms_instance; // 0x140A8FCB8
AgAchievementPlatformData::AgAchievementPlatformData(); // 0x140657F20
AgAchievementsManager::AgAchievementsManager(); // 0x140657F50
AgDebugChannel<1>::~AgDebugChannel<1>(); // 0x140658010
AgAchievementsManager::~AgAchievementsManager(); // 0x1406581C0
AgService::~AgService(); // 0x140658280
AgSilverWareDebugChannel::~AgSilverWareDebugChannel(); // 0x140658300
long AgAchievementsManager::onSingletonInit(); // 0x140658AE0
long AgAchievementsManager::onSingletonExit(); // 0x140658AA0
void AgAchievementsManager::unlock(AgAchievementPlatformData * achievementData); // 0x140658D70
void AgAchievementsManager::onJoinThread(); // 0x140658A70
long AgAchievementsManager::getThreadIsRunning(); // 0x1406587F0
void AgAchievementsManager::onExecuteThread(); // 0x1406589B0
long AgAchievementsManager::_internalUnlock(const AgAchievementPlatformData & achievementData); // 0x1406584C0
void AgAchievementsManager::_internalUnlockSteam(AgAchievementPlatformData achievementData); // 0x1406585A0//decompilation failure at 140A8FCB8!
AgServiceCommandBase *__fastcall AgBindServiceCommand<AgAllocator<1>,void,AgAchievementPlatformData,AgAchievementPlatformData>(
        AgAllocator<1> allocator,
        void (__fastcall *func)(AgAchievementPlatformData *__struct_ptr),
        AgAchievementPlatformData *p1)
{
  char *v5; // rbx
  AgString copy; // [rsp+40h] [rbp-28h] BYREF
  AgAllocator<1> v8; // [rsp+70h] [rbp+8h] BYREF
  AgAchievementPlatformData *v9; // [rsp+80h] [rbp+18h]
  char *v10; // [rsp+88h] [rbp+20h]

  v9 = p1;
  v8 = allocator;
  v5 = (char *)AgAllocator<1>::allocate(&v8, 0x28ui64);
  v10 = v5;
  if ( v5 )
  {
    AgString::AgString(&copy, &p1->m_achievementId);
    *(_QWORD *)v5 = &AgServiceCommandBase::`vftable';
    *(_QWORD *)v5 = &AgServiceCommand<AgAllocator<1>,void,void (AgAchievementPlatformData),void (AgAchievementPlatformData)>::`vftable';
    *((_QWORD *)v5 + 1) = func;
    AgString::AgString((AgString *)(v5 + 24), &copy);
    AgString::~AgString(&copy);
  }
  else
  {
    v5 = 0i64;
  }
  AgString::~AgString(&p1->m_achievementId);
  return (AgServiceCommandBase *)v5;
}

void __fastcall AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        AgPointer<AgPlayer> *this,
        const AgPointer<AgPlayer> *rhs)
{
  AgReferenceCount *m_ref; // rsi
  int m_strongCount; // ebx

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  m_ref = rhs->m_ref;
  if ( rhs->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          return;
      }
      if ( m_strongCount != -1 )
      {
        this->m_ref = rhs->m_ref;
        this->m_ptr = rhs->m_ptr;
      }
    }
  }
}

void __fastcall AgAchievementPlatformData::AgAchievementPlatformData(AgAchievementPlatformData *this)
{
  AgString::AgString(&this->m_achievementId);
}

void __fastcall AgAchievementsManager::AgAchievementsManager(AgAchievementsManager *this)
{
  this->AgSingleton<AgAchievementsManager>::__vftable = (AgAchievementsManager_vtbl *)&AgSingleton<AgAchievementsManager>::`vftable';
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgIThreadHost::`vftable';
  this->AgSingleton<AgAchievementsManager>::__vftable = (AgAchievementsManager_vtbl *)&AgAchievementsManager::`vftable'{for `AgSingleton<AgAchievementsManager>'};
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgAchievementsManager::`vftable'{for `AgIThreadHost'};
  this->m_unlockQueue.m_buffer.m_baseMem = 0i64;
  this->m_unlockQueue.m_buffer.m_returnedMem = 0i64;
  this->m_unlockQueue.m_buffer.m_numItems = 0;
  this->m_unlockQueue.m_sem.m_data.m_aborted = 0;
  this->m_unlockQueue.m_sem.m_data.m_sem = 0i64;
  this->m_unlockQueue.m_sem.m_data.m_sem = CreateSemaphoreA(0i64, 0, 0x7FFFFFFF, 0i64);
  this->m_workerThread.m_ref = 0i64;
  this->m_workerThread.m_ptr = 0i64;
  this->m_shutdownThread = 0;
}

void __fastcall AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::~AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>(
        AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1> *this)
{
  AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(this);
}

void __fastcall AgDebugChannel<1>::~AgDebugChannel<1>(AgDebugChannel<1> *this, unsigned __int64 a2)
{
  operator delete(this->m_counter.m_deltaTime, a2);
}

void __fastcall AgPointer<AgService>::~AgPointer<AgService>(AgPointer<AgService> *this)
{
  AgService *m_ptr; // rdi
  AgReferenceCount *m_ref; // rbx
  int v3; // esi

  m_ptr = this->m_ptr;
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( this->m_ref )
  {
    this->m_ref = 0i64;
    v3 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v3 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
      {
        AgService::~AgService(m_ptr);
        operator delete(m_ptr, 0xA8ui64);
      }
      if ( v3 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgQueue<AgAchievementPlatformData>::~AgQueue<AgAchievementPlatformData>(
        AgQueue<AgAchievementPlatformData> *this)
{
  void *m_sem; // rcx

  AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(&this->m_buffer);
  if ( !this->m_sem.m_data.m_aborted )
  {
    this->m_sem.m_data.m_aborted = 1;
    ReleaseSemaphore(this->m_sem.m_data.m_sem, 1000, 0i64);
  }
  m_sem = this->m_sem.m_data.m_sem;
  if ( m_sem )
    CloseHandle(m_sem);
  AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(&this->m_buffer);
}

void __fastcall AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::~AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>(
        AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *this)
{
  AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::free(this);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_lock);
}

void __fastcall AgSingleton<AgAchievementsManager>::~AgSingleton<AgAchievementsManager>(
        AgSingleton<AgAchievementsManager> *this)
{
  this->__vftable = (AgSingleton<AgAchievementsManager>_vtbl *)&AgSingleton<AgAchievementsManager>::`vftable';
}

void __fastcall std::vector<AgServiceCommandBase *>::~vector<AgServiceCommandBase *>(
        std::vector<AgServiceCommandBase *> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)this,
      (AgLogger **)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgAchievementsManager::~AgAchievementsManager(AgAchievementsManager *this)
{
  void *m_sem; // rcx

  this->AgSingleton<AgAchievementsManager>::__vftable = (AgAchievementsManager_vtbl *)&AgAchievementsManager::`vftable'{for `AgSingleton<AgAchievementsManager>'};
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgAchievementsManager::`vftable'{for `AgIThreadHost'};
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->m_workerThread);
  AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(&this->m_unlockQueue.m_buffer);
  if ( !this->m_unlockQueue.m_sem.m_data.m_aborted )
  {
    this->m_unlockQueue.m_sem.m_data.m_aborted = 1;
    ReleaseSemaphore(this->m_unlockQueue.m_sem.m_data.m_sem, 1000, 0i64);
  }
  m_sem = this->m_unlockQueue.m_sem.m_data.m_sem;
  if ( m_sem )
    CloseHandle(m_sem);
  AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(&this->m_unlockQueue.m_buffer);
  this->AgIThreadHost::__vftable = (AgIThreadHost_vtbl *)&AgIThreadHost::`vftable';
  this->AgSingleton<AgAchievementsManager>::__vftable = (AgAchievementsManager_vtbl *)&AgSingleton<AgAchievementsManager>::`vftable';
}

void __fastcall AgPerformanceCounter::~AgPerformanceCounter(AgPerformanceCounter *this, unsigned __int64 a2)
{
  operator delete(this->m_deltaTime, a2);
}

void __fastcall AgService::~AgService(AgService *this, unsigned __int64 a2)
{
  AgLogger **Myfirst; // rdx

  operator delete(this->m_channel.m_counter.m_deltaTime, a2);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_condition);
  Myfirst = (AgLogger **)this->m_commands._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
      (std::allocator<AgLogger *> *)&this->m_commands,
      Myfirst,
      ((char *)this->m_commands._Mypair._Myval2._Myend - (char *)Myfirst) >> 3);
    this->m_commands._Mypair._Myval2._Myfirst = 0i64;
    this->m_commands._Mypair._Myval2._Mylast = 0i64;
    this->m_commands._Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgServiceCommandBase::~AgServiceCommandBase(AgServiceCommandBase *this)
{
  this->__vftable = (AgServiceCommandBase_vtbl *)&AgServiceCommandBase::`vftable';
}

void __fastcall AgSilverWareDebugChannel::~AgSilverWareDebugChannel(
        AgSilverWareDebugChannel *this,
        unsigned __int64 a2)
{
  operator delete(this->m_counter.m_deltaTime, a2);
}

void __fastcall AgServiceCommandBase::operator delete(void *memory, void *__formal)
{
  (*(void (__fastcall **)(void *, void *))(*(_QWORD *)memory + 16i64))(memory, __formal);
}

char __fastcall AgServiceCommand<AgAllocator<1>,void,void (AgAchievementPlatformData),void (AgAchievementPlatformData)>::operator()(
        AgServiceCommand<AgAllocator<1>,void,void __cdecl(AgAchievementPlatformData),void __cdecl(AgAchievementPlatformData)> *this)
{
  AgString v3; // [rsp+28h] [rbp-20h] BYREF

  AgString::AgString(&v3, &this->m_p1.m_achievementId);
  ((void (__fastcall *)(AgString *))this->m_delegate)(&v3);
  return 1;
}

__int64 __fastcall AgAchievementsManager::_internalUnlock(
        AgAchievementsManager *this,
        const AgAchievementPlatformData *achievementData)
{
  AgPointer<AgService> *Service; // rdi
  AgServiceCommandBase *v3; // rbx
  AgString v5; // [rsp+28h] [rbp-50h] BYREF
  AgString v6; // [rsp+38h] [rbp-40h] BYREF
  AgString copy; // [rsp+48h] [rbp-30h] BYREF
  AgPointer<AgService> result; // [rsp+58h] [rbp-20h] BYREF

  AgString::AgString(&copy, &achievementData->m_achievementId);
  AgString::AgString(&v5, &copy);
  Service = AgWorkerPool::getService((AgWorkerPool *)AgSingleton<AgWorkerPool>::ms_instance, &result);
  AgString::AgString(&v6, &v5);
  v3 = AgBindServiceCommand<AgAllocator<1>,void,AgAchievementPlatformData,AgAchievementPlatformData>(
         (AgAllocator<1>)&v6,
         AgAchievementsManager::_internalUnlockSteam,
         (AgAchievementPlatformData *)&v6);
  AgString::~AgString(&v5);
  AgService::post(Service->m_ptr, v3);
  AgPointer<AgService>::~AgPointer<AgService>(&result);
  AgString::~AgString(&copy);
  return 1i64;
}

void __fastcall AgAchievementsManager::_internalUnlockSteam(AgAchievementPlatformData *achievementData)
{
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 *v4; // rbx
  __int64 v5; // rdi
  const char *CString; // rax
  __int64 v7; // rdx
  __int64 v8; // rax
  char v9; // al
  const char *v10; // rax

  if ( AgSilverware::steamAvailable() )
  {
    if ( *(_QWORD *)(SteamInternal_ContextInit(&`SteamInternal_ModuleContext'::`2'::s_CallbackCounterAndContext, v2) + 40) )
    {
      v4 = *(__int64 **)(SteamInternal_ContextInit(&`SteamInternal_ModuleContext'::`2'::s_CallbackCounterAndContext, v3)
                       + 40);
      v5 = *v4;
      CString = AgString::getCString(&achievementData->m_achievementId);
      LOBYTE(v4) = (*(__int64 (__fastcall **)(__int64 *, const char *))(v5 + 56))(v4, CString);
      v8 = SteamInternal_ContextInit(&`SteamInternal_ModuleContext'::`2'::s_CallbackCounterAndContext, v7);
      v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v8 + 40) + 80i64))(*(_QWORD *)(v8 + 40));
      if ( !(_BYTE)v4 || !v9 )
      {
        v10 = AgString::getCString(&achievementData->m_achievementId);
        AgTrace("[steam][Warning] Unable to unlock achievement: %s", v10);
      }
    }
  }
  AgString::~AgString(&achievementData->m_achievementId);
}

void __fastcall std::_Wrap_alloc<std::allocator<OGLShader *>>::deallocate(
        std::allocator<AgLogger *> *this,
        AgLogger **_Ptr,
        unsigned __int64 _Count)
{
  AgLogger **v3; // rax
  char *v4; // rdx

  if ( _Count > 0x1FFFFFFFFFFFFFFFi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 8 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    v3 = (AgLogger **)*(_Ptr - 1);
    if ( v3 >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)v3);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = v3;
  }
  operator delete(_Ptr);
}

void __fastcall AgServiceCommand<AgAllocator<1>,void,void (AgAchievementPlatformData),void (AgAchievementPlatformData)>::destroy(
        AgServiceCommand<AgAllocator<1>,void,void __cdecl(AgAchievementPlatformData),void __cdecl(AgAchievementPlatformData)> *this)
{
  ((void (__fastcall *)(AgServiceCommand<AgAllocator<1>,void,void __cdecl(AgAchievementPlatformData),void __cdecl(AgAchievementPlatformData)> *, _QWORD))this->~AgServiceCommandBase)(
    this,
    0i64);
  AgAllocator<1>::deallocate(&this->m_allocator, this);
}

void __fastcall AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1>::free(
        AgAlignedPointer<AgRingBufferLocked<AgAchievementPlatformData>,1> *this,
        unsigned __int64 a2)
{
  unsigned int i; // esi
  AgRingBufferLocked<AgAchievementPlatformData> *v4; // rdi

  if ( this->m_returnedMem )
  {
    for ( i = 0; i < this->m_numItems; ++i )
    {
      v4 = &this->m_returnedMem[(unsigned __int64)i];
      AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::free(v4);
      DeleteCriticalSection((LPCRITICAL_SECTION)&v4->m_lock);
    }
  }
  operator delete(this->m_baseMem, a2);
  this->m_baseMem = 0i64;
  this->m_returnedMem = 0i64;
}

void __fastcall AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::free(
        AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *this)
{
  AgMutex *p_m_lock; // rsi
  AgAchievementPlatformData *m_buffer; // rcx
  _QWORD *p_m_text; // rbx

  p_m_lock = &this->m_lock;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_lock);
  m_buffer = this->m_buffer;
  if ( m_buffer )
  {
    p_m_text = &m_buffer[-1].m_achievementId.m_text;
    `eh vector destructor iterator'(
      m_buffer,
      0x10ui64,
      (unsigned __int64)m_buffer[-1].m_achievementId.m_text,
      (void (__fastcall *)(void *))AgUtilities::captureScreenshot);
    operator delete[](p_m_text, 16i64 * *p_m_text + 8);
  }
  this->m_buffer = 0i64;
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_lock);
}

AgPointer<AgService> *__fastcall AgWorkerPool::getService(AgWorkerPool *this, AgPointer<AgService> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)&this->m_service);
  return result;
}

_BOOL8 __fastcall AgAchievementsManager::getThreadIsRunning(AgAchievementsManager *this)
{
  return LODWORD(this->m_workerThread.m_ptr) == 0;
}

void __fastcall AgQueue<AgAchievementPlatformData>::init(
        AgQueue<AgAchievementPlatformData> *this,
        unsigned int maxItems)
{
  unsigned __int8 *v4; // rbp
  AgRingBufferLocked<AgAchievementPlatformData> *v5; // rsi
  int v6; // edi
  AgMutex *p_m_lock; // rbx
  unsigned __int64 v8; // rdx

  v4 = (unsigned __int8 *)operator new[](0xC0ui64);
  v5 = (AgRingBufferLocked<AgAchievementPlatformData> *)((unsigned __int64)(v4 + 63) & 0xFFFFFFFFFFFFFFC0ui64);
  v6 = 0;
  p_m_lock = &v5->m_lock;
  do
  {
    if ( p_m_lock != (AgMutex *)16 )
    {
      *(_DWORD *)&p_m_lock[-1].m_data.m_criticalSection.data[24] = 0;
      *(_QWORD *)&p_m_lock[-1].m_data.m_criticalSection.data[32] = 0i64;
      InitializeCriticalSection((LPCRITICAL_SECTION)p_m_lock);
      *(_DWORD *)p_m_lock[1].m_data.m_criticalSection.data = 0;
      *(_DWORD *)&p_m_lock[1].m_data.m_criticalSection.data[8] = 0;
    }
    ++v6;
    p_m_lock = (AgMutex *)((char *)p_m_lock + 128);
  }
  while ( !v6 );
  this->m_buffer.m_baseMem = v4;
  this->m_buffer.m_returnedMem = v5;
  this->m_buffer.m_numItems = 1;
  AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::init(v5, maxItems);
  operator delete(0i64, v8);
}

void __fastcall AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::init(
        AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *this,
        unsigned int numItems)
{
  unsigned int i; // eax
  __int64 v4; // rsi
  __int64 v5; // rax
  unsigned __int64 v6; // kr00_8
  bool v7; // cf
  unsigned __int64 v8; // rax
  _QWORD *v9; // rax
  AgAchievementPlatformData *v10; // rdi

  for ( i = numItems & -numItems; i < numItems; i *= 2 )
    ;
  this->m_sz = i;
  v4 = i;
  v6 = i;
  v5 = 16i64 * i;
  if ( !is_mul_ok(v6, 0x10ui64) )
    v5 = -1i64;
  v7 = __CFADD__(v5, 8i64);
  v8 = v5 + 8;
  if ( v7 )
    v8 = -1i64;
  v9 = operator new[](v8);
  if ( v9 )
  {
    *v9 = v4;
    v10 = (AgAchievementPlatformData *)(v9 + 1);
    `eh vector constructor iterator'(
      v9 + 1,
      0x10ui64,
      (unsigned int)v4,
      (void (__fastcall *)(void *))AgAchievementPlatformData::AgAchievementPlatformData,
      (void (__fastcall *)(void *))AgUtilities::captureScreenshot);
  }
  else
  {
    v10 = 0i64;
  }
  this->m_buffer = v10;
  this->m_write = 0;
  this->m_read = 0;
}

void __fastcall AgAchievementsManager::onExecuteThread(AgAchievementsManager *this)
{
  BOOL v2; // eax
  AgString v3; // [rsp+28h] [rbp-20h] BYREF

  if ( LODWORD(this->m_workerThread.m_ptr) )
  {
    LODWORD(this->m_workerThread.m_ptr) = 1;
  }
  else
  {
    while ( 1 )
    {
      AgString::AgString(&v3);
      if ( this->m_unlockQueue.m_buffer.m_numItems )
        break;
      v2 = !WaitForSingleObjectEx(*(HANDLE *)&this->m_unlockQueue.m_sem.m_data.m_aborted, 0xFFFFFFFF, 1)
        && !this->m_unlockQueue.m_buffer.m_numItems;
      if ( !v2
        || !AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::pop(
              (AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *)this->m_unlockQueue.m_buffer.m_baseMem,
              (AgAchievementPlatformData *)&v3,
              1u) )
      {
        break;
      }
      AgAchievementsManager::_internalUnlock(
        (AgAchievementsManager *)((char *)this - 8),
        (const AgAchievementPlatformData *)&v3);
      AgString::~AgString(&v3);
      if ( LODWORD(this->m_workerThread.m_ptr) )
      {
        LODWORD(this->m_workerThread.m_ptr) = 1;
        return;
      }
    }
    AgString::~AgString(&v3);
    LODWORD(this->m_workerThread.m_ptr) = 1;
  }
}

void __fastcall AgAchievementsManager::onJoinThread(AgAchievementsManager *this)
{
  LODWORD(this->m_workerThread.m_ptr) = 1;
  if ( !this->m_unlockQueue.m_buffer.m_numItems )
  {
    this->m_unlockQueue.m_buffer.m_numItems = 1;
    ReleaseSemaphore(*(HANDLE *)&this->m_unlockQueue.m_sem.m_data.m_aborted, 1000, 0i64);
  }
}

__int64 __fastcall AgAchievementsManager::onSingletonExit(AgAchievementsManager *this)
{
  if ( this->getThreadIsRunning(&this->AgIThreadHost) )
    AgThread::join(this->m_workerThread.m_ptr);
  AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_workerThread, 0i64);
  return 0i64;
}

__int64 __fastcall AgAchievementsManager::onSingletonInit(AgAchievementsManager *this)
{
  AgThread *v2; // rax
  AgController *v3; // r8
  AgIThreadHost *v4; // rdx
  AgController *v5; // rax

  v2 = (AgThread *)operator new(0x28ui64);
  v3 = 0i64;
  if ( v2 )
  {
    v4 = &this->AgIThreadHost;
    if ( !this )
      v4 = 0i64;
    AgThread::AgThread(v2, v4, 0x400000ui64, -1, "AgThread");
    v3 = v5;
  }
  AgPointer<AgThread>::operator=((AgPointer<AgController> *)&this->m_workerThread, v3);
  AgQueue<AgAchievementPlatformData>::init(&this->m_unlockQueue, 0x32u);
  return 1i64;
}

__int64 __fastcall AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::pop(
        AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *this,
        AgAchievementPlatformData *items,
        unsigned int numItems)
{
  AgMutex *p_m_lock; // r14
  unsigned int v7; // ebp
  unsigned int i; // esi

  p_m_lock = &this->m_lock;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_lock);
  if ( __TSS0__1__pop___AgRingBufferImpl_UAgAchievementPlatformData__VAgMutex__V2___QEAAIPEAUAgAchievementPlatformData__I_Z_4HA > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 40i64) )
  {
    Init_thread_header(&__TSS0__1__pop___AgRingBufferImpl_UAgAchievementPlatformData__VAgMutex__V2___QEAAIPEAUAgAchievementPlatformData__I_Z_4HA);
    if ( __TSS0__1__pop___AgRingBufferImpl_UAgAchievementPlatformData__VAgMutex__V2___QEAAIPEAUAgAchievementPlatformData__I_Z_4HA == -1 )
    {
      AgString::AgString(&`AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::pop'::`2'::zero.m_achievementId);
      atexit(`AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::pop'::`2'::`dynamic atexit destructor for 'zero'');
      Init_thread_footer(&__TSS0__1__pop___AgRingBufferImpl_UAgAchievementPlatformData__VAgMutex__V2___QEAAIPEAUAgAchievementPlatformData__I_Z_4HA);
    }
  }
  v7 = 0;
  for ( i = this->m_read; v7 < numItems; ++v7 )
  {
    if ( i >= this->m_write )
      break;
    AgString::operator=(&items[v7].m_achievementId, &this->m_buffer[i & (this->m_sz - 1)].m_achievementId);
    AgString::operator=(
      &this->m_buffer[i++ & (this->m_sz - 1)].m_achievementId,
      &`AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::pop'::`2'::zero.m_achievementId);
  }
  this->m_read = i;
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_lock);
  return v7;
}

__int64 __fastcall AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::push(
        AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex> *this,
        AgAchievementPlatformData *items,
        unsigned int numItems)
{
  AgMutex *p_m_lock; // rbp
  unsigned int v7; // esi
  unsigned int m_write; // edi
  unsigned int m_sz; // edx

  p_m_lock = &this->m_lock;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_lock);
  v7 = 0;
  m_write = this->m_write;
  while ( v7 < numItems )
  {
    m_sz = this->m_sz;
    if ( m_write >= m_sz + this->m_read )
      break;
    AgString::operator=(&this->m_buffer[m_write++ & (m_sz - 1)].m_achievementId, &items[v7++].m_achievementId);
  }
  this->m_write = m_write;
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_lock);
  return v7;
}

void __fastcall AgAchievementsManager::unlock(AgAchievementsManager *this, AgAchievementPlatformData *achievementData)
{
  if ( (unsigned int)AgRingBufferImpl<AgAchievementPlatformData,AgMutex,AgMutex>::push(
                       this->m_unlockQueue.m_buffer.m_returnedMem,
                       achievementData,
                       1u) )
  {
    if ( !this->m_unlockQueue.m_sem.m_data.m_aborted )
      ReleaseSemaphore(this->m_unlockQueue.m_sem.m_data.m_sem, 1, 0i64);
  }
}

