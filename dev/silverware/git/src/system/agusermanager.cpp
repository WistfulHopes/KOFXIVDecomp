#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/silverware/git/sdk/system/agsystemmanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/silverware/git/sdk/system/agsystemconfig.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/silverware/git/src/platforms/shared/system/agdefaultusermanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "dev/silverware/git/sdk/util/agjsondata.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/silverware/git/sdk/agpointer.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/util/ageventdispatcher.h"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"

std::piecewise_construct_t std::piecewise_construct; // 0x14086A1B2
typedef AgDefaultUserManager AgPlatformUserManager;
AgUserManager::AgUserManager(); // 0x14067BEC0
AgAsyncEventDispatcher<AgUserAddedEvent>::~AgAsyncEventDispatcher<AgUserAddedEvent>(); // 0x14067BFE0
AgAsyncEventDispatcher<AgUserRemovedEvent>::~AgAsyncEventDispatcher<AgUserRemovedEvent>(); // 0x14067C060
AgAsyncEventDispatcher<AgUserUpdatedEvent>::~AgAsyncEventDispatcher<AgUserUpdatedEvent>(); // 0x14067C0E0
AgEventDispatcherBase<AgUserAddedEvent>::~AgEventDispatcherBase<AgUserAddedEvent>(); // 0x14067C160
AgEventDispatcherBase<AgUserRemovedEvent>::~AgEventDispatcherBase<AgUserRemovedEvent>(); // 0x14067C1C0
AgEventDispatcherBase<AgUserUpdatedEvent>::~AgEventDispatcherBase<AgUserUpdatedEvent>(); // 0x14067C220
AgPointer<AgUser> AgUserManager::getUser(long long userId); // 0x14067D6B0
std::map<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > > >::~map<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > > >(); // 0x14067C2F0
std::pair<__int64 const ,AgPointer<AgUser> >::~pair<__int64 const ,AgPointer<AgUser> >(); // 0x14067C330
AgUserAddedEvent::~AgUserAddedEvent(); // 0x14067C470
AgUserEvent::~AgUserEvent(); // 0x14067C490
AgUserManager::~AgUserManager(); // 0x14067C4B0
unsigned long AgUserManager::getUsers(std::vector<AgPointer<AgUser>,std::allocator<AgPointer<AgUser> > > & users); // 0x14067D740
AgUserManager * AgUserManager::createSingleton(); // 0x14067D180
long AgUserManager::onSingletonInit(); // 0x14067D830
long AgUserManager::onSingletonExit(); // 0x14067D7C0
void AgUserManager::update(); // 0x14067DD30
void AgUserManager::_addUser(AgPointer<AgUser> user); // 0x14067CBA0
AgPointer<AgUser> AgUserManager::_getUser(long long userId); // 0x14067CD80
unsigned long AgUserManager::_getUsers(std::vector<AgPointer<AgUser>,std::allocator<AgPointer<AgUser> > > & users); // 0x14067CE10//decompilation failure at 14086A1B2!
std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<__int64 &&>,std::tuple<>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        const std::piecewise_construct_t *<_Val_0>,
        std::tuple<__int64 &&> *<_Val_1>,
        std::tuple<> *<_Val_2>)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v5; // r9

  v5 = std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buynode0(this);
  *(_WORD *)&v5->_Color = 0;
  if ( v5 != (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)-32i64 )
  {
    v5->_Myval.first = *<_Val_1>->_Myfirst._Val;
    v5->_Myval.second.m_ref = 0i64;
    v5->_Myval.second.m_ptr = 0i64;
  }
  return v5;
}

void __fastcall std::_Destroy_range<std::allocator<AgUserAddedEvent>,AgUserAddedEvent *>(
        AgUserAddedEvent *_First,
        AgUserAddedEvent *_Last,
        std::_Wrap_alloc<std::allocator<AgUserAddedEvent> > *_Al)
{
  AgUserAddedEvent *v4; // rdi

  if ( _First != _Last )
  {
    v4 = _First;
    do
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)v4++);
    while ( v4 != _Last );
  }
}

void __fastcall std::_Destroy_range<std::allocator<AgPointer<AgThread>>,AgPointer<AgThread> *>(
        AgPointer<AgUser> *_First,
        AgPointer<AgUser> *_Last,
        std::_Wrap_alloc<std::allocator<AgPointer<AgUser> > > *_Al)
{
  AgPointer<AgUser> *v4; // rbx

  if ( _First != _Last )
  {
    v4 = _First;
    do
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)v4++);
    while ( v4 != _Last );
  }
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *__fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *result,
        bool _Addleft,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Wherenode,
        std::pair<__int64 const ,AgPointer<AgUser> > *_Val,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Node)
{
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v10; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v12; // r8
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Left; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v15; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v16; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v17; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v18; // r8
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v19; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v20; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v21; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v22; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v23; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v24; // rcx

  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize >= 0x492492492492491i64 )
  {
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&_Node->_Myval.second);
    operator delete(_Node);
    std::_Xlength_error("map/set<T> too long");
  }
  this->_Mypair._Myval2._Myval2._Mysize = Mysize + 1;
  _Node->_Parent = _Wherenode;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Node;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
LABEL_9:
    Myhead->_Right = _Node;
    goto LABEL_10;
  }
  if ( !_Addleft )
  {
    _Wherenode->_Right = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
    if ( _Wherenode != this->_Mypair._Myval2._Myval2._Myhead->_Right )
      goto LABEL_10;
    goto LABEL_9;
  }
  _Wherenode->_Left = _Node;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
LABEL_10:
  v10 = _Node;
  while ( !v10->_Parent->_Color )
  {
    Parent = v10->_Parent;
    v12 = Parent->_Parent;
    Left = v12->_Left;
    if ( Parent == v12->_Left )
    {
      Right = v12->_Right;
      if ( Right->_Color )
      {
        if ( v10 == Parent->_Right )
        {
          v10 = v10->_Parent;
          v15 = Parent->_Right;
          Parent->_Right = v15->_Left;
          if ( !v15->_Left->_Isnil )
            v15->_Left->_Parent = Parent;
          v15->_Parent = Parent->_Parent;
          if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v15;
          }
          else
          {
            v16 = Parent->_Parent;
            if ( v10 == v16->_Left )
              v16->_Left = v15;
            else
              v16->_Right = v15;
          }
          v15->_Left = v10;
          v10->_Parent = v15;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Left;
        v17->_Left = v17->_Left->_Right;
        v19 = v18->_Right;
        if ( !v19->_Isnil )
          v19->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v20 = v17->_Parent;
          if ( v17 == v20->_Right )
            v20->_Right = v18;
          else
            v20->_Left = v18;
        }
        v18->_Right = v17;
LABEL_50:
        v17->_Parent = v18;
        continue;
      }
      Parent->_Color = 1;
      Right->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
    else
    {
      if ( Left->_Color )
      {
        if ( v10 == Parent->_Left )
        {
          v10 = v10->_Parent;
          v21 = Parent->_Left;
          Parent->_Left = Parent->_Left->_Right;
          v22 = v21->_Right;
          if ( !v22->_Isnil )
            v22->_Parent = v10;
          v21->_Parent = v10->_Parent;
          if ( v10 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
          }
          else
          {
            v23 = v10->_Parent;
            if ( v10 == v23->_Right )
              v23->_Right = v21;
            else
              v23->_Left = v21;
          }
          v21->_Right = v10;
          v10->_Parent = v21;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Right;
        v17->_Right = v18->_Left;
        if ( !v18->_Left->_Isnil )
          v18->_Left->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v24 = v17->_Parent;
          if ( v17 == v24->_Left )
            v24->_Left = v18;
          else
            v24->_Right = v18;
        }
        v18->_Left = v17;
        goto LABEL_50;
      }
      Parent->_Color = 1;
      Left->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
  }
  this->_Mypair._Myval2._Myval2._Myhead->_Parent->_Color = 1;
  result->_Ptr = _Node;
  return result;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *__fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_hint<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > _Where,
        std::pair<__int64 const ,AgPointer<AgUser> > *_Val,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Newnode)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // r9
  __int64 first; // r12
  bool v12; // cc
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Ptr; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Left; // r9
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v16; // rbx
  std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > v17; // [rsp+30h] [rbp-48h] BYREF
  __int64 v18; // [rsp+38h] [rbp-40h]
  std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >,bool> resulta; // [rsp+40h] [rbp-38h] BYREF

  v18 = -2i64;
  v17._Ptr = 0i64;
  if ( !this->_Mypair._Myval2._Myval2._Mysize )
  {
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
      this,
      result,
      1,
      this->_Mypair._Myval2._Myval2._Myhead,
      _Val,
      _Newnode);
    return result;
  }
  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  if ( _Where._Ptr == this->_Mypair._Myval2._Myval2._Myhead->_Left )
  {
    if ( _Val->first < _Where._Ptr->_Myval.first )
    {
      std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
        this,
        result,
        1,
        _Where._Ptr,
        _Val,
        _Newnode);
      return result;
    }
    goto LABEL_33;
  }
  if ( _Where._Ptr == Myhead )
  {
    Right = Myhead->_Right;
    if ( Right->_Myval.first < _Val->first )
    {
      std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
        this,
        result,
        0,
        Right,
        _Val,
        _Newnode);
      return result;
    }
    goto LABEL_33;
  }
  first = _Val->first;
  v12 = _Where._Ptr->_Myval.first < _Val->first;
  if ( _Where._Ptr->_Myval.first > _Val->first )
  {
    Ptr = _Where._Ptr;
    v17._Ptr = _Where._Ptr;
    if ( _Where._Ptr->_Isnil )
    {
      Left = _Where._Ptr->_Right;
    }
    else
    {
      Left = _Where._Ptr->_Left;
      if ( _Where._Ptr->_Left->_Isnil )
      {
        while ( 1 )
        {
          Parent = Ptr->_Parent;
          if ( Parent->_Isnil || Ptr != Parent->_Left )
            break;
          Ptr = Ptr->_Parent;
          v17._Ptr = Parent;
        }
        Left = Ptr;
        if ( !Ptr->_Isnil )
          Left = Ptr->_Parent;
      }
      else
      {
        while ( !Left->_Right->_Isnil )
          Left = Left->_Right;
      }
    }
    v17._Ptr = Left;
    if ( Left->_Myval.first < first )
    {
      if ( Left->_Right->_Isnil )
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
          this,
          result,
          0,
          Left,
          _Val,
          _Newnode);
      else
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
          this,
          result,
          1,
          _Where._Ptr,
          _Val,
          _Newnode);
      return result;
    }
    v12 = _Where._Ptr->_Myval.first < first;
  }
  if ( !v12
    || (v17._Ptr = _Where._Ptr,
        v16 = this->_Mypair._Myval2._Myval2._Myhead,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgStringKey const,AgPointer<AgLeaderboard>>>>>::operator++(&v17)->_Ptr != v16)
    && first >= v17._Ptr->_Myval.first )
  {
LABEL_33:
    result->_Ptr = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_nohint<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
                                                                                             this,
                                                                                             &resulta,
                                                                                             0,
                                                                                             _Val,
                                                                                             _Newnode)->first;
    return result;
  }
  if ( _Where._Ptr->_Right->_Isnil )
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
      this,
      result,
      0,
      _Where._Ptr,
      _Val,
      _Newnode);
  else
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
      this,
      result,
      1,
      v17._Ptr,
      _Val,
      _Newnode);
  return result;
}

std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >,bool> *__fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_nohint<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >,bool> *result,
        bool _Leftish,
        std::pair<__int64 const ,AgPointer<AgUser> > *_Val,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Newnode)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // r9
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // r10
  bool v10; // r8
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rbx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v13; // rax
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > resulta; // [rsp+40h] [rbp-18h] BYREF

  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  Parent = this->_Mypair._Myval2._Myval2._Myhead->_Parent;
  v10 = 1;
  while ( !Parent->_Isnil )
  {
    Myhead = Parent;
    if ( _Leftish )
      v10 = Parent->_Myval.first >= _Val->first;
    else
      v10 = _Val->first < Parent->_Myval.first;
    if ( v10 )
      Parent = Parent->_Left;
    else
      Parent = Parent->_Right;
  }
  Right = Myhead;
  if ( v10 )
  {
    if ( Myhead == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    {
      result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(this, &resulta, 1, Myhead, _Val, _Newnode)->_Ptr;
      result->second = 1;
      return result;
    }
    if ( Myhead->_Isnil )
    {
      Right = Myhead->_Right;
    }
    else if ( Myhead->_Left->_Isnil )
    {
      while ( 1 )
      {
        v13 = Right->_Parent;
        if ( v13->_Isnil || Right != v13->_Left )
          break;
        Right = Right->_Parent;
      }
      if ( !Right->_Isnil )
        Right = Right->_Parent;
    }
    else
    {
      for ( Right = Myhead->_Left; !Right->_Right->_Isnil; Right = Right->_Right )
        ;
    }
  }
  if ( Right->_Myval.first >= _Val->first )
  {
    resulta._Ptr = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)&_Newnode->_Myval;
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&_Newnode->_Myval.second);
    operator delete(_Newnode);
    result->first._Ptr = Right;
    result->second = 0;
  }
  else
  {
    result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_at<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(this, &resulta, v10, Myhead, _Val, _Newnode)->_Ptr;
    result->second = 1;
  }
  return result;
}

AgUserAddedEvent *__fastcall std::_Uninitialized_move_al_unchecked1<AgUserAddedEvent *,AgUserAddedEvent *,std::allocator<AgUserAddedEvent>>(
        AgUserAddedEvent *_First,
        AgUserAddedEvent *_Last,
        AgUserAddedEvent *_Dest,
        std::_Wrap_alloc<std::allocator<AgUserAddedEvent> > *_Al)
{
  while ( _First != _Last )
  {
    if ( _Dest )
    {
      *_Dest = *_First;
      _First->user.m_ref = 0i64;
      _First->user.m_ptr = 0i64;
    }
    ++_Dest;
    ++_First;
  }
  return _Dest;
}

AgPointer<AgUser> *__fastcall std::_Uninitialized_move_al_unchecked1<AgPointer<AgUser> *,AgPointer<AgUser> *,std::allocator<AgPointer<AgUser>>>(
        AgPointer<AgUser> *_First,
        AgPointer<AgUser> *_Last,
        AgPointer<AgUser> *_Dest,
        std::_Wrap_alloc<std::allocator<AgPointer<AgUser> > > *_Al)
{
  while ( _First != _Last )
  {
    if ( _Dest )
    {
      *_Dest = *_First;
      _First->m_ref = 0i64;
      _First->m_ptr = 0i64;
    }
    ++_Dest;
    ++_First;
  }
  return _Dest;
}

void __fastcall AgUserManager::AgUserManager(AgUserManager *this)
{
  this->__vftable = (AgUserManager_vtbl *)&AgSingleton<AgUserManager>::`vftable';
  this->__vftable = (AgUserManager_vtbl *)&AgUserManager::`vftable';
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  this->m_users._Mypair._Myval2._Myval2._Myhead = 0i64;
  this->m_users._Mypair._Myval2._Myval2._Mysize = 0i64;
  this->m_users._Mypair._Myval2._Myval2._Myhead = std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buyheadnode(&this->m_users);
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserAdded);
  this->UserAdded.m_bindings._Mypair._Myval2._Myfirst = 0i64;
  this->UserAdded.m_bindings._Mypair._Myval2._Mylast = 0i64;
  this->UserAdded.m_bindings._Mypair._Myval2._Myend = 0i64;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserAdded.m_queueMutex);
  this->UserAdded.m_eventQueue._Mypair._Myval2._Myfirst = 0i64;
  this->UserAdded.m_eventQueue._Mypair._Myval2._Mylast = 0i64;
  this->UserAdded.m_eventQueue._Mypair._Myval2._Myend = 0i64;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserRemoved);
  this->UserRemoved.m_bindings._Mypair._Myval2._Myfirst = 0i64;
  this->UserRemoved.m_bindings._Mypair._Myval2._Mylast = 0i64;
  this->UserRemoved.m_bindings._Mypair._Myval2._Myend = 0i64;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserRemoved.m_queueMutex);
  this->UserRemoved.m_eventQueue._Mypair._Myval2._Myfirst = 0i64;
  this->UserRemoved.m_eventQueue._Mypair._Myval2._Mylast = 0i64;
  this->UserRemoved.m_eventQueue._Mypair._Myval2._Myend = 0i64;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserUpdated);
  this->UserUpdated.m_bindings._Mypair._Myval2._Myfirst = 0i64;
  this->UserUpdated.m_bindings._Mypair._Myval2._Mylast = 0i64;
  this->UserUpdated.m_bindings._Mypair._Myval2._Myend = 0i64;
  InitializeCriticalSection((LPCRITICAL_SECTION)&this->UserUpdated.m_queueMutex);
  this->UserUpdated.m_eventQueue._Mypair._Myval2._Myfirst = 0i64;
  this->UserUpdated.m_eventQueue._Mypair._Myval2._Mylast = 0i64;
  this->UserUpdated.m_eventQueue._Mypair._Myval2._Myend = 0i64;
}

void __fastcall AgAsyncEventDispatcher<AgUserAddedEvent>::~AgAsyncEventDispatcher<AgUserAddedEvent>(
        AgAsyncEventDispatcher<AgUserAddedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  std::vector<AgUserAddedEvent>::_Tidy(&this->m_eventQueue);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      ((char *)this->m_bindings._Mypair._Myval2._Myend - (char *)Myfirst) >> 4);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgAsyncEventDispatcher<AgUserRemovedEvent>::~AgAsyncEventDispatcher<AgUserRemovedEvent>(
        AgAsyncEventDispatcher<AgUserRemovedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  std::vector<AgUserRemovedEvent>::_Tidy(&this->m_eventQueue);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      ((char *)this->m_bindings._Mypair._Myval2._Myend - (char *)Myfirst) >> 4);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgAsyncEventDispatcher<AgUserUpdatedEvent>::~AgAsyncEventDispatcher<AgUserUpdatedEvent>(
        AgAsyncEventDispatcher<AgUserUpdatedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  std::vector<AgUserUpdatedEvent>::_Tidy(&this->m_eventQueue);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      this->m_bindings._Mypair._Myval2._Myend - Myfirst);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgEventDispatcherBase<AgUserAddedEvent>::~AgEventDispatcherBase<AgUserAddedEvent>(
        AgEventDispatcherBase<AgUserAddedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      ((char *)this->m_bindings._Mypair._Myval2._Myend - (char *)Myfirst) >> 4);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgEventDispatcherBase<AgUserRemovedEvent>::~AgEventDispatcherBase<AgUserRemovedEvent>(
        AgEventDispatcherBase<AgUserRemovedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      ((char *)this->m_bindings._Mypair._Myval2._Myend - (char *)Myfirst) >> 4);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgEventDispatcherBase<AgUserUpdatedEvent>::~AgEventDispatcherBase<AgUserUpdatedEvent>(
        AgEventDispatcherBase<AgUserUpdatedEvent> *this)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rdx

  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  if ( Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&this->m_bindings,
      Myfirst,
      this->m_bindings._Mypair._Myval2._Myend - Myfirst);
    this->m_bindings._Mypair._Myval2._Myfirst = 0i64;
    this->m_bindings._Mypair._Myval2._Mylast = 0i64;
    this->m_bindings._Mypair._Myval2._Myend = 0i64;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgSingleton<AgUserManager>::~AgSingleton<AgUserManager>(AgSingleton<AgUserManager> *this)
{
  this->__vftable = (AgSingleton<AgUserManager>_vtbl *)&AgSingleton<AgUserManager>::`vftable';
}

void __fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::~_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::~_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this)
{
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::map<__int64,AgPointer<AgUser>>::~map<__int64,AgPointer<AgUser>>(
        std::map<__int64,AgPointer<AgUser>> *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::pair<__int64 const,AgPointer<AgUser>>::~pair<__int64 const,AgPointer<AgUser>>(
        std::pair<__int64 const ,AgPointer<AgUser> > *this)
{
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->second);
}

void __fastcall std::vector<AgUserAddedEvent>::~vector<AgUserAddedEvent>(std::vector<AgUserAddedEvent> *this)
{
  std::vector<AgUserAddedEvent>::_Tidy(this);
}

void __fastcall std::vector<AgUserRemovedEvent>::~vector<AgUserRemovedEvent>(std::vector<AgUserRemovedEvent> *this)
{
  std::vector<AgUserRemovedEvent>::_Tidy(this);
}

void __fastcall std::vector<AgUserUpdatedEvent>::~vector<AgUserUpdatedEvent>(std::vector<AgUserUpdatedEvent> *this)
{
  std::vector<AgUserUpdatedEvent>::_Tidy(this);
}

void __fastcall std::vector<AgDelegate1<AgUserAddedEvent const &,void>>::~vector<AgDelegate1<AgUserAddedEvent const &,void>>(
        std::vector<AgDelegate1<AgUserAddedEvent const &,void>> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall std::vector<AgDelegate1<AgUserRemovedEvent const &,void>>::~vector<AgDelegate1<AgUserRemovedEvent const &,void>>(
        std::vector<AgDelegate1<AgUserRemovedEvent const &,void>> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall std::vector<AgDelegate1<AgUserUpdatedEvent const &,void>>::~vector<AgDelegate1<AgUserUpdatedEvent const &,void>>(
        std::vector<AgDelegate1<AgUserUpdatedEvent const &,void>> *this)
{
  if ( this->_Mypair._Myval2._Myfirst )
  {
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgUserAddedEvent::~AgUserAddedEvent(AgUserAddedEvent *this)
{
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)this);
}

void __fastcall AgUserEvent::~AgUserEvent(AgUserEvent *this)
{
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)this);
}

void __fastcall AgUserManager::~AgUserManager(AgUserManager *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > result; // [rsp+50h] [rbp+18h] BYREF

  AgAsyncEventDispatcher<AgUserUpdatedEvent>::~AgAsyncEventDispatcher<AgUserUpdatedEvent>(&this->UserUpdated);
  AgAsyncEventDispatcher<AgUserRemovedEvent>::~AgAsyncEventDispatcher<AgUserRemovedEvent>(&this->UserRemoved);
  AgAsyncEventDispatcher<AgUserAddedEvent>::~AgAsyncEventDispatcher<AgUserAddedEvent>(&this->UserAdded);
  std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
    &this->m_users,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->m_users._Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)this->m_users._Mypair._Myval2._Myval2._Myhead);
  operator delete(this->m_users._Mypair._Myval2._Myval2._Myhead);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  this->__vftable = (AgUserManager_vtbl *)&AgSingleton<AgUserManager>::`vftable';
}

std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *__fastcall std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgStringKey const,AgPointer<AgLeaderboard>>>>>::operator++(
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *this)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Ptr; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *j; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *i; // rax

  Ptr = this->_Ptr;
  if ( this->_Ptr->_Isnil )
    return this;
  Right = Ptr->_Right;
  if ( Right->_Isnil )
  {
    for ( i = Ptr->_Parent; !i->_Isnil; i = i->_Parent )
    {
      if ( this->_Ptr != i->_Right )
        break;
      this->_Ptr = i;
    }
    this->_Ptr = i;
    return this;
  }
  for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
    Right = j;
  this->_Ptr = Right;
  return this;
}

std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buyheadnode(
        std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *result; // rax

  result = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)operator new(0x38ui64);
  if ( !result )
    invalid_parameter_noinfo_noreturn();
  result->_Left = result;
  if ( result != (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)-8i64 )
    result->_Parent = result;
  if ( result != (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)-16i64 )
    result->_Right = result;
  *(_WORD *)&result->_Color = 257;
  return result;
}

std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> **__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buynode0(
        std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> **v2; // rdx

  v2 = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> **)operator new(0x38ui64);
  if ( !v2 )
    invalid_parameter_noinfo_noreturn();
  *v2 = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> **)-8i64 )
    v2[1] = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> **)-16i64 )
    v2[2] = this->_Mypair._Myval2._Myval2._Myhead;
  return v2;
}

void __fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Destroy_if_not_nil(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Newnode)
{
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&_Newnode->_Myval.second);
  operator delete(_Newnode);
}

void __fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Erase(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Rootnode)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v2; // rdi
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *i; // rbx

  v2 = _Rootnode;
  for ( i = _Rootnode; !i->_Isnil; v2 = i )
  {
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Erase(
      this,
      i->_Right);
    i = i->_Left;
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&v2->_Myval.second);
    operator delete(v2);
  }
}

void __fastcall std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
        std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *this,
        std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *_Wherenode)
{
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Right; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Parent; // rax

  Right = _Wherenode->_Right;
  _Wherenode->_Right = Right->_Left;
  if ( !Right->_Left->_Isnil )
    Right->_Left->_Parent = _Wherenode;
  Right->_Parent = _Wherenode->_Parent;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Right;
    Right->_Left = _Wherenode;
    _Wherenode->_Parent = Right;
  }
  else
  {
    Parent = _Wherenode->_Parent;
    if ( _Wherenode == Parent->_Left )
      Parent->_Left = Right;
    else
      Parent->_Right = Right;
    Right->_Left = _Wherenode;
    _Wherenode->_Parent = Right;
  }
}

void __fastcall std::vector<AgUserAddedEvent>::_Reallocate(
        std::vector<AgUserAddedEvent> *this,
        unsigned __int64 _Count)
{
  AgUserAddedEvent *v4; // r12
  AgUserAddedEvent *Mylast; // r14
  AgUserAddedEvent *Myfirst; // rbx
  signed __int64 v7; // rsi

  v4 = (AgUserAddedEvent *)std::allocator<AgDelegate1<AgShutdownEvent const &,void>>::allocate(
                             (std::allocator<AgDelegate1<AgShutdownEvent const &,void> > *)this,
                             _Count);
  std::_Uninitialized_move_al_unchecked1<AgUserAddedEvent *,AgUserAddedEvent *,std::allocator<AgUserAddedEvent>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    (std::_Wrap_alloc<std::allocator<AgUserAddedEvent> > *)this);
  Mylast = this->_Mypair._Myval2._Mylast;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v7 = (char *)Mylast - (char *)this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( ; Myfirst != Mylast; ++Myfirst )
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = (AgUserAddedEvent *)((char *)v4 + (v7 & 0xFFFFFFFFFFFFFFF0ui64));
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<AgPointer<AgUser>>::_Reallocate(
        std::vector<AgPointer<AgUser>> *this,
        unsigned __int64 _Count)
{
  AgPointer<AgUser> *v4; // r12
  AgPointer<AgUser> *Mylast; // r14
  AgPointer<AgUser> *Myfirst; // rbx
  signed __int64 v7; // rsi

  v4 = (AgPointer<AgUser> *)std::allocator<AgDelegate1<AgShutdownEvent const &,void>>::allocate(
                              (std::allocator<AgDelegate1<AgShutdownEvent const &,void> > *)this,
                              _Count);
  std::_Uninitialized_move_al_unchecked1<AgPointer<AgUser> *,AgPointer<AgUser> *,std::allocator<AgPointer<AgUser>>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    (std::_Wrap_alloc<std::allocator<AgPointer<AgUser> > > *)this);
  Mylast = this->_Mypair._Myval2._Mylast;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v7 = (char *)Mylast - (char *)this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( ; Myfirst != Mylast; ++Myfirst )
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = (AgPointer<AgUser> *)((char *)v4 + (v7 & 0xFFFFFFFFFFFFFFF0ui64));
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<AgUserAddedEvent>::_Reserve(std::vector<AgUserAddedEvent> *this, unsigned __int64 _Count)
{
  AgUserAddedEvent *Myend; // r10
  AgUserAddedEvent *Mylast; // r8
  AgUserAddedEvent *Myfirst; // rcx
  __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( Myend - Mylast < _Count )
  {
    Myfirst = this->_Mypair._Myval2._Myfirst;
    v6 = Mylast - Myfirst;
    if ( 0xFFFFFFFFFFFFFFFi64 - v6 < _Count )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + _Count;
    v8 = Myend - Myfirst;
    v9 = 0i64;
    if ( 0xFFFFFFFFFFFFFFFi64 - (v8 >> 1) >= v8 )
      v9 = v8 + (v8 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgUserAddedEvent>::_Reallocate(this, v7);
  }
}

void __fastcall std::vector<AgPointer<AgUser>>::_Reserve(std::vector<AgPointer<AgUser>> *this, unsigned __int64 _Count)
{
  AgPointer<AgUser> *Myend; // r10
  AgPointer<AgUser> *Mylast; // r8
  AgPointer<AgUser> *Myfirst; // rcx
  __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( Myend - Mylast < _Count )
  {
    Myfirst = this->_Mypair._Myval2._Myfirst;
    v6 = Mylast - Myfirst;
    if ( 0xFFFFFFFFFFFFFFFi64 - v6 < _Count )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + _Count;
    v8 = Myend - Myfirst;
    v9 = 0i64;
    if ( 0xFFFFFFFFFFFFFFFi64 - (v8 >> 1) >= v8 )
      v9 = v8 + (v8 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgPointer<AgUser>>::_Reallocate(this, v7);
  }
}

void __fastcall std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
        std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *this,
        std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *_Wherenode)
{
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Left; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Right; // rax
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Parent; // rax

  Left = _Wherenode->_Left;
  _Wherenode->_Left = _Wherenode->_Left->_Right;
  Right = Left->_Right;
  if ( !Right->_Isnil )
    Right->_Parent = _Wherenode;
  Left->_Parent = _Wherenode->_Parent;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Left;
    Left->_Right = _Wherenode;
    _Wherenode->_Parent = Left;
  }
  else
  {
    Parent = _Wherenode->_Parent;
    if ( _Wherenode == Parent->_Right )
      Parent->_Right = Left;
    else
      Parent->_Left = Left;
    Left->_Right = _Wherenode;
    _Wherenode->_Parent = Left;
  }
}

void __fastcall std::vector<AgUserAddedEvent>::_Tidy(std::vector<AgUserAddedEvent> *this)
{
  AgUserAddedEvent *Myfirst; // rbx
  AgUserAddedEvent *i; // rdi

  Myfirst = this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( i = this->_Mypair._Myval2._Mylast; Myfirst != i; ++Myfirst )
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall std::vector<AgUserRemovedEvent>::_Tidy(std::vector<AgUserRemovedEvent> *this)
{
  AgUserRemovedEvent *Myfirst; // rbx
  AgUserRemovedEvent *i; // rdi

  Myfirst = this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( i = this->_Mypair._Myval2._Mylast; Myfirst != i; ++Myfirst )
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)this,
      (AgDelegate1<AgUserUpdatedEvent const &,void> *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall std::vector<AgUserUpdatedEvent>::_Tidy(std::vector<AgUserUpdatedEvent> *this)
{
  AgUserUpdatedEvent *Myfirst; // rbx
  AgUserUpdatedEvent *i; // rdi

  Myfirst = this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( i = this->_Mypair._Myval2._Mylast; Myfirst != i; ++Myfirst )
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)Myfirst);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)this,
      (AgJsonNode *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgUserManager::_addUser(AgUserManager *this, AgPointer<AgUser> *user)
{
  __int64 m_id; // r9
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // r8
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Ptr; // rbx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *_Newnode; // rax
  std::vector<AgUserAddedEvent> *p_m_eventQueue; // rbx
  AgUserAddedEvent *Mylast; // rcx
  signed __int64 v11; // rdi
  AgUserAddedEvent *v12; // rcx
  const AgPointer<AgPlayer> *v13; // rdi
  AgUserAddedEvent *v14; // rcx
  AgPointer<AgUser> v15; // [rsp+38h] [rbp-50h] BYREF
  int v16; // [rsp+48h] [rbp-40h]
  AgMutex *p_m_queueMutex; // [rsp+50h] [rbp-38h]
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > result; // [rsp+90h] [rbp+8h] BYREF
  AgPointer<AgUser> *v19; // [rsp+98h] [rbp+10h]
  __int64 v20; // [rsp+A0h] [rbp+18h] BYREF
  std::tuple<__int64 &&> v21; // [rsp+A8h] [rbp+20h] BYREF

  v19 = user;
  m_id = user->m_ptr->m_id;
  v20 = m_id;
  Myhead = this->m_users._Mypair._Myval2._Myval2._Myhead;
  Parent = Myhead->_Parent;
  Ptr = Myhead;
  while ( !Parent->_Isnil )
  {
    if ( Parent->_Myval.first >= m_id )
    {
      Ptr = Parent;
      Parent = Parent->_Left;
    }
    else
    {
      Parent = Parent->_Right;
    }
  }
  if ( Ptr == Myhead || m_id < Ptr->_Myval.first )
  {
    v21._Myfirst._Val = &v20;
    _Newnode = std::_Tree_comp_alloc<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<__int64 &&>,std::tuple<>>(
                 &this->m_users,
                 &std::piecewise_construct_8,
                 &v21,
                 (std::tuple<> *)&result);
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Insert_hint<std::pair<__int64 const,AgPointer<AgUser>> &,std::_Tree_node<std::pair<__int64 const,AgPointer<AgUser>>,void *> *>(
      &this->m_users,
      &result,
      (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)Ptr,
      &_Newnode->_Myval,
      _Newnode);
    Ptr = result._Ptr;
  }
  AgPointer<AgUser>::operator=(&Ptr->_Myval.second, user);
  v15 = 0i64;
  AgPointer<AgUser>::operator=(&v15, user);
  v16 = 0;
  p_m_queueMutex = &this->UserAdded.m_queueMutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->UserAdded.m_queueMutex);
  v16 = 1;
  p_m_eventQueue = &this->UserAdded.m_eventQueue;
  Mylast = this->UserAdded.m_eventQueue._Mypair._Myval2._Mylast;
  if ( &v15 >= (AgPointer<AgUser> *)Mylast || p_m_eventQueue->_Mypair._Myval2._Myfirst > (AgUserAddedEvent *)&v15 )
  {
    if ( Mylast == this->UserAdded.m_eventQueue._Mypair._Myval2._Myend )
      std::vector<AgUserAddedEvent>::_Reserve(&this->UserAdded.m_eventQueue, 1ui64);
    v14 = this->UserAdded.m_eventQueue._Mypair._Myval2._Mylast;
    result._Ptr = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)v14;
    v20 = (__int64)v14;
    if ( v14 )
      AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        (AgPointer<AgPlayer> *)v14,
        (const AgPointer<AgPlayer> *)&v15);
  }
  else
  {
    v11 = (char *)&v15 - (char *)p_m_eventQueue->_Mypair._Myval2._Myfirst;
    if ( Mylast == this->UserAdded.m_eventQueue._Mypair._Myval2._Myend )
      std::vector<AgUserAddedEvent>::_Reserve(&this->UserAdded.m_eventQueue, 1ui64);
    v12 = this->UserAdded.m_eventQueue._Mypair._Myval2._Mylast;
    result._Ptr = (std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *)v12;
    v13 = (const AgPointer<AgPlayer> *)((char *)p_m_eventQueue->_Mypair._Myval2._Myfirst + (v11 & 0xFFFFFFFFFFFFFFF0ui64));
    v20 = (__int64)v12;
    if ( v12 )
      AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>((AgPointer<AgPlayer> *)v12, v13);
  }
  ++this->UserAdded.m_eventQueue._Mypair._Myval2._Mylast;
  LeaveCriticalSection((LPCRITICAL_SECTION)&this->UserAdded.m_queueMutex);
  v16 = 0;
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&v15);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)user);
}

AgPointer<AgUser> *__fastcall AgUserManager::_getUser(AgUserManager *this, AgPointer<AgUser> *result, __int64 userId)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // r9
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v6; // rdx

  Myhead = this->m_users._Mypair._Myval2._Myval2._Myhead;
  Parent = Myhead->_Parent;
  v6 = Myhead;
  while ( !Parent->_Isnil )
  {
    if ( Parent->_Myval.first >= userId )
    {
      v6 = Parent;
      Parent = Parent->_Left;
    }
    else
    {
      Parent = Parent->_Right;
    }
  }
  if ( v6 == Myhead || userId < v6->_Myval.first )
    v6 = this->m_users._Mypair._Myval2._Myval2._Myhead;
  if ( v6 == Myhead )
  {
    result->m_ref = 0i64;
    result->m_ptr = 0i64;
  }
  else
  {
    AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
      (AgPointer<AgPlayer> *)result,
      (const AgPointer<AgPlayer> *)&v6->_Myval.second);
  }
  return result;
}

__int64 __fastcall AgUserManager::_getUsers(AgUserManager *this, std::vector<AgPointer<AgUser>> *users)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Left; // rbx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *j; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *i; // rax

  Myhead = this->m_users._Mypair._Myval2._Myval2._Myhead;
  Left = Myhead->_Left;
  if ( Myhead->_Left == Myhead )
    return LODWORD(this->m_users._Mypair._Myval2._Myval2._Mysize);
  do
  {
    std::vector<AgPointer<AgUser>>::push_back(users, &Left->_Myval.second);
    if ( !Left->_Isnil )
    {
      Right = Left->_Right;
      if ( Right->_Isnil )
      {
        for ( i = Left->_Parent; !i->_Isnil; i = i->_Parent )
        {
          if ( Left != i->_Right )
            break;
          Left = i;
        }
        Left = i;
      }
      else
      {
        Left = Left->_Right;
        for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
          Left = j;
      }
    }
  }
  while ( Left != this->m_users._Mypair._Myval2._Myval2._Myhead );
  return LODWORD(this->m_users._Mypair._Myval2._Myval2._Mysize);
}

AgDelegate1<AgShutdownEvent const &,void> *__fastcall std::allocator<AgDelegate1<AgShutdownEvent const &,void>>::allocate(
        std::allocator<AgDelegate1<AgShutdownEvent const &,void> > *this,
        unsigned __int64 _Count)
{
  AgDelegate1<AgShutdownEvent const &,void> *result; // rax
  unsigned __int64 v3; // rdx
  void (__fastcall *v4)(detail::GenericClass *); // rax
  void (__fastcall *v5)(detail::GenericClass *); // rcx

  if ( !_Count )
    return 0i64;
  if ( _Count > 0xFFFFFFFFFFFFFFFi64 )
    std::_Xbad_alloc();
  v3 = 16 * _Count;
  if ( v3 < 0x1000 )
  {
    result = (AgDelegate1<AgShutdownEvent const &,void> *)operator new(v3);
    if ( !result )
      invalid_parameter_noinfo_noreturn();
  }
  else
  {
    if ( v3 + 39 <= v3 )
      std::_Xbad_alloc();
    v4 = (void (__fastcall *)(detail::GenericClass *))operator new(v3 + 39);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    result = (AgDelegate1<AgShutdownEvent const &,void> *)(((unsigned __int64)v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    result[-1].m_Closure.m_pFunction = v5;
  }
  return result;
}

void __fastcall AgEventDispatcherBase<AgUserAddedEvent>::call(
        AgEventDispatcherBase<AgUserAddedEvent> *this,
        const AgUserAddedEvent *e)
{
  AgDelegate1<AgUserAddedEvent const &,void> *Myfirst; // rbx
  void (__fastcall *m_pFunction)(detail::GenericClass *); // rbp
  detail::GenericClass *m_pthis; // r14

  EnterCriticalSection((LPCRITICAL_SECTION)this);
  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  while ( Myfirst != this->m_bindings._Mypair._Myval2._Mylast )
  {
    m_pFunction = Myfirst->m_Closure.m_pFunction;
    m_pthis = Myfirst->m_Closure.m_pthis;
    ++Myfirst;
    LeaveCriticalSection((LPCRITICAL_SECTION)this);
    ((void (__fastcall *)(detail::GenericClass *, const AgUserAddedEvent *))m_pFunction)(m_pthis, e);
    EnterCriticalSection((LPCRITICAL_SECTION)this);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgEventDispatcherBase<AgUserRemovedEvent>::call(
        AgEventDispatcherBase<AgUserRemovedEvent> *this,
        const AgUserRemovedEvent *e)
{
  AgDelegate1<AgUserRemovedEvent const &,void> *Myfirst; // rbx
  void (__fastcall *m_pFunction)(detail::GenericClass *); // rbp
  detail::GenericClass *m_pthis; // r14

  EnterCriticalSection((LPCRITICAL_SECTION)this);
  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  while ( Myfirst != this->m_bindings._Mypair._Myval2._Mylast )
  {
    m_pFunction = Myfirst->m_Closure.m_pFunction;
    m_pthis = Myfirst->m_Closure.m_pthis;
    ++Myfirst;
    LeaveCriticalSection((LPCRITICAL_SECTION)this);
    ((void (__fastcall *)(detail::GenericClass *, const AgUserRemovedEvent *))m_pFunction)(m_pthis, e);
    EnterCriticalSection((LPCRITICAL_SECTION)this);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgEventDispatcherBase<AgUserUpdatedEvent>::call(
        AgEventDispatcherBase<AgUserUpdatedEvent> *this,
        const AgUserUpdatedEvent *e)
{
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rbx
  void (__fastcall *m_pFunction)(detail::GenericClass *); // rbp
  detail::GenericClass *m_pthis; // r14

  EnterCriticalSection((LPCRITICAL_SECTION)this);
  Myfirst = this->m_bindings._Mypair._Myval2._Myfirst;
  while ( Myfirst != this->m_bindings._Mypair._Myval2._Mylast )
  {
    m_pFunction = Myfirst->m_Closure.m_pFunction;
    m_pthis = Myfirst->m_Closure.m_pthis;
    ++Myfirst;
    LeaveCriticalSection((LPCRITICAL_SECTION)this);
    ((void (__fastcall *)(detail::GenericClass *, const AgUserUpdatedEvent *))m_pFunction)(m_pthis, e);
    EnterCriticalSection((LPCRITICAL_SECTION)this);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
}

void __fastcall AgUserManager::createSingleton()
{
  AgDefaultUserManager *v0; // rax

  v0 = (AgDefaultUserManager *)operator new(0x1C0ui64);
  if ( v0 )
    AgDefaultUserManager::AgDefaultUserManager(v0);
}

void __fastcall std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
        std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *this,
        AgDelegate1<AgUserUpdatedEvent const &,void> *_Ptr,
        unsigned __int64 _Count)
{
  void (__fastcall *m_pFunction)(detail::GenericClass *); // rax
  char *v4; // rdx

  if ( _Count > 0xFFFFFFFFFFFFFFFi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 16 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    m_pFunction = _Ptr[-1].m_Closure.m_pFunction;
    if ( (AgDelegate1<AgUserUpdatedEvent const &,void> *)m_pFunction >= _Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)m_pFunction);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = (AgDelegate1<AgUserUpdatedEvent const &,void> *)m_pFunction;
  }
  operator delete(_Ptr);
}

void __fastcall std::allocator<AgJsonNode>::deallocate(
        std::allocator<AgJsonNode> *this,
        AgJsonNode *_Ptr,
        unsigned __int64 _Count)
{
  AgJsonNodeData *m_ptr; // rax
  char *v4; // rdx

  if ( _Count > 0xAAAAAAAAAAAAAAAi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 24 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    m_ptr = _Ptr[-1].m_data.m_ptr;
    if ( m_ptr >= (AgJsonNodeData *)_Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)m_ptr);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = (AgJsonNode *)m_ptr;
  }
  operator delete(_Ptr);
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *__fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > _First,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > _Last)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Myhead; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v7; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Left; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *v9; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v10; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *j; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *i; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > resulta; // [rsp+30h] [rbp+8h] BYREF
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v15; // [rsp+40h] [rbp+18h]
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Ptr; // [rsp+48h] [rbp+20h]

  Ptr = _Last._Ptr;
  v15 = _First._Ptr;
  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  if ( _First._Ptr == this->_Mypair._Myval2._Myval2._Myhead->_Left && _Last._Ptr == Myhead )
  {
    std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::_Erase(
      this,
      Myhead->_Parent);
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Right = this->_Mypair._Myval2._Myval2._Myhead;
    v7 = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Mysize = 0i64;
    Left = v7->_Left;
    v9 = result;
    result->_Ptr = Left;
  }
  else
  {
    if ( _First._Ptr != _Last._Ptr )
    {
      do
      {
        v10 = _First._Ptr;
        if ( !_First._Ptr->_Isnil )
        {
          Right = _First._Ptr->_Right;
          if ( Right->_Isnil )
          {
            for ( i = _First._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
            {
              if ( _First._Ptr != i->_Right )
                break;
              v15 = i;
              _First._Ptr = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
              Right = j;
            v15 = Right;
          }
        }
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
          this,
          &resulta,
          (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > >)v10);
        _First._Ptr = v15;
      }
      while ( v15 != Ptr );
    }
    v9 = result;
    result->_Ptr = _First._Ptr;
  }
  return v9;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *__fastcall std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const,AgPointer<AgUser>>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<__int64,AgPointer<AgUser>,std::less<__int64>,std::allocator<std::pair<__int64 const ,AgPointer<AgUser> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > _Where)
{
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v5; // rsi
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Right; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *j; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *i; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Left; // rdi
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Parent; // rbx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v11; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *k; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v13; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *m; // rax
  std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *v15; // rax
  char Color; // cl
  bool n; // zf
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v18; // rdx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v19; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *v20; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v21; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v22; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v23; // rcx
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v24; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *v25; // rax
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<__int64 const ,AgPointer<AgUser> >,void *> *Ptr; // [rsp+60h] [rbp+18h]

  Ptr = _Where._Ptr;
  v5 = _Where._Ptr;
  if ( !_Where._Ptr->_Isnil )
  {
    Right = _Where._Ptr->_Right;
    if ( Right->_Isnil )
    {
      for ( i = _Where._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
      {
        if ( _Where._Ptr != i->_Right )
          break;
        _Where._Ptr = i;
      }
      _Where._Ptr = i;
      Ptr = i;
    }
    else
    {
      _Where._Ptr = _Where._Ptr->_Right;
      for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
        _Where._Ptr = j;
      Ptr = _Where._Ptr;
    }
  }
  if ( v5->_Left->_Isnil )
  {
    Left = v5->_Right;
  }
  else if ( v5->_Right->_Isnil )
  {
    Left = v5->_Left;
  }
  else
  {
    Left = _Where._Ptr->_Right;
    if ( _Where._Ptr != v5 )
    {
      v5->_Left->_Parent = _Where._Ptr;
      _Where._Ptr->_Left = v5->_Left;
      if ( _Where._Ptr == v5->_Right )
      {
        Parent = _Where._Ptr;
      }
      else
      {
        Parent = _Where._Ptr->_Parent;
        if ( !Left->_Isnil )
          Left->_Parent = Parent;
        Parent->_Left = Left;
        _Where._Ptr->_Right = v5->_Right;
        v5->_Right->_Parent = _Where._Ptr;
      }
      if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
      {
        this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Where._Ptr;
      }
      else
      {
        v15 = (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<__int64 const ,AgPointer<AgUser> > > > > *)v5->_Parent;
        if ( v15->_Ptr == v5 )
          v15->_Ptr = _Where._Ptr;
        else
          v15[2]._Ptr = _Where._Ptr;
      }
      _Where._Ptr->_Parent = v5->_Parent;
      Color = _Where._Ptr->_Color;
      _Where._Ptr->_Color = v5->_Color;
      v5->_Color = Color;
      goto LABEL_45;
    }
  }
  Parent = v5->_Parent;
  if ( !Left->_Isnil )
    Left->_Parent = Parent;
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Left;
  }
  else if ( Parent->_Left == v5 )
  {
    Parent->_Left = Left;
  }
  else
  {
    Parent->_Right = Left;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Left == v5 )
  {
    if ( Left->_Isnil )
    {
      v11 = Parent;
    }
    else
    {
      v11 = Left;
      for ( k = Left->_Left; !k->_Isnil; k = k->_Left )
        v11 = k;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Left = v11;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Right == v5 )
  {
    if ( Left->_Isnil )
    {
      v13 = Parent;
    }
    else
    {
      v13 = Left;
      for ( m = Left->_Right; !m->_Isnil; m = m->_Right )
        v13 = m;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Right = v13;
  }
LABEL_45:
  if ( v5->_Color != 1 )
    goto LABEL_84;
  for ( n = Left == this->_Mypair._Myval2._Myval2._Myhead->_Parent;
        !n;
        n = v18 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    v18 = Parent;
    v19 = Parent;
    if ( Left->_Color != 1 )
      break;
    v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
    if ( Left == Parent->_Left )
    {
      v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v21 = Parent->_Right;
        Parent->_Right = v21->_Left;
        if ( !v21->_Left->_Isnil )
          v21->_Left->_Parent = Parent;
        v21->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
        }
        else
        {
          v22 = Parent->_Parent;
          if ( Parent == v22->_Left )
            v22->_Left = v21;
          else
            v22->_Right = v21;
        }
        v21->_Left = Parent;
        Parent->_Parent = v21;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Left->_Color != 1 || v20->_Right->_Color != 1 )
        {
          if ( v20->_Right->_Color == 1 )
          {
            v20->_Left->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Right->_Color = 1;
          std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
LABEL_75:
        v20->_Color = 0;
      }
    }
    else
    {
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v23 = Parent->_Left;
        Parent->_Left = Parent->_Left->_Right;
        v24 = v23->_Right;
        if ( !v24->_Isnil )
          v24->_Parent = Parent;
        v23->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v23;
        }
        else
        {
          v25 = Parent->_Parent;
          if ( Parent == v25->_Right )
            v25->_Right = v23;
          else
            v25->_Left = v23;
        }
        v23->_Right = Parent;
        Parent->_Parent = v23;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Right->_Color != 1 || v20->_Left->_Color != 1 )
        {
          if ( v20->_Left->_Color == 1 )
          {
            v20->_Right->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Left->_Color = 1;
          std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
        goto LABEL_75;
      }
    }
    Parent = Parent->_Parent;
    Left = v19;
  }
  Left->_Color = 1;
LABEL_84:
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&v5->_Myval.second);
  operator delete(v5);
  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize )
    this->_Mypair._Myval2._Myval2._Mysize = Mysize - 1;
  result->_Ptr = Ptr;
  return result;
}

AgPointer<AgUser> *__fastcall AgUserManager::getUser(AgUserManager *this, AgPointer<AgUser> *result, __int64 userId)
{
  AgMutex *p_m_mutex; // rdi

  p_m_mutex = &this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  AgUserManager::_getUser(this, result, userId);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_mutex);
  return result;
}

__int64 __fastcall AgUserManager::getUsers(AgUserManager *this, std::vector<AgPointer<AgUser>> *users)
{
  AgMutex *p_m_mutex; // rsi

  p_m_mutex = &this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
  LODWORD(users) = AgUserManager::_getUsers(this, users);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_mutex);
  return (unsigned int)users;
}

void __fastcall ActorWeapon::ActionFlagCheck(_SETJMP_FLOAT128 *JumpBuffer)
{
  ;
}

__int64 __fastcall AgUserManager::onSingletonExit(AgUserManager *this)
{
  AgSingleton<AgSystemManager> *v1; // rbx
  AgDelegate1<AgSuspendingEvent const &,void> v4; // [rsp+20h] [rbp-18h] BYREF

  v1 = AgSingleton<AgSystemManager>::ms_instance;
  v4.m_Closure.m_pthis = (detail::GenericClass *)this;
  v4.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *)) AgUserManager::`vcall'{32,{flat}};
  AgEventDispatcherBase<AgSuspendingEvent>::unbind(
    (AgEventDispatcherBase<AgSuspendingEvent> *)&AgSingleton<AgSystemManager>::ms_instance[33],
    &v4);
  v4.m_Closure.m_pthis = (detail::GenericClass *)this;
  v4.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *)) AgUserManager::`vcall'{40,{flat}};
  AgEventDispatcherBase<AgResumingEvent>::unbind(
    (AgEventDispatcherBase<AgResumingEvent> *)&v1[49],
    (AgDelegate1<AgResumingEvent const &,void> *)&v4);
  return 1i64;
}

__int64 __fastcall AgUserManager::onSingletonInit(AgUserManager *this)
{
  AgSingleton<AgSystemManager> *v2; // rdi
  AgSingleton<AgSystemManager> *v3; // rbx
  AgDelegate1<AgSuspendingEvent const &,void> _Val; // [rsp+48h] [rbp-20h] BYREF

  v2 = AgSingleton<AgSystemManager>::ms_instance;
  v3 = AgSingleton<AgSystemManager>::ms_instance + 33;
  _Val.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *)) AgUserManager::`vcall'{32,{flat}};
  _Val.m_Closure.m_pthis = (detail::GenericClass *)this;
  EnterCriticalSection((LPCRITICAL_SECTION)&AgSingleton<AgSystemManager>::ms_instance[33]);
  std::vector<AgDelegate1<AgSuspendingEvent const &,void>>::push_back(
    (std::vector<AgDelegate1<AgSuspendingEvent const &,void>> *)&v3[5],
    &_Val);
  LeaveCriticalSection((LPCRITICAL_SECTION)v3);
  _Val.m_Closure.m_pFunction = (void (__fastcall *)(detail::GenericClass *)) AgUserManager::`vcall'{40,{flat}};
  _Val.m_Closure.m_pthis = (detail::GenericClass *)this;
  EnterCriticalSection((LPCRITICAL_SECTION)&v2[49]);
  std::vector<AgDelegate1<AgResumingEvent const &,void>>::push_back(
    (std::vector<AgDelegate1<AgResumingEvent const &,void>> *)&v2[54],
    (const AgDelegate1<AgResumingEvent const &,void> *)&_Val);
  LeaveCriticalSection((LPCRITICAL_SECTION)&v2[49]);
  return 1i64;
}

void __fastcall std::vector<AgPointer<AgUser>>::push_back(
        std::vector<AgPointer<AgUser>> *this,
        const AgPointer<AgUser> *_Val)
{
  AgPointer<AgUser> *Mylast; // rax
  AgPointer<AgUser> *Myfirst; // rcx
  signed __int64 v6; // rdi
  AgPointer<AgUser> *v7; // rcx
  const AgPointer<AgPlayer> *v8; // rdi
  AgPointer<AgUser> *v9; // rcx

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || (Myfirst = this->_Mypair._Myval2._Myfirst, Myfirst > _Val) )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgPointer<AgUser>>::_Reserve(this, 1ui64);
    v9 = this->_Mypair._Myval2._Mylast;
    if ( v9 )
      AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        (AgPointer<AgPlayer> *)v9,
        (const AgPointer<AgPlayer> *)_Val);
  }
  else
  {
    v6 = (char *)_Val - (char *)Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgPointer<AgUser>>::_Reserve(this, 1ui64);
    v7 = this->_Mypair._Myval2._Mylast;
    v8 = (const AgPointer<AgPlayer> *)((char *)this->_Mypair._Myval2._Myfirst + (v6 & 0xFFFFFFFFFFFFFFF0ui64));
    if ( v7 )
      AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>((AgPointer<AgPlayer> *)v7, v8);
  }
  ++this->_Mypair._Myval2._Mylast;
}

void __fastcall AgAsyncEventDispatcher<AgUserAddedEvent>::run(AgAsyncEventDispatcher<AgUserAddedEvent> *this)
{
  AgUserAddedEvent *Myend; // r14
  std::vector<AgUserAddedEvent> *p_m_eventQueue; // rax
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rsi
  AgUserAddedEvent *Mylast; // rdi
  const AgUserAddedEvent *v6; // rbx
  AgPointer<KOFApplication> *v7; // rbx
  __int128 v8; // [rsp+28h] [rbp-30h] BYREF
  AgUserAddedEvent *v9; // [rsp+38h] [rbp-20h]

  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v8 = 0i64;
  Myend = 0i64;
  v9 = 0i64;
  p_m_eventQueue = &this->m_eventQueue;
  if ( &v8 == (__int128 *)&this->m_eventQueue )
  {
    Mylast = (AgUserAddedEvent *)*((_QWORD *)&v8 + 1);
    Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)v8;
  }
  else
  {
    Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)p_m_eventQueue->_Mypair._Myval2._Myfirst;
    *(_QWORD *)&v8 = p_m_eventQueue->_Mypair._Myval2._Myfirst;
    p_m_eventQueue->_Mypair._Myval2._Myfirst = 0i64;
    Mylast = this->m_eventQueue._Mypair._Myval2._Mylast;
    *((_QWORD *)&v8 + 1) = Mylast;
    this->m_eventQueue._Mypair._Myval2._Mylast = 0i64;
    Myend = this->m_eventQueue._Mypair._Myval2._Myend;
    v9 = Myend;
    this->m_eventQueue._Mypair._Myval2._Myend = 0i64;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v6 = (const AgUserAddedEvent *)Myfirst;
  if ( Myfirst != (AgDelegate1<AgUserUpdatedEvent const &,void> *)Mylast )
  {
    do
      AgEventDispatcherBase<AgUserAddedEvent>::call(this, v6++);
    while ( v6 != Mylast );
  }
  if ( Myfirst )
  {
    v7 = (AgPointer<KOFApplication> *)Myfirst;
    if ( Myfirst != (AgDelegate1<AgUserUpdatedEvent const &,void> *)Mylast )
    {
      do
        AgPointer<AgUser>::~AgPointer<AgUser>(v7++);
      while ( v7 != (AgPointer<KOFApplication> *)Mylast );
    }
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&v8,
      Myfirst,
      ((char *)Myend - (char *)Myfirst) >> 4);
  }
}

void __fastcall AgAsyncEventDispatcher<AgUserRemovedEvent>::run(AgAsyncEventDispatcher<AgUserRemovedEvent> *this)
{
  AgUserRemovedEvent *Myend; // r14
  std::vector<AgUserRemovedEvent> *p_m_eventQueue; // rax
  AgDelegate1<AgUserUpdatedEvent const &,void> *Myfirst; // rsi
  AgUserRemovedEvent *Mylast; // rdi
  const AgUserRemovedEvent *v6; // rbx
  AgPointer<KOFApplication> *v7; // rbx
  __int128 v8; // [rsp+28h] [rbp-30h] BYREF
  AgUserRemovedEvent *v9; // [rsp+38h] [rbp-20h]

  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v8 = 0i64;
  Myend = 0i64;
  v9 = 0i64;
  p_m_eventQueue = &this->m_eventQueue;
  if ( &v8 == (__int128 *)&this->m_eventQueue )
  {
    Mylast = (AgUserRemovedEvent *)*((_QWORD *)&v8 + 1);
    Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)v8;
  }
  else
  {
    Myfirst = (AgDelegate1<AgUserUpdatedEvent const &,void> *)p_m_eventQueue->_Mypair._Myval2._Myfirst;
    *(_QWORD *)&v8 = p_m_eventQueue->_Mypair._Myval2._Myfirst;
    p_m_eventQueue->_Mypair._Myval2._Myfirst = 0i64;
    Mylast = this->m_eventQueue._Mypair._Myval2._Mylast;
    *((_QWORD *)&v8 + 1) = Mylast;
    this->m_eventQueue._Mypair._Myval2._Mylast = 0i64;
    Myend = this->m_eventQueue._Mypair._Myval2._Myend;
    v9 = Myend;
    this->m_eventQueue._Mypair._Myval2._Myend = 0i64;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v6 = (const AgUserRemovedEvent *)Myfirst;
  if ( Myfirst != (AgDelegate1<AgUserUpdatedEvent const &,void> *)Mylast )
  {
    do
      AgEventDispatcherBase<AgUserRemovedEvent>::call(this, v6++);
    while ( v6 != Mylast );
  }
  if ( Myfirst )
  {
    v7 = (AgPointer<KOFApplication> *)Myfirst;
    if ( Myfirst != (AgDelegate1<AgUserUpdatedEvent const &,void> *)Mylast )
    {
      do
        AgPointer<AgUser>::~AgPointer<AgUser>(v7++);
      while ( v7 != (AgPointer<KOFApplication> *)Mylast );
    }
    std::_Wrap_alloc<std::allocator<AgDelegate1<AgSuspendingEvent const &,void>>>::deallocate(
      (std::_Wrap_alloc<std::allocator<AgDelegate1<AgUserUpdatedEvent const &,void> > > *)&v8,
      Myfirst,
      ((char *)Myend - (char *)Myfirst) >> 4);
  }
}

void __fastcall AgAsyncEventDispatcher<AgUserUpdatedEvent>::run(AgAsyncEventDispatcher<AgUserUpdatedEvent> *this)
{
  AgUserUpdatedEvent *Myend; // r14
  std::vector<AgUserUpdatedEvent> *p_m_eventQueue; // rax
  AgJsonNode *Myfirst; // rsi
  AgUserUpdatedEvent *Mylast; // rdi
  const AgUserUpdatedEvent *v6; // rbx
  AgPointer<KOFApplication> *v7; // rbx
  __int128 v8; // [rsp+28h] [rbp-30h] BYREF
  AgUserUpdatedEvent *v9; // [rsp+38h] [rbp-20h]

  EnterCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v8 = 0i64;
  Myend = 0i64;
  v9 = 0i64;
  p_m_eventQueue = &this->m_eventQueue;
  if ( &v8 == (__int128 *)&this->m_eventQueue )
  {
    Mylast = (AgUserUpdatedEvent *)*((_QWORD *)&v8 + 1);
    Myfirst = (AgJsonNode *)v8;
  }
  else
  {
    Myfirst = (AgJsonNode *)p_m_eventQueue->_Mypair._Myval2._Myfirst;
    *(_QWORD *)&v8 = p_m_eventQueue->_Mypair._Myval2._Myfirst;
    p_m_eventQueue->_Mypair._Myval2._Myfirst = 0i64;
    Mylast = this->m_eventQueue._Mypair._Myval2._Mylast;
    *((_QWORD *)&v8 + 1) = Mylast;
    this->m_eventQueue._Mypair._Myval2._Mylast = 0i64;
    Myend = this->m_eventQueue._Mypair._Myval2._Myend;
    v9 = Myend;
    this->m_eventQueue._Mypair._Myval2._Myend = 0i64;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&this->m_queueMutex);
  v6 = (const AgUserUpdatedEvent *)Myfirst;
  if ( Myfirst != (AgJsonNode *)Mylast )
  {
    do
      AgEventDispatcherBase<AgUserUpdatedEvent>::call(this, v6++);
    while ( v6 != Mylast );
  }
  if ( Myfirst )
  {
    v7 = (AgPointer<KOFApplication> *)Myfirst;
    if ( Myfirst != (AgJsonNode *)Mylast )
    {
      do
      {
        AgPointer<AgUser>::~AgPointer<AgUser>(v7);
        v7 = (AgPointer<KOFApplication> *)((char *)v7 + 24);
      }
      while ( v7 != (AgPointer<KOFApplication> *)Mylast );
    }
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)&v8,
      Myfirst,
      ((char *)Myend - (char *)Myfirst) / 24);
  }
}

void __fastcall AgUserManager::update(AgUserManager *this)
{
  AgAsyncEventDispatcher<AgUserAddedEvent>::run(&this->UserAdded);
  AgAsyncEventDispatcher<AgUserRemovedEvent>::run(&this->UserRemoved);
  AgAsyncEventDispatcher<AgUserUpdatedEvent>::run(&this->UserUpdated);
}

