#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/silverware/git/sdk/agmutex.h"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "dev/silverware/git/sdk/util/agworkerpool.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "dev/silverware/git/sdk/agmath.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"

AgPointer<AgFile> AgFile::open(const AgPath & path, unsigned long accessMode, long wait); // 0x14065F800
long AgFile::exists(const AgPath & path); // 0x14065F790
AgFile::AgFile(AgPointer<AgMount> mount, const AgPath & path, unsigned long accessMode); // 0x14065F4D0
AgFile::~AgFile(); // 0x14065F590
long AgFile::waitOpen(); // 0x14065FDC0
void AgFile::setOpen(long open); // 0x14065FC60
void AgFile::setError(const AgFileErrorData & errorData); // 0x14065FA50
void AgFile::setModified(long modified); // 0x14065FB90
void AgFile::setFlushed(long flushed); // 0x14065FB00
void AgFile::setStoring(long storing); // 0x14065FD10
void AgFile::close(); // 0x14065F6D0
void AgFile::postStoreJob(); // 0x14065F8A0AgServiceCommandBase *__fastcall AgBindServiceCommand<AgAllocator<1>,AgFile,AgPointer<AgFile>,void>(
        AgAllocator<1> allocator,
        AgPointer<AgFile> *y,
        __int128 *func)
{
  char *v5; // rdi
  const AgPointer<AgPlayer> *v6; // rax
  AgPointer<KOFApplication> *v7; // rbx
  KOFApplication *m_ptr; // rdx
  __m128i v9; // xmm0
  __int64 v10; // rax
  AgPointer<AgPlayer> v12; // [rsp+40h] [rbp-38h] BYREF
  __int128 v13; // [rsp+50h] [rbp-28h]
  AgAllocator<1> v14; // [rsp+80h] [rbp+8h] BYREF
  AgPointer<AgFile> *v15; // [rsp+88h] [rbp+10h]
  char *v16; // [rsp+98h] [rbp+20h]

  v15 = y;
  v14 = allocator;
  v5 = (char *)AgAllocator<1>::allocate(&v14, 0x30ui64);
  v16 = v5;
  if ( v5 )
  {
    v13 = *func;
    AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(&v12, (const AgPointer<AgPlayer> *)y);
    v7 = (AgPointer<KOFApplication> *)v6;
    *(_QWORD *)v5 = &AgServiceCommandBase::`vftable';
    *(_QWORD *)v5 = &AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void (void),void (void)>::`vftable';
    AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>((AgPointer<AgPlayer> *)(v5 + 8), v6);
    m_ptr = v7->m_ptr;
    *((_QWORD *)v5 + 3) = 0i64;
    v9 = (__m128i)v13;
    *((_QWORD *)v5 + 4) = v13;
    Scaleform::Render::SubImage::GetAsImage((std::_Wrap_alloc<std::allocator<AgString> > *)m_ptr + _mm_cvtsi128_si32(_mm_srli_si128(v9, 8)));
    *((_QWORD *)v5 + 3) = v10;
    AgPointer<AgUser>::~AgPointer<AgUser>(v7);
  }
  else
  {
    v5 = 0i64;
  }
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)y);
  return (AgServiceCommandBase *)v5;
}

void __fastcall AgFile::AgFile(AgFile *this, AgPointer<AgMount> *mount, const AgPath *path, unsigned int accessMode)
{
  AgStringRef *v8; // rax
  AgStringRef v9; // [rsp+30h] [rbp-48h] BYREF
  AgStringRef v10; // [rsp+40h] [rbp-38h] BYREF

  this->m_refCount = 0i64;
  this->__vftable = (AgFile_vtbl *)&AgStream::`vftable';
  this->__vftable = (AgFile_vtbl *)&AgFile::`vftable';
  this->m_mutex = &mount->m_ptr->m_mutex;
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)&this->m_mount,
    (const AgPointer<AgPlayer> *)mount);
  AgString::AgString(&this->m_path.m_path, &path->m_path);
  this->m_accessMode = accessMode;
  *(_QWORD *)&this->m_open = 0i64;
  *(_QWORD *)&this->m_modified = 0i64;
  this->m_error.error = AgFileError_None;
  this->m_error.systemError = 0i64;
  AgStringRef::AgStringRef(&v10, "FileSystem.Stream");
  v9 = *v8;
  AgSilverWareDebugChannel::AgSilverWareDebugChannel(&this->m_channel, &v9);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)mount);
}

void __fastcall AgFile::~AgFile(AgFile *this, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdx

  this->__vftable = (AgFile_vtbl *)&AgFile::`vftable';
  if ( this->m_open )
    AgFile::setOpen(this, 0);
  operator delete(this->m_channel.m_counter.m_deltaTime, a2);
  AgString::~AgString(&this->m_path.m_path, v3);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->m_mount);
  this->__vftable = (AgFile_vtbl *)&AgStream::`vftable';
}

char __fastcall AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void (void),void (void)>::operator()(
        AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void __cdecl(void),void __cdecl(void)> *this)
{
  this->m_delegate.m_Closure.m_pFunction(this->m_delegate.m_Closure.m_pthis);
  return 1;
}

void __fastcall Scaleform::Render::SubImage::GetAsImage(std::_Wrap_alloc<std::allocator<AgString> > *this)
{
  ;
}

void __fastcall AgFile::close(AgFile *this)
{
  AgMutex *m_mutex; // rdi

  if ( this->m_modified )
  {
    m_mutex = this->m_mutex;
    EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
    if ( this->m_flushed != 1 )
    {
      this->m_flushed = 1;
      this->m_mount.m_ptr->m_modified = 1;
      AgFile::postStoreJob(this);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
  }
  AgFile::setOpen(this, 0);
}

void __fastcall AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void (void),void (void)>::destroy(
        AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void __cdecl(void),void __cdecl(void)> *this)
{
  ((void (__fastcall *)(AgServiceCommand<AgAllocator<1>,AgPointer<AgFile>,void __cdecl(void),void __cdecl(void)> *, _QWORD))this->~AgServiceCommandBase)(
    this,
    0i64);
  AgAllocator<1>::deallocate(&this->m_allocator, this);
}

_BOOL8 __fastcall AgFile::exists(const AgPath *path)
{
  return AgSingleton<AgFileSystem>::ms_instance
      && AgFileSystem::exists((AgFileSystem *)AgSingleton<AgFileSystem>::ms_instance, path);
}

AgStringRef *__fastcall AgFile::getName(AgFile *this, AgStringRef *result)
{
  AgStringRef::AgStringRef(result, &this->m_path.m_path);
  return result;
}

__int64 __fastcall AgFile::isValid(AgFile *this)
{
  AgFile::waitOpen(this);
  return (unsigned int)this->m_open;
}

AgPointer<AgFile> *__fastcall AgFile::open(
        AgPointer<AgFile> *result,
        const AgPath *path,
        unsigned int accessMode,
        int wait)
{
  AgFile *m_ptr; // rcx
  AgPointer<AgFile> resulta; // [rsp+30h] [rbp-18h] BYREF

  if ( AgSingleton<AgFileSystem>::ms_instance )
  {
    AgFileSystem::open((AgFileSystem *)AgSingleton<AgFileSystem>::ms_instance, &resulta, path, accessMode);
    m_ptr = resulta.m_ptr;
    if ( wait && resulta.m_ptr )
    {
      AgFile::waitOpen(resulta.m_ptr);
      m_ptr = resulta.m_ptr;
    }
    result->m_ref = resulta.m_ref;
    result->m_ptr = m_ptr;
    resulta = 0i64;
    AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&resulta);
  }
  else
  {
    result->m_ref = 0i64;
    result->m_ptr = 0i64;
  }
  return result;
}

void __fastcall AgFile::postStoreJob(AgFile *this)
{
  AgReferenceCount *v2; // rax
  int v3; // eax
  AgReferenceCount *m_refCount; // rbx
  int m_strongCount; // edi
  AgPointer<AgFile> *v6; // rax
  AgServiceCommandBase *v7; // rdi
  int v8; // esi
  AgPointer<AgPlayer> value; // [rsp+30h] [rbp-50h]
  AgPointer<AgPlayer> rhs; // [rsp+40h] [rbp-40h] BYREF
  __int128 v11; // [rsp+50h] [rbp-30h]
  AgPointer<AgPlayer> v12; // [rsp+60h] [rbp-20h] BYREF
  __int128 v13; // [rsp+70h] [rbp-10h] BYREF

  value = 0i64;
  if ( this )
  {
    if ( this->m_refCount )
    {
      v3 = 0;
    }
    else
    {
      v2 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      if ( v2 )
      {
        v2->m_strongCount = 1;
        v2->m_weakCount = 1;
        v2->m_data = this;
      }
      else
      {
        v2 = 0i64;
      }
      this->m_refCount = v2;
      v3 = 1;
    }
    m_refCount = this->m_refCount;
    if ( !v3 )
      AgReferenceCount::incRef(this->m_refCount);
    value.m_ref = m_refCount;
    value.m_ptr = (AgPlayer *)this;
  }
  else
  {
    m_refCount = 0i64;
  }
  *(_QWORD *)&v11 =  AgFile::`vcall'{96,{flat}};
  DWORD2(v11) = 0;
  rhs = 0i64;
  if ( m_refCount )
  {
    m_strongCount = m_refCount->m_strongCount;
    if ( m_refCount->m_strongCount )
    {
      while ( 1 )
      {
        m_refCount = value.m_ref;
        if ( AgAtomicCompareExchange(&value.m_ref->m_strongCount, m_strongCount, m_strongCount + 1) == m_strongCount )
          break;
        m_strongCount = value.m_ref->m_strongCount;
        if ( !value.m_ref->m_strongCount )
          goto LABEL_19;
      }
      if ( m_strongCount != -1 )
        rhs = value;
    }
    else
    {
LABEL_19:
      m_refCount = value.m_ref;
    }
  }
  v13 = v11;
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(&v12, &rhs);
  v7 = AgBindServiceCommand<AgAllocator<1>,AgFile,AgPointer<AgFile>,void>((AgAllocator<1>)&rhs, v6, &v13);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&rhs);
  AgService::post((AgService *)AgSingleton<AgWorkerPool>::ms_instance[31].__vftable, v7);
  if ( m_refCount )
  {
    v8 = 0;
    if ( !AgAtomicDecrement(&m_refCount->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_refCount->m_weakCount) )
        v8 = 1;
      m_refCount->m_data = 0i64;
      if ( value.m_ptr )
        ((void (__fastcall *)(AgPlayer *, __int64))value.m_ptr->m_refCount->m_strongCount)(value.m_ptr, 1i64);
      if ( v8 )
        AgReferenceCount::operator delete(m_refCount);
    }
  }
}

void __fastcall AgFile::setError(AgFile *this, const AgFileErrorData *errorData)
{
  AgMutex *m_mutex; // rsi
  AgCondition *p_m_stateChanged; // rbx

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  this->m_error = *errorData;
  p_m_stateChanged = &this->m_mount.m_ptr->m_stateChanged;
  EnterCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  WakeAllConditionVariable((PCONDITION_VARIABLE)&p_m_stateChanged->m_conditionVariable.m_data);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
}

void __fastcall AgFile::setFlushed(AgFile *this, int flushed)
{
  AgMutex *m_mutex; // rsi

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  if ( this->m_flushed != flushed )
  {
    this->m_flushed = flushed;
    if ( flushed )
    {
      this->m_mount.m_ptr->m_modified = 1;
      AgFile::postStoreJob(this);
    }
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
}

void __fastcall AgFile::setModified(AgFile *this, int modified)
{
  AgMutex *m_mutex; // rbp
  AgCondition *p_m_stateChanged; // rbx

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  if ( modified )
    this->m_mount.m_ptr->m_modified = 1;
  if ( this->m_modified != modified )
  {
    this->m_modified = modified;
    p_m_stateChanged = &this->m_mount.m_ptr->m_stateChanged;
    EnterCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
    WakeAllConditionVariable((PCONDITION_VARIABLE)&p_m_stateChanged->m_conditionVariable.m_data);
    LeaveCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
    if ( modified )
      AgFile::postStoreJob(this);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
}

void __fastcall AgFile::setOpen(AgFile *this, int open)
{
  AgMutex *m_mutex; // rsi
  AgCondition *p_m_stateChanged; // rbx

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  this->m_open = open;
  p_m_stateChanged = &this->m_mount.m_ptr->m_stateChanged;
  EnterCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  WakeAllConditionVariable((PCONDITION_VARIABLE)&p_m_stateChanged->m_conditionVariable.m_data);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
}

void __fastcall AgFile::setStoring(AgFile *this, int storing)
{
  AgMutex *m_mutex; // rsi
  AgCondition *p_m_stateChanged; // rbx

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  this->m_storing = storing;
  p_m_stateChanged = &this->m_mount.m_ptr->m_stateChanged;
  EnterCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  WakeAllConditionVariable((PCONDITION_VARIABLE)&p_m_stateChanged->m_conditionVariable.m_data);
  LeaveCriticalSection((LPCRITICAL_SECTION)p_m_stateChanged);
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
}

__int64 __fastcall AgFile::waitOpen(AgFile *this)
{
  AgMutex *m_mutex; // rbp
  AgMount *m_ptr; // rdi
  AgMutex *v4; // rsi
  unsigned int m_open; // ebx

  m_mutex = this->m_mutex;
  EnterCriticalSection((LPCRITICAL_SECTION)m_mutex);
  while ( !this->m_open )
  {
    if ( this->m_error.error )
      break;
    m_ptr = this->m_mount.m_ptr;
    if ( !m_ptr->m_mounted )
      break;
    v4 = this->m_mutex;
    EnterCriticalSection((LPCRITICAL_SECTION)&m_ptr->m_stateChanged);
    LeaveCriticalSection((LPCRITICAL_SECTION)v4);
    SleepConditionVariableCS(
      (PCONDITION_VARIABLE)&m_ptr->m_stateChanged.m_conditionVariable.m_data,
      (PCRITICAL_SECTION)m_ptr->m_stateChanged.m_conditionVariable.m_mutex,
      0xFFFFFFFF);
    LeaveCriticalSection((LPCRITICAL_SECTION)&m_ptr->m_stateChanged);
    EnterCriticalSection((LPCRITICAL_SECTION)v4);
  }
  m_open = this->m_open;
  LeaveCriticalSection((LPCRITICAL_SECTION)m_mutex);
  return m_open;
}

