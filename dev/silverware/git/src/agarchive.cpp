#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstddef"
#include "dev/silverware/git/sdk/agendian.inl"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xatomic0.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/system_error"
#include "dev/silverware/git/sdk/util/agdebugchannels.h"
#include "dev/silverware/git/sdk/agreferencecount.h"
#include "dev/silverware/git/sdk/util/agperformancecounter.h"
#include "dev/silverware/git/sdk/agclock.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thread"
#include "dev/silverware/git/sdk/filesystem/agfile.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/memory"
#include "dev/silverware/git/sdk/agmutex.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wio.h"
#include "dev/silverware/git/sdk/agscopedlock.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/algorithm"
#include "dev/silverware/git/sdk/filesystem/agpath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/tuple"
#include "dev/silverware/git/sdk/agarchivedirectory.h"
#include "dev/silverware/git/sdk/filesystem/agdirectory.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xutility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/utility"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/iosfwd"
#include "dev/silverware/git/sdk/memory/agallocators.h"
#include "dev/silverware/git/sdk/agsingleton.h"
#include "dev/silverware/git/sdk/agarchivefile.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocinfo"
#include "dev/silverware/git/sdk/system/agusermanager.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/time.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xiosbase"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/ctype.h"
#include "dev/silverware/git/sdk/util/agdelegate.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocale"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/string.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memory.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_memcpy_s.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/mutex"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/chrono"
#include "dev/silverware/git/sdk/system/agsysteminfo.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vector"
#include "dev/silverware/git/sdk/agmutex.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/malloc.h"
#include "dev/silverware/git/sdk/agreferencecountinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/cmath"
#include "dev/silverware/git/sdk/agcondition.inl"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/math.h"
#include "dev/silverware/git/sdk/agmemorystream.h"
#include "dev/silverware/git/sdk/platforms/pc/system/agpcsysteminfo.h"
#include "dev/silverware/git/sdk/agthreadpool.h"
#include "dev/silverware/git/sdk/util/agservice.h"
#include "dev/silverware/git/sdk/agsemaphore.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/sys/stat.h"
#include "dev/silverware/git/sdk/agthread.h"
#include "dev/silverware/git/sdk/agcondition.h"
#include "dev/silverware/git/sdk/agconditionvariable.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/condition_variable"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xstring"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory0"
#include "dev/silverware/git/sdk/agreference.h"
#include "dev/silverware/git/sdk/agpointerinl.h"
#include "dev/silverware/git/sdk/agmemorypool.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdio.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wstdio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_new.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_stdio_config.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/map"
#include "dev/silverware/git/sdk/agmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtree"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/wchar.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wconio.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_exception.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/limits"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/corecrt_wtime.h"
#include "dev/silverware/git/sdk/agreferenceinl.h"
#include "dev/silverware/git/sdk/util/agservicecommand.h"
#include "dev/silverware/git/sdk/filesystem/agmount.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xfacet"
#include "dev/silverware/git/sdk/system/aguser.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/list"
#include "dev/silverware/git/sdk/agconditionvariable.inl"
#include "dev/silverware/git/sdk/agreferencedobjectinl.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xmemory"
#include "dev/silverware/git/sdk/agpointer.h"
#include "dev/silverware/git/sdk/agarchive.h"
#include "dev/silverware/git/sdk/agreferencedobject.h"
#include "dev/silverware/git/sdk/agstring.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtgmath.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/thr/xthread"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xtr1common"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/string"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vcruntime_typeinfo.h"
#include "program files (x86)/windows kits/10/include/10.0.10240.0/ucrt/stdlib.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/vadefs.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/ios"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/functional"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/xlocnum"
#include "dev/silverware/git/sdk/agsemaphore.inl"
#include "dev/silverware/git/sdk/agstream.h"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/stdexcept"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/exception"
#include "program files (x86)/microsoft visual studio 14.0/vc/include/type_traits"

AgArchive::AgArchive(const AgString & fileName, const AgString & mountPoint); // 0x14066C3C0
std::_List_buy<AgPointer<AgArchive>,std::allocator<AgPointer<AgArchive> > >::~_List_buy<AgPointer<AgArchive>,std::allocator<AgPointer<AgArchive> > >(); // 0x14066C8E0
std::map<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> > >::~map<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> > >(); // 0x14066C9F0
std::map<AgString,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> >,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> > > > >::~map<AgString,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> >,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> > > > >(); // 0x14066CA30
std::pair<AgString,AgArchive::ArchiveEntry>::~pair<AgString,AgArchive::ArchiveEntry>(); // 0x14066CA70
std::pair<AgString,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> > >::~pair<AgString,std::vector<AgArchive::DirectoryEntry,std::allocator<AgArchive::DirectoryEntry> > >(); // 0x14066CAB0
AgArchive::~AgArchive(); // 0x14066CB00
AgArchive::ArchiveEntry::~ArchiveEntry(); // 0x14066CC40
AgArchive::DirectoryEntry::~DirectoryEntry(); // 0x14066CC60
class AgPointer<AgAsyncStreamReader>
{
public:
	AgPointer<AgAsyncStreamReader>(const AgReference<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader>(AgPointer<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader>(const AgPointer<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader>(AgAsyncStreamReader *);
	AgPointer<AgAsyncStreamReader>();
	~AgPointer<AgAsyncStreamReader>();
	AgPointer<AgAsyncStreamReader> & operator=(AgPointer<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader> & operator=(const AgReference<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader> & operator=(const AgPointer<AgAsyncStreamReader> &);
	AgPointer<AgAsyncStreamReader> & operator=(AgAsyncStreamReader *);
	bool operator<(const AgPointer<AgAsyncStreamReader> &);
	AgAsyncStreamReader * operator->();
	AgAsyncStreamReader & operator*();
	bool operator==(const AgPointer<AgAsyncStreamReader> &);
	bool operator==(AgAsyncStreamReader *);
	bool operator!=(const AgPointer<AgAsyncStreamReader> &);
	bool operator!=(AgAsyncStreamReader *);
	AgAsyncStreamReader * getObject();
	void swap(AgPointer<AgAsyncStreamReader> &);
private:
	AgReferenceCount * m_ref; // 0x0
	AgAsyncStreamReader * m_ptr; // 0x8
public:
	AgPointer<AgStream> operator class AgPointer<class AgStream>();
};
void AgArchive::mount(); // 0x140699F20
AgPointer<AgDirectory> AgArchive::openDirectory(const AgPath & path, AgStringRef filter, unsigned long filterMask); // 0x14066F310
class AgPointer<AgArchiveDirectory>
{
public:
	AgPointer<AgArchiveDirectory>(const AgReference<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory>(AgPointer<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory>(const AgPointer<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory>(AgArchiveDirectory *);
	AgPointer<AgArchiveDirectory>();
	~AgPointer<AgArchiveDirectory>();
	AgPointer<AgArchiveDirectory> & operator=(AgPointer<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory> & operator=(const AgReference<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory> & operator=(const AgPointer<AgArchiveDirectory> &);
	AgPointer<AgArchiveDirectory> & operator=(AgArchiveDirectory *);
	bool operator<(const AgPointer<AgArchiveDirectory> &);
	AgArchiveDirectory * operator->();
	AgArchiveDirectory & operator*();
	bool operator==(const AgPointer<AgArchiveDirectory> &);
	bool operator==(AgArchiveDirectory *);
	bool operator!=(const AgPointer<AgArchiveDirectory> &);
	bool operator!=(AgArchiveDirectory *);
	AgArchiveDirectory * getObject();
	void swap(AgPointer<AgArchiveDirectory> &);
private:
	AgReferenceCount * m_ref; // 0x0
	AgArchiveDirectory * m_ptr; // 0x8
public:
	AgPointer<AgDirectory> operator class AgPointer<class AgDirectory>();
};
void AgArchive::_create(AgPointer<AgStream> stream); // 0x14066D6F0
class AgPointer<AgBlowfish>
{
public:
	AgPointer<AgBlowfish>(const AgReference<AgBlowfish> &);
	AgPointer<AgBlowfish>(AgPointer<AgBlowfish> &);
	AgPointer<AgBlowfish>(const AgPointer<AgBlowfish> &);
	AgPointer<AgBlowfish>(AgBlowfish *);
	AgPointer<AgBlowfish>();
	~AgPointer<AgBlowfish>();
	AgPointer<AgBlowfish> & operator=(AgPointer<AgBlowfish> &);
	AgPointer<AgBlowfish> & operator=(const AgReference<AgBlowfish> &);
	AgPointer<AgBlowfish> & operator=(const AgPointer<AgBlowfish> &);
	AgPointer<AgBlowfish> & operator=(AgBlowfish *);
	bool operator<(const AgPointer<AgBlowfish> &);
	AgBlowfish * operator->();
	AgBlowfish & operator*();
	bool operator==(const AgPointer<AgBlowfish> &);
	bool operator==(AgBlowfish *);
	bool operator!=(const AgPointer<AgBlowfish> &);
	bool operator!=(AgBlowfish *);
	AgBlowfish * getObject();
	void swap(AgPointer<AgBlowfish> &);
private:
	AgReferenceCount * m_ref; // 0x0
	AgBlowfish * m_ptr; // 0x8
};
typedef AgPointer<AgFile> AgFileStreamPtr;
long AgArchive::containsFile(const AgString & fileName); // 0x14066E1D0
AgPointer<AgFile> AgArchive::open(const AgPath & path, unsigned long accessMode); // 0x14066EF30
AgPointer<AgStream> AgArchive::createSourceStreamPtr(); // 0x14066E300
long AgArchive::isEncrypted(); // 0x14066EF20void __fastcall AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
        AgPointer<AgPlayer> *this,
        const AgPointer<AgPlayer> *rhs)
{
  AgReferenceCount *m_ref; // rsi
  int m_strongCount; // ebx

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  m_ref = rhs->m_ref;
  if ( rhs->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          return;
      }
      if ( m_strongCount != -1 )
      {
        this->m_ref = rhs->m_ref;
        this->m_ptr = rhs->m_ptr;
      }
    }
  }
}

void __fastcall std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>(
        std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > *this,
        std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *_Right)
{
  AgString::AgString((AgString *)&this->first, &_Right->first);
  this->second._Mypair._Myval2._Myfirst = 0i64;
  this->second._Mypair._Myval2._Mylast = 0i64;
  this->second._Mypair._Myval2._Myend = 0i64;
  this->second = _Right->second;
  _Right->second._Mypair._Myval2._Myfirst = 0i64;
  _Right->second._Mypair._Myval2._Mylast = 0i64;
  _Right->second._Mypair._Myval2._Myend = 0i64;
}

AgPointer<AgDirectory> *__fastcall AgPointer<AgArchiveDirectory>::operator<AgDirectory> AgPointer<AgDirectory>(
        AgPointer<AgArchiveDirectory> *this,
        AgPointer<AgDirectory> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)this);
  return result;
}

AgPointer<AgStream> *__fastcall AgPointer<AgAsyncStreamReader>::operator<AgStream> AgPointer<AgStream>(
        AgPointer<AgAsyncStreamReader> *this,
        AgPointer<AgStream> *result)
{
  AgPointer<AgBuffer<AgAllocator<1>>>::AgPointer<AgBuffer<AgAllocator<1>>>(
    (AgPointer<AgPlayer> *)result,
    (const AgPointer<AgPlayer> *)this);
  return result;
}

std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buynode<std::pair<AgString,AgArchive::ArchiveEntry>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::pair<AgString,AgArchive::ArchiveEntry> *<_Val_0>)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v5; // [rsp+50h] [rbp+18h]

  v5 = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buynode0(this);
  *(_WORD *)&v5->_Color = 0;
  std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *>>>::construct<std::pair<AgString const,AgArchive::ArchiveEntry>,std::pair<AgString,AgArchive::ArchiveEntry>>(
    (std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> > > *)this,
    &v5->_Myval,
    <_Val_0>);
  return v5;
}

std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buynode<std::pair<AgString,std::vector<AgArchive::DirectoryEntry>>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *<_Val_0>)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v3; // rbx

  v3 = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buynode0(this);
  *(_WORD *)&v3->_Color = 0;
  if ( v3 != (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *)-32i64 )
    std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>(
      &v3->_Myval,
      <_Val_0>);
  return v3;
}

void __fastcall std::_Destroy_range<std::allocator<AgArchive::DirectoryEntry>,AgArchive::DirectoryEntry *>(
        AgArchive::DirectoryEntry *_First,
        AgArchive::DirectoryEntry *_Last,
        std::_Wrap_alloc<std::allocator<AgArchive::DirectoryEntry> > *_Al)
{
  AgArchive::DirectoryEntry *v4; // rdi

  if ( _First != _Last )
  {
    v4 = _First;
    do
    {
      AgString::~AgString(&v4->m_name);
      ++v4;
    }
    while ( v4 != _Last );
  }
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Insert_at<std::pair<AgString const,AgArchive::ArchiveEntry> &,std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *> *>(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *result,
        bool _Addleft,
        std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Wherenode,
        std::pair<AgString const ,AgArchive::ArchiveEntry> *_Val,
        std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Node)
{
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Myhead; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v10; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Parent; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v12; // r8
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Left; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Right; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v15; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v16; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v17; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v18; // r8
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v19; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v20; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v21; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v22; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v23; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v24; // rcx

  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize >= 0x333333333333332i64 )
  {
    AgString::~AgString(&_Node->_Myval.second.m_fileName);
    AgString::~AgString((AgString *)&_Node->_Myval.first);
    operator delete(_Node);
    std::_Xlength_error("map/set<T> too long");
  }
  this->_Mypair._Myval2._Myval2._Mysize = Mysize + 1;
  _Node->_Parent = _Wherenode;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Node;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
LABEL_9:
    Myhead->_Right = _Node;
    goto LABEL_10;
  }
  if ( !_Addleft )
  {
    _Wherenode->_Right = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
    if ( _Wherenode != this->_Mypair._Myval2._Myval2._Myhead->_Right )
      goto LABEL_10;
    goto LABEL_9;
  }
  _Wherenode->_Left = _Node;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
LABEL_10:
  v10 = _Node;
  while ( !v10->_Parent->_Color )
  {
    Parent = v10->_Parent;
    v12 = Parent->_Parent;
    Left = v12->_Left;
    if ( Parent == v12->_Left )
    {
      Right = v12->_Right;
      if ( Right->_Color )
      {
        if ( v10 == Parent->_Right )
        {
          v10 = v10->_Parent;
          v15 = Parent->_Right;
          Parent->_Right = v15->_Left;
          if ( !v15->_Left->_Isnil )
            v15->_Left->_Parent = Parent;
          v15->_Parent = Parent->_Parent;
          if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v15;
          }
          else
          {
            v16 = Parent->_Parent;
            if ( v10 == v16->_Left )
              v16->_Left = v15;
            else
              v16->_Right = v15;
          }
          v15->_Left = v10;
          v10->_Parent = v15;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Left;
        v17->_Left = v17->_Left->_Right;
        v19 = v18->_Right;
        if ( !v19->_Isnil )
          v19->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v20 = v17->_Parent;
          if ( v17 == v20->_Right )
            v20->_Right = v18;
          else
            v20->_Left = v18;
        }
        v18->_Right = v17;
LABEL_50:
        v17->_Parent = v18;
        continue;
      }
      Parent->_Color = 1;
      Right->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
    else
    {
      if ( Left->_Color )
      {
        if ( v10 == Parent->_Left )
        {
          v10 = v10->_Parent;
          v21 = Parent->_Left;
          Parent->_Left = Parent->_Left->_Right;
          v22 = v21->_Right;
          if ( !v22->_Isnil )
            v22->_Parent = v10;
          v21->_Parent = v10->_Parent;
          if ( v10 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
          }
          else
          {
            v23 = v10->_Parent;
            if ( v10 == v23->_Right )
              v23->_Right = v21;
            else
              v23->_Left = v21;
          }
          v21->_Right = v10;
          v10->_Parent = v21;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Right;
        v17->_Right = v18->_Left;
        if ( !v18->_Left->_Isnil )
          v18->_Left->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v24 = v17->_Parent;
          if ( v17 == v24->_Left )
            v24->_Left = v18;
          else
            v24->_Right = v18;
        }
        v18->_Left = v17;
        goto LABEL_50;
      }
      Parent->_Color = 1;
      Left->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
  }
  this->_Mypair._Myval2._Myval2._Myhead->_Parent->_Color = 1;
  result->_Ptr = _Node;
  return result;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Insert_at<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>> &,std::_Tree_node<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>,void *> *>(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *result,
        bool _Addleft,
        std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *_Wherenode,
        std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > *_Val,
        std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *_Node)
{
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Myhead; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v10; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Parent; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v12; // r8
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Left; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Right; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v15; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v16; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v17; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v18; // r8
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v19; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v20; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v21; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v22; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v23; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v24; // rcx

  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize >= 0x38E38E38E38E38Di64 )
  {
    std::vector<AgArchive::DirectoryEntry>::_Tidy(&_Node->_Myval.second);
    AgString::~AgString((AgString *)&_Node->_Myval.first);
    operator delete(_Node);
    std::_Xlength_error("map/set<T> too long");
  }
  this->_Mypair._Myval2._Myval2._Mysize = Mysize + 1;
  _Node->_Parent = _Wherenode;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Node;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
LABEL_9:
    Myhead->_Right = _Node;
    goto LABEL_10;
  }
  if ( !_Addleft )
  {
    _Wherenode->_Right = _Node;
    Myhead = this->_Mypair._Myval2._Myval2._Myhead;
    if ( _Wherenode != this->_Mypair._Myval2._Myval2._Myhead->_Right )
      goto LABEL_10;
    goto LABEL_9;
  }
  _Wherenode->_Left = _Node;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    this->_Mypair._Myval2._Myval2._Myhead->_Left = _Node;
LABEL_10:
  v10 = _Node;
  while ( !v10->_Parent->_Color )
  {
    Parent = v10->_Parent;
    v12 = Parent->_Parent;
    Left = v12->_Left;
    if ( Parent == v12->_Left )
    {
      Right = v12->_Right;
      if ( Right->_Color )
      {
        if ( v10 == Parent->_Right )
        {
          v10 = v10->_Parent;
          v15 = Parent->_Right;
          Parent->_Right = v15->_Left;
          if ( !v15->_Left->_Isnil )
            v15->_Left->_Parent = Parent;
          v15->_Parent = Parent->_Parent;
          if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v15;
          }
          else
          {
            v16 = Parent->_Parent;
            if ( v10 == v16->_Left )
              v16->_Left = v15;
            else
              v16->_Right = v15;
          }
          v15->_Left = v10;
          v10->_Parent = v15;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Left;
        v17->_Left = v17->_Left->_Right;
        v19 = v18->_Right;
        if ( !v19->_Isnil )
          v19->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v20 = v17->_Parent;
          if ( v17 == v20->_Right )
            v20->_Right = v18;
          else
            v20->_Left = v18;
        }
        v18->_Right = v17;
LABEL_50:
        v17->_Parent = v18;
        continue;
      }
      Parent->_Color = 1;
      Right->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
    else
    {
      if ( Left->_Color )
      {
        if ( v10 == Parent->_Left )
        {
          v10 = v10->_Parent;
          v21 = Parent->_Left;
          Parent->_Left = Parent->_Left->_Right;
          v22 = v21->_Right;
          if ( !v22->_Isnil )
            v22->_Parent = v10;
          v21->_Parent = v10->_Parent;
          if ( v10 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
          {
            this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
          }
          else
          {
            v23 = v10->_Parent;
            if ( v10 == v23->_Right )
              v23->_Right = v21;
            else
              v23->_Left = v21;
          }
          v21->_Right = v10;
          v10->_Parent = v21;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v17 = v10->_Parent->_Parent;
        v18 = v17->_Right;
        v17->_Right = v18->_Left;
        if ( !v18->_Left->_Isnil )
          v18->_Left->_Parent = v17;
        v18->_Parent = v17->_Parent;
        if ( v17 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v18;
        }
        else
        {
          v24 = v17->_Parent;
          if ( v17 == v24->_Left )
            v24->_Left = v18;
          else
            v24->_Right = v18;
        }
        v18->_Left = v17;
        goto LABEL_50;
      }
      Parent->_Color = 1;
      Left->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
  }
  this->_Mypair._Myval2._Myval2._Myhead->_Parent->_Color = 1;
  result->_Ptr = _Node;
  return result;
}

std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >,bool> *__fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Insert_nohint<std::pair<AgString const,AgArchive::ArchiveEntry> &,std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *> *>(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >,bool> *result,
        bool _Leftish,
        std::pair<AgString const ,AgArchive::ArchiveEntry> *_Val,
        std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Newnode)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Myhead; // rdi
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Parent; // rbx
  bool v11; // si
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *i; // rbx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v14; // rax
  AgStringRef left; // [rsp+40h] [rbp-68h] BYREF
  AgStringRef right; // [rsp+50h] [rbp-58h] BYREF
  AgStringRef v17; // [rsp+60h] [rbp-48h] BYREF
  AgStringRef v18; // [rsp+70h] [rbp-38h] BYREF

  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  Parent = this->_Mypair._Myval2._Myval2._Myhead->_Parent;
  v11 = 1;
  while ( !Parent->_Isnil )
  {
    Myhead = Parent;
    if ( _Leftish )
    {
      AgStringRef::AgStringRef(&right, &_Val->first);
      AgStringRef::AgStringRef(&left, &Parent->_Myval.first);
      v11 = AgString::caselessCompare(&left, &right) >= 0;
    }
    else
    {
      AgStringRef::AgStringRef(&v17, &Parent->_Myval.first);
      AgStringRef::AgStringRef(&v18, &_Val->first);
      v11 = AgString::caselessCompare(&v18, &v17) < 0;
    }
    if ( v11 )
      Parent = Parent->_Left;
    else
      Parent = Parent->_Right;
  }
  i = Myhead;
  if ( v11 )
  {
    if ( Myhead == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    {
      result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Insert_at<std::pair<AgString const,AgArchive::ArchiveEntry> &,std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *> *>(this, (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *)&left, 1, Myhead, _Val, _Newnode)->_Ptr;
      result->second = 1;
      return result;
    }
    if ( Myhead->_Isnil )
    {
      i = Myhead->_Right;
    }
    else if ( Myhead->_Left->_Isnil )
    {
      while ( 1 )
      {
        v14 = i->_Parent;
        if ( v14->_Isnil || i != v14->_Left )
          break;
        i = i->_Parent;
      }
      if ( !i->_Isnil )
        i = i->_Parent;
    }
    else
    {
      for ( i = Myhead->_Left; !i->_Right->_Isnil; i = i->_Right )
        ;
    }
  }
  AgStringRef::AgStringRef(&v18, &_Val->first);
  AgStringRef::AgStringRef(&v17, &i->_Myval.first);
  if ( AgString::caselessCompare(&v17, &v18) >= 0 )
  {
    left.m_text = (const char *)&_Newnode->_Myval;
    right.m_text = (const char *)&_Newnode->_Myval.second;
    AgString::~AgString(&_Newnode->_Myval.second.m_fileName);
    AgString::~AgString((AgString *)&_Newnode->_Myval.first);
    operator delete(_Newnode);
    result->first._Ptr = i;
    result->second = 0;
  }
  else
  {
    result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Insert_at<std::pair<AgString const,AgArchive::ArchiveEntry> &,std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *> *>(this, (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *)&left, v11, Myhead, _Val, _Newnode)->_Ptr;
    result->second = 1;
  }
  return result;
}

std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >,bool> *__fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Insert_nohint<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>> &,std::_Tree_node<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>,void *> *>(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >,bool> *result,
        bool _Leftish,
        std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > *_Val,
        std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *_Newnode)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Myhead; // rdi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Parent; // rbx
  bool v11; // si
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *i; // rbx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v14; // rax
  AgStringRef right; // [rsp+40h] [rbp-68h] BYREF
  AgStringRef left; // [rsp+50h] [rbp-58h] BYREF
  AgStringRef v17; // [rsp+60h] [rbp-48h] BYREF
  AgStringRef v18; // [rsp+70h] [rbp-38h] BYREF

  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  Parent = this->_Mypair._Myval2._Myval2._Myhead->_Parent;
  v11 = 1;
  while ( !Parent->_Isnil )
  {
    Myhead = Parent;
    if ( _Leftish )
    {
      AgStringRef::AgStringRef(&right, &_Val->first);
      AgStringRef::AgStringRef(&left, &Parent->_Myval.first);
      v11 = AgString::caselessCompare(&left, &right) >= 0;
    }
    else
    {
      AgStringRef::AgStringRef(&v17, &Parent->_Myval.first);
      AgStringRef::AgStringRef(&v18, &_Val->first);
      v11 = AgString::caselessCompare(&v18, &v17) < 0;
    }
    if ( v11 )
      Parent = Parent->_Left;
    else
      Parent = Parent->_Right;
  }
  i = Myhead;
  if ( v11 )
  {
    if ( Myhead == this->_Mypair._Myval2._Myval2._Myhead->_Left )
    {
      result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Insert_at<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>> &,std::_Tree_node<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>,void *> *>(this, (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *)&right, 1, Myhead, _Val, _Newnode)->_Ptr;
      result->second = 1;
      return result;
    }
    if ( Myhead->_Isnil )
    {
      i = Myhead->_Right;
    }
    else if ( Myhead->_Left->_Isnil )
    {
      while ( 1 )
      {
        v14 = i->_Parent;
        if ( v14->_Isnil || i != v14->_Left )
          break;
        i = i->_Parent;
      }
      if ( !i->_Isnil )
        i = i->_Parent;
    }
    else
    {
      for ( i = Myhead->_Left; !i->_Right->_Isnil; i = i->_Right )
        ;
    }
  }
  AgStringRef::AgStringRef(&v18, &_Val->first);
  AgStringRef::AgStringRef(&v17, &i->_Myval.first);
  if ( AgString::caselessCompare(&v17, &v18) >= 0 )
  {
    right.m_text = (const char *)&_Newnode->_Myval;
    std::vector<AgArchive::DirectoryEntry>::_Tidy(&_Newnode->_Myval.second);
    AgString::~AgString((AgString *)&_Newnode->_Myval.first);
    operator delete(_Newnode);
    result->first._Ptr = i;
    result->second = 0;
  }
  else
  {
    result->first = (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Insert_at<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>> &,std::_Tree_node<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>,void *> *>(this, (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *)&right, v11, Myhead, _Val, _Newnode)->_Ptr;
    result->second = 1;
  }
  return result;
}

AgArchive::DirectoryEntry *__fastcall std::_Uninitialized_move_al_unchecked1<AgArchive::DirectoryEntry *,AgArchive::DirectoryEntry *,std::allocator<AgArchive::DirectoryEntry>>(
        AgArchive::DirectoryEntry *_First,
        AgArchive::DirectoryEntry *_Last,
        AgArchive::DirectoryEntry *_Dest,
        std::_Wrap_alloc<std::allocator<AgArchive::DirectoryEntry> > *_Al)
{
  while ( _First != _Last )
  {
    if ( _Dest )
    {
      AgString::AgString(&_Dest->m_name, &_First->m_name);
      _Dest->m_isDirectory = _First->m_isDirectory;
    }
    ++_Dest;
    ++_First;
  }
  return _Dest;
}

void __fastcall std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *>>>::construct<std::pair<AgString const,AgArchive::ArchiveEntry>,std::pair<AgString,AgArchive::ArchiveEntry>>(
        std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> > > *this,
        std::pair<AgString const ,AgArchive::ArchiveEntry> *_Ptr,
        std::pair<AgString,AgArchive::ArchiveEntry> *<_Args_0>)
{
  if ( _Ptr )
  {
    AgString::AgString((AgString *)&_Ptr->first, &<_Args_0>->first);
    AgString::AgString(&_Ptr->second.m_fileName, &<_Args_0>->second.m_fileName);
    _Ptr->second.m_offset = <_Args_0>->second.m_offset;
    _Ptr->second.m_size = <_Args_0>->second.m_size;
  }
}

std::pair<AgString,AgArchive::ArchiveEntry> *__fastcall std::make_pair<AgString &,AgArchive::ArchiveEntry &>(
        std::pair<AgString,AgArchive::ArchiveEntry> *result,
        AgString *_Val1,
        AgArchive::ArchiveEntry *_Val2)
{
  AgString::AgString(&result->first, _Val1);
  AgString::AgString(&result->second.m_fileName, &_Val2->m_fileName);
  result->second.m_offset = _Val2->m_offset;
  result->second.m_size = _Val2->m_size;
  return result;
}

std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *__fastcall std::make_pair<AgString,std::vector<AgArchive::DirectoryEntry>>(
        std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *result,
        AgString *_Val1,
        std::vector<AgArchive::DirectoryEntry> *_Val2)
{
  AgString::AgString(&result->first, _Val1);
  result->second._Mypair._Myval2._Myfirst = 0i64;
  result->second._Mypair._Myval2._Mylast = 0i64;
  result->second._Mypair._Myval2._Myend = 0i64;
  result->second = *_Val2;
  _Val2->_Mypair._Myval2._Myfirst = 0i64;
  _Val2->_Mypair._Myval2._Mylast = 0i64;
  _Val2->_Mypair._Myval2._Myend = 0i64;
  return result;
}

void __fastcall AgPointer<AgMount>::AgPointer<AgMount>(AgPointer<AgMount> *this, AgMount *t)
{
  AgReferenceCount *v4; // rax
  int v5; // ecx
  AgReferenceCount *m_refCount; // rsi

  this->m_ref = 0i64;
  this->m_ptr = 0i64;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      v5 = 1;
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = t;
      }
      else
      {
        v4 = 0i64;
      }
      t->m_refCount = v4;
    }
    m_refCount = t->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(t->m_refCount);
    this->m_ref = m_refCount;
    this->m_ptr = t;
  }
}

void __fastcall AgArchive::AgArchive(AgArchive *this, const AgString *fileName, const AgString *mountPoint)
{
  const char *CString; // rax
  AgAsyncStreamReader *v6; // rbx
  AgPointer<AgStream> *v7; // rax
  AgAsyncStreamReader *v8; // rax
  AgAsyncStreamReader *v9; // rbx
  AgReferenceCount *v10; // rax
  int v11; // eax
  AgReferenceCount *m_refCount; // rdi
  AgPointer<AgStream> *v13; // rax
  AgFile *m_ptr; // rdi
  AgReferenceCount *m_ref; // rbx
  int v16; // er14
  AgPointer<AgAsyncStreamReader> v17; // [rsp+40h] [rbp-31h] BYREF
  AgPointer<AgFile> result; // [rsp+50h] [rbp-21h] BYREF
  AgString v19; // [rsp+60h] [rbp-11h] BYREF
  AgPointer<AgUser> v20; // [rsp+70h] [rbp-1h] BYREF
  AgPointer<AgStream> v21; // [rsp+80h] [rbp+Fh] BYREF
  AgPointer<AgStream> v22; // [rsp+90h] [rbp+1Fh] BYREF

  v20 = 0i64;
  AgMount::AgMount(this, mountPoint, &v20);
  this->__vftable = (AgArchive_vtbl *)&AgArchive::`vftable';
  AgString::AgString(&this->m_sourceFileName, fileName);
  this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead = 0i64;
  this->m_archiveEntries._Mypair._Myval2._Myval2._Mysize = 0i64;
  this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buyheadnode(&this->m_archiveEntries);
  this->m_directories._Mypair._Myval2._Myval2._Myhead = 0i64;
  this->m_directories._Mypair._Myval2._Myval2._Mysize = 0i64;
  this->m_directories._Mypair._Myval2._Myval2._Myhead = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buyheadnode(&this->m_directories);
  this->m_archiveSize = 0i64;
  this->m_overlays._Mypair._Myval2._Myhead = 0i64;
  this->m_overlays._Mypair._Myval2._Mysize = 0i64;
  this->m_overlays._Mypair._Myval2._Myhead = std::_List_alloc<std::_List_base_types<AgPointer<AgArchive>>>::_Buynode0(
                                               &this->m_overlays,
                                               0i64,
                                               0i64);
  CString = AgString::getCString((AgString *)fileName);
  AgTrace("[archive] Creating archive from %s", CString);
  AgString::AgString(&v19, fileName);
  AgPath::clean((AgPath *)&v19);
  AgFile::open(&result, (const AgPath *)&v19, 1u, 1);
  AgString::~AgString(&v19);
  if ( result.m_ptr && result.m_ptr->m_open )
  {
    v6 = (AgAsyncStreamReader *)operator new(0x100ui64);
    if ( v6 )
    {
      v17.m_ref = (AgReferenceCount *)&v21;
      v7 = AgPointer<AgFile>::operator<AgStream> AgPointer<AgStream>(&result, &v21);
      AgAsyncStreamReader::AgAsyncStreamReader(v6, v7, 4u, 0x10000ui64, 0i64, 0i64);
      v9 = v8;
    }
    else
    {
      v9 = 0i64;
    }
    v17 = 0i64;
    if ( v9 )
    {
      if ( v9->m_refCount )
      {
        v11 = 0;
      }
      else
      {
        v10 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
        if ( v10 )
        {
          v10->m_strongCount = 1;
          v10->m_weakCount = 1;
          v10->m_data = v9;
        }
        else
        {
          v10 = 0i64;
        }
        v9->m_refCount = v10;
        v11 = 1;
      }
      m_refCount = v9->m_refCount;
      if ( !v11 )
        AgReferenceCount::incRef(v9->m_refCount);
      v17.m_ref = m_refCount;
      v17.m_ptr = v9;
    }
    v13 = AgPointer<AgAsyncStreamReader>::operator<AgStream> AgPointer<AgStream>(&v17, &v22);
    AgArchive::_create(this, v13);
    AgMount::setError(this, 0);
    AgPointer<AgAsyncStreamReader>::~AgPointer<AgAsyncStreamReader>(&v17);
  }
  else
  {
    AgTrace("[archive] ERROR: Failed to open source .wad!");
    AgMount::setError(this, 1);
  }
  m_ptr = result.m_ptr;
  result.m_ptr = 0i64;
  m_ref = result.m_ref;
  if ( result.m_ref )
  {
    result.m_ref = 0i64;
    v16 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v16 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgFile *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v16 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgPointer<AgArchiveDirectory>::~AgPointer<AgArchiveDirectory>(AgPointer<AgArchiveDirectory> *this)
{
  AgArchiveDirectory *m_ptr; // rdi
  AgReferenceCount *m_ref; // rbx
  int v3; // esi

  m_ptr = this->m_ptr;
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( this->m_ref )
  {
    this->m_ref = 0i64;
    v3 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v3 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgArchiveDirectory *, __int64))m_ptr->~AgDirectory)(m_ptr, 1i64);
      if ( v3 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgPointer<AgAsyncStreamReader>::~AgPointer<AgAsyncStreamReader>(AgPointer<AgAsyncStreamReader> *this)
{
  AgAsyncStreamReader *m_ptr; // rdi
  AgReferenceCount *m_ref; // rbx
  int v3; // esi

  m_ptr = this->m_ptr;
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( this->m_ref )
  {
    this->m_ref = 0i64;
    v3 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v3 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgAsyncStreamReader *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v3 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgPointer<AgBlowfish>::~AgPointer<AgBlowfish>(AgPointer<AgBlowfish> *this)
{
  AgBlowfish *m_ptr; // rbp
  AgReferenceCount *m_ref; // rbx
  int v3; // edi

  m_ptr = this->m_ptr;
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( this->m_ref )
  {
    this->m_ref = 0i64;
    v3 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v3 = 1;
      m_ref->m_data = 0i64;
      operator delete(m_ptr, 0x1050ui64);
      if ( v3 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
}

void __fastcall AgReference<AgArchive>::~AgReference<AgArchive>(AgReference<AgArchive> *this)
{
  AgReferenceCount *m_ref; // rbx

  this->__vftable = (AgReference<AgArchive>_vtbl *)&AgReference<AgArchive>::`vftable';
  this->m_ptr = 0i64;
  m_ref = this->m_ref;
  if ( m_ref )
  {
    this->m_ref = 0i64;
    if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
      AgReferenceCount::operator delete(m_ref);
  }
}

void __fastcall std::_List_alloc<std::_List_base_types<AgPointer<AgArchive>>>::~_List_alloc<std::_List_base_types<AgPointer<AgArchive>>>(
        std::_List_alloc<std::_List_base_types<AgPointer<AgArchive>> > *this)
{
  operator delete(this->_Mypair._Myval2._Myhead);
}

void __fastcall std::_List_buy<AgPointer<AgArchive>>::~_List_buy<AgPointer<AgArchive>>(
        std::_List_buy<AgPointer<AgArchive>> *this)
{
  operator delete(this->_Mypair._Myval2._Myhead);
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::~_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::~_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::~_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this)
{
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::~_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this)
{
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::list<AgPointer<AgArchive>>::~list<AgPointer<AgArchive>>(std::list<AgPointer<AgArchive>> *this)
{
  std::list<AgPointer<AgArchive>>::clear(this);
  operator delete(this->_Mypair._Myval2._Myhead);
}

void __fastcall std::map<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>>::~map<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>>(
        std::map<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> > > *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::map<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>>::~map<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>>(
        std::map<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > *this)
{
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > result; // [rsp+48h] [rbp+10h] BYREF

  std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
    this,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->_Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->_Mypair._Myval2._Myval2._Myhead);
  operator delete(this->_Mypair._Myval2._Myval2._Myhead);
}

void __fastcall std::pair<AgString,AgArchive::ArchiveEntry>::~pair<AgString,AgArchive::ArchiveEntry>(
        std::pair<AgString,AgArchive::ArchiveEntry> *this)
{
  AgString::~AgString(&this->second.m_fileName);
  AgString::~AgString(&this->first);
}

void __fastcall std::pair<AgString,std::vector<AgArchive::DirectoryEntry>>::~pair<AgString,std::vector<AgArchive::DirectoryEntry>>(
        std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *this)
{
  std::vector<AgArchive::DirectoryEntry>::_Tidy(&this->second);
  AgString::~AgString(&this->first);
}

void __fastcall std::vector<AgArchive::DirectoryEntry>::~vector<AgArchive::DirectoryEntry>(
        std::vector<AgArchive::DirectoryEntry> *this)
{
  std::vector<AgArchive::DirectoryEntry>::_Tidy(this);
}

void __fastcall AgArchive::~AgArchive(AgArchive *this)
{
  std::list<AgPointer<AgArchive>> *p_m_overlays; // rbx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > result; // [rsp+50h] [rbp+18h] BYREF

  p_m_overlays = &this->m_overlays;
  std::list<AgPointer<AgArchive>>::clear(&this->m_overlays);
  operator delete(p_m_overlays->_Mypair._Myval2._Myhead);
  std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
    &this->m_directories,
    &result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->m_directories._Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)this->m_directories._Mypair._Myval2._Myval2._Myhead);
  operator delete(this->m_directories._Mypair._Myval2._Myval2._Myhead);
  std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
    &this->m_archiveEntries,
    (std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *)&result,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead->_Left,
    (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead);
  operator delete(this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead);
  AgString::~AgString(&this->m_sourceFileName);
  AgMount::~AgMount(this);
}

void __fastcall AgMount::~AgMount(AgMount *this, unsigned __int64 a2)
{
  this->__vftable = (AgMount_vtbl *)&AgMount::`vftable';
  operator delete(this->m_channel.m_counter.m_deltaTime, a2);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_finishedWriting);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_stateChanged);
  AgString::~AgString(&this->m_mountPoint);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&this->m_user);
  DeleteCriticalSection((LPCRITICAL_SECTION)&this->m_mutex);
}

void __fastcall AgArchive::ArchiveEntry::~ArchiveEntry(AgArchive::ArchiveEntry *this)
{
  AgString::~AgString(&this->m_fileName);
}

void __fastcall AgArchive::DirectoryEntry::~DirectoryEntry(AgArchive::DirectoryEntry *this)
{
  AgString::~AgString(&this->m_name);
}

AgPointer<AgArchiveDirectory> *__fastcall AgPointer<AgArchiveDirectory>::operator=(
        AgPointer<AgArchiveDirectory> *this,
        AgArchiveDirectory *t)
{
  AgArchiveDirectory *v2; // rdi
  AgReferenceCount *v4; // rax
  int v5; // eax
  AgReferenceCount *m_refCount; // rbp
  AgReferenceCount *m_ref; // rsi
  AgArchiveDirectory *m_ptr; // r14
  int v9; // edi

  v2 = t;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = v2;
      }
      v2->m_refCount = v4;
      v5 = 1;
    }
    m_refCount = v2->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(v2->m_refCount);
  }
  else
  {
    v2 = 0i64;
    m_refCount = 0i64;
  }
  m_ref = this->m_ref;
  m_ptr = this->m_ptr;
  this->m_ref = m_refCount;
  this->m_ptr = v2;
  if ( m_ref )
  {
    v9 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v9 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgArchiveDirectory *, __int64))m_ptr->~AgDirectory)(m_ptr, 1i64);
      if ( v9 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
  return this;
}

AgPointer<AgStream> *__fastcall AgPointer<AgStream>::operator=(
        AgPointer<AgStream> *this,
        const AgPointer<AgStream> *rhs)
{
  AgReferenceCount *m_ref; // rdi
  int m_strongCount; // ebx
  AgReferenceCount *v6; // rbx
  AgStream *m_ptr; // rdi
  int v8; // ebp
  AgPointer<AgStream> v10; // [rsp+28h] [rbp-20h]

  v10 = 0i64;
  m_ref = rhs->m_ref;
  if ( rhs->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          goto LABEL_8;
      }
      if ( m_strongCount != -1 )
        v10 = *rhs;
    }
  }
LABEL_8:
  v6 = this->m_ref;
  m_ptr = this->m_ptr;
  *this = v10;
  if ( v6 )
  {
    v8 = 0;
    if ( !AgAtomicDecrement(&v6->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&v6->m_weakCount) )
        v8 = 1;
      v6->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgStream *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v8 )
        AgReferenceCount::operator delete(v6);
    }
  }
  return this;
}

AgPointer<AgStream> *__fastcall AgPointer<AgStream>::operator=(AgPointer<AgStream> *this, AgStream *t)
{
  AgStream *v2; // rdi
  AgReferenceCount *v4; // rax
  int v5; // eax
  AgReferenceCount *m_refCount; // rbp
  AgReferenceCount *m_ref; // rsi
  AgStream *m_ptr; // r14
  int v9; // edi

  v2 = t;
  if ( t )
  {
    if ( t->m_refCount )
    {
      v5 = 0;
    }
    else
    {
      v4 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
      if ( v4 )
      {
        v4->m_strongCount = 1;
        v4->m_weakCount = 1;
        v4->m_data = v2;
      }
      v2->m_refCount = v4;
      v5 = 1;
    }
    m_refCount = v2->m_refCount;
    if ( !v5 )
      AgReferenceCount::incRef(v2->m_refCount);
  }
  else
  {
    v2 = 0i64;
    m_refCount = 0i64;
  }
  m_ref = this->m_ref;
  m_ptr = this->m_ptr;
  this->m_ref = m_refCount;
  this->m_ptr = v2;
  if ( m_ref )
  {
    v9 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v9 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgStream *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v9 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
  return this;
}

std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buyheadnode(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *result; // rax

  result = (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *)operator new(0x50ui64);
  if ( !result )
    invalid_parameter_noinfo_noreturn();
  result->_Left = result;
  if ( result != (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *)-8i64 )
    result->_Parent = result;
  if ( result != (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *)-16i64 )
    result->_Right = result;
  *(_WORD *)&result->_Color = 257;
  return result;
}

std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buyheadnode(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *result; // rax

  result = (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *)operator new(0x48ui64);
  if ( !result )
    invalid_parameter_noinfo_noreturn();
  result->_Left = result;
  if ( result != (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *)-8i64 )
    result->_Parent = result;
  if ( result != (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *)-16i64 )
    result->_Right = result;
  *(_WORD *)&result->_Color = 257;
  return result;
}

std::_List_node<AgPointer<AgArchive>,void *> *__fastcall std::_List_alloc<std::_List_base_types<AgPointer<AgArchive>>>::_Buynode0(
        std::_List_alloc<std::_List_base_types<AgPointer<AgArchive>> > *this,
        std::_List_node<AgPointer<AgArchive>,void *> *_Next,
        std::_List_node<AgPointer<AgArchive>,void *> *_Prev)
{
  std::_List_node<AgPointer<AgArchive>,void *> *result; // rax

  result = (std::_List_node<AgPointer<AgArchive>,void *> *)operator new(0x20ui64);
  if ( !result )
    invalid_parameter_noinfo_noreturn();
  if ( !_Next )
  {
    _Next = result;
    _Prev = result;
  }
  result->_Next = _Next;
  if ( result != (std::_List_node<AgPointer<AgArchive>,void *> *)-8i64 )
    result->_Prev = _Prev;
  return result;
}

std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> **__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buynode0(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> **v2; // rdx

  v2 = (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> **)operator new(0x50ui64);
  if ( !v2 )
    invalid_parameter_noinfo_noreturn();
  *v2 = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> **)-8i64 )
    v2[1] = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> **)-16i64 )
    v2[2] = this->_Mypair._Myval2._Myval2._Myhead;
  return v2;
}

std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> **__fastcall std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buynode0(
        std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> **v2; // rdx

  v2 = (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> **)operator new(0x48ui64);
  if ( !v2 )
    invalid_parameter_noinfo_noreturn();
  *v2 = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> **)-8i64 )
    v2[1] = this->_Mypair._Myval2._Myval2._Myhead;
  if ( v2 != (std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> **)-16i64 )
    v2[2] = this->_Mypair._Myval2._Myval2._Myhead;
  return v2;
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Destroy_if_not_nil(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Newnode)
{
  std::pair<AgString const ,AgArchive::ArchiveEntry> *p_Myval; // rbx

  p_Myval = &_Newnode->_Myval;
  AgString::~AgString(&_Newnode->_Myval.second.m_fileName);
  AgString::~AgString((AgString *)&p_Myval->first);
  operator delete(_Newnode);
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Destroy_if_not_nil(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *_Newnode)
{
  std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > *p_Myval; // rbx

  p_Myval = &_Newnode->_Myval;
  std::vector<AgArchive::DirectoryEntry>::_Tidy(&_Newnode->_Myval.second);
  AgString::~AgString((AgString *)&p_Myval->first);
  operator delete(_Newnode);
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Erase(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Rootnode)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v2; // rsi
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *i; // rbx

  v2 = _Rootnode;
  for ( i = _Rootnode; !i->_Isnil; v2 = i )
  {
    std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Erase(
      this,
      i->_Right);
    i = i->_Left;
    AgString::~AgString(&v2->_Myval.second.m_fileName);
    AgString::~AgString((AgString *)&v2->_Myval.first);
    operator delete(v2);
  }
}

void __fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Erase(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *_Rootnode)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v2; // rsi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *i; // rbx

  v2 = _Rootnode;
  for ( i = _Rootnode; !i->_Isnil; v2 = i )
  {
    std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Erase(
      this,
      i->_Right);
    i = i->_Left;
    std::vector<AgArchive::DirectoryEntry>::_Tidy(&v2->_Myval.second);
    AgString::~AgString((AgString *)&v2->_Myval.first);
    operator delete(v2);
  }
}

void __fastcall std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
        std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *this,
        std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *_Wherenode)
{
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Right; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Parent; // rax

  Right = _Wherenode->_Right;
  _Wherenode->_Right = Right->_Left;
  if ( !Right->_Left->_Isnil )
    Right->_Left->_Parent = _Wherenode;
  Right->_Parent = _Wherenode->_Parent;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Right;
    Right->_Left = _Wherenode;
    _Wherenode->_Parent = Right;
  }
  else
  {
    Parent = _Wherenode->_Parent;
    if ( _Wherenode == Parent->_Left )
      Parent->_Left = Right;
    else
      Parent->_Right = Right;
    Right->_Left = _Wherenode;
    _Wherenode->_Parent = Right;
  }
}

void __fastcall std::vector<AgArchive::DirectoryEntry>::_Reallocate(
        std::vector<AgArchive::DirectoryEntry> *this,
        unsigned __int64 _Count)
{
  AgArchive::DirectoryEntry *v4; // r14
  AgArchive::DirectoryEntry *Mylast; // rsi
  AgArchive::DirectoryEntry *Myfirst; // rbx
  signed __int64 v7; // r15

  v4 = (AgArchive::DirectoryEntry *)std::allocator<AgArchive::DirectoryEntry>::allocate(
                                      (std::allocator<AgJsonNode> *)this,
                                      _Count);
  std::_Uninitialized_move_al_unchecked1<AgArchive::DirectoryEntry *,AgArchive::DirectoryEntry *,std::allocator<AgArchive::DirectoryEntry>>(
    this->_Mypair._Myval2._Myfirst,
    this->_Mypair._Myval2._Mylast,
    v4,
    (std::_Wrap_alloc<std::allocator<AgArchive::DirectoryEntry> > *)this);
  Mylast = this->_Mypair._Myval2._Mylast;
  Myfirst = this->_Mypair._Myval2._Myfirst;
  v7 = Mylast - this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( ; Myfirst != Mylast; ++Myfirst )
      AgString::~AgString(&Myfirst->m_name);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)this,
      (AgJsonNode *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
  }
  this->_Mypair._Myval2._Myend = &v4[_Count];
  this->_Mypair._Myval2._Mylast = &v4[v7];
  this->_Mypair._Myval2._Myfirst = v4;
}

void __fastcall std::vector<AgArchive::DirectoryEntry>::_Reserve(
        std::vector<AgArchive::DirectoryEntry> *this,
        unsigned __int64 _Count)
{
  AgArchive::DirectoryEntry *Myend; // rcx
  AgArchive::DirectoryEntry *Mylast; // r9
  signed __int64 v6; // rdx
  unsigned __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx

  Myend = this->_Mypair._Myval2._Myend;
  Mylast = this->_Mypair._Myval2._Mylast;
  if ( Myend - Mylast < _Count )
  {
    v6 = Mylast - this->_Mypair._Myval2._Myfirst;
    if ( 0xAAAAAAAAAAAAAAAi64 - v6 < _Count )
      std::_Xlength_error("vector<T> too long");
    v7 = v6 + _Count;
    v8 = (unsigned __int128)(((char *)Myend - (char *)this->_Mypair._Myval2._Myfirst) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64;
    v9 = 0i64;
    v10 = ((unsigned __int64)v8 >> 63) + (v8 >> 2);
    if ( 0xAAAAAAAAAAAAAAAi64 - (v10 >> 1) >= v10 )
      v9 = v10 + (v10 >> 1);
    if ( v9 >= v7 )
      v7 = v9;
    std::vector<AgArchive::DirectoryEntry>::_Reallocate(this, v7);
  }
}

void __fastcall std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
        std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *this,
        std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *_Wherenode)
{
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Left; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Right; // rax
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *Parent; // rax

  Left = _Wherenode->_Left;
  _Wherenode->_Left = _Wherenode->_Left->_Right;
  Right = Left->_Right;
  if ( !Right->_Isnil )
    Right->_Parent = _Wherenode;
  Left->_Parent = _Wherenode->_Parent;
  if ( _Wherenode == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Left;
    Left->_Right = _Wherenode;
    _Wherenode->_Parent = Left;
  }
  else
  {
    Parent = _Wherenode->_Parent;
    if ( _Wherenode == Parent->_Right )
      Parent->_Right = Left;
    else
      Parent->_Left = Left;
    Left->_Right = _Wherenode;
    _Wherenode->_Parent = Left;
  }
}

void __fastcall std::vector<AgArchive::DirectoryEntry>::_Tidy(std::vector<AgArchive::DirectoryEntry> *this)
{
  AgArchive::DirectoryEntry *Myfirst; // rbx
  AgArchive::DirectoryEntry *i; // rdi

  Myfirst = this->_Mypair._Myval2._Myfirst;
  if ( this->_Mypair._Myval2._Myfirst )
  {
    for ( i = this->_Mypair._Myval2._Mylast; Myfirst != i; ++Myfirst )
      AgString::~AgString(&Myfirst->m_name);
    std::allocator<AgJsonNode>::deallocate(
      (std::allocator<AgJsonNode> *)this,
      (AgJsonNode *)this->_Mypair._Myval2._Myfirst,
      this->_Mypair._Myval2._Myend - this->_Mypair._Myval2._Myfirst);
    this->_Mypair._Myval2._Myfirst = 0i64;
    this->_Mypair._Myval2._Mylast = 0i64;
    this->_Mypair._Myval2._Myend = 0i64;
  }
}

void __fastcall AgArchive::_create(AgArchive *this, AgPointer<AgStream> *stream)
{
  AgArchive *v3; // r12
  AgReferenceCount *m_ref; // rdi
  int m_strongCount; // ebx
  int v6; // ebx
  int v7; // ebx
  unsigned int v8; // eax
  unsigned __int8 *v9; // r15
  AgBlowfish *v10; // rax
  AgBlowfish *v11; // rax
  AgBlowfish *m_ptr; // rdi
  AgReferenceCount *v13; // rax
  int v14; // eax
  AgReferenceCount *m_refCount; // rsi
  AgMemoryStream *v16; // rax
  AgStream *v17; // rax
  void *v18; // rsi
  AgStream *v19; // rbx
  AgStream_vtbl *v20; // rdi
  __int64 v21; // rax
  unsigned __int64 v22; // rdx
  unsigned int v23; // er15
  unsigned __int64 v24; // rdx
  void *v25; // rbx
  int i; // edi
  unsigned __int64 v27; // rdx
  const AgString *v28; // rax
  std::pair<AgString,AgArchive::ArchiveEntry> *v29; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *_Newnode; // rax
  int v31; // er13
  unsigned __int8 *v32; // rdi
  AgBlowfish *v33; // rax
  AgBlowfish *v34; // rax
  AgBlowfish *v35; // r12
  AgReferenceCount *v36; // rax
  int v37; // eax
  AgReferenceCount *v38; // rsi
  int j; // edi
  AgMemoryStream *v40; // rax
  int v41; // edi
  int v42; // edi
  std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *p_m_directories; // r13
  unsigned __int64 v44; // rdx
  AgString *v45; // rax
  std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > *v46; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v47; // rax
  AgArchive::DirectoryEntry *Myfirst; // rsi
  AgArchive::DirectoryEntry *v49; // rdi
  AgArchive::DirectoryEntry *k; // r12
  unsigned __int64 v51; // rdx
  AgArchive::DirectoryEntry *v52; // rax
  unsigned __int64 v53; // rsi
  int v54; // esi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Ptr; // r12
  unsigned __int64 v56; // rdx
  const AgString *v57; // rax
  AgStringRef *v58; // rax
  int v59; // edi
  AgStream *v60; // rdi
  AgReferenceCount *v61; // rbx
  int v62; // esi
  int v63; // [rsp+30h] [rbp-D0h] BYREF
  int v64; // [rsp+34h] [rbp-CCh] BYREF
  unsigned int size; // [rsp+38h] [rbp-C8h] BYREF
  int size_4; // [rsp+3Ch] [rbp-C4h] BYREF
  int v67; // [rsp+40h] [rbp-C0h] BYREF
  int v68; // [rsp+44h] [rbp-BCh] BYREF
  void *p_second; // [rsp+48h] [rbp-B8h]
  char text[4]; // [rsp+50h] [rbp-B0h] BYREF
  int v71; // [rsp+54h] [rbp-ACh] BYREF
  unsigned __int8 *v72; // [rsp+58h] [rbp-A8h]
  AgPointer<AgStream> rhs; // [rsp+60h] [rbp-A0h] BYREF
  AgArchive::ArchiveEntry _Val1; // [rsp+70h] [rbp-90h] BYREF
  __int128 v75; // [rsp+90h] [rbp-70h]
  std::vector<AgArchive::DirectoryEntry> _Val2; // [rsp+A0h] [rbp-60h] BYREF
  AgPointer<AgBlowfish> v77; // [rsp+B8h] [rbp-48h] BYREF
  AgString s1; // [rsp+C8h] [rbp-38h] BYREF
  AgArchive::DirectoryEntry v79; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v80; // [rsp+F0h] [rbp-10h]
  AgString v81; // [rsp+F8h] [rbp-8h] BYREF
  AgString v82; // [rsp+108h] [rbp+8h] BYREF
  std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >,bool> v83; // [rsp+118h] [rbp+18h] BYREF
  AgStringRef copy; // [rsp+130h] [rbp+30h] BYREF
  AgString v85; // [rsp+140h] [rbp+40h] BYREF
  std::pair<AgString,AgArchive::ArchiveEntry> result; // [rsp+150h] [rbp+50h] BYREF
  std::pair<AgString,std::vector<AgArchive::DirectoryEntry> > v87; // [rsp+180h] [rbp+80h] BYREF
  std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >,bool> v88; // [rsp+1A8h] [rbp+A8h] BYREF
  AgStringRef v89; // [rsp+1B8h] [rbp+B8h] BYREF
  char v91; // [rsp+230h] [rbp+130h] BYREF
  unsigned __int64 v92; // [rsp+238h] [rbp+138h] BYREF

  v80 = -2i64;
  v3 = this;
  AgTrace("[archive] Loading headers...");
  *(_DWORD *)text = 0;
  v67 = 0;
  v68 = 0;
  size_4 = 0;
  v63 = 0;
  stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)text, 4u);
  AgString::AgString(&s1, text, 4);
  if ( operator!=(&s1, "AGAR") )
  {
    v67 = 1;
    v68 = 0;
    size_4 = 0;
  }
  else
  {
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v67, 4u);
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v68, 4u);
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&size_4, 4u);
  }
  rhs = 0i64;
  m_ref = stream->m_ref;
  if ( stream->m_ref )
  {
    m_strongCount = m_ref->m_strongCount;
    if ( m_ref->m_strongCount )
    {
      while ( AgAtomicCompareExchange(&m_ref->m_strongCount, m_strongCount, m_strongCount + 1) != m_strongCount )
      {
        m_strongCount = m_ref->m_strongCount;
        if ( !m_ref->m_strongCount )
          goto LABEL_11;
      }
      if ( m_strongCount != -1 )
        rhs = *stream;
    }
  }
LABEL_11:
  if ( v67 > 1 || v67 == 1 && v68 >= 1 )
  {
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v63, 4u);
    v7 = v63;
    v8 = v63 & 0x80000000;
    v3->m_isEncrypted = v63 & 0x80000000;
    v6 = v7 & 0x7FFFFFFF;
    v63 = v6;
    if ( v8 )
    {
      v9 = (unsigned __int8 *)operator new[](v6);
      stream->m_ptr->read(stream->m_ptr, v9, v6);
      this->m_dataOffset = stream->m_ptr->getPosition(stream->m_ptr);
      v10 = (AgBlowfish *)operator new(0x1050ui64);
      p_second = v10;
      if ( v10 )
      {
        AgBlowfish::AgBlowfish(v10, key, 56);
        m_ptr = v11;
      }
      else
      {
        m_ptr = 0i64;
      }
      v77 = 0i64;
      if ( m_ptr )
      {
        if ( m_ptr->m_refCount )
        {
          v14 = 0;
        }
        else
        {
          v13 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
          p_second = v13;
          if ( v13 )
          {
            v13->m_strongCount = 1;
            v13->m_weakCount = 1;
            v13->m_data = m_ptr;
          }
          else
          {
            v13 = 0i64;
          }
          m_ptr->m_refCount = v13;
          v14 = 1;
        }
        m_refCount = m_ptr->m_refCount;
        if ( !v14 )
          AgReferenceCount::incRef(m_ptr->m_refCount);
        v77.m_ref = m_refCount;
        v77.m_ptr = m_ptr;
      }
      else
      {
        m_ptr = v77.m_ptr;
      }
      AgBlowfish::Decrypt(m_ptr, v9, v6);
      v16 = (AgMemoryStream *)AgMemoryPoolImpl<AgMutex,AgMutex>::_alloc(&AgMemoryStream::s_pool);
      p_second = v16;
      if ( v16 )
        AgMemoryStream::AgMemoryStream(v16, v9, v6, 1);
      else
        v17 = 0i64;
      AgPointer<AgStream>::operator=(stream, v17);
      stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v63, 4u);
      AgPointer<AgBlowfish>::~AgPointer<AgBlowfish>(&v77);
      v6 = v63;
      v3 = this;
    }
  }
  else
  {
    v6 = *(_DWORD *)text;
    v63 = *(_DWORD *)text;
  }
  if ( size_4 > 0 )
  {
    v18 = operator new[](size_4);
    v19 = stream->m_ptr;
    v20 = v19->__vftable;
    v21 = v19->getPosition(v19);
    v20->setPosition(v19, v21 + size_4);
    operator delete(v18, v22);
    v6 = v63;
  }
  AgTrace("[archive] Contains %i files", (unsigned int)v6);
  v23 = 256;
  v25 = operator new[](0x100ui64);
  for ( i = 0; i < v63; ++i )
  {
    size = 0;
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&size, 4u);
    if ( size > v23 )
    {
      operator delete(v25, v27);
      v23 = size;
      v25 = operator new[](size);
    }
    ((void (__fastcall *)(AgStream *, void *))stream->m_ptr->read)(stream->m_ptr, v25);
    *((_BYTE *)v25 + size) = 0;
    AgString::AgString(&_Val1.m_fileName);
    memset(&_Val1, 0, sizeof(_Val1));
    AgString::AgString(&v81, (const char *)v25, -1);
    AgString::operator=(&_Val1.m_fileName, v28);
    AgString::~AgString(&v81);
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&_Val1.m_size, 8u);
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&_Val1.m_offset, 8u);
    v29 = std::make_pair<AgString &,AgArchive::ArchiveEntry &>(&result, &_Val1.m_fileName, &_Val1);
    _Newnode = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Buynode<std::pair<AgString,AgArchive::ArchiveEntry>>(
                 &v3->m_archiveEntries,
                 v29);
    std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Insert_nohint<std::pair<AgString const,AgArchive::ArchiveEntry> &,std::_Tree_node<std::pair<AgString const,AgArchive::ArchiveEntry>,void *> *>(
      &v3->m_archiveEntries,
      &v88,
      0,
      &_Newnode->_Myval,
      _Newnode);
    p_second = &result.second;
    AgString::~AgString(&result.second.m_fileName);
    AgString::~AgString(&result.first);
    AgString::~AgString(&_Val1.m_fileName);
  }
  if ( v67 > 1 || v67 == 1 && v68 >= 1 )
  {
    AgPointer<AgStream>::operator=(stream, &rhs);
    v64 = 0;
    stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v64, 4u);
    v31 = v64 & 0x7FFFFFFF;
    v64 &= ~0x80000000;
    if ( v3->m_isEncrypted )
    {
      v32 = (unsigned __int8 *)operator new[](v31);
      v72 = v32;
      stream->m_ptr->read(stream->m_ptr, v32, v31);
      v3->m_dataOffset = stream->m_ptr->getPosition(stream->m_ptr);
      v33 = (AgBlowfish *)operator new(0x1050ui64);
      p_second = v33;
      if ( v33 )
      {
        AgBlowfish::AgBlowfish(v33, key_0, 56);
        v35 = v34;
      }
      else
      {
        v35 = 0i64;
      }
      v75 = 0i64;
      if ( v35 )
      {
        if ( v35->m_refCount )
        {
          v37 = 0;
        }
        else
        {
          v36 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
          p_second = v36;
          if ( v36 )
          {
            v36->m_strongCount = 1;
            v36->m_weakCount = 1;
            v36->m_data = v35;
          }
          v35->m_refCount = v36;
          v37 = 1;
        }
        v38 = v35->m_refCount;
        if ( !v37 )
        {
          for ( j = v38->m_strongCount; v38->m_strongCount; j = v38->m_strongCount )
          {
            if ( AgAtomicCompareExchange(&v38->m_strongCount, j, j + 1) == j )
              break;
          }
          v32 = v72;
        }
        *(_QWORD *)&v75 = v38;
        *((_QWORD *)&v75 + 1) = v35;
      }
      else
      {
        v35 = (AgBlowfish *)*((_QWORD *)&v75 + 1);
        v38 = (AgReferenceCount *)v75;
      }
      AgBlowfish::Decrypt(v35, v32, v31);
      v40 = (AgMemoryStream *)AgMemoryPoolImpl<AgMutex,AgMutex>::_alloc(&AgMemoryStream::s_pool);
      p_second = v40;
      if ( v40 )
        AgMemoryStream::AgMemoryStream(v40, v32, v31, 1);
      AgPointer<AgStream>::operator=(stream, v40);
      stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v64, 4u);
      *((_QWORD *)&v75 + 1) = 0i64;
      if ( v38 )
      {
        *(_QWORD *)&v75 = 0i64;
        v41 = 0;
        if ( !AgAtomicDecrement(&v38->m_strongCount) )
        {
          if ( !AgAtomicDecrement(&v38->m_weakCount) )
            v41 = 1;
          v38->m_data = 0i64;
          operator delete(v35, 0x1050ui64);
          if ( v41 )
            AgReferenceCount::operator delete(v38);
        }
      }
      v31 = v64;
      v3 = this;
    }
    v42 = 0;
    LODWORD(v72) = 0;
    if ( v31 > 0 )
    {
      p_m_directories = &v3->m_directories;
      do
      {
        LODWORD(v92) = 0;
        stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v92, 4u);
        if ( (unsigned int)v92 > v23 )
        {
          operator delete(v25, v44);
          v23 = v92;
          v25 = operator new[]((unsigned int)v92);
        }
        ((void (__fastcall *)(AgStream *, void *))stream->m_ptr->read)(stream->m_ptr, v25);
        *((_BYTE *)v25 + (unsigned int)v92) = 0;
        v71 = 0;
        stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v71, 4u);
        memset(&_Val2, 0, sizeof(_Val2));
        AgString::AgString(&v82, (const char *)v25, -1);
        v46 = std::make_pair<AgString,std::vector<AgArchive::DirectoryEntry>>(&v87, v45, &_Val2);
        v47 = std::_Tree_comp_alloc<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Buynode<std::pair<AgString,std::vector<AgArchive::DirectoryEntry>>>(
                p_m_directories,
                v46);
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Insert_nohint<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>> &,std::_Tree_node<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>,void *> *>(
          p_m_directories,
          &v83,
          0,
          &v47->_Myval,
          v47);
        std::vector<AgArchive::DirectoryEntry>::_Tidy(&v87.second);
        AgString::~AgString(&v87.first);
        AgString::~AgString(&v82);
        Myfirst = _Val2._Mypair._Myval2._Myfirst;
        if ( _Val2._Mypair._Myval2._Myfirst )
        {
          v49 = _Val2._Mypair._Myval2._Myfirst;
          p_second = _Val2._Mypair._Myval2._Myfirst;
          for ( k = _Val2._Mypair._Myval2._Mylast; v49 != k; p_second = v49 )
          {
            AgString::~AgString(&v49->m_name);
            ++v49;
          }
          v51 = _Val2._Mypair._Myval2._Myend - Myfirst;
          if ( v51 > 0xAAAAAAAAAAAAAAAi64 )
            invalid_parameter_noinfo_noreturn();
          if ( 24 * v51 >= 0x1000 )
          {
            if ( ((unsigned __int8)Myfirst & 0x1F) != 0 )
              invalid_parameter_noinfo_noreturn();
            v52 = *(AgArchive::DirectoryEntry **)&Myfirst[-1].m_isDirectory;
            if ( v52 >= Myfirst )
              invalid_parameter_noinfo_noreturn();
            v53 = (char *)Myfirst - (char *)v52;
            if ( v53 < 8 )
              invalid_parameter_noinfo_noreturn();
            if ( v53 > 0x27 )
              invalid_parameter_noinfo_noreturn();
            Myfirst = v52;
          }
          operator delete(Myfirst);
          memset(&_Val2, 0, sizeof(_Val2));
          v42 = (int)v72;
        }
        v54 = 0;
        if ( v71 > 0 )
        {
          Ptr = v83.first._Ptr;
          do
          {
            LODWORD(v92) = 0;
            stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v92, 4u);
            if ( (unsigned int)v92 > v23 )
            {
              operator delete(v25, v56);
              v23 = v92;
              v25 = operator new[]((unsigned int)v92);
            }
            ((void (__fastcall *)(AgStream *, void *))stream->m_ptr->read)(stream->m_ptr, v25);
            *((_BYTE *)v25 + (unsigned int)v92) = 0;
            stream->m_ptr->read(stream->m_ptr, (unsigned __int8 *)&v91, 1u);
            AgString::AgString(&v85, (const char *)v25, -1);
            AgStringRef::AgStringRef(&v89, v57);
            copy = *v58;
            v59 = v91 != 0;
            AgString::AgString(&v79.m_name, &copy);
            v79.m_isDirectory = v59;
            std::vector<AgArchive::DirectoryEntry>::push_back(&Ptr->_Myval.second, &v79);
            AgString::~AgString(&v79.m_name);
            AgString::~AgString(&v85);
            ++v54;
          }
          while ( v54 < v71 );
          v42 = (int)v72;
        }
        LODWORD(v72) = ++v42;
      }
      while ( v42 < v64 );
    }
  }
  operator delete(v25, v24);
  if ( !this->m_isEncrypted )
    this->m_dataOffset = stream->m_ptr->getPosition(stream->m_ptr);
  AgTrace("[archive] Current data offset: %ul bytes", this->m_dataOffset);
  v60 = rhs.m_ptr;
  rhs.m_ptr = 0i64;
  v61 = rhs.m_ref;
  if ( rhs.m_ref )
  {
    rhs.m_ref = 0i64;
    v62 = 0;
    if ( !AgAtomicDecrement(&v61->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&v61->m_weakCount) )
        v62 = 1;
      v61->m_data = 0i64;
      if ( v60 )
        ((void (__fastcall *)(AgStream *, __int64))v60->~AgStream)(v60, 1i64);
      if ( v62 )
        AgReferenceCount::operator delete(v61);
    }
  }
  AgString::~AgString(&s1);
  AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)stream);
}

AgJsonNode *__fastcall std::allocator<AgArchive::DirectoryEntry>::allocate(
        std::allocator<AgJsonNode> *this,
        unsigned __int64 _Count)
{
  AgJsonNode *result; // rax
  unsigned __int64 v3; // rcx
  AgJsonNodeData *v4; // rax
  AgJsonNodeData *v5; // rcx

  if ( !_Count )
    return 0i64;
  if ( _Count > 0xAAAAAAAAAAAAAAAi64 )
    std::_Xbad_alloc();
  v3 = 24 * _Count;
  if ( 24 * _Count < 0x1000 )
  {
    result = (AgJsonNode *)operator new(v3);
    if ( !result )
      invalid_parameter_noinfo_noreturn();
  }
  else
  {
    if ( v3 + 39 <= v3 )
      std::_Xbad_alloc();
    v4 = (AgJsonNodeData *)operator new(v3 + 39);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    result = (AgJsonNode *)(((unsigned __int64)&v4[1].m_refCount + 7) & 0xFFFFFFFFFFFFFFE0ui64);
    result[-1].m_data.m_ptr = v5;
  }
  return result;
}

void __fastcall std::list<AgPointer<AgArchive>>::clear(std::list<AgPointer<AgArchive>> *this)
{
  std::_List_node<AgPointer<AgArchive>,void *> *Next; // rbx
  std::_List_node<AgPointer<AgArchive>,void *> *v3; // rdi

  Next = this->_Mypair._Myval2._Myhead->_Next;
  this->_Mypair._Myval2._Myhead->_Next = this->_Mypair._Myval2._Myhead;
  this->_Mypair._Myval2._Myhead->_Prev = this->_Mypair._Myval2._Myhead;
  this->_Mypair._Myval2._Mysize = 0i64;
  if ( Next != this->_Mypair._Myval2._Myhead )
  {
    do
    {
      v3 = Next->_Next;
      AgPointer<AgUser>::~AgPointer<AgUser>((AgPointer<KOFApplication> *)&Next->_Myval);
      operator delete(Next);
      Next = v3;
    }
    while ( v3 != this->_Mypair._Myval2._Myhead );
  }
}

_BOOL8 __fastcall AgArchive::containsFile(AgArchive *this, const AgString *fileName)
{
  std::_List_node<AgPointer<AgArchive>,void *> *Myhead; // rax
  std::_List_node<AgPointer<AgArchive>,void *> **p_Prev; // rbx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v5; // rbx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v6; // rsi
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *i; // rdi
  AgStringRef right; // [rsp+20h] [rbp-48h] BYREF
  AgStringRef left; // [rsp+30h] [rbp-38h] BYREF
  AgStringRef v11; // [rsp+40h] [rbp-28h] BYREF
  AgStringRef v12; // [rsp+50h] [rbp-18h] BYREF
  AgString *str; // [rsp+78h] [rbp+10h]

  str = (AgString *)fileName;
  Myhead = this->m_overlays._Mypair._Myval2._Myhead;
  if ( Myhead == Myhead->_Next )
  {
LABEL_4:
    v5 = this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead;
    v6 = v5;
    for ( i = v5->_Parent; !i->_Isnil; fileName = str )
    {
      AgStringRef::AgStringRef(&right, fileName);
      AgStringRef::AgStringRef(&left, &i->_Myval.first);
      if ( AgString::caselessCompare(&left, &right) >= 0 )
      {
        v6 = i;
        i = i->_Left;
      }
      else
      {
        i = i->_Right;
      }
    }
    if ( v6 == this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead
      || (AgStringRef::AgStringRef(&v11, &v6->_Myval.first),
          AgStringRef::AgStringRef(&v12, str),
          AgString::caselessCompare(&v12, &v11) < 0) )
    {
      v6 = this->m_archiveEntries._Mypair._Myval2._Myval2._Myhead;
    }
    return v6 != v5;
  }
  else
  {
    while ( 1 )
    {
      p_Prev = &Myhead->_Prev;
      if ( AgArchive::containsFile(Myhead->_Prev->_Myval.m_ptr, fileName) == 1 )
        return 1i64;
      Myhead = *p_Prev;
      fileName = str;
      if ( *p_Prev == this->m_overlays._Mypair._Myval2._Myhead->_Next )
        goto LABEL_4;
    }
  }
}

__int64 __fastcall AgHttp::onSingletonExit(__crt_locale_data *__formal)
{
  return 0i64;
}

AgPointer<AgStream> *__fastcall AgArchive::createSourceStreamPtr(AgArchive *this, AgPointer<AgStream> *result)
{
  AgFile *m_ptr; // rsi
  AgReferenceCount *m_ref; // rdi
  int v5; // ebp
  AgPointer<AgFile> resulta; // [rsp+30h] [rbp-38h] BYREF
  AgPath path; // [rsp+40h] [rbp-28h] BYREF

  AgString::AgString(&path.m_path, &this->m_sourceFileName);
  AgPath::clean(&path);
  AgFile::open(&resulta, &path, 1u, 1);
  AgString::~AgString(&path.m_path);
  AgFile::waitOpen(resulta.m_ptr);
  AgPointer<AgFile>::operator<AgStream> AgPointer<AgStream>(&resulta, result);
  m_ptr = resulta.m_ptr;
  resulta.m_ptr = 0i64;
  m_ref = resulta.m_ref;
  if ( resulta.m_ref )
  {
    resulta.m_ref = 0i64;
    v5 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v5 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgFile *, __int64))m_ptr->~AgStream)(m_ptr, 1i64);
      if ( v5 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
  return result;
}

void __fastcall std::allocator<AgJsonNode>::deallocate(
        std::allocator<AgJsonNode> *this,
        AgJsonNode *_Ptr,
        unsigned __int64 _Count)
{
  AgJsonNodeData *m_ptr; // rax
  char *v4; // rdx

  if ( _Count > 0xAAAAAAAAAAAAAAAi64 )
    invalid_parameter_noinfo_noreturn();
  if ( 24 * _Count >= 0x1000 )
  {
    if ( ((unsigned __int8)_Ptr & 0x1F) != 0 )
      invalid_parameter_noinfo_noreturn();
    m_ptr = _Ptr[-1].m_data.m_ptr;
    if ( m_ptr >= (AgJsonNodeData *)_Ptr )
      invalid_parameter_noinfo_noreturn();
    v4 = (char *)((char *)_Ptr - (char *)m_ptr);
    if ( (unsigned __int64)v4 < 8 )
      invalid_parameter_noinfo_noreturn();
    if ( (unsigned __int64)v4 > 0x27 )
      invalid_parameter_noinfo_noreturn();
    _Ptr = (AgJsonNode *)m_ptr;
  }
  operator delete(_Ptr);
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > _First,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > _Last)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Myhead; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v7; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Left; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *v9; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v10; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Right; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *j; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *i; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > resulta; // [rsp+30h] [rbp+8h] BYREF
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v15; // [rsp+40h] [rbp+18h]
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Ptr; // [rsp+48h] [rbp+20h]

  Ptr = _Last._Ptr;
  v15 = _First._Ptr;
  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  if ( _First._Ptr == this->_Mypair._Myval2._Myval2._Myhead->_Left && _Last._Ptr == Myhead )
  {
    std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::_Erase(
      this,
      Myhead->_Parent);
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Right = this->_Mypair._Myval2._Myval2._Myhead;
    v7 = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Mysize = 0i64;
    Left = v7->_Left;
    v9 = result;
    result->_Ptr = Left;
  }
  else
  {
    if ( _First._Ptr != _Last._Ptr )
    {
      do
      {
        v10 = _First._Ptr;
        if ( !_First._Ptr->_Isnil )
        {
          Right = _First._Ptr->_Right;
          if ( Right->_Isnil )
          {
            for ( i = _First._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
            {
              if ( _First._Ptr != i->_Right )
                break;
              v15 = i;
              _First._Ptr = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
              Right = j;
            v15 = Right;
          }
        }
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
          this,
          &resulta,
          (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > >)v10);
        _First._Ptr = v15;
      }
      while ( v15 != Ptr );
    }
    v9 = result;
    result->_Ptr = _First._Ptr;
  }
  return v9;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const,AgArchive::ArchiveEntry>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<AgString,AgArchive::ArchiveEntry,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,AgArchive::ArchiveEntry> >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > _Where)
{
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v5; // rsi
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Right; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *j; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *i; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Left; // rdi
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Parent; // rbx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v11; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *k; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v13; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *m; // rax
  std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *v15; // rax
  char Color; // cl
  bool n; // zf
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v18; // rdx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v19; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *v20; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v21; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v22; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v23; // rcx
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v24; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *v25; // rax
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<AgString const ,AgArchive::ArchiveEntry>,void *> *Ptr; // [rsp+60h] [rbp+18h]

  Ptr = _Where._Ptr;
  v5 = _Where._Ptr;
  if ( !_Where._Ptr->_Isnil )
  {
    Right = _Where._Ptr->_Right;
    if ( Right->_Isnil )
    {
      for ( i = _Where._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
      {
        if ( _Where._Ptr != i->_Right )
          break;
        _Where._Ptr = i;
      }
      _Where._Ptr = i;
      Ptr = i;
    }
    else
    {
      _Where._Ptr = _Where._Ptr->_Right;
      for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
        _Where._Ptr = j;
      Ptr = _Where._Ptr;
    }
  }
  if ( v5->_Left->_Isnil )
  {
    Left = v5->_Right;
  }
  else if ( v5->_Right->_Isnil )
  {
    Left = v5->_Left;
  }
  else
  {
    Left = _Where._Ptr->_Right;
    if ( _Where._Ptr != v5 )
    {
      v5->_Left->_Parent = _Where._Ptr;
      _Where._Ptr->_Left = v5->_Left;
      if ( _Where._Ptr == v5->_Right )
      {
        Parent = _Where._Ptr;
      }
      else
      {
        Parent = _Where._Ptr->_Parent;
        if ( !Left->_Isnil )
          Left->_Parent = Parent;
        Parent->_Left = Left;
        _Where._Ptr->_Right = v5->_Right;
        v5->_Right->_Parent = _Where._Ptr;
      }
      if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
      {
        this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Where._Ptr;
      }
      else
      {
        v15 = (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,AgArchive::ArchiveEntry> > > > *)v5->_Parent;
        if ( v15->_Ptr == v5 )
          v15->_Ptr = _Where._Ptr;
        else
          v15[2]._Ptr = _Where._Ptr;
      }
      _Where._Ptr->_Parent = v5->_Parent;
      Color = _Where._Ptr->_Color;
      _Where._Ptr->_Color = v5->_Color;
      v5->_Color = Color;
      goto LABEL_45;
    }
  }
  Parent = v5->_Parent;
  if ( !Left->_Isnil )
    Left->_Parent = Parent;
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Left;
  }
  else if ( Parent->_Left == v5 )
  {
    Parent->_Left = Left;
  }
  else
  {
    Parent->_Right = Left;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Left == v5 )
  {
    if ( Left->_Isnil )
    {
      v11 = Parent;
    }
    else
    {
      v11 = Left;
      for ( k = Left->_Left; !k->_Isnil; k = k->_Left )
        v11 = k;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Left = v11;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Right == v5 )
  {
    if ( Left->_Isnil )
    {
      v13 = Parent;
    }
    else
    {
      v13 = Left;
      for ( m = Left->_Right; !m->_Isnil; m = m->_Right )
        v13 = m;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Right = v13;
  }
LABEL_45:
  if ( v5->_Color != 1 )
    goto LABEL_84;
  for ( n = Left == this->_Mypair._Myval2._Myval2._Myhead->_Parent;
        !n;
        n = v18 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    v18 = Parent;
    v19 = Parent;
    if ( Left->_Color != 1 )
      break;
    v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
    if ( Left == Parent->_Left )
    {
      v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v21 = Parent->_Right;
        Parent->_Right = v21->_Left;
        if ( !v21->_Left->_Isnil )
          v21->_Left->_Parent = Parent;
        v21->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
        }
        else
        {
          v22 = Parent->_Parent;
          if ( Parent == v22->_Left )
            v22->_Left = v21;
          else
            v22->_Right = v21;
        }
        v21->_Left = Parent;
        Parent->_Parent = v21;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Left->_Color != 1 || v20->_Right->_Color != 1 )
        {
          if ( v20->_Right->_Color == 1 )
          {
            v20->_Left->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Right->_Color = 1;
          std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
LABEL_75:
        v20->_Color = 0;
      }
    }
    else
    {
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v23 = Parent->_Left;
        Parent->_Left = Parent->_Left->_Right;
        v24 = v23->_Right;
        if ( !v24->_Isnil )
          v24->_Parent = Parent;
        v23->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v23;
        }
        else
        {
          v25 = Parent->_Parent;
          if ( Parent == v25->_Right )
            v25->_Right = v23;
          else
            v25->_Left = v23;
        }
        v23->_Right = Parent;
        Parent->_Parent = v23;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Right->_Color != 1 || v20->_Left->_Color != 1 )
        {
          if ( v20->_Left->_Color == 1 )
          {
            v20->_Right->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Left->_Color = 1;
          std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
        goto LABEL_75;
      }
    }
    Parent = Parent->_Parent;
    Left = v19;
  }
  Left->_Color = 1;
LABEL_84:
  AgString::~AgString(&v5->_Myval.second.m_fileName);
  AgString::~AgString((AgString *)&v5->_Myval.first);
  operator delete(v5);
  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize )
    this->_Mypair._Myval2._Myval2._Mysize = Mysize - 1;
  result->_Ptr = Ptr;
  return result;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > _First,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > _Last)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Myhead; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v7; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Left; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *v9; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v10; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Right; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *j; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *i; // rcx
  std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > resulta; // [rsp+30h] [rbp+8h] BYREF
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v15; // [rsp+40h] [rbp+18h]
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Ptr; // [rsp+48h] [rbp+20h]

  Ptr = _Last._Ptr;
  v15 = _First._Ptr;
  Myhead = this->_Mypair._Myval2._Myval2._Myhead;
  if ( _First._Ptr == this->_Mypair._Myval2._Myval2._Myhead->_Left && _Last._Ptr == Myhead )
  {
    std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::_Erase(
      this,
      Myhead->_Parent);
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Left = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Myhead->_Right = this->_Mypair._Myval2._Myval2._Myhead;
    v7 = this->_Mypair._Myval2._Myval2._Myhead;
    this->_Mypair._Myval2._Myval2._Mysize = 0i64;
    Left = v7->_Left;
    v9 = result;
    result->_Ptr = Left;
  }
  else
  {
    if ( _First._Ptr != _Last._Ptr )
    {
      do
      {
        v10 = _First._Ptr;
        if ( !_First._Ptr->_Isnil )
        {
          Right = _First._Ptr->_Right;
          if ( Right->_Isnil )
          {
            for ( i = _First._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
            {
              if ( _First._Ptr != i->_Right )
                break;
              v15 = i;
              _First._Ptr = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
              Right = j;
            v15 = Right;
          }
        }
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
          this,
          &resulta,
          (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > >)v10);
        _First._Ptr = v15;
      }
      while ( v15 != Ptr );
    }
    v9 = result;
    result->_Ptr = _First._Ptr;
  }
  return v9;
}

std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *__fastcall std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const,std::vector<AgArchive::DirectoryEntry>>>,0>>::erase(
        std::_Tree<std::_Tmap_traits<AgString,std::vector<AgArchive::DirectoryEntry>,AgArchiveMapCompare,std::allocator<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > >,0> > *this,
        std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *result,
        std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > _Where)
{
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v5; // rsi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Right; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *j; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *i; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Left; // rdi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Parent; // rbx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v11; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *k; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v13; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *m; // rax
  std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *v15; // rax
  char Color; // cl
  bool n; // zf
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v18; // rdx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v19; // r8
  std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *v20; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v21; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v22; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v23; // rcx
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v24; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *v25; // rax
  unsigned __int64 Mysize; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Ptr; // [rsp+60h] [rbp+18h]

  Ptr = _Where._Ptr;
  v5 = _Where._Ptr;
  if ( !_Where._Ptr->_Isnil )
  {
    Right = _Where._Ptr->_Right;
    if ( Right->_Isnil )
    {
      for ( i = _Where._Ptr->_Parent; !i->_Isnil; i = i->_Parent )
      {
        if ( _Where._Ptr != i->_Right )
          break;
        _Where._Ptr = i;
      }
      _Where._Ptr = i;
      Ptr = i;
    }
    else
    {
      _Where._Ptr = _Where._Ptr->_Right;
      for ( j = Right->_Left; !j->_Isnil; j = j->_Left )
        _Where._Ptr = j;
      Ptr = _Where._Ptr;
    }
  }
  if ( v5->_Left->_Isnil )
  {
    Left = v5->_Right;
  }
  else if ( v5->_Right->_Isnil )
  {
    Left = v5->_Left;
  }
  else
  {
    Left = _Where._Ptr->_Right;
    if ( _Where._Ptr != v5 )
    {
      v5->_Left->_Parent = _Where._Ptr;
      _Where._Ptr->_Left = v5->_Left;
      if ( _Where._Ptr == v5->_Right )
      {
        Parent = _Where._Ptr;
      }
      else
      {
        Parent = _Where._Ptr->_Parent;
        if ( !Left->_Isnil )
          Left->_Parent = Parent;
        Parent->_Left = Left;
        _Where._Ptr->_Right = v5->_Right;
        v5->_Right->_Parent = _Where._Ptr;
      }
      if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
      {
        this->_Mypair._Myval2._Myval2._Myhead->_Parent = _Where._Ptr;
      }
      else
      {
        v15 = (std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> > > > > *)v5->_Parent;
        if ( v15->_Ptr == v5 )
          v15->_Ptr = _Where._Ptr;
        else
          v15[2]._Ptr = _Where._Ptr;
      }
      _Where._Ptr->_Parent = v5->_Parent;
      Color = _Where._Ptr->_Color;
      _Where._Ptr->_Color = v5->_Color;
      v5->_Color = Color;
      goto LABEL_45;
    }
  }
  Parent = v5->_Parent;
  if ( !Left->_Isnil )
    Left->_Parent = Parent;
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Parent == v5 )
  {
    this->_Mypair._Myval2._Myval2._Myhead->_Parent = Left;
  }
  else if ( Parent->_Left == v5 )
  {
    Parent->_Left = Left;
  }
  else
  {
    Parent->_Right = Left;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Left == v5 )
  {
    if ( Left->_Isnil )
    {
      v11 = Parent;
    }
    else
    {
      v11 = Left;
      for ( k = Left->_Left; !k->_Isnil; k = k->_Left )
        v11 = k;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Left = v11;
  }
  if ( this->_Mypair._Myval2._Myval2._Myhead->_Right == v5 )
  {
    if ( Left->_Isnil )
    {
      v13 = Parent;
    }
    else
    {
      v13 = Left;
      for ( m = Left->_Right; !m->_Isnil; m = m->_Right )
        v13 = m;
    }
    this->_Mypair._Myval2._Myval2._Myhead->_Right = v13;
  }
LABEL_45:
  if ( v5->_Color != 1 )
    goto LABEL_84;
  for ( n = Left == this->_Mypair._Myval2._Myval2._Myhead->_Parent;
        !n;
        n = v18 == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
  {
    v18 = Parent;
    v19 = Parent;
    if ( Left->_Color != 1 )
      break;
    v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
    if ( Left == Parent->_Left )
    {
      v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v21 = Parent->_Right;
        Parent->_Right = v21->_Left;
        if ( !v21->_Left->_Isnil )
          v21->_Left->_Parent = Parent;
        v21->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v21;
        }
        else
        {
          v22 = Parent->_Parent;
          if ( Parent == v22->_Left )
            v22->_Left = v21;
          else
            v22->_Right = v21;
        }
        v21->_Left = Parent;
        Parent->_Parent = v21;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Left->_Color != 1 || v20->_Right->_Color != 1 )
        {
          if ( v20->_Right->_Color == 1 )
          {
            v20->_Left->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Right;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Right->_Color = 1;
          std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
LABEL_75:
        v20->_Color = 0;
      }
    }
    else
    {
      if ( !v20->_Color )
      {
        v20->_Color = 1;
        Parent->_Color = 0;
        v23 = Parent->_Left;
        Parent->_Left = Parent->_Left->_Right;
        v24 = v23->_Right;
        if ( !v24->_Isnil )
          v24->_Parent = Parent;
        v23->_Parent = Parent->_Parent;
        if ( Parent == this->_Mypair._Myval2._Myval2._Myhead->_Parent )
        {
          this->_Mypair._Myval2._Myval2._Myhead->_Parent = v23;
        }
        else
        {
          v25 = Parent->_Parent;
          if ( Parent == v25->_Right )
            v25->_Right = v23;
          else
            v25->_Left = v23;
        }
        v23->_Right = Parent;
        Parent->_Parent = v23;
        v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
      }
      if ( !v20->_Isnil )
      {
        if ( v20->_Right->_Color != 1 || v20->_Left->_Color != 1 )
        {
          if ( v20->_Left->_Color == 1 )
          {
            v20->_Right->_Color = 1;
            v20->_Color = 0;
            std::_Tree<std::_Tmap_traits<AgControllerUID,FighterOperationMapper,std::less<AgControllerUID>,std::allocator<std::pair<AgControllerUID const,FighterOperationMapper>>,0>>::_Lrotate(
              (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
              v20);
            v20 = (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent->_Left;
          }
          v20->_Color = Parent->_Color;
          Parent->_Color = 1;
          v20->_Left->_Color = 1;
          std::_Tree<std::_Tmap_traits<enum AgControllerComponentType,std::list<AgControllerComponent *>,std::less<enum AgControllerComponentType>,std::allocator<std::pair<enum AgControllerComponentType const,std::list<AgControllerComponent *>>>,0>>::_Rrotate(
            (std::_Tree<std::_Tmap_traits<AgStringRef,AgJsonNode,std::less<AgStringRef>,std::allocator<std::pair<AgStringRef const ,AgJsonNode> >,0> > *)this,
            (std::_Tree_node<std::pair<AgStringRef const ,AgJsonNode>,void *> *)Parent);
          break;
        }
        goto LABEL_75;
      }
    }
    Parent = Parent->_Parent;
    Left = v19;
  }
  Left->_Color = 1;
LABEL_84:
  std::vector<AgArchive::DirectoryEntry>::_Tidy(&v5->_Myval.second);
  AgString::~AgString((AgString *)&v5->_Myval.first);
  operator delete(v5);
  Mysize = this->_Mypair._Myval2._Myval2._Mysize;
  if ( Mysize )
    this->_Mypair._Myval2._Myval2._Mysize = Mysize - 1;
  result->_Ptr = Ptr;
  return result;
}

__int64 __fastcall AgArchive::exists(AgArchive *this, const AgPath *path)
{
  AgPath *Relative; // rax
  AgPath result; // [rsp+28h] [rbp-20h] BYREF

  Relative = AgPath::getRelative((AgPath *)path, &result);
  LODWORD(this) = AgArchive::containsFile(this, &Relative->m_path);
  AgString::~AgString(&result.m_path);
  return (unsigned int)this;
}

AgPath *__fastcall AgMount::expandPath(AgMount *this, AgPath *result, const AgPath *__formal)
{
  AgString::AgString(&result->m_path, &pnewText, -1);
  AgPath::clean(result);
  return result;
}

__int64 __fastcall AgReferenceCount::incWeakRef(AgReferenceCount *this)
{
  int m_weakCount; // ebx

  m_weakCount = this->m_weakCount;
  if ( m_weakCount )
  {
    while ( this->m_strongCount )
    {
      if ( AgAtomicCompareExchange(&this->m_weakCount, m_weakCount, m_weakCount + 1) == m_weakCount )
        return (unsigned int)(m_weakCount + 1);
      m_weakCount = this->m_weakCount;
      if ( !m_weakCount )
        return 0i64;
    }
  }
  return 0i64;
}

__int64 __fastcall AgArchive::isEncrypted(AgArchive *this)
{
  return (unsigned int)this->m_isEncrypted;
}

void __fastcall AgPCStorageMount::mount(AgSteamRemoteMount *this)
{
  AgMount::setMounted(this, 1);
}

AgPointer<AgFile> *__fastcall AgArchive::open(
        AgArchive *this,
        AgPointer<AgFile> *result,
        const AgPath *path,
        unsigned int accessMode)
{
  AgArchive *v5; // rsi
  char v6; // di
  std::_List_node<AgPointer<AgArchive>,void *> *Myhead; // rax
  std::_List_node<AgPointer<AgArchive>,void *> **p_Prev; // r13
  AgPointer<AgFile> *v9; // rax
  void (__fastcall ***v10)(_QWORD, __int64); // rdi
  volatile int *v11; // rbx
  int v12; // er15
  AgPath *Relative; // rax
  const AgString *v14; // r14
  char *m_text; // rbx
  const AgString *v16; // r15
  AgController *v17; // rax
  AgArchiveFile *v18; // r14
  AgReferenceCount *v19; // rax
  int v20; // eax
  AgReferenceCount *m_refCount; // rbx
  unsigned __int64 v22; // r9
  int v23; // er14
  AgReferenceCount *v25; // [rsp+38h] [rbp-C8h]
  AgArchive *v26; // [rsp+40h] [rbp-C0h]
  volatile int *value; // [rsp+48h] [rbp-B8h] BYREF
  void (__fastcall ***v28)(_QWORD, __int64); // [rsp+50h] [rbp-B0h]
  AgString v29; // [rsp+58h] [rbp-A8h] BYREF
  AgString str; // [rsp+68h] [rbp-98h] BYREF
  AgReference<AgArchive> v31; // [rsp+78h] [rbp-88h] BYREF
  __int64 v32; // [rsp+90h] [rbp-70h]
  const AgString *v33; // [rsp+98h] [rbp-68h]
  const AgString *v34; // [rsp+A0h] [rbp-60h]
  AgController *v35; // [rsp+A8h] [rbp-58h]
  AgReference<AgArchive> *v36; // [rsp+B0h] [rbp-50h]
  AgReferenceCount *v37; // [rsp+B8h] [rbp-48h]
  AgPath resulta; // [rsp+C0h] [rbp-40h] BYREF
  AgStringRef right; // [rsp+D0h] [rbp-30h] BYREF
  AgStringRef left; // [rsp+E0h] [rbp-20h] BYREF
  AgStringRef v41; // [rsp+F0h] [rbp-10h] BYREF
  AgStringRef v42; // [rsp+100h] [rbp+0h] BYREF
  const AgPath *v43; // [rsp+170h] [rbp+70h]

  v43 = path;
  v32 = -2i64;
  v5 = this;
  result->m_ref = 0i64;
  result->m_ptr = 0i64;
  v6 = 1;
  Myhead = this->m_overlays._Mypair._Myval2._Myhead;
  if ( Myhead != Myhead->_Next )
  {
    do
    {
      p_Prev = &Myhead->_Prev;
      v9 = (AgPointer<AgFile> *)((__int64 (__fastcall *)(AgArchive *, volatile int **))Myhead->_Prev->_Myval.m_ptr->open)(
                                  Myhead->_Prev->_Myval.m_ptr,
                                  &value);
      AgPointer<AgAudioChannel>::operator=(result, v9);
      v10 = v28;
      v28 = 0i64;
      v11 = value;
      if ( value )
      {
        value = 0i64;
        v12 = 0;
        if ( !AgAtomicDecrement(v11) )
        {
          if ( !AgAtomicDecrement(v11 + 1) )
            v12 = 1;
          *((_QWORD *)v11 + 1) = 0i64;
          if ( v10 )
            (**v10)(v10, 1i64);
          if ( v12 )
            AgReferenceCount::operator delete((void *)v11);
        }
      }
      if ( result->m_ptr )
        break;
      Myhead = *p_Prev;
    }
    while ( *p_Prev != v5->m_overlays._Mypair._Myval2._Myhead->_Next );
    v6 = 1;
    path = v43;
  }
  if ( !result->m_ptr )
  {
    Relative = AgPath::getRelative((AgPath *)path, &resulta);
    AgString::AgString(&str, &Relative->m_path);
    AgString::~AgString(&resulta.m_path);
    v14 = (const AgString *)v5->m_archiveEntries._Mypair._Myval2._Myval2._Myhead;
    m_text = v14->m_text;
    while ( !m_text[25] )
    {
      AgStringRef::AgStringRef(&right, &str);
      AgStringRef::AgStringRef(&left, (const AgString *)m_text + 2);
      if ( AgString::caselessCompare(&left, &right) >= 0 )
      {
        v14 = (const AgString *)m_text;
        m_text = *(char **)m_text;
      }
      else
      {
        m_text = (char *)*((_QWORD *)m_text + 2);
      }
    }
    if ( v14 == (const AgString *)v5->m_archiveEntries._Mypair._Myval2._Myval2._Myhead
      || (AgStringRef::AgStringRef(&v41, v14 + 2),
          AgStringRef::AgStringRef(&v42, &str),
          AgString::caselessCompare(&v42, &v41) < 0) )
    {
      v14 = (const AgString *)v5->m_archiveEntries._Mypair._Myval2._Myval2._Myhead;
      v34 = v14;
    }
    else
    {
      v33 = v14;
    }
    if ( v14 != (const AgString *)v5->m_archiveEntries._Mypair._Myval2._Myval2._Myhead )
    {
      v16 = v14 + 3;
      v17 = (AgController *)operator new(0xD8ui64);
      v18 = (AgArchiveFile *)v17;
      v35 = v17;
      if ( v17 )
      {
        AgString::AgString(&v29, v16);
        AgPath::clean((AgPath *)&v29);
        v36 = &v31;
        if ( v5->m_refCount )
        {
          v20 = 0;
        }
        else
        {
          v19 = (AgReferenceCount *)AgReferenceCount::operator new(0x10ui64);
          v37 = v19;
          if ( v19 )
          {
            v19->m_strongCount = 1;
            v19->m_weakCount = 1;
            v19->m_data = v5;
          }
          v5->m_refCount = v19;
          v20 = 1;
        }
        m_refCount = v5->m_refCount;
        if ( !v20 )
          AgReferenceCount::incRef(v5->m_refCount);
        v6 = 7;
        v31.__vftable = (AgReference<AgArchive>_vtbl *)&AgReference<AgArchive>::`vftable';
        *(_OWORD *)&v31.m_ref = 0i64;
        if ( m_refCount && (unsigned int)AgReferenceCount::incWeakRef(m_refCount) )
        {
          v31.m_ref = m_refCount;
          v31.m_ptr = v5;
        }
        v22 = (unsigned __int64)v16[1].m_text;
        LODWORD(v22) = v22 & 0x7FFFFFFF;
        AgArchiveFile::AgArchiveFile(
          v18,
          &v31,
          *(_QWORD *)&v16[1].m_length + v5->m_dataOffset,
          v22,
          (const AgPath *)&v29,
          ((unsigned __int64)v16[1].m_text >> 31) & 1);
      }
      else
      {
        v5 = v26;
        m_refCount = v25;
      }
      AgPointer<AgThread>::operator=((AgPointer<AgController> *)result, v17);
      if ( (v6 & 4) != 0 )
      {
        v6 &= ~4u;
        if ( m_refCount )
        {
          v23 = 0;
          if ( !AgAtomicDecrement(&m_refCount->m_strongCount) )
          {
            if ( !AgAtomicDecrement(&m_refCount->m_weakCount) )
              v23 = 1;
            m_refCount->m_data = 0i64;
            if ( v5 )
              ((void (__fastcall *)(AgArchive *, __int64))v5->~AgMount)(v5, 1i64);
            if ( v23 )
              AgReferenceCount::operator delete(m_refCount);
          }
        }
      }
      if ( (v6 & 2) != 0 )
        AgString::~AgString(&v29);
    }
    AgString::~AgString(&str);
  }
  return result;
}

AgPointer<AgDirectory> *__fastcall AgArchive::openDirectory(
        AgArchive *this,
        AgPointer<AgDirectory> *result,
        const AgPath *path,
        AgStringRef *filter,
        unsigned int filterMask)
{
  AgPath *Relative; // rax
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Myhead; // rdi
  std::_Tree_node<std::pair<AgString const ,std::vector<AgArchive::DirectoryEntry> >,void *> *Parent; // rbx
  AgArchiveDirectory *v12; // rbx
  AgPointer<AgMount> *v13; // rax
  AgArchiveDirectory *v14; // rax
  const AgString *p_m_name; // rbx
  AgArchiveDirectory *m_ptr; // rsi
  AgStringRef *v17; // rax
  AgReferenceCount *m_ref; // rbx
  int v19; // edi
  AgPointer<AgArchiveDirectory> v21; // [rsp+38h] [rbp-99h] BYREF
  AgString str; // [rsp+48h] [rbp-89h] BYREF
  AgPath resulta; // [rsp+58h] [rbp-79h] BYREF
  __int64 v24; // [rsp+68h] [rbp-69h]
  AgStringRef right; // [rsp+70h] [rbp-61h] BYREF
  AgStringRef left; // [rsp+80h] [rbp-51h] BYREF
  AgStringRef v27; // [rsp+90h] [rbp-41h] BYREF
  AgStringRef v28; // [rsp+A0h] [rbp-31h] BYREF
  AgPointer<AgMount> v29; // [rsp+B0h] [rbp-21h] BYREF
  AgStringRef v30; // [rsp+C0h] [rbp-11h] BYREF
  AgStringRef v31; // [rsp+D0h] [rbp-1h] BYREF
  AgStringRef v32; // [rsp+E0h] [rbp+Fh] BYREF

  v24 = -2i64;
  Relative = AgPath::getRelative((AgPath *)path, &resulta);
  AgString::AgString(&str, &Relative->m_path);
  AgString::~AgString(&resulta.m_path);
  Myhead = this->m_directories._Mypair._Myval2._Myval2._Myhead;
  Parent = Myhead->_Parent;
  while ( !Parent->_Isnil )
  {
    AgStringRef::AgStringRef(&right, &str);
    AgStringRef::AgStringRef(&left, &Parent->_Myval.first);
    if ( AgString::caselessCompare(&left, &right) >= 0 )
    {
      Myhead = Parent;
      Parent = Parent->_Left;
    }
    else
    {
      Parent = Parent->_Right;
    }
  }
  if ( Myhead == this->m_directories._Mypair._Myval2._Myval2._Myhead
    || (AgStringRef::AgStringRef(&v27, &Myhead->_Myval.first),
        AgStringRef::AgStringRef(&v28, &str),
        AgString::caselessCompare(&v28, &v27) < 0) )
  {
    Myhead = this->m_directories._Mypair._Myval2._Myval2._Myhead;
  }
  v21 = 0i64;
  if ( Myhead == this->m_directories._Mypair._Myval2._Myval2._Myhead )
    goto LABEL_17;
  v12 = (AgArchiveDirectory *)operator new(0xA8ui64);
  if ( v12 )
  {
    *(_QWORD *)&resulta.m_path.m_length = &v29;
    v30 = *filter;
    AgPointer<AgMount>::AgPointer<AgMount>(&v29, this);
    AgArchiveDirectory::AgArchiveDirectory(v12, v13, path, &v30, filterMask);
  }
  else
  {
    v14 = 0i64;
  }
  AgPointer<AgArchiveDirectory>::operator=(&v21, v14);
  p_m_name = &Myhead->_Myval.second._Mypair._Myval2._Myfirst->m_name;
  if ( p_m_name == (const AgString *)Myhead->_Myval.second._Mypair._Myval2._Mylast )
  {
LABEL_17:
    m_ptr = v21.m_ptr;
  }
  else
  {
    m_ptr = v21.m_ptr;
    do
    {
      AgStringRef::AgStringRef(&v32, p_m_name);
      v31 = *v17;
      AgArchiveDirectory::addEntry(m_ptr, &v31, p_m_name[1].m_length);
      p_m_name = (const AgString *)((char *)p_m_name + 24);
    }
    while ( p_m_name != (const AgString *)Myhead->_Myval.second._Mypair._Myval2._Mylast );
  }
  AgPointer<AgArchiveDirectory>::operator<AgDirectory> AgPointer<AgDirectory>(&v21, result);
  v21.m_ptr = 0i64;
  m_ref = v21.m_ref;
  if ( v21.m_ref )
  {
    v21.m_ref = 0i64;
    v19 = 0;
    if ( !AgAtomicDecrement(&m_ref->m_strongCount) )
    {
      if ( !AgAtomicDecrement(&m_ref->m_weakCount) )
        v19 = 1;
      m_ref->m_data = 0i64;
      if ( m_ptr )
        ((void (__fastcall *)(AgArchiveDirectory *, __int64))m_ptr->~AgDirectory)(m_ptr, 1i64);
      if ( v19 )
        AgReferenceCount::operator delete(m_ref);
    }
  }
  AgString::~AgString(&str);
  return result;
}

void __fastcall std::vector<AgArchive::DirectoryEntry>::push_back(
        std::vector<AgArchive::DirectoryEntry> *this,
        AgArchive::DirectoryEntry *_Val)
{
  AgArchive::DirectoryEntry *Mylast; // rcx
  signed __int64 v5; // rsi
  AgArchive::DirectoryEntry *v6; // rdi
  AgArchive::DirectoryEntry *v7; // rsi
  AgArchive::DirectoryEntry *v8; // rdi

  Mylast = this->_Mypair._Myval2._Mylast;
  if ( _Val >= Mylast || this->_Mypair._Myval2._Myfirst > _Val )
  {
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgArchive::DirectoryEntry>::_Reserve(this, 1ui64);
    v8 = this->_Mypair._Myval2._Mylast;
    if ( v8 )
    {
      AgString::AgString(&v8->m_name, &_Val->m_name);
      v8->m_isDirectory = _Val->m_isDirectory;
    }
  }
  else
  {
    v5 = _Val - this->_Mypair._Myval2._Myfirst;
    if ( Mylast == this->_Mypair._Myval2._Myend )
      std::vector<AgArchive::DirectoryEntry>::_Reserve(this, 1ui64);
    v6 = this->_Mypair._Myval2._Mylast;
    v7 = &this->_Mypair._Myval2._Myfirst[v5];
    if ( v6 )
    {
      AgString::AgString(&v6->m_name, &v7->m_name);
      v6->m_isDirectory = v7->m_isDirectory;
    }
  }
  ++this->_Mypair._Myval2._Mylast;
}

void __fastcall ActorWeapon::ActionFlagCheck(_SETJMP_FLOAT128 *JumpBuffer)
{
  ;
}

